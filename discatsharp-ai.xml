<repomix>This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where line numbers have been added, content has been formatted for parsing.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.repomixignore
ARTICLES.md
BUILDING.md
CHANGELOG.md
CONTRIBUTING.md
DisCatSharp.ApplicationCommands/ApplicationCommandsConfiguration.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsExtension.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsModule.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsUtilities.cs
DisCatSharp.ApplicationCommands/Attributes/ApplicationCommandModuleLifespanAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/CheckBaseAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuCooldownAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/DontInjectAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireAnyPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireBotPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireDirectMessageAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireGuildAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireGuildOwnerAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireNsfwAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequirePermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireSkuEntitlementAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamAdmin.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamDeveloper.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamMember.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamOwner.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamReadOnly.cs
DisCatSharp.ApplicationCommands/Attributes/RequireUserPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/AutocompleteAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChannelTypesAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceNameAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProviderAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IAutocompleteProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IChoiceProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/MinimumMaximumAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/OptionAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandCooldownAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandGroupAttribute.cs
DisCatSharp.ApplicationCommands/Checks/ApplicationCommandEqualityChecks.cs
DisCatSharp.ApplicationCommands/Context/ApplicationCommandsTranslationContext.cs
DisCatSharp.ApplicationCommands/Context/AutocompleteContext.cs
DisCatSharp.ApplicationCommands/Context/BaseContext.cs
DisCatSharp.ApplicationCommands/Context/ContextMenuContext.cs
DisCatSharp.ApplicationCommands/Context/InteractionContext.cs
DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj
DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj.DotSettings
DisCatSharp.ApplicationCommands/Entities/ChoiceTranslator.cs
DisCatSharp.ApplicationCommands/Entities/CommandTranslator.cs
DisCatSharp.ApplicationCommands/Entities/FakeApplicationCommandObjects.cs
DisCatSharp.ApplicationCommands/Entities/GroupTranslator.cs
DisCatSharp.ApplicationCommands/Entities/ICooldownResponder.cs
DisCatSharp.ApplicationCommands/Entities/OptionTranslator.cs
DisCatSharp.ApplicationCommands/Entities/RegisteredDiscordApplicationCommand.cs
DisCatSharp.ApplicationCommands/Entities/SubGroupTranslator.cs
DisCatSharp.ApplicationCommands/Enums/ApplicationCommandFinalType.cs
DisCatSharp.ApplicationCommands/Enums/ApplicationCommandModuleLifespan.cs
DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuErrorEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuExecutedEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleReadyEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleStartupFinishedEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/GlobalApplicationCommandsRegisteredEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/GuildApplicationCommandsRegisteredEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandErrorEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandExecutedEventArgs.cs
DisCatSharp.ApplicationCommands/Exceptions/ContextMenu/ContextMenuExecutionChecksFailedException.cs
DisCatSharp.ApplicationCommands/Exceptions/SlashCommand/SlashExecutionChecksFailedException.cs
DisCatSharp.ApplicationCommands/ExtensionMethods.cs
DisCatSharp.ApplicationCommands/GlobalSuppressions.cs
DisCatSharp.ApplicationCommands/Workers/ApplicationCommandWorker.cs
DisCatSharp.ApplicationCommands/Workers/RegistrationWorker.cs
DisCatSharp.Attributes/DeprecatedAttribute.cs
DisCatSharp.Attributes/DisCatSharp.Attributes.csproj
DisCatSharp.Attributes/DisCatSharp.Attributes.csproj.DotSettings
DisCatSharp.Attributes/DiscordDeprecatedAttribute.cs
DisCatSharp.Attributes/DiscordInExperimentAttribute.cs
DisCatSharp.Attributes/DiscordUnreleasedAttribute.cs
DisCatSharp.Attributes/ExperimentalAttribute.cs
DisCatSharp.Attributes/Features.cs
DisCatSharp.Attributes/GlobalSuppressions.cs
DisCatSharp.Attributes/Properties/AssemblyProperties.cs
DisCatSharp.Attributes/RequiresFeatureAttribute.cs
DisCatSharp.CommandsNext/Attributes/AliasesAttribute.cs
DisCatSharp.CommandsNext/Attributes/CheckBaseAttribute.cs
DisCatSharp.CommandsNext/Attributes/CommandAttribute.cs
DisCatSharp.CommandsNext/Attributes/CooldownAttribute.cs
DisCatSharp.CommandsNext/Attributes/DescriptionAttribute.cs
DisCatSharp.CommandsNext/Attributes/DontInjectAttribute.cs
DisCatSharp.CommandsNext/Attributes/GroupAttribute.cs
DisCatSharp.CommandsNext/Attributes/HiddenAttribute.cs
DisCatSharp.CommandsNext/Attributes/ModuleLifespanAttribute.cs
DisCatSharp.CommandsNext/Attributes/PriorityAttribute.cs
DisCatSharp.CommandsNext/Attributes/RemainingTextAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireBoostingAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireBotPermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireCertifiedModeratorAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireCommunityAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireDirectMessageAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireGuildAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireGuildOwnerAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireMemberVerificationGateAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireNsfwAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireOwnerAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireOwnerOrIdAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequirePermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequirePrefixesAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireReferencedMessageAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireRolesAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireStaffAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireUserPermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireWelcomeScreenAttribute.cs
DisCatSharp.CommandsNext/BaseCommandModule.cs
DisCatSharp.CommandsNext/CommandsNextConfiguration.cs
DisCatSharp.CommandsNext/CommandsNextEvents.cs
DisCatSharp.CommandsNext/CommandsNextExtension.cs
DisCatSharp.CommandsNext/CommandsNextUtilities.cs
DisCatSharp.CommandsNext/Converters/ArgumentBindingResult.cs
DisCatSharp.CommandsNext/Converters/BaseHelpFormatter.cs
DisCatSharp.CommandsNext/Converters/DefaultHelpFormatter.cs
DisCatSharp.CommandsNext/Converters/EntityConverters.cs
DisCatSharp.CommandsNext/Converters/EnumConverter.cs
DisCatSharp.CommandsNext/Converters/HelpFormatterFactory.cs
DisCatSharp.CommandsNext/Converters/IArgumentConverter.cs
DisCatSharp.CommandsNext/Converters/NullableConverter.cs
DisCatSharp.CommandsNext/Converters/NumericConverters.cs
DisCatSharp.CommandsNext/Converters/StringConverter.cs
DisCatSharp.CommandsNext/Converters/TimeConverters.cs
DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj
DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj.DotSettings
DisCatSharp.CommandsNext/Entities/Builders/CommandBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandGroupBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandModuleBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandOverloadBuilder.cs
DisCatSharp.CommandsNext/Entities/Command.cs
DisCatSharp.CommandsNext/Entities/CommandArgument.cs
DisCatSharp.CommandsNext/Entities/CommandGroup.cs
DisCatSharp.CommandsNext/Entities/CommandHelpMessage.cs
DisCatSharp.CommandsNext/Entities/CommandModule.cs
DisCatSharp.CommandsNext/Entities/CommandOverload.cs
DisCatSharp.CommandsNext/Entities/CommandResult.cs
DisCatSharp.CommandsNext/Entities/ICooldownResponder.cs
DisCatSharp.CommandsNext/EventArgs/CommandContext.cs
DisCatSharp.CommandsNext/EventArgs/CommandErrorEventArgs.cs
DisCatSharp.CommandsNext/EventArgs/CommandEventArgs.cs
DisCatSharp.CommandsNext/EventArgs/CommandExecutionEventArgs.cs
DisCatSharp.CommandsNext/Exceptions/ChecksFailedException.cs
DisCatSharp.CommandsNext/Exceptions/CommandNotFoundException.cs
DisCatSharp.CommandsNext/Exceptions/DuplicateCommandException.cs
DisCatSharp.CommandsNext/Exceptions/DuplicateOverloadException.cs
DisCatSharp.CommandsNext/Exceptions/InvalidOverloadException.cs
DisCatSharp.CommandsNext/ExtensionMethods.cs
DisCatSharp.CommandsNext/GlobalSuppressions.cs
DisCatSharp.Common/DisCatSharp.Common.csproj
DisCatSharp.Common/DisCatSharp.Common.csproj.DotSettings
DisCatSharp.Common/GlobalSuppressions.cs
DisCatSharp.Common/RegularExpressions/CommonRegEx.cs
DisCatSharp.Common/RegularExpressions/DiscordRegEx.cs
DisCatSharp.Common/Serialization/DateTimeFormatAttribute.cs
DisCatSharp.Common/Serialization/DecomposerAttribute.cs
DisCatSharp.Common/Serialization/EnumAttributes.cs
DisCatSharp.Common/Serialization/Int53Attribute.cs
DisCatSharp.Common/Serialization/SerializationAttribute.cs
DisCatSharp.Common/Serialization/TimeSpanAttributes.cs
DisCatSharp.Common/Serialization/TimeSpanFormatAttribute.cs
DisCatSharp.Common/Serialization/UnixTimestampAttributes.cs
DisCatSharp.Common/Types/CharSpanLookupDictionary.cs
DisCatSharp.Common/Types/CharSpanLookupReadOnlyDictionary.cs
DisCatSharp.Common/Types/ContinuousMemoryBuffer.cs
DisCatSharp.Common/Types/IMemoryBuffer.cs
DisCatSharp.Common/Types/LinqMethods.cs
DisCatSharp.Common/Types/MemoryBuffer.cs
DisCatSharp.Common/Types/SecureRandom.cs
DisCatSharp.Common/Types/Serialization/ComplexDecomposer.cs
DisCatSharp.Common/Types/Serialization/IDecomposer.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEvent.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventArgs.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionHandler.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionMode.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventHandler.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventTimeoutException.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncManualResetEvent.cs
DisCatSharp.Common/Utilities/AsyncExecutor.cs
DisCatSharp.Common/Utilities/AsyncManualResetEvent.cs
DisCatSharp.Common/Utilities/EnsureObjectStates.cs
DisCatSharp.Common/Utilities/Extensions.cs
DisCatSharp.Common/Utilities/ReflectionUtilities.cs
DisCatSharp.Common/Utilities/RuntimeInformation.cs
DisCatSharp.Common/Utilities/WaveformConverter.cs
DisCatSharp.Common/Utilities/WaveformVisualizer.cs
DisCatSharp.Configuration/ConfigurationExtensions.cs
DisCatSharp.Configuration/DisCatSharp.Configuration.csproj
DisCatSharp.Configuration/GlobalSuppressions.cs
DisCatSharp.Configuration/Models/ConfigSection.cs
DisCatSharp.Docs/articles/experimental/gcp_attachments.md
DisCatSharp.Docs/articles/experimental/index.md
DisCatSharp.Docs/articles/experimental/search_guild_members.md
DisCatSharp.Docs/articles/faq.md
DisCatSharp.Docs/articles/getting_started/bot_account.md
DisCatSharp.Docs/articles/getting_started/first_bot.md
DisCatSharp.Docs/articles/getting_started/templates.md
DisCatSharp.Docs/articles/getting_started/web_app.md
DisCatSharp.Docs/articles/index.md
DisCatSharp.Docs/articles/misc/hosting.md
DisCatSharp.Docs/articles/misc/nightly_builds.md
DisCatSharp.Docs/articles/misc/reporting_issues.md
DisCatSharp.Docs/articles/misc/sentry.md
DisCatSharp.Docs/articles/misc/voice_activities.md
DisCatSharp.Docs/articles/modules/application_commands/cooldowns.md
DisCatSharp.Docs/articles/modules/application_commands/events.md
DisCatSharp.Docs/articles/modules/application_commands/intro.md
DisCatSharp.Docs/articles/modules/application_commands/modals.md
DisCatSharp.Docs/articles/modules/application_commands/options.md
DisCatSharp.Docs/articles/modules/application_commands/paginated_modals.md
DisCatSharp.Docs/articles/modules/application_commands/translations/reference.md
DisCatSharp.Docs/articles/modules/application_commands/translations/using.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/advanced.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/commands.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/configuration.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/docker.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/intro.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/queue.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/setup.md
DisCatSharp.Docs/articles/modules/audio/voicenext/prerequisites.md
DisCatSharp.Docs/articles/modules/audio/voicenext/receive.md
DisCatSharp.Docs/articles/modules/audio/voicenext/transmit.md
DisCatSharp.Docs/articles/modules/commandsnext/command_attributes.md
DisCatSharp.Docs/articles/modules/commandsnext/cooldowns.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/argument_converters.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/command_handler.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/help_formatter.md
DisCatSharp.Docs/articles/modules/commandsnext/dependency_injection.md
DisCatSharp.Docs/articles/modules/commandsnext/intro.md
DisCatSharp.Docs/articles/modules/interactivity/interactivity.md
DisCatSharp.Docs/articles/modules/oauth2/oauth2_client.md
DisCatSharp.Docs/articles/sec_comp/sentry.md
DisCatSharp.Docs/articles/topics/components/buttons.md
DisCatSharp.Docs/articles/topics/components/select_menus.md
DisCatSharp.Docs/articles/topics/events.md
DisCatSharp.Docs/articles/topics/intents.md
DisCatSharp.Docs/articles/topics/logging/default.md
DisCatSharp.Docs/articles/topics/logging/di.md
DisCatSharp.Docs/articles/topics/logging/third_party.md
DisCatSharp.Docs/articles/topics/messagebuilder.md
DisCatSharp.Docs/articles/topics/sharding.md
DisCatSharp.Docs/articles/topics/workarounds.md
DisCatSharp.Docs/changelogs/index.md
DisCatSharp.Docs/changelogs/v10/10_0_0.md
DisCatSharp.Docs/changelogs/v10/10_1_0.md
DisCatSharp.Docs/changelogs/v10/10_2_0.md
DisCatSharp.Docs/changelogs/v10/10_3_0.md
DisCatSharp.Docs/changelogs/v10/10_4_0.md
DisCatSharp.Docs/changelogs/v10/10_6_0.md
DisCatSharp.Docs/changelogs/v10/10_6_2.md
DisCatSharp.Docs/changelogs/v10/10_6_4.md
DisCatSharp.Docs/changelogs/v10/10_6_6.md
DisCatSharp.Docs/changelogs/v9/9_8_2.md
DisCatSharp.Docs/changelogs/v9/9_8_3.md
DisCatSharp.Docs/changelogs/v9/9_8_4.md
DisCatSharp.Docs/changelogs/v9/9_8_5.md
DisCatSharp.Docs/changelogs/v9/9_9_0.md
DisCatSharp.Docs/images/ok_hand.svg
DisCatSharp.Docs/index.md
DisCatSharp.Docs/natives/index.md
DisCatSharp.Docs/snippets/global_name.cs
DisCatSharp.Docs/vs/analyzer/dcs/0001.md
DisCatSharp.Docs/vs/analyzer/dcs/0002.md
DisCatSharp.Docs/vs/analyzer/dcs/0101.md
DisCatSharp.Docs/vs/analyzer/dcs/0102.md
DisCatSharp.Docs/vs/analyzer/dcs/0103.md
DisCatSharp.Docs/vs/analyzer/dcs/0200.md
DisCatSharp.Docs/vs/index.md
DisCatSharp.Experimental/AudioHelper.cs
DisCatSharp.Experimental/DisCatSharp.Experimental.csproj
DisCatSharp.Experimental/DisCatSharpExtensions.cs
DisCatSharp.Experimental/DiscordApiClientHook.cs
DisCatSharp.Experimental/Entities/Channel/DiscordChannelMethodHooks.cs
DisCatSharp.Experimental/Entities/Clyde/ClydeProfile.cs
DisCatSharp.Experimental/Entities/Clyde/ClydeSettings.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchParams.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchValidator.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMethodsHook.cs
DisCatSharp.Experimental/Entities/Guild/DiscordMemberFilter.cs
DisCatSharp.Experimental/Entities/Guild/DiscordMemberPaginationFilter.cs
DisCatSharp.Experimental/Entities/Guild/DiscordQueries.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSafetySignals.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSearchGuildMembersResponse.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSupplementalGuildMember.cs
DisCatSharp.Experimental/Entities/Message/DiscordMessageBuilderMethodHooks.cs
DisCatSharp.Experimental/Entities/Message/GcpAttachment.cs
DisCatSharp.Experimental/Entities/Message/GcpAttachmentsResponse.cs
DisCatSharp.Experimental/Entities/Message/GcpAttachmentUploadInformation.cs
DisCatSharp.Experimental/Enums/Guild/JoinSourceType.cs
DisCatSharp.Experimental/Enums/Guild/MemberSortType.cs
DisCatSharp.Experimental/GlobalSuppressions.cs
DisCatSharp.Experimental/Payloads/ClydeSettingsPayloads.cs
DisCatSharp.Experimental/Payloads/RestGcpAttachmentsPayload.cs
DisCatSharp.Hosting.DependencyInjection/DisCatSharp.Hosting.DependencyInjection.csproj
DisCatSharp.Hosting.DependencyInjection/ServiceCollectionExtensions.cs
DisCatSharp.Hosting/BaseHostedService.cs
DisCatSharp.Hosting/ConfigurationExtensions.cs
DisCatSharp.Hosting/Constants.cs
DisCatSharp.Hosting/DisCatSharp.Hosting.csproj
DisCatSharp.Hosting/DiscordHostedService.cs
DisCatSharp.Hosting/DiscordSharedHostedService.cs
DisCatSharp.Hosting/GlobalSuppressions.cs
DisCatSharp.Hosting/IDiscordHostedService.cs
DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj
DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj.DotSettings
DisCatSharp.Interactivity/Entities/Page.cs
DisCatSharp.Interactivity/Entities/PaginationEmojis.cs
DisCatSharp.Interactivity/Enums/ButtonPaginationBehavior.cs
DisCatSharp.Interactivity/Enums/InteractionResponseBehavior.cs
DisCatSharp.Interactivity/Enums/Modal/ModalPage.cs
DisCatSharp.Interactivity/Enums/Modal/PaginatedModalResponse.cs
DisCatSharp.Interactivity/Enums/PaginationBehaviour.cs
DisCatSharp.Interactivity/Enums/PaginationDeletion.cs
DisCatSharp.Interactivity/Enums/PollBehaviour.cs
DisCatSharp.Interactivity/Enums/SplitType.cs
DisCatSharp.Interactivity/EventHandling/Components/ComponentEventWaiter.cs
DisCatSharp.Interactivity/EventHandling/Components/ComponentPaginator.cs
DisCatSharp.Interactivity/EventHandling/Components/ModalEventWaiter.cs
DisCatSharp.Interactivity/EventHandling/Components/PaginationButtons.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ButtonPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentCollectRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentMatchRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/InteractionPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ModalMatchRequest.cs
DisCatSharp.Interactivity/EventHandling/EventWaiter.cs
DisCatSharp.Interactivity/EventHandling/IPaginator.cs
DisCatSharp.Interactivity/EventHandling/Paginator.cs
DisCatSharp.Interactivity/EventHandling/Poller.cs
DisCatSharp.Interactivity/EventHandling/ReactionCollector.cs
DisCatSharp.Interactivity/EventHandling/Requests/CollectRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/IPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/MatchRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/PaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/PollRequest.cs
DisCatSharp.Interactivity/Extensions/ChannelExtensions.cs
DisCatSharp.Interactivity/Extensions/ClientExtensions.cs
DisCatSharp.Interactivity/Extensions/InteractionExtensions.cs
DisCatSharp.Interactivity/Extensions/MessageExtensions.cs
DisCatSharp.Interactivity/GlobalSuppressions.cs
DisCatSharp.Interactivity/Helpers/InteractivityHelpers.cs
DisCatSharp.Interactivity/InteractivityConfiguration.cs
DisCatSharp.Interactivity/InteractivityEvents.cs
DisCatSharp.Interactivity/InteractivityExtension.cs
DisCatSharp.Interactivity/InteractivityResult.cs
DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj
DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj.DotSettings
DisCatSharp.Lavalink/Entities/DefaultQueueEntry.cs
DisCatSharp.Lavalink/Entities/Filters/IPluginFilter.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkChannelMix.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkDisortion.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkEqualizer.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkFilters.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkKaraoke.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkLowPass.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkRotation.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkTimescale.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkTremolo.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkVibrato.cs
DisCatSharp.Lavalink/Entities/IQueueEntry.cs
DisCatSharp.Lavalink/Entities/LavalinkException.cs
DisCatSharp.Lavalink/Entities/LavalinkInfo.cs
DisCatSharp.Lavalink/Entities/LavalinkLyricsResult.cs
DisCatSharp.Lavalink/Entities/LavalinkPlayer.cs
DisCatSharp.Lavalink/Entities/LavalinkPlayerState.cs
DisCatSharp.Lavalink/Entities/LavalinkPlaylist.cs
DisCatSharp.Lavalink/Entities/LavalinkPlaylistInfo.cs
DisCatSharp.Lavalink/Entities/LavalinkRestResponse.cs
DisCatSharp.Lavalink/Entities/LavalinkSessionConfiguration.cs
DisCatSharp.Lavalink/Entities/LavalinkStats.cs
DisCatSharp.Lavalink/Entities/LavalinkTrack.cs
DisCatSharp.Lavalink/Entities/LavalinkTrackLoadingResult.cs
DisCatSharp.Lavalink/Entities/LavalinkVoiceState.cs
DisCatSharp.Lavalink/Entities/LyricsLine.cs
DisCatSharp.Lavalink/Entities/Websocket/EventOP.cs
DisCatSharp.Lavalink/Entities/Websocket/LavalinkOp.cs
DisCatSharp.Lavalink/Entities/Websocket/PlayerUpdateOp.cs
DisCatSharp.Lavalink/Entities/Websocket/ReadyOp.cs
DisCatSharp.Lavalink/Entities/Websocket/StatsOp.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackEndEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackException.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackExceptionEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackStartEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackStuckEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/WebSocketClosedEvent.cs
DisCatSharp.Lavalink/Enums/Filters/LavalinkFilterBand.cs
DisCatSharp.Lavalink/Enums/LavalinkEvents.cs
DisCatSharp.Lavalink/Enums/LavalinkLoadResultType.cs
DisCatSharp.Lavalink/Enums/LavalinkRestEndpoints.cs
DisCatSharp.Lavalink/Enums/LavalinkSearchType.cs
DisCatSharp.Lavalink/Enums/LavalinkTrackEndReason.cs
DisCatSharp.Lavalink/Enums/RepeatMode.cs
DisCatSharp.Lavalink/Enums/Severity.cs
DisCatSharp.Lavalink/Enums/Websocket/EventOpType.cs
DisCatSharp.Lavalink/Enums/Websocket/OpType.cs
DisCatSharp.Lavalink/EventArgs/GuildPlayerDestroyedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkPlayerStateUpdateEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkSessionConnectedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkSessionDisconnectedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkStatsReceivedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackEndedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackExceptionEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackStartedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackStuckEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkWebsocketClosedEventArgs.cs
DisCatSharp.Lavalink/Exceptions/LavalinkRestException.cs
DisCatSharp.Lavalink/ExtensionMethods.cs
DisCatSharp.Lavalink/GlobalSuppressions.cs
DisCatSharp.Lavalink/LavalinkConfiguration.cs
DisCatSharp.Lavalink/LavalinkExtension.cs
DisCatSharp.Lavalink/LavalinkGuildPlayer.cs
DisCatSharp.Lavalink/LavalinkJson.cs
DisCatSharp.Lavalink/LavalinkQueue.cs
DisCatSharp.Lavalink/LavalinkRestClient.cs
DisCatSharp.Lavalink/LavalinkSession.cs
DisCatSharp.Lavalink/Models/LavalinkPlayerUpdateModel.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerCreatePayload.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerUpdatePayload.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestVoiceStateUpdatePayload.cs
DisCatSharp.Logos/browserconfig.xml
DisCatSharp.Logos/logo.svg
DisCatSharp.sln
DisCatSharp.Targets/DisCatSharp.targets
DisCatSharp.Targets/InternalsVisibleTo.targets
DisCatSharp.Targets/Library.targets
DisCatSharp.Targets/NuGet.targets
DisCatSharp.Targets/Package.targets
DisCatSharp.Targets/TestProject.targets
DisCatSharp.Targets/Version.targets
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/AppCommandSplitPartialTests.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/DisCatSharp.ApplicationCommands.Tests.csproj
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part0.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part1.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part2.cs
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/ConfigurationExtensionTests.cs
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/DisCatSharp.Configuration.Tests.csproj
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/BasicEventHandlerTests.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/DisCatSharp.EventHandlers.Tests.csproj
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/EventsEnumIntegrityTests.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/ServiceProviderTests.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/DisCatSharp.Hosting.Tests.csproj
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/ExtensionTests.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/HostTests.cs
DisCatSharp.Tests/SafetyTests/DisCatSharp.SafetyTests.csproj
DisCatSharp.Tests/SafetyTests/HttpTest.cs
DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/DisCatSharp.Analyzer.VSIX.csproj
DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/LICENSE.md
DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/Properties/AssemblyInfo.cs
DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/source.extension.cs
DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/source.extension.vsixmanifest
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/README.md
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AnalyzerReleases.Shipped.md
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AnalyzerReleases.Unshipped.md
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AttributeAnalyzer.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj.DotSettings
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/GlobalSuppressions.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.Designer.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.resx
DisCatSharp.Tools/DisCatSharp.Tools.sln
DisCatSharp.VoiceNext/AudioFormat.cs
DisCatSharp.VoiceNext/Codec/Helpers.cs
DisCatSharp.VoiceNext/Codec/Interop.cs
DisCatSharp.VoiceNext/Codec/Opus.cs
DisCatSharp.VoiceNext/Codec/Rtp.cs
DisCatSharp.VoiceNext/Codec/Sodium.cs
DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj
DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj.DotSettings
DisCatSharp.VoiceNext/Entities/AudioSender.cs
DisCatSharp.VoiceNext/Entities/VoiceDispatch.cs
DisCatSharp.VoiceNext/Entities/VoiceIdentifyPayload.cs
DisCatSharp.VoiceNext/Entities/VoicePacket.cs
DisCatSharp.VoiceNext/Entities/VoiceReadyPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayloadData.cs
DisCatSharp.VoiceNext/Entities/VoiceServerUpdatePayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSessionDescriptionPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSpeakingPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceStateUpdatePayload.cs
DisCatSharp.VoiceNext/Entities/VoiceUserJoinPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceUserLeavePayload.cs
DisCatSharp.VoiceNext/EventArgs/VoiceReceiveEventArgs.cs
DisCatSharp.VoiceNext/EventArgs/VoiceUserJoinEventArgs.cs
DisCatSharp.VoiceNext/EventArgs/VoiceUserLeaveEventArgs.cs
DisCatSharp.VoiceNext/ExtensionMethods.cs
DisCatSharp.VoiceNext/GlobalSuppressions.cs
DisCatSharp.VoiceNext/Interop/Bindings.cs
DisCatSharp.VoiceNext/Interop/OpusControl.cs
DisCatSharp.VoiceNext/Interop/OpusError.cs
DisCatSharp.VoiceNext/Interop/OpusPacketMetrics.cs
DisCatSharp.VoiceNext/Interop/OpusSignal.cs
DisCatSharp.VoiceNext/IVoiceFilter.cs
DisCatSharp.VoiceNext/RawVoicePacket.cs
DisCatSharp.VoiceNext/StreamExtensions.cs
DisCatSharp.VoiceNext/VoiceApplication.cs
DisCatSharp.VoiceNext/VoiceNextConfiguration.cs
DisCatSharp.VoiceNext/VoiceNextConnection.cs
DisCatSharp.VoiceNext/VoiceNextEvents.cs
DisCatSharp.VoiceNext/VoiceNextExtension.cs
DisCatSharp.VoiceNext/VoiceTransmitSink.cs
DisCatSharp/BaseExtension.cs
DisCatSharp/Clients/BaseDiscordClient.cs
DisCatSharp/Clients/DiscordClient.cs
DisCatSharp/Clients/DiscordClient.Dispatch.cs
DisCatSharp/Clients/DiscordClient.EventHandlers.cs
DisCatSharp/Clients/DiscordClient.Events.cs
DisCatSharp/Clients/DiscordClient.WebSocket.cs
DisCatSharp/Clients/DiscordOAuth2Client.cs
DisCatSharp/Clients/DiscordShardedClient.cs
DisCatSharp/Clients/DiscordShardedClient.Events.cs
DisCatSharp/Clients/DiscordWebhookClient.cs
DisCatSharp/DisCatSharp.csproj
DisCatSharp/DisCatSharp.csproj.DotSettings
DisCatSharp/DiscordConfiguration.cs
DisCatSharp/Entities/Application/DiscordApplication.cs
DisCatSharp/Entities/Application/DiscordApplicationCommand.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandAutocompleteChoice.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandLocalization.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandOption.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandOptionChoice.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandPermission.cs
DisCatSharp/Entities/Application/DiscordApplicationEmoji.cs
DisCatSharp/Entities/Application/DiscordApplicationInstallParams.cs
DisCatSharp/Entities/Application/DiscordApplicationIntegrationTypeConfiguration.cs
DisCatSharp/Entities/Application/DiscordApplicationRoleConnectionMetadata.cs
DisCatSharp/Entities/Application/DiscordGuildApplicationCommandPermission.cs
DisCatSharp/Entities/Application/DiscordIntegrationTypesConfig.cs
DisCatSharp/Entities/Application/DiscordOAuth2InstallParams.cs
DisCatSharp/Entities/Application/DiscordRpcApplication.cs
DisCatSharp/Entities/Channel/ChannelTypeExtensions.cs
DisCatSharp/Entities/Channel/DiscordChannel.cs
DisCatSharp/Entities/Channel/DiscordDmChannel.cs
DisCatSharp/Entities/Channel/DiscordFollowedChannel.cs
DisCatSharp/Entities/Channel/DiscordGuildDirectoryChannel.cs
DisCatSharp/Entities/Channel/DiscordGuildDirectoryEntry.cs
DisCatSharp/Entities/Channel/Overwrite/DiscordOverwrite.cs
DisCatSharp/Entities/Channel/Overwrite/DiscordOverwriteBuilder.cs
DisCatSharp/Entities/Color/DiscordColor.Colors.cs
DisCatSharp/Entities/Color/DiscordColor.cs
DisCatSharp/Entities/Core/CooldownBucket.cs
DisCatSharp/Entities/Core/DisCatSharpBuilder.cs
DisCatSharp/Entities/Core/DisCatSharpCommandContext.cs
DisCatSharp/Entities/Core/IBucket.cs
DisCatSharp/Entities/Core/ICooldown.cs
DisCatSharp/Entities/DiscordLocales.cs
DisCatSharp/Entities/DiscordProtocol.cs
DisCatSharp/Entities/DiscordSignedLink.cs
DisCatSharp/Entities/DiscordUri.cs
DisCatSharp/Entities/Embed/DiscordEmbed.cs
DisCatSharp/Entities/Embed/DiscordEmbedAuthor.cs
DisCatSharp/Entities/Embed/DiscordEmbedBuilder.cs
DisCatSharp/Entities/Embed/DiscordEmbedField.cs
DisCatSharp/Entities/Embed/DiscordEmbedFooter.cs
DisCatSharp/Entities/Embed/DiscordEmbedImage.cs
DisCatSharp/Entities/Embed/DiscordEmbedProvider.cs
DisCatSharp/Entities/Embed/DiscordEmbedThumbnail.cs
DisCatSharp/Entities/Embed/DiscordEmbedVideo.cs
DisCatSharp/Entities/Emoji/DiscordEmoji.cs
DisCatSharp/Entities/Emoji/DiscordEmoji.EmojiUtils.cs
DisCatSharp/Entities/Emoji/DiscordUnicodeEmoji.cs
DisCatSharp/Entities/Emoji/PartialEmoji.cs
DisCatSharp/Entities/Guild/Automod/AutomodAction.cs
DisCatSharp/Entities/Guild/Automod/AutomodActionMetadata.cs
DisCatSharp/Entities/Guild/Automod/AutomodRule.cs
DisCatSharp/Entities/Guild/Automod/AutomodTriggerMetadata.cs
DisCatSharp/Entities/Guild/DiscordAuditLogObjects.cs
DisCatSharp/Entities/Guild/DiscordBan.cs
DisCatSharp/Entities/Guild/DiscordBulkBanResponse.cs
DisCatSharp/Entities/Guild/DiscordClanSettings.cs
DisCatSharp/Entities/Guild/DiscordGuild.AuditLog.cs
DisCatSharp/Entities/Guild/DiscordGuild.cs
DisCatSharp/Entities/Guild/DiscordGuild.Features.cs
DisCatSharp/Entities/Guild/DiscordGuildEmoji.cs
DisCatSharp/Entities/Guild/DiscordGuildInventorySettings.cs
DisCatSharp/Entities/Guild/DiscordGuildJoinRequest.cs
DisCatSharp/Entities/Guild/DiscordGuildJoinRequestSearchResult.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreening.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningField.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningFieldResponse.cs
DisCatSharp/Entities/Guild/DiscordGuildPreview.cs
DisCatSharp/Entities/Guild/DiscordGuildTemplate.cs
DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreen.cs
DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreenChannel.cs
DisCatSharp/Entities/Guild/DiscordMember.cs
DisCatSharp/Entities/Guild/DiscordRole.cs
DisCatSharp/Entities/Guild/DiscordRoleTags.cs
DisCatSharp/Entities/Guild/IncidentsData.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboarding.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPrompt.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPromptOption.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordServerGuide.cs
DisCatSharp/Entities/Guild/Onboarding/NewMemberAction.cs
DisCatSharp/Entities/Guild/Onboarding/ResourceChannel.cs
DisCatSharp/Entities/Guild/Onboarding/WelcomeMessage.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordRecurrenceRuleNWeekday.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEvent.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventEntityMetadata.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRule.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRuleValidator.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventUser.cs
DisCatSharp/Entities/Guild/Stage/DiscordStageInstance.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannel.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMember.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMetadata.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadResult.cs
DisCatSharp/Entities/Guild/ThreadAndForum/ForumPostTag.cs
DisCatSharp/Entities/Guild/ThreadAndForum/ForumReactionEmoji.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidget.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidgetMember.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidgetSettings.cs
DisCatSharp/Entities/Integration/DiscordIntegration.cs
DisCatSharp/Entities/Integration/DiscordIntegrationAccount.cs
DisCatSharp/Entities/Interaction/AuthorizingIntegrationOwners.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordLinkButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordPremiumButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponentResult.cs
DisCatSharp/Entities/Interaction/Components/DiscordComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordComponentEmoji.cs
DisCatSharp/Entities/Interaction/Components/DiscordComponentResult.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordBaseSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordChannelSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordMentionableSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordRoleSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordSelectDefaultValue.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponentOption.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordUserSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Text/DiscordTextComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordBaseButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordContainerComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordFileDisplayComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryItem.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionAccessory.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSeparatorComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordTextDisplayComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordThumbnailComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordUnfurledMediaItem.cs
DisCatSharp/Entities/Interaction/DiscordActivityInstance.cs
DisCatSharp/Entities/Interaction/DiscordCallbackHintBuilder.cs
DisCatSharp/Entities/Interaction/DiscordFollowupMessageBuilder.cs
DisCatSharp/Entities/Interaction/DiscordInteraction.cs
DisCatSharp/Entities/Interaction/DiscordInteractionApplicationCommandCallbackData.cs
DisCatSharp/Entities/Interaction/DiscordInteractionCallback.cs
DisCatSharp/Entities/Interaction/DiscordInteractionCallbackHint.cs
DisCatSharp/Entities/Interaction/DiscordInteractionCallbackResponse.cs
DisCatSharp/Entities/Interaction/DiscordInteractionData.cs
DisCatSharp/Entities/Interaction/DiscordInteractionDataOption.cs
DisCatSharp/Entities/Interaction/DiscordInteractionMetadata.cs
DisCatSharp/Entities/Interaction/DiscordInteractionModalBuilder.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResolvedCollection.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResource.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResponseBuilder.cs
DisCatSharp/Entities/Invite/DiscordInvite.cs
DisCatSharp/Entities/Invite/DiscordInviteChannel.cs
DisCatSharp/Entities/Invite/DiscordInviteGuild.cs
DisCatSharp/Entities/Invite/DiscordInviteStage.cs
DisCatSharp/Entities/Message/DiscordAttachment.cs
DisCatSharp/Entities/Message/DiscordForwardedMessage.cs
DisCatSharp/Entities/Message/DiscordMentions.cs
DisCatSharp/Entities/Message/DiscordMessage.cs
DisCatSharp/Entities/Message/DiscordMessageActivity.cs
DisCatSharp/Entities/Message/DiscordMessageApplication.cs
DisCatSharp/Entities/Message/DiscordMessageBuilder.cs
DisCatSharp/Entities/Message/DiscordMessageFile.cs
DisCatSharp/Entities/Message/DiscordMessageInteraction.cs
DisCatSharp/Entities/Message/DiscordMessageReference.cs
DisCatSharp/Entities/Message/DiscordMessageSnapshots.cs
DisCatSharp/Entities/Message/DiscordReaction.cs
DisCatSharp/Entities/Message/DiscordUnfurledMedia.cs
DisCatSharp/Entities/Message/Mentions.cs
DisCatSharp/Entities/Message/Polls/DiscordPoll.cs
DisCatSharp/Entities/Message/Polls/DiscordPollAnswer.cs
DisCatSharp/Entities/Message/Polls/DiscordPollAnswerCount.cs
DisCatSharp/Entities/Message/Polls/DiscordPollBuilder.cs
DisCatSharp/Entities/Message/Polls/DiscordPollMedia.cs
DisCatSharp/Entities/Message/Polls/DiscordPollRequest.cs
DisCatSharp/Entities/Message/Polls/DiscordPollResult.cs
DisCatSharp/Entities/NullableSnowflakeObject.cs
DisCatSharp/Entities/OAuth2/DiscordAccessToken.cs
DisCatSharp/Entities/OAuth2/DiscordApplicationRoleConnection.cs
DisCatSharp/Entities/OAuth2/DiscordAuthorizationInformation.cs
DisCatSharp/Entities/ObservableApiObject.cs
DisCatSharp/Entities/Optional.cs
DisCatSharp/Entities/SnowflakeObject.cs
DisCatSharp/Entities/Sticker/DiscordSticker.cs
DisCatSharp/Entities/Sticker/DiscordStickerPack.cs
DisCatSharp/Entities/Store/DiscordEntitlement.cs
DisCatSharp/Entities/Store/DiscordSku.cs
DisCatSharp/Entities/Store/DiscordStoreSku.cs
DisCatSharp/Entities/Store/DiscordSubscription.cs
DisCatSharp/Entities/User/DiscordActivity.cs
DisCatSharp/Entities/User/DiscordClan.cs
DisCatSharp/Entities/User/DiscordConnection.cs
DisCatSharp/Entities/User/DiscordPresence.cs
DisCatSharp/Entities/User/DiscordTeam.cs
DisCatSharp/Entities/User/DiscordUser.cs
DisCatSharp/Entities/Voice/DiscordSoundboardSound.cs
DisCatSharp/Entities/Voice/DiscordVoiceRegion.cs
DisCatSharp/Entities/Voice/DiscordVoiceState.cs
DisCatSharp/Entities/Webhook/DiscordWebhook.cs
DisCatSharp/Entities/Webhook/DiscordWebhookBuilder.cs
DisCatSharp/Enums/Application/ApplicationCommandHandlerType.cs
DisCatSharp/Enums/Application/ApplicationCommandIntegrationTypes.cs
DisCatSharp/Enums/Application/ApplicationCommandOptionType.cs
DisCatSharp/Enums/Application/ApplicationCommandPermissionType.cs
DisCatSharp/Enums/Application/ApplicationCommandType.cs
DisCatSharp/Enums/Application/ApplicationDiscoverabilityState.cs
DisCatSharp/Enums/Application/ApplicationDiscoveryEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationExplicitContentFilter.cs
DisCatSharp/Enums/Application/ApplicationFlags.cs
DisCatSharp/Enums/Application/ApplicationInteractionsVersion.cs
DisCatSharp/Enums/Application/ApplicationMonetizationEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationMonetizationState.cs
DisCatSharp/Enums/Application/ApplicationRoleConnectionMetadataType.cs
DisCatSharp/Enums/Application/ApplicationVerificationEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationVerificationState.cs
DisCatSharp/Enums/Application/RpcApplicationState.cs
DisCatSharp/Enums/Application/StoreApplicationState.cs
DisCatSharp/Enums/Channel/ChannelFlags.cs
DisCatSharp/Enums/Channel/ChannelType.cs
DisCatSharp/Enums/Channel/DirectoryCategory.cs
DisCatSharp/Enums/Channel/OverwriteType.cs
DisCatSharp/Enums/Channel/VideoQualityMode.cs
DisCatSharp/Enums/Core/CooldownBucketType.cs
DisCatSharp/Enums/Core/DisCatSharpCommandType.cs
DisCatSharp/Enums/Core/DisCatSharpStatisticType.cs
DisCatSharp/Enums/Discord/ApiChannel.cs
DisCatSharp/Enums/Discord/DiscordDomain.cs
DisCatSharp/Enums/Discord/DiscordEvent.cs
DisCatSharp/Enums/Discord/DiscordIntents.cs
DisCatSharp/Enums/Discord/DiscordShortlink.cs
DisCatSharp/Enums/Discord/GatewayCompressionLevel.cs
DisCatSharp/Enums/Discord/OAuth.cs
DisCatSharp/Enums/Discord/TokenType.cs
DisCatSharp/Enums/Guild/AuditLogActionCategory.cs
DisCatSharp/Enums/Guild/AuditLogActionType.cs
DisCatSharp/Enums/Guild/Automod/AutomodActionType.cs
DisCatSharp/Enums/Guild/Automod/AutomodEventType.cs
DisCatSharp/Enums/Guild/Automod/AutomodKeywordPresetType.cs
DisCatSharp/Enums/Guild/Automod/AutomodTriggerType.cs
DisCatSharp/Enums/Guild/BadgeType.cs
DisCatSharp/Enums/Guild/BannerType.cs
DisCatSharp/Enums/Guild/DefaultMessageNotifications.cs
DisCatSharp/Enums/Guild/ExplicitContentFilter.cs
DisCatSharp/Enums/Guild/HubType.cs
DisCatSharp/Enums/Guild/JoinRequestStatusType.cs
DisCatSharp/Enums/Guild/MemberFlags.cs
DisCatSharp/Enums/Guild/MembershipScreeningFieldType.cs
DisCatSharp/Enums/Guild/MfaLevel.cs
DisCatSharp/Enums/Guild/NsfwLevel.cs
DisCatSharp/Enums/Guild/Onboarding/NewMemberActionType.cs
DisCatSharp/Enums/Guild/Onboarding/OnboardingMode.cs
DisCatSharp/Enums/Guild/Onboarding/PromptType.cs
DisCatSharp/Enums/Guild/Permission.cs
DisCatSharp/Enums/Guild/PlayStyle.cs
DisCatSharp/Enums/Guild/PremiumTier.cs
DisCatSharp/Enums/Guild/PriceTierType.cs
DisCatSharp/Enums/Guild/RoleFlags.cs
DisCatSharp/Enums/Guild/RoleType.cs
DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleFrequency.cs
DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleWeekday.cs
DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventEntityType.cs
DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventStatus.cs
DisCatSharp/Enums/Guild/SystemChannelFlags.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ForumLayout.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ForumPostSortOrder.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ThreadAutoArchiveDuration.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ThreadMemberFlags.cs
DisCatSharp/Enums/Guild/VerificationLevel.cs
DisCatSharp/Enums/Guild/WidgetType.cs
DisCatSharp/Enums/Integration/IntegrationExpireBehavior.cs
DisCatSharp/Enums/Interaction/ButtonStyle.cs
DisCatSharp/Enums/Interaction/ComponentType.cs
DisCatSharp/Enums/Interaction/IFrameModalSize.cs
DisCatSharp/Enums/Interaction/InteractionCallbackEphemerality.cs
DisCatSharp/Enums/Interaction/InteractionContextType.cs
DisCatSharp/Enums/Interaction/InteractionResponseType.cs
DisCatSharp/Enums/Interaction/InteractionType.cs
DisCatSharp/Enums/Interaction/SeparatorSpacingSize.cs
DisCatSharp/Enums/Interaction/TextComponentStyle.cs
DisCatSharp/Enums/Invite/InviteFlags.cs
DisCatSharp/Enums/Invite/InviteType.cs
DisCatSharp/Enums/Invite/TargetType.cs
DisCatSharp/Enums/Message/AttachmentFlags.cs
DisCatSharp/Enums/Message/EmbedFlags.cs
DisCatSharp/Enums/Message/LoadingState.cs
DisCatSharp/Enums/Message/MentionType.cs
DisCatSharp/Enums/Message/MessageActivityType.cs
DisCatSharp/Enums/Message/MessageFlags.cs
DisCatSharp/Enums/Message/MessageType.cs
DisCatSharp/Enums/Message/PollLayoutType.cs
DisCatSharp/Enums/Message/ReferenceType.cs
DisCatSharp/Enums/Message/TimestampFormat.cs
DisCatSharp/Enums/Message/UnfurledMediaFlags.cs
DisCatSharp/Enums/Store/EntitlementOwnerType.cs
DisCatSharp/Enums/Store/EntitlementType.cs
DisCatSharp/Enums/Store/ProductLine.cs
DisCatSharp/Enums/Store/SkuAccessType.cs
DisCatSharp/Enums/Store/SkuFlags.cs
DisCatSharp/Enums/Store/SkuType.cs
DisCatSharp/Enums/Store/SubscriptionStatus.cs
DisCatSharp/Enums/User/ConnectionMetadataVisibilityType.cs
DisCatSharp/Enums/User/ConnectionVisibilityType.cs
DisCatSharp/Enums/User/PremiumType.cs
DisCatSharp/Enums/User/UserFlags.cs
DisCatSharp/Enums/VersionCheckMode.cs
DisCatSharp/Enums/Voice/AnimationType.cs
DisCatSharp/Enums/Voice/SpeakingFlags.cs
DisCatSharp/EventArgs/Application/ApplicationCommandEventArgs.cs
DisCatSharp/EventArgs/Application/ApplicationCommandPermissionsUpdateEventArgs.cs
DisCatSharp/EventArgs/Application/GuildApplicationCommandCountEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelCreateEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelDeleteEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelPinsUpdateEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelUpdateEventArgs.cs
DisCatSharp/EventArgs/Channel/DMChannelDeleteEventArgs.cs
DisCatSharp/EventArgs/Channel/VoiceChannelStatusUpdateEventArgs.cs
DisCatSharp/EventArgs/ClientErrorEventArgs.cs
DisCatSharp/EventArgs/DiscordEventArgs.cs
DisCatSharp/EventArgs/EmbeddedActivityUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodActionExecutedEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodCreateRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodDeleteRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodUpdateRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Ban/GuildBanAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Ban/GuildBanRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildAuditLogEntryCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildDownloadCompletedEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildEmojisUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildIntegrationsUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildStickersUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMembersChunkEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserAddEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundsUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/SoundboardSoundsEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadListSyncEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadMembersUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadMemberUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutUpdateEventArgs.cs
DisCatSharp/EventArgs/HeartBeatEventArgs.cs
DisCatSharp/EventArgs/Interaction/ComponentInteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Interaction/ContextMenuInteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Interaction/InteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Invite/InviteCreateEventArgs.cs
DisCatSharp/EventArgs/Invite/InviteDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageAcknowledgeEventArgs.cs
DisCatSharp/EventArgs/Message/MessageBulkDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageCreateEventArgs.cs
DisCatSharp/EventArgs/Message/MessageDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageUpdateEventArgs.cs
DisCatSharp/EventArgs/Message/Polls/MessagePollVoteAddEventArgs.cs
DisCatSharp/EventArgs/Message/Polls/MessagePollVoteRemoveEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionAddEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEmojiEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionsClearEventArgs.cs
DisCatSharp/EventArgs/PayloadReceivedEventArgs.cs
DisCatSharp/EventArgs/RateLimitExceptionEventArgs.cs
DisCatSharp/EventArgs/ReadyEventArgs.cs
DisCatSharp/EventArgs/Socket/SocketDisconnectEventArgs.cs
DisCatSharp/EventArgs/Socket/SocketEventArgs.cs
DisCatSharp/EventArgs/Socket/WebSocketMessageEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceCreateEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceDeleteEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceUpdateEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementCreateEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementDeleteEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementUpdateEventArgs.cs
DisCatSharp/EventArgs/Store/SubscriptionCreateEventArgs.cs
DisCatSharp/EventArgs/Store/SubscriptionUpdateEventArgs.cs
DisCatSharp/EventArgs/TypingStartEventArgs.cs
DisCatSharp/EventArgs/UnknownEventArgs.cs
DisCatSharp/EventArgs/User/PresenceUpdateEventArgs.cs
DisCatSharp/EventArgs/User/UserSettingsUpdateEventArgs.cs
DisCatSharp/EventArgs/User/UserSpeakingEventArgs.cs
DisCatSharp/EventArgs/User/UserUpdateEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceChannelEffectSendEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceServerUpdateEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceStateUpdateEventArgs.cs
DisCatSharp/EventArgs/WebhooksUpdateEventArgs.cs
DisCatSharp/EventArgs/ZombiedEventArgs.cs
DisCatSharp/Exceptions/BadRequestException.cs
DisCatSharp/Exceptions/DisCatSharpException.cs
DisCatSharp/Exceptions/DisCatSharpUserException.cs
DisCatSharp/Exceptions/DiscordJsonException.cs
DisCatSharp/Exceptions/ExceptionFilter.cs
DisCatSharp/Exceptions/NotFoundException.cs
DisCatSharp/Exceptions/NotIndexedException.cs
DisCatSharp/Exceptions/RateLimitException.cs
DisCatSharp/Exceptions/RequestSizeException.cs
DisCatSharp/Exceptions/ServerErrorException.cs
DisCatSharp/Exceptions/UnauthorizedException.cs
DisCatSharp/Exceptions/ValidationException.cs
DisCatSharp/Formatter.cs
DisCatSharp/GlobalSuppressions.cs
DisCatSharp/Internals.cs
DisCatSharp/Logging/CompositeDefaultLogger.cs
DisCatSharp/Logging/DefaultLogger.cs
DisCatSharp/Logging/DefaultLoggerFactory.cs
DisCatSharp/Logging/DefaultLoggerProvider.cs
DisCatSharp/Logging/LoggerEvents.cs
DisCatSharp/Logging/ShardedLoggerFactory.cs
DisCatSharp/MediaTool.cs
DisCatSharp/Net/Abstractions/AuditLogAbstractions.cs
DisCatSharp/Net/Abstractions/ClientProperties.cs
DisCatSharp/Net/Abstractions/FollowedChannelAddPayload.cs
DisCatSharp/Net/Abstractions/Gateway/DiscordDispatchPayload.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayHello.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayIdentifyResume.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayInfo.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayOpCode.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayPayload.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayRequestGuildMembers.cs
DisCatSharp/Net/Abstractions/Gateway/SoundboardSoundsPayloads.cs
DisCatSharp/Net/Abstractions/Gateway/VoiceStateUpdatePayload.cs
DisCatSharp/Net/Abstractions/IOAuth2Payload.cs
DisCatSharp/Net/Abstractions/ReadyPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestApplicationCommandPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestApplicationPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestAutomodRuleModifyPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestChannelPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestForumPostTagPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildScheduledEventPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildSoundboardSoundPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestOAuth2ApplicationRoleConnectionPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestStageInstancePayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestStickerPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestStorePayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestUserPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestWebhookPayloads.cs
DisCatSharp/Net/Abstractions/ShardInfo.cs
DisCatSharp/Net/Abstractions/StatusUpdate.cs
DisCatSharp/Net/Abstractions/Transport/TransportActivity.cs
DisCatSharp/Net/Abstractions/Transport/TransportApplication.cs
DisCatSharp/Net/Abstractions/Transport/TransportMember.cs
DisCatSharp/Net/Abstractions/Transport/TransportTeam.cs
DisCatSharp/Net/Abstractions/Transport/TransportUser.cs
DisCatSharp/Net/Abstractions/VoiceStateUpdate.cs
DisCatSharp/Net/ConnectionEndpoint.cs
DisCatSharp/Net/Models/ApplicationCommandEditModel.cs
DisCatSharp/Net/Models/AutomodRuleEditModel.cs
DisCatSharp/Net/Models/BaseEditModel.cs
DisCatSharp/Net/Models/ChannelEditModel.cs
DisCatSharp/Net/Models/ForumChannelEditModel.cs
DisCatSharp/Net/Models/ForumPostTagEditModel.cs
DisCatSharp/Net/Models/GuildEditModel.cs
DisCatSharp/Net/Models/MemberEditModel.cs
DisCatSharp/Net/Models/MembershipScreeningEditModel.cs
DisCatSharp/Net/Models/RoleEditModel.cs
DisCatSharp/Net/Models/ScheduledEventEditModel.cs
DisCatSharp/Net/Models/SoundboardSoundEditModel.cs
DisCatSharp/Net/Models/ThreadEditModel.cs
DisCatSharp/Net/Models/WelcomeScreenEditModel.cs
DisCatSharp/Net/Rest/BaseRestRequest.cs
DisCatSharp/Net/Rest/CommonHeaders.cs
DisCatSharp/Net/Rest/DiscordApiClient.cs
DisCatSharp/Net/Rest/Endpoints.cs
DisCatSharp/Net/Rest/IpEndpoint.cs
DisCatSharp/Net/Rest/MultipartWebRequest.cs
DisCatSharp/Net/Rest/RateLimitBucket.cs
DisCatSharp/Net/Rest/RestClient.cs
DisCatSharp/Net/Rest/RestFormRequest.cs
DisCatSharp/Net/Rest/RestRequest.cs
DisCatSharp/Net/Rest/RestRequestMethod.cs
DisCatSharp/Net/Rest/RestResponse.cs
DisCatSharp/Net/Rest/SessionBucket.cs
DisCatSharp/Net/Serialization/DiscordComponentJsonConverter.cs
DisCatSharp/Net/Serialization/DiscordJson.cs
DisCatSharp/Net/Serialization/SnowflakeArrayAsDictionaryJsonConverter.cs
DisCatSharp/Net/Udp/BaseUdpClient.cs
DisCatSharp/Net/Udp/DCSUdpClient.cs
DisCatSharp/Net/WebSocket/IWebSocketClient.cs
DisCatSharp/Net/WebSocket/PayloadDecompressor.cs
DisCatSharp/Net/WebSocket/SocketLock.cs
DisCatSharp/Net/WebSocket/WebSocketClient.cs
DisCatSharp/QueryUriBuilder.cs
DisCatSharp/ReadOnlyConcurrentDictionary.cs
DisCatSharp/ReadOnlySet.cs
DisCatSharp/RingBuffer.cs
DisCatSharp/Utilities.cs
LICENSE.md
README.md
RELEASENOTES.md</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".repomixignore">.devcontainer/
.github/
.nuget/
DisCatSharp.Archive/
DisCatSharp.VoiceNext.Natives/
*.ruleset
*.ps1
.editorconfig
*.json
Directory.Build.props
DisCatSharp.code-workspace
.gitignore
.gitattributes
DisCatSharp.Docs/api/
DisCatSharp.Docs/pdf/
DisCatSharp.Docs/dcs/
*.yml
*.bat
*.dll
*.min
discatsharp-ai-test.xml
discatsharp-ai.xml</file><file path="ARTICLES.md"># Writing articles for DisCatSharp

## Markdown header

```md
---
uid: article_name
title: Article Title
description: Short article description
author: DisCatSharp Team
---

Your article content
```

## Available yml header options

| Key         | Description        | Example          |
| ----------- | ------------------ | ---------------- |
| uid         | uid for cross ref  | cats             |
| title       | site title         | Cats             |
| description | short summarize    | Meow             |
| author      | your name          | DisCatSharp Team |

## Markdown docs for docfx

https://dotnet.github.io/docfx/docs/markdown.html</file><file path="BUILDING.md"># Building DisCatSharp
These are detailed instructions on how to build the DisCatSharp library under various environmnets.

It is recommended you have prior experience with multi-target .NET Core/Standard projects, as well as the `dotnet` CLI utility, and MSBuild.

## Requirements
In order to build the library, you will first need to install some software.

### Windows
On Windows, we only officially support Visual Studio 2022 17.0 or newer. Visual Studio Code and other IDEs might work, but are generally not supported or even guaranteed to work properly.

* **Windows 10** - while we support running the library on Windows 7 and above, we only support building on Windows 10 and better.
* [**Git for Windows**](https://git-scm.com/download/win) - required to clone the repository.
* [**Visual Studio 2022**](https://www.visualstudio.com/downloads/) - community edition or better. We do not support Visual Studio 2021 and older.
* **Windows PowerShell** - required to run the build scripts. You need to make sure your script execution policy allows execution of unsigned scripts.
* [**.NET SDK 8.0 or newer**](https://www.microsoft.com/net/download) - required to build the project.

### GNU/Linux
On GNU/Linux, we support building via Visual Studio Code and .NET Core SDK. Other IDEs might work, but are not supported or guaranteed to work properly.

While these should apply to any modern distribution, we only test against Ubuntu 24.04. Your mileage may vary.

When installing the below, make sure you install all the dependencies properly. We might ship a build environment as a docker container in the future.

* **Any modern GNU/Linux distribution** - like Ubuntu 24.04.
* **Git** - to clone the repository.
* [**Visual Studio Code**](https://code.visualstudio.com/Download) - a recent version is required.
   * **C# for Visual Studio Code (powered by OmniSharp)** - required for syntax highlighting and basic Intellisense
* [**.NET SDK 8.0 or newer**](https://www.microsoft.com/net/download) - required to build the project.
* [**PowerShell Core**](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7.5) - required to execute the build scripts.

## Instructions
Once you install all the necessary prerequisites, you can proceed to building. These instructions assume you have already cloned the repository.

### Windows
Building on Windows is relatively easy. There&apos;s 2 ways to build the project:

#### Building through Visual Studio
Building through Visual Studio yields just binaries you can use in your projects.

1. Open the solution in Visual Studio.
2. Set the configuration to Release.
3. Select Build &gt; Build Solution to build the project.
4. Select Build &gt; Publish DisCatSharp to publish the binaries.

#### Building with the build script
Building this way outputs NuGet packages, and a documentation package. Ensure you have an internet connection available, as the script will install programs necessary to build the documentation.

1. Open PowerShell and navigate to the directory which you cloned DisCatSharp to.
2. Execute `.\DisCatSharp.Tools\rebuild-lib.ps1 -ArtifactLocation .\dcs-artifacts -Configuration Release` and wait for the script to finish execution.
3. Once it&apos;s done, the artifacts will be available in *dcs-artifacts* directory, next to the directory to which the repository is cloned.

### GNU/Linux
When all necessary prerequisites are installed, you can proceed to building. There are technically 2 ways to build the library, though both of them perform the same steps, they are just invoked slightly differently.

#### Through Visual Studio Code
1. Open Visual Studio Code and open the folder to which you cloned DisCatSharp as your workspace.
2. Select Build &gt; Run Task...
3. Select `buildRelease` task and wait for it to finish.
4. The artifacts will be placed in *dcs-artifacts* directory, next to where the repository is cloned.

#### Through PowerShell
1. Open PowerShell (`pwsh`) and navigate to the directory which you cloned DisCatSharp to.
2. Execute `./DisCatSharp.Tools/rebuild-lib.ps1 -ArtifactLocation ./dcs-artifacts -Configuration Release` and wait for the script to finish execution.
3. Once it&apos;s done, the artifacts will be available in *dcs-artifacts* directory, next to the directory to which the repository is cloned.</file><file path="CHANGELOG.md"># Changelogs

Please visit our [documentation](https://docs.dcs.aitsys.dev/changelogs) for more information.</file><file path="CONTRIBUTING.md"># Contributing to DisCatSharp
We&apos;re really happy to accept contributions. However we also ask that you follow several rules when doing so.

# Proper base
When opening a PR, please make sure your branch targets the latest release branch, in this case it would be `main`. Also make sure your branch is even with the target branch, to avoid unnecessary surprises.

# Versioning
We follow custom [SemVer](https://semver.org/) versioning when it comes to pushing stable releases. Ideally, this means you should only be creating PRs for `PATCH` and `MINOR` changes. If you wish to introduce a `major` (breaking) change, please discuss it beforehand so we can determine how to integrate it into our next major version. If this involves removing a public facing property/method, mark it with the `Deprecated` attribute instead on the latest release branch.

Warning: We use a slightly different method for SemVer. {DISCORD_API_VERSION}.{MAJOR}.{MINOR}-{PATCH}

# Proper titles
When opening issues, make sure the title reflects the purpose of the issue or the pull request. Prefer past tense, and
be brief. Further description belongs inside the issue or PR.

# Descriptive changes
We require the commits describe the change made. It can be a short description. If you fixed or resolved an open issue,
please reference it by using the # notation.

Examples of good commit messages:

* `Fixed a potential memory leak with cache entities. Fixes #142.`
* `Implemented new command extension. Resolves #169.`
* `Changed message cache behaviour. It&apos;s now global instead of per-channel.`
* `Fixed a potential NRE.`
* ```
  Changed message cache behaviour:

  - Messages are now stored globally.
  - Cache now deletes messages when they are deleted from discord.
  - Cache itself is now a ring buffer.
  ```

# Code style
We use [Microsoft C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)
throughout the repository, with several exceptions:

* Preference of `this`. While this one is not required, it&apos;s ill-advised to remove the existing instances thereof.
* When working with async code, and your method consists of a single `await` statement not in any `if`, `while`, etc.
  blocks, pass the task through instead of awaiting it. For example:

  ```cs
  public Task DoSomethingAsync()
    =&gt; this.DoAnotherThingAsync();

  public Task DoAnotherThingAsync()
  {
      Console.WriteLine(&quot;42&quot;);
      return this.DoYetAnotherThingAsync(42);
  }

  public async Task DoYetAnotherThingAsync(int num)
  {
      if (num == 42)
          await SuperAwesomeMethodAsync();
  }
  ```

In addition to these, we also have several preferences:

* Use initializer syntax when possible:

  ```cs
  var a = new Class
  {
      StringNumber = &quot;forty-two&quot;,
      Number = 42
  };

  var b = new Dictionary&lt;string, int&gt;()
  {
      [&quot;forty-two&quot;] = 42,
      [&quot;sixty-nine&quot;] = 69
  };

  var c = new List&lt;int&gt;() { 42, 69 };

  var d = new[] { 42, 69 };
  ```
* Inline `out` declarations when possible: `SomeOutMethod(42, out var stringified);`
* Members in classes should be ordered as follows (with few exceptions):
   * Public `const` fields.
   * Non-public `const` fields.
   * Public static properties.
   * Public static fields.
   * Non-public static properties.
   * Non-public static fields.
   * Public properties.
   * Public fields.
   * Private properties.
   * Private fields.
   * Static constructor.
   * Public constructors.
   * Non-public constructors.
   * Public methods (with the exception of methods overridden from `System.Object`).
   * Non-public methods.
   * Methods overridden from `System.Object`.
   * Public static methods.
   * Non-public static methods.
   * Operator overloads.
   * Public events.
   * Non-public events.

# Code changes
One of our requirements is that all code change commits must build successfully. This is verified by our CI. When you
open a pull request, AppVeyor will start a build. You can view its summary by visiting it from the checks section on
the PR overview page.

PRs that do not build will not be accepted.

Furthermore we require that methods you implement on Discord entities have a reflection in the Discord API.

# Developer Certificate of Origin (DCO)
```
Version 1.1

Copyright (C) 2004, 2006 The Linux Foundation and its contributors.

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.


Developer&apos;s Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
```</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsConfiguration.cs">public sealed class ApplicationCommandsConfiguration
	public IServiceProvider ServiceProvider { internal get; set; } = new ServiceCollection().BuildServiceProvider(true);</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsExtension.cs">public sealed class ApplicationCommandsExtension : BaseExtension
	internal static ApplicationCommandsConfiguration Configuration;
		=&gt; s_registeredCommands.Select(guild =&gt;
				.Select(parent =&gt; new RegisteredDiscordApplicationCommand(parent)).ToList())).ToList().AsReadOnly();
	protected internal override void Setup(DiscordClient client)
			throw new InvalidOperationException(&quot;What did I tell you?&quot;);
				_ = Task.Run(async () =&gt; await this.UpdateAsync().ConfigureAwait(false));
	private async Task CatchInteractionsOnStartup(DiscordClient sender, InteractionCreateEventArgs e)
			await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Attention: This application is still starting up. Application commands are unavailable for now.&quot;)).ConfigureAwait(false);
			await Task.Delay(1).ConfigureAwait(false);
	private async Task CatchContextMenuInteractionsOnStartup(DiscordClient sender, ContextMenuInteractionCreateEventArgs e)
			await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Attention: This application is still starting up. Context menu commands are unavailable for now.&quot;)).ConfigureAwait(false);
	private void FinishedRegistration()
	public void CleanModule()
		this._updateList.Clear();
		s_singletonModules.Clear();
		CommandMethods.Clear();
		GroupCommands.Clear();
		ContextMenuCommands.Clear();
		SubGroupCommands.Clear();
		s_registeredCommands.Clear();
		GlobalCommandsInternal.Clear();
		GuildCommandsInternal.Clear();
		s_missingScopeGuildIdsGlobal.Clear();
		this.MISSING_SCOPE_GUILD_IDS.Clear();
		HandledInteractions.Clear();
	public async Task CleanGuildCommandsAsync()
			await this.Client.BulkOverwriteGuildApplicationCommandsAsync(guild.Id, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
	public async Task CleanGlobalCommandsAsync()
		=&gt; await this.Client.BulkOverwriteGlobalApplicationCommandsAsync(Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
	public void RegisterGuildCommands(Assembly assembly, ulong guildId)
		var types = assembly.GetTypes().Where(xt =&gt;
			var xti = xt.GetTypeInfo();
			return xti.IsModuleCandidateType() &amp;&amp; !xti.IsNested;
			this.RegisterGuildCommands(xt, guildId);
	public void RegisterGlobalCommands(Assembly assembly)
			this.RegisterGlobalCommands(xt);
	public void RegisterGuildCommands&lt;T&gt;(ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
		=&gt; this._updateList.Add(new(guildId, new(typeof(T), translationSetup)));
	public void RegisterGuildCommands(Type type, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
		if (!typeof(ApplicationCommandsModule).IsAssignableFrom(type))
			throw new ArgumentException(&quot;Command classes have to inherit from ApplicationCommandsModule&quot;, nameof(type));
		this._updateList.Add(new(guildId, new(type, translationSetup)));
	public void RegisterGlobalCommands&lt;T&gt;(Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
		=&gt; this._updateList.Add(new(null, new(typeof(T), translationSetup)));
	public void RegisterGlobalCommands(Type type, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
		this._updateList.Add(new(null, new(type, translationSetup)));
		add =&gt; this._applicationCommandsModuleReady.Register(value);
		remove =&gt; this._applicationCommandsModuleReady.Unregister(value);
		add =&gt; this._applicationCommandsModuleStartupFinished.Register(value);
		remove =&gt; this._applicationCommandsModuleStartupFinished.Unregister(value);
		add =&gt; this._guildApplicationCommandsRegistered.Register(value);
		remove =&gt; this._guildApplicationCommandsRegistered.Unregister(value);
		add =&gt; this._globalApplicationCommandsRegistered.Register(value);
		remove =&gt; this._globalApplicationCommandsRegistered.Unregister(value);
	internal async Task UpdateAsync()
		this.Client.Logger.Log(LogLevel.Information, &quot;Request to register commands on shard {shard}&quot;, this.Client.ShardId);
				this.Client.Logger.Log(LogLevel.Information, &quot;Shard {shard} already setup, skipping&quot;, this.Client.ShardId);
			this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Shard {shard} has {guilds} guilds&quot;, this.Client.ShardId, this.Client.ReadyGuildIds.Count);
			var globalCommands = IsCalledByUnitTest ? null : (await this.Client.GetGlobalApplicationCommandsAsync(Configuration?.EnableLocalization ?? false).ConfigureAwait(false))?.ToList() ?? null;
			var guilds = CheckAllGuilds ? this.Client.ReadyGuildIds : this._updateList.Where(x =&gt; x.Key is not null)?.Select(x =&gt; x.Key!.Value).Distinct().ToList();
			var wrongShards = guilds is not null &amp;&amp; this.Client.ReadyGuildIds.Count is not 0 ? guilds.Where(x =&gt; !this.Client.ReadyGuildIds.Contains(x)).ToList() : [];
				this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Some guilds are not on the same shard as the client. Removing them from the update list&quot;);
					this._updateList.RemoveAll(x =&gt; x.Key == guild);
			var commandsPending = this._updateList.Select(x =&gt; x.Key).Distinct().ToList();
						commands = (await this.Client.GetGuildApplicationCommandsAsync(guild, Configuration?.EnableLocalization ?? false).ConfigureAwait(false)).ToList() ?? null;
								GuildDiscordCommands.Add(guild, [.. commands]);
								failedGuilds.Add(guild);
				this._updateList.Add(new(null, new(typeof(DefaultHelpModule))));
				commandsPending = this._updateList.Select(x =&gt; x.Key).Distinct().ToList();
				this._updateList.Add(new(null, new(typeof(DefaultUserAppsHelpModule))));
					this._updateList.Remove(new(null, new(typeof(DefaultHelpModule))));
				GlobalDiscordCommands.AddRange(globalCommands);
					var entryPointCommand = globalCommands.First(command =&gt; command.Name == &quot;launch&quot;);
				this.Client.Logger.Log(ApplicationCommandsLogLevel, key.HasValue ? $&quot;Registering commands in guild {key.Value}&quot; : &quot;Registering global commands&quot;);
					this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Found guild {guild} in shard {shard}!&quot;, key.Value, this.Client.ShardId);
					this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Registering&quot;);
				await this.RegisterCommands(this._updateList.Where(x =&gt; x.Key == key).Select(x =&gt; x.Value).ToList(), key).ConfigureAwait(false);
			s_missingScopeGuildIdsGlobal.AddRange(failedGuilds);
			this.Client.Logger.Log(LogLevel.Information, &quot;Application command setup finished for shard {ShardId}, enabling receiving&quot;, this.Client.ShardId);
			await this._applicationCommandsModuleStartupFinished.InvokeAsync(this, new(Configuration?.ServiceProvider)
			}).ConfigureAwait(false);
			this.FinishedRegistration();
			this.Client.Logger.LogCritical(ex, &quot;There was an error during the application commands setup&quot;);
			this.Client.Logger.LogError(ex.Message);
			this.Client.Logger.LogError(ex.StackTrace);
	private async Task RegisterCommands(List&lt;ApplicationCommandsModuleConfiguration&gt; types, ulong? guildId)
		this.Client.Logger.Log(LogLevel.Information, &quot;Registering commands on shard {shard}&quot;, this.Client.ShardId);
				var module = type.GetTypeInfo();
				var ctx = new ApplicationCommandsTranslationContext(type, module.FullName);
					classes.Add(module);
				else if (module.GetMembers(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance).Any(x =&gt; x.IsDefined(typeof(SlashCommandGroupAttribute))))
					classes = module.GetMembers(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)
						.Where(x =&gt; x.IsDefined(typeof(SlashCommandGroupAttribute)))
						.Select(x =&gt; module.GetNestedType(x.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance).GetTypeInfo()).ToList();
					classes = module.DeclaredNestedTypes.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandGroupAttribute&gt;() != null).ToList();
					if (!string.IsNullOrEmpty(ctx.GroupTranslations))
					var slashGroupsTuple = await NestedCommandWorker.ParseSlashGroupsAsync(type, classes, guildId, groupTranslations).ConfigureAwait(false);
							unitTestCommands.AddRange(slashGroupsTuple.applicationCommands);
						updateList.AddRange(slashGroupsTuple.applicationCommands);
										foreach (var scg in cmd.Options.Where(x =&gt; x.Type is ApplicationCommandOptionType.SubCommandGroup))
														cs.Add(new(sc.Name, sc.Description, null, null, sc.RawNameLocalizations, sc.RawDescriptionLocalizations));
														cs.Add(new(sc.Name, sc.Description, [.. sc.Options], null, sc.RawNameLocalizations, sc.RawDescriptionLocalizations));
											cgs.Add(new(scg.Name, scg.Description, cs, null, scg.RawNameLocalizations, scg.RawDescriptionLocalizations));
										foreach (var sc2 in cmd.Options.Where(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand))
												cs2.Add(new(sc2.Name, sc2.Description, null, null, sc2.RawNameLocalizations, sc2.RawDescriptionLocalizations));
												cs2.Add(new(sc2.Name, sc2.Description, [.. sc2.Options], null, sc2.RawNameLocalizations, sc2.RawDescriptionLocalizations));
									cgwsgs.Add(new(cmd.Name, cmd.Description, cgs, cs2, cmd.Type, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
								groupTranslation.AddRange(cgwsgs.Select(cgwsg =&gt; JsonConvert.DeserializeObject&lt;GroupTranslator&gt;(JsonConvert.SerializeObject(cgwsg))!));
						commandTypeSources.AddRange(slashGroupsTuple.commandTypeSources);
						s_singletonModules.AddRange(slashGroupsTuple.singletonModules);
						groupCommands.AddRange(slashGroupsTuple.groupCommands);
						subGroupCommands.AddRange(slashGroupsTuple.subGroupCommands);
					if (!string.IsNullOrEmpty(ctx.SingleTranslations))
					var methods = module.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null);
					var slashCommands = await CommandWorker.ParseBasicSlashCommandsAsync(type, methods, guildId, commandTranslations).ConfigureAwait(false);
							unitTestCommands.AddRange(slashCommands.applicationCommands);
						updateList.AddRange(slashCommands.applicationCommands);
							foreach (var cmd in slashCommands.applicationCommands.Where(cmd =&gt; cmd.Type is ApplicationCommandType.ChatInput &amp;&amp; (cmd.Options is null || !cmd.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand or ApplicationCommandOptionType.SubCommandGroup))))
									cs.Add(new(cmd.Name, cmd.Description, null, ApplicationCommandType.ChatInput, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
									cs.Add(new(cmd.Name, cmd.Description, [.. cmd.Options], ApplicationCommandType.ChatInput, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
									var json = JsonConvert.SerializeObject(c);
									translation.Add(obj!);
						commandTypeSources.AddRange(slashCommands.commandTypeSources);
						commandMethods.AddRange(slashCommands.commandMethods);
					var contextMethods = module.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;ContextMenuAttribute&gt;() is not null);
					var contextCommands = await CommandWorker.ParseContextMenuCommands(type, contextMethods, commandTranslations).ConfigureAwait(false);
							unitTestCommands.AddRange(contextCommands.applicationCommands);
						updateList.AddRange(contextCommands.applicationCommands);
									cs.Add(new(cmd.Name, null, null, cmd.Type));
								translation.AddRange(cs.Select(c =&gt; JsonConvert.DeserializeObject&lt;CommandTranslator&gt;(JsonConvert.SerializeObject(c))!));
						commandTypeSources.AddRange(contextCommands.commandTypeSources);
						contextMenuCommands.AddRange(contextCommands.contextMenuCommands);
						s_singletonModules.Add(CreateInstance(module, Configuration?.ServiceProvider));
				this.Client.Logger.LogCritical(ex, &quot;NRE Exception thrown: {msg}\nStack: {stack}&quot;, ex.Message, ex.StackTrace);
					this.Client.Logger.LogCritical(brex, @&quot;There was an error registering application commands: {res}&quot;, brex.WebResponse.Response);
						this.Client.Logger.LogCritical(brex1, @&quot;There was an error registering application commands: {res}&quot;, brex1.WebResponse.Response);
						this.Client.Logger.LogCritical(ex, @&quot;There was an error parsing the application commands&quot;);
			updateList = updateList.DistinctBy(x =&gt; x.Name).ToList();
				await this.CheckRegistrationStartup(translation, groupTranslation, guildId);
								var regCommands = await RegistrationWorker.RegisterGlobalCommandsAsync(this.Client, updateList, EntryPointCommand).ConfigureAwait(false);
									var actualCommands = regCommands.Distinct().ToList();
									commands.AddRange(actualCommands);
									GlobalCommandsInternal.AddRange(actualCommands);
											await this.Client.DeleteGlobalApplicationCommandAsync(cmd.Id).ConfigureAwait(false);
										this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Could not delete global command {cmdId}. Please clean up manually&quot;, cmd.Id);
								var regCommands = await RegistrationWorker.RegisterGuildCommandsAsync(this.Client, guildId.Value, updateList).ConfigureAwait(false);
									GuildCommandsInternal.Add(guildId.Value, actualCommands);
										if (this.Client.Guilds.TryGetValue(guildId.Value, out var guild))
											guild.InternalRegisteredApplicationCommands.AddRange(actualCommands);
								foreach (var cmd in GuildDiscordCommands.First(x =&gt; x.Key == guildId.Value).Value)
										await this.Client.DeleteGuildApplicationCommandAsync(guildId.Value, cmd.Id).ConfigureAwait(false);
										this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Could not delete guild command {cmdId} in guild {guildId}. Please clean up manually&quot;, cmd.Id, guildId.Value);
						this.Client.Logger.LogError(&quot;Could not register application commands for guild {guildId}.\nError: {exc}&quot;, guildId, ex.JsonMessage);
						if (commandMethods!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var com))
						if (groupCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var groupCom))
						if (subGroupCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var subCom))
						if (contextMenuCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var cmCom))
					CommandMethods.AddRange(commandMethods.DistinctBy(x =&gt; x.Name));
					GroupCommands.AddRange(groupCommands.DistinctBy(x =&gt; x.Name));
					SubGroupCommands.AddRange(subGroupCommands.DistinctBy(x =&gt; x.Name));
					ContextMenuCommands.AddRange(contextMenuCommands.DistinctBy(x =&gt; x.Name));
					s_registeredCommands.Add(new(guildId, commands.ToList()));
					foreach (var app in commandMethods.Select(command =&gt; types.First(t =&gt; t.Type == command.Method.DeclaringType)))
						await this._guildApplicationCommandsRegistered.InvokeAsync(this, new(Configuration?.ServiceProvider)
							RegisteredCommands = GuildCommandsInternal.FirstOrDefault(c =&gt; c.Key == guildId.Value).Value ?? []
						await this._globalApplicationCommandsRegistered.InvokeAsync(this, new(Configuration?.ServiceProvider)
							this.Client.Logger.LogCritical(ex, @&quot;There was an general error registering application commands&quot;);
			s_registeredCommands.Add(new(guildId, unitTestCommands.ToList()));
	private async Task CheckRegistrationStartup(List&lt;CommandTranslator&gt;? translation = null, List&lt;GroupTranslator&gt;? groupTranslation = null, ulong? guildId = null)
					var fs = File.Create(fileName);
					var ms = new MemoryStream();
					var writer = new StreamWriter(ms);
					await writer.WriteAsync(JsonConvert.SerializeObject(translation.DistinctBy(x =&gt; x.Name), Formatting.Indented)).ConfigureAwait(false);
					await writer.FlushAsync().ConfigureAwait(false);
					await ms.CopyToAsync(fs).ConfigureAwait(false);
					await fs.FlushAsync().ConfigureAwait(false);
					fs.Close();
					await fs.DisposeAsync().ConfigureAwait(false);
					ms.Close();
					await ms.DisposeAsync().ConfigureAwait(false);
					this.Client.Logger.LogInformation(&quot;Exported base translation to {exppath}&quot;, fileName);
					await writer.WriteAsync(JsonConvert.SerializeObject(groupTranslation.DistinctBy(x =&gt; x.Name), Formatting.Indented)).ConfigureAwait(false);
				this.Client.Logger.LogError(@&quot;{msg}&quot;, ex.Message);
				this.Client.Logger.LogError(@&quot;{stack}&quot;, ex.StackTrace);
			await this.Client.DisconnectAsync().ConfigureAwait(false);
	private async Task CheckStartupFinishAsync(ApplicationCommandsExtension sender, ApplicationCommandsModuleStartupFinishedEventArgs args)
				await this._applicationCommandsModuleReady.InvokeAsync(sender, new(Configuration?.ServiceProvider)
					Environment.Exit(0);
	private Task InteractionHandler(DiscordClient client, InteractionCreateEventArgs e)
		this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Got slash interaction on shard {shard}&quot;, this.Client.ShardId);
		if (HandledInteractions.Contains(e.Interaction.Id) || (e.Interaction is { GuildId: not null, AuthorizingIntegrationOwners.GuildInstallKey: not null } &amp;&amp; !client.Guilds.ContainsKey(e.Interaction.GuildId.Value)))
			this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Ignoring, already received or wrong shard&quot;);
			return Task.FromResult(true);
		HandledInteractions.Add(e.Interaction.Id);
		_ = Task.Run(async () =&gt;
					var context = new InteractionContext
						ResolvedUserMentions = e.Interaction.Data.Resolved?.Users?.Values.ToList() ?? [],
						ResolvedRoleMentions = e.Interaction.Data.Resolved?.Roles?.Values.ToList() ?? [],
						ResolvedChannelMentions = e.Interaction.Data.Resolved?.Channels?.Values.ToList() ?? [],
						ResolvedAttachments = e.Interaction.Data.Resolved?.Attachments?.Values.ToList() ?? [],
							await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Application commands failed to register properly on startup.&quot;).AsEphemeral()).ConfigureAwait(false);
							throw new InvalidOperationException(&quot;Application commands failed to register properly on startup.&quot;);
						var methods = CommandMethods.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
						var groups = GroupCommands.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
						var subgroups = SubGroupCommands.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
							await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;An application command was executed, but no command was registered for it.&quot;).AsEphemeral()).ConfigureAwait(false);
							throw new InvalidOperationException($&quot;An application command was executed, but no command was registered for it.\n\tCommand name: {e.Interaction.Data.Name}\n\tCommand ID: {e.Interaction.Data.Id}&quot;);
								var method = methods.First().Method;
									this.Client.Logger.LogDebug(&quot;Executing {cmd}&quot;, method.Name);
								var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options).ConfigureAwait(false);
								await this.RunCommandAsync(context, method, args).ConfigureAwait(false);
								var method = groups.First().Methods.First(x =&gt; x.Key == command.Name).Value;
								var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options[0].Options).ConfigureAwait(false);
								var group = subgroups.First().SubCommands.First(x =&gt; x.Name == command.Name);
								var method = group.Methods.First(x =&gt; x.Key == command.Options[0].Name).Value;
								var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options[0].Options[0].Options).ConfigureAwait(false);
								throw new ArgumentOutOfRangeException(null, &quot;Could not determine application command type&quot;);
						await this._slashExecuted.InvokeAsync(this, new(this.Client.ServiceProvider)
						await this._slashError.InvokeAsync(this, new(this.Client.ServiceProvider)
						this.Client.Logger.LogError(ex, &quot;Error in slash interaction&quot;);
						throw new InvalidOperationException(&quot;An autocomplete interaction was created, but no command was registered for it&quot;);
								var focusedOption = e.Interaction.Data.Options.First(o =&gt; o.Focused);
								var option = method.GetParameters().Skip(1).First(p =&gt; p.GetCustomAttribute&lt;OptionAttribute&gt;().Name == focusedOption.Name);
								var providerMethod = provider.GetMethod(nameof(IAutocompleteProvider.Provider));
								var providerInstance = Activator.CreateInstance(provider);
								var context = new AutocompleteContext
									Options = e.Interaction.Data.Options.ToList(),
								var choices = await ((Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt;)providerMethod.Invoke(providerInstance, [context])).ConfigureAwait(false);
								await e.Interaction.CreateResponseAsync(InteractionResponseType.AutoCompleteResult, new DiscordInteractionResponseBuilder().AddAutoCompleteChoices(choices)).ConfigureAwait(false);
								var group = groups.First().Methods.First(x =&gt; x.Key == command.Name).Value;
								var focusedOption = command.Options.First(o =&gt; o.Focused);
								var option = group.GetParameters().Skip(1).First(p =&gt; p.GetCustomAttribute&lt;OptionAttribute&gt;().Name == focusedOption.Name);
									Options = command.Options.ToList(),
								var group = subgroups.First().SubCommands.First(x =&gt; x.Name == command.Name).Methods.First(x =&gt; x.Key == command.Options[0].Name).Value;
								var focusedOption = command.Options[0].Options.First(o =&gt; o.Focused);
									Options = command.Options[0].Options.ToList(),
						this.Client.Logger.LogError(ex, &quot;Error in autocomplete interaction&quot;);
					throw new ArgumentOutOfRangeException(null, &quot;Received out unknown interaction type&quot;);
	private static ApplicationCommandFinalType GetInteractionType(DiscordInteractionData data)
		if (data.Options.All(x =&gt;
		if (data.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommandGroup))
		else if (data.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand))
	private Task ContextMenuHandler(DiscordClient client, ContextMenuInteractionCreateEventArgs e)
		this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Got context menu interaction on shard {shard}&quot;, this.Client.ShardId);
		if (HandledInteractions.Contains(e.Interaction.Id))
			this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Ignoring, already received&quot;);
			var context = new ContextMenuContext(e.Type switch
				_ =&gt; throw new ArgumentOutOfRangeException(nameof(e.Type), &quot;Unknown context menu type&quot;)
					await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Context menus failed to register properly on startup.&quot;).AsEphemeral()).ConfigureAwait(false);
					throw new InvalidOperationException(&quot;Context menus failed to register properly on startup.&quot;);
				var method = ContextMenuCommands.FirstOrDefault(x =&gt; x.CommandId == e.Interaction.Data.Id);
					await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;A context menu command was executed, but no command was registered for it.&quot;).AsEphemeral()).ConfigureAwait(false);
					throw new InvalidOperationException(&quot;A context menu command was executed, but no command was registered for it.&quot;);
				await this.RunCommandAsync(context, method.Method, new[] { context }).ConfigureAwait(false);
				await this._contextMenuExecuted.InvokeAsync(this, new(this.Client.ServiceProvider)
				await this._contextMenuErrored.InvokeAsync(this, new(this.Client.ServiceProvider)
	internal async Task RunCommandAsync(BaseContext context, MethodInfo method, IEnumerable&lt;object&gt; args)
		this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Executing {cmd}&quot;, method.Name);
				method.IsStatic ? ActivatorUtilities.CreateInstance(Configuration?.ServiceProvider.CreateScope().ServiceProvider, method.DeclaringType) : CreateInstance(method.DeclaringType, Configuration?.ServiceProvider.CreateScope().ServiceProvider),
				method.IsStatic ? ActivatorUtilities.CreateInstance(Configuration?.ServiceProvider, method.DeclaringType) : CreateInstance(method.DeclaringType, Configuration?.ServiceProvider),
			ApplicationCommandModuleLifespan.Singleton =&gt; s_singletonModules.First(x =&gt; ReferenceEquals(x.GetType(), method.DeclaringType)),
		ApplicationCommandsModule module = null;
				await RunPreexecutionChecksAsync(method, slashContext).ConfigureAwait(false);
				var shouldExecute = await (module?.BeforeSlashExecutionAsync(slashContext) ?? Task.FromResult(true)).ConfigureAwait(false);
						await context.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource).ConfigureAwait(false);
					await ((Task)method.Invoke(classInstance, args.ToArray())).ConfigureAwait(false);
					await (module?.AfterSlashExecutionAsync(slashContext) ?? Task.CompletedTask).ConfigureAwait(false);
				await RunPreexecutionChecksAsync(method, contextMenuContext).ConfigureAwait(false);
				var shouldExecute = await (module?.BeforeContextMenuExecutionAsync(contextMenuContext) ?? Task.FromResult(true)).ConfigureAwait(false);
					await (module?.AfterContextMenuExecutionAsync(contextMenuContext) ?? Task.CompletedTask).ConfigureAwait(false);
	internal static object CreateInstance(Type t, IServiceProvider services)
		var ti = t.GetTypeInfo();
			.Where(xci =&gt; xci.IsPublic)
			.ToArray();
			throw new ArgumentException(&quot;Specified type does not contain a public constructor or contains more than one public constructor.&quot;);
		var constructorArgs = constructor.GetParameters();
			throw new InvalidOperationException(&quot;Dependency collection needs to be specified for parameterized constructors.&quot;);
				args[i] = services.GetRequiredService(constructorArgs[i].ParameterType);
		var moduleInstance = Activator.CreateInstance(t, args);
		var props = t.GetRuntimeProperties().Where(xp =&gt; xp.CanWrite &amp;&amp; xp.SetMethod is not null &amp;&amp; !xp.SetMethod.IsStatic &amp;&amp; xp.SetMethod.IsPublic);
			var service = services.GetService(prop.PropertyType);
			prop.SetValue(moduleInstance, service);
		var fields = t.GetRuntimeFields().Where(xf =&gt; !xf.IsInitOnly &amp;&amp; xf is { IsStatic: false, IsPublic: true });
			var service = services.GetService(field.FieldType);
			field.SetValue(moduleInstance, service);
	private async Task&lt;List&lt;object?&gt;&gt; ResolveInteractionCommandParameters(InteractionCreateEventArgs e, InteractionContext context, MethodBase method, IReadOnlyList&lt;DiscordInteractionDataOption&gt; options)
		var parameters = method.GetParameters().Skip(1).ToList();
			if (parameter.IsOptional &amp;&amp; (options is null || (!options?.Any(x =&gt; x.Name == parameter.GetCustomAttribute&lt;OptionAttribute&gt;()?.Name.ToLower()) ?? true)))
				args.Add(parameter.DefaultValue);
				var option = options.Single(x =&gt; x.Name == parameter.GetCustomAttribute&lt;OptionAttribute&gt;()?.Name.ToLower());
					args.Add(option.Value.ToString());
					args.Add(Enum.Parse(parameter.ParameterType, (string)option.Value));
					args.Add((ulong?)option.Value);
					args.Add((int?)option.Value);
						args.Add(null);
						args.Add(Convert.ToInt64(option.Value));
					args.Add((bool?)option.Value);
					args.Add((double?)option.Value);
					    e.Interaction.Data.Resolved.Attachments.TryGetValue((ulong)option.Value, out var attachment))
						args.Add(attachment);
						args.Add(new DiscordAttachment
					    e.Interaction.Data.Resolved.Members.TryGetValue((ulong)option.Value, out var member))
						args.Add(member);
					         e.Interaction.Data.Resolved.Users.TryGetValue((ulong)option.Value, out var user))
						args.Add(user);
						args.Add(await this.Client.GetUserAsync((ulong)option.Value).ConfigureAwait(false));
					    e.Interaction.Data.Resolved.Channels.TryGetValue((ulong)option.Value, out var channel))
						args.Add(channel);
						args.Add(e.Interaction.Guild.GetChannel((ulong)option.Value));
					    e.Interaction.Data.Resolved.Roles.TryGetValue((ulong)option.Value, out var role))
						args.Add(role);
						args.Add(e.Interaction.Guild.GetRole((ulong)option.Value));
					if (e.Interaction.Data.Resolved.Channels != null &amp;&amp; e.Interaction.Data.Resolved.Channels.TryGetValue((ulong)option.Value, out var channel))
					if (e.Interaction.Data.Resolved.Roles != null &amp;&amp; e.Interaction.Data.Resolved.Roles.TryGetValue((ulong)option.Value, out var role))
					else if (e.Interaction.Data.Resolved.Members != null &amp;&amp; e.Interaction.Data.Resolved.Members.TryGetValue((ulong)option.Value, out var member))
					else if (e.Interaction.Data.Resolved.Users != null &amp;&amp; e.Interaction.Data.Resolved.Users.TryGetValue((ulong)option.Value, out var user))
						throw new ArgumentException(&quot;Error resolving mentionable option.&quot;);
					throw new ArgumentException(&quot;Error resolving interaction.&quot;);
	private static async Task RunPreexecutionChecksAsync(MemberInfo method, BaseContext context)
						attributes.AddRange(method.DeclaringType.DeclaringType.DeclaringType.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
					attributes.AddRange(method.DeclaringType.DeclaringType.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
				attributes.AddRange(method.DeclaringType!.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
				attributes.AddRange(method.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;(true));
					var result = await att.ExecuteChecksAsync(ctx).ConfigureAwait(false);
					dict.Add(att, result);
				if (dict.Any(x =&gt; x.Value is false))
					throw new SlashExecutionChecksFailedException
						FailedChecks = dict.Where(x =&gt; x.Value is false).Select(x =&gt; x.Key).ToList()
					var result = await att.ExecuteChecksAsync(cMctx).ConfigureAwait(false);
					throw new ContextMenuExecutionChecksFailedException
	private static async Task&lt;List&lt;DiscordApplicationCommandOptionChoice&gt;&gt; GetChoiceAttributesFromProvider(List&lt;ChoiceProviderAttribute&gt; customAttributes, ulong? guildId = null)
			var method = choiceProviderAttribute.ProviderType.GetMethod(nameof(IChoiceProvider.Provider)) ?? throw new ArgumentException(&quot;ChoiceProviders must inherit from IChoiceProvider.&quot;);
			var instance = Activator.CreateInstance(choiceProviderAttribute.ProviderType);
			if (choiceProviderAttribute.ProviderType.IsSubclassOf(typeof(ChoiceProvider)))
				choiceProviderAttribute.ProviderType.GetProperty(nameof(ChoiceProvider.GuildId))
				choiceProviderAttribute.ProviderType.GetProperty(nameof(ChoiceProvider.Services))
			var result = (await ((Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt;)method.Invoke(instance, null)!).ConfigureAwait(false)).ToList();
				choices.AddRange(result);
	private static List&lt;DiscordApplicationCommandOptionChoice&gt; GetChoiceAttributesFromEnumParameter(Type enumParam)
		=&gt; (from Enum enumValue in Enum.GetValues(enumParam) select new DiscordApplicationCommandOptionChoice(enumValue.GetName(), enumValue.ToString())).ToList();
	private static ApplicationCommandOptionType GetParameterType(Type type)
												: throw new ArgumentException(&quot;Cannot convert type! Argument types must be string, int, long, bool, double, DiscordChannel, DiscordUser, DiscordRole, SnowflakeObject, DiscordAttachment or an Enum.&quot;);
	private static List&lt;DiscordApplicationCommandOptionChoice&gt; GetChoiceAttributesFromParameter(List&lt;ChoiceAttribute&gt; choiceAttributes) =&gt;
			: choiceAttributes.Select(att =&gt; new DiscordApplicationCommandOptionChoice(att.Name, att.Value)).ToList();
	internal static async Task&lt;List&lt;DiscordApplicationCommandOption&gt;&gt; ParseParametersAsync(IEnumerable&lt;ParameterInfo&gt; parameters, string commandName, ulong? guildId)
			var optionAttribute = parameter.GetCustomAttribute&lt;OptionAttribute&gt;() ?? throw new ArgumentException($&quot;One or more arguments of the command &apos;{commandName}&apos; are missing the Option attribute!&quot;);
					throw new ArgumentException($&quot;The command &apos;{commandName}&apos; has autocomplete enabled but is missing an autocomplete attribute!&quot;);
					throw new ArgumentException($&quot;The command &apos;{commandName}&apos; has an autocomplete provider but the option to have autocomplete set to false!&quot;);
			var choices = GetChoiceAttributesFromParameter(parameter.GetCustomAttributes&lt;ChoiceAttribute&gt;().ToList());
			var choiceProviders = parameter.GetCustomAttributes&lt;ChoiceProviderAttribute&gt;().ToList();
				choices = await GetChoiceAttributesFromProvider(choiceProviders, guildId).ConfigureAwait(false);
			options.Add(new(optionAttribute.Name, optionAttribute.Description, parameterType, !parameter.IsOptional, choices, null, channelTypes, optionAttribute.Autocomplete, minimumValue, maximumValue, minimumLength: minimumLength, maximumLength: maximumLength));
		add =&gt; this._slashError.Register(value);
		remove =&gt; this._slashError.Unregister(value);
		add =&gt; this._slashExecuted.Register(value);
		remove =&gt; this._slashExecuted.Unregister(value);
		add =&gt; this._contextMenuErrored.Register(value);
		remove =&gt; this._contextMenuErrored.Unregister(value);
		add =&gt; this._contextMenuExecuted.Register(value);
		remove =&gt; this._contextMenuExecuted.Unregister(value);
internal sealed class ApplicationCommandsModuleConfiguration
internal class ApplicationCommandSourceLink
internal sealed class CommandMethod
internal sealed class GroupCommand
internal sealed class SubGroupCommand
internal sealed class ContextMenuCommand
internal sealed class DefaultHelpModule : ApplicationCommandsModule
	internal async Task DefaultHelpAsync(
		var globalCommandsTask = ctx.Client.GetGlobalApplicationCommandsAsync();
			var guildCommandsTask = ctx.Client.GetGuildApplicationCommandsAsync(ctx.Guild.Id);
			await Task.WhenAll(globalCommandsTask, guildCommandsTask).ConfigureAwait(false);
			applicationCommands = globalCommandsTask.Result.Concat(guildCommandsTask.Result)
				.Where(ac =&gt; !ac.Name.Equals(&quot;help&quot;, StringComparison.OrdinalIgnoreCase))
				.GroupBy(ac =&gt; ac.Name).Select(x =&gt; x.First())
				.ToList();
			await Task.WhenAll(globalCommandsTask).ConfigureAwait(false);
				await ctx.EditResponseAsync(new DiscordWebhookBuilder()
					.WithContent(&quot;There are no slash commands&quot;)).ConfigureAwait(false);
				await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
					.WithContent(&quot;There are no slash commands&quot;).AsEphemeral()).ConfigureAwait(false);
		if (commandTwoName is not null &amp;&amp; !commandTwoName.Equals(&quot;no_options_for_this_command&quot;))
			var commandsWithSubCommands = applicationCommands.FindAll(ac =&gt; ac.Options is not null &amp;&amp; ac.Options.Any(op =&gt; op.Type == ApplicationCommandOptionType.SubCommandGroup));
			var subCommandParent = commandsWithSubCommands.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
			var cmdParent = commandsWithSubCommands.FirstOrDefault(cm =&gt; cm.Options.Any(op =&gt; op.Name.Equals(commandOneName))).Options
				.FirstOrDefault(opt =&gt; opt.Name.Equals(commandOneName, StringComparison.OrdinalIgnoreCase));
			var cmd = cmdParent.Options.FirstOrDefault(op =&gt; op.Name.Equals(commandTwoName, StringComparison.OrdinalIgnoreCase));
			var discordEmbed = new DiscordEmbedBuilder
				Description = $&quot;{subCommandParent.Mention.Replace(subCommandParent.Name, $&quot;{subCommandParent.Name} {cmdParent.Name} {cmd.Name}&quot;)}: {cmd.Description ?? &quot;No description provided.&quot;}&quot;
				var commandOptions = cmd.Options.ToList();
				var sb = new StringBuilder();
					sb.Append(&apos;`&apos;).Append(option.Name).Append(&quot;`: &quot;).Append(option.Description ?? &quot;No description provided.&quot;).Append(&apos;\n&apos;);
				sb.Append(&apos;\n&apos;);
				discordEmbed.AddField(new(&quot;Arguments&quot;, sb.ToString().Trim()));
					.AddEmbed(discordEmbed)).ConfigureAwait(false);
				await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
					new DiscordInteractionResponseBuilder().AddEmbed(discordEmbed).AsEphemeral()).ConfigureAwait(false);
		else if (commandOneName is not null &amp;&amp; commandTwoName is null &amp;&amp; !commandOneName.Equals(&quot;no_options_for_this_command&quot;))
			var commandsWithOptions = applicationCommands.FindAll(ac =&gt; ac.Options is not null &amp;&amp; ac.Options.All(op =&gt; op.Type == ApplicationCommandOptionType.SubCommand));
			var subCommandParent = commandsWithOptions.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
			var subCommand = subCommandParent.Options.FirstOrDefault(op =&gt; op.Name.Equals(commandOneName, StringComparison.OrdinalIgnoreCase));
				Description = $&quot;{subCommandParent.Mention.Replace(subCommandParent.Name, $&quot;{subCommandParent.Name} {subCommand.Name}&quot;)}: {subCommand.Description ?? &quot;No description provided.&quot;}&quot;
				var commandOptions = subCommand.Options.ToList();
				await ctx.EditResponseAsync(new DiscordWebhookBuilder().AddEmbed(discordEmbed)).ConfigureAwait(false);
			var command = applicationCommands.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
						.WithContent($&quot;No command called {commandName} in guild {ctx.Guild.Name}&quot;)).ConfigureAwait(false);
						.WithContent($&quot;No command called {commandName} in guild {ctx.Guild.Name}&quot;).AsEphemeral()).ConfigureAwait(false);
			}.AddField(new(&quot;Command is NSFW&quot;, command.IsNsfw.ToString()));
				var commandOptions = command.Options.ToList();
	public sealed class DefaultHelpAutoCompleteProvider : IAutocompleteProvider
		public async Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext context)
			var globalCommandsTask = context.Client.GetGlobalApplicationCommandsAsync();
				var guildCommandsTask = context.Client.GetGuildApplicationCommandsAsync(context.Guild.Id);
				slashCommands = globalCommandsTask.Result.Concat(guildCommandsTask.Result)
					.Where(ac =&gt; ac.Name.StartsWith(context.Options[0].Value.ToString(), StringComparison.OrdinalIgnoreCase))
			var options = slashCommands.Take(25).Select(sc =&gt; new DiscordApplicationCommandAutocompleteChoice(sc.Name, sc.Name.Trim())).ToList();
			return options.AsEnumerable();
	public sealed class DefaultHelpAutoCompleteLevelOneProvider : IAutocompleteProvider
					.GroupBy(ac =&gt; ac.Name).Select(x =&gt; x.First());
			var command = slashCommands.FirstOrDefault(ac =&gt;
				ac.Name.Equals(context.Options[0].Value.ToString().Trim(), StringComparison.OrdinalIgnoreCase));
				options.Add(new(&quot;no_options_for_this_command&quot;, &quot;no_options_for_this_command&quot;));
				var opt = command.Options.Where(c =&gt; c.Type is ApplicationCommandOptionType.SubCommandGroup or ApplicationCommandOptionType.SubCommand
				                                     &amp;&amp; c.Name.StartsWith(context.Options[1].Value.ToString(), StringComparison.InvariantCultureIgnoreCase)).ToList();
				options.AddRange(opt.Take(25).Select(option =&gt; new DiscordApplicationCommandAutocompleteChoice(option.Name, option.Name.Trim())));
	public sealed class DefaultHelpAutoCompleteLevelTwoProvider : IAutocompleteProvider
			var foundCommand = command.Options.FirstOrDefault(op =&gt; op.Name.Equals(context.Options[1].Value.ToString().Trim(), StringComparison.OrdinalIgnoreCase));
				var opt = foundCommand.Options.Where(x =&gt; x.Type == ApplicationCommandOptionType.SubCommand &amp;&amp;
				                                          x.Name.StartsWith(context.Options[2].Value.ToString(), StringComparison.OrdinalIgnoreCase)).ToList();
internal sealed class DefaultUserAppsHelpModule : ApplicationCommandsModule
	internal async Task DefaulUserAppstHelpAsync(
			await globalCommandsTask.ConfigureAwait(false);
	public sealed class DefaultUserAppsHelpAutoCompleteProvider : IAutocompleteProvider
	public sealed class DefaultUserAppsHelpAutoCompleteLevelOneProvider : IAutocompleteProvider
	public sealed class DefaultUserAppsHelpAutoCompleteLevelTwoProvider : IAutocompleteProvider</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsModule.cs">public abstract class ApplicationCommandsModule
	public virtual Task&lt;bool&gt; BeforeSlashExecutionAsync(InteractionContext ctx)
		=&gt; Task.FromResult(true);
	public virtual Task AfterSlashExecutionAsync(InteractionContext ctx)
	public virtual Task&lt;bool&gt; BeforeContextMenuExecutionAsync(ContextMenuContext ctx)
	public virtual Task AfterContextMenuExecutionAsync(ContextMenuContext ctx)</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsUtilities.cs">public static class ApplicationCommandsUtilities
	internal static bool IsModuleCandidateType(this Type type)
		=&gt; type.GetTypeInfo().IsModuleCandidateType();
	internal static bool IsModuleCandidateType(this TypeInfo ti)
			ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking type {name}&quot;, ti.FullName);
		var timodule = tmodule.GetTypeInfo();
		if (!timodule.IsAssignableFrom(ti))
				ApplicationCommandsExtension.Logger.LogDebug(&quot;Not assignable from type&quot;);
		if (ti.IsGenericType &amp;&amp; ti.Name.Contains(&quot;AnonymousType&quot;) &amp;&amp; (ti.Name.StartsWith(&quot;&lt;&gt;&quot;, StringComparison.Ordinal) || ti.Name.StartsWith(&quot;VB$&quot;, StringComparison.Ordinal)) &amp;&amp; (ti.Attributes &amp; TypeAttributes.NotPublic) == TypeAttributes.NotPublic)
				ApplicationCommandsExtension.Logger.LogDebug(&quot;Anonymous&quot;);
		var tdelegate = typeof(Delegate).GetTypeInfo();
		if (tdelegate.IsAssignableFrom(ti))
				ApplicationCommandsExtension.Logger.LogDebug(&quot;Delegated&quot;);
			ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking qualifying methods&quot;);
		return ti.DeclaredMethods.Any(xmi =&gt; xmi.IsCommandCandidate(out _)) || ti.DeclaredNestedTypes.Any(xti =&gt; xti.IsModuleCandidateType());
	internal static bool IsCommandCandidate(this MethodInfo method, out ParameterInfo[] parameters)
				ApplicationCommandsExtension.Logger.LogDebug(&quot;Not existent&quot;);
			ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking method {name}&quot;, method.Name);
				ApplicationCommandsExtension.Logger.LogDebug(&quot;abstract, constructor or special name&quot;);
		parameters = method.GetParameters();
		if (parameters.Length == 0 || (parameters.First().ParameterType != typeof(ContextMenuContext) &amp;&amp; parameters.First().ParameterType != typeof(InteractionContext)) || method.ReturnType != typeof(Task))
				ApplicationCommandsExtension.Logger.LogDebug(&quot;Missing first parameter with type ContextMenuContext or InteractionContext&quot;);
			ApplicationCommandsExtension.Logger.LogDebug(&quot;Qualifies&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/ApplicationCommandModuleLifespanAttribute.cs">public class ApplicationCommandModuleLifespanAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/CheckBaseAttribute.cs">public abstract class ApplicationCommandCheckBaseAttribute : Attribute
	public abstract Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx);</file><file path="DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuAttribute.cs">public sealed class ContextMenuAttribute : Attribute
			throw new ArgumentException(&quot;Context menus cannot be of type ChatInput (Slash).&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuCooldownAttribute.cs">public sealed class ContextMenuCooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : ApplicationCommandCheckBaseAttribute, ICooldown&lt;BaseContext, CooldownBucket&gt;
	public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
	public CooldownBucket GetBucket(BaseContext ctx)
		var bid = this.GetBucketId(ctx, out _, out _, out _, out _);
		ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
	public TimeSpan GetRemainingCooldown(BaseContext ctx)
		var bucket = this.GetBucket(ctx);
	public async Task&lt;bool&gt; RespondRatelimitHitAsync(BaseContext ctx, bool noHit, CooldownBucket bucket)
				await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;));
				await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;).AsEphemeral());
		var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
		var providerInstance = Activator.CreateInstance(this.ResponderType);
		await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
	private string GetBucketId(BaseContext ctx, out ulong userId, out ulong channelId, out ulong guildId, out ulong memberId)
		var bid = CooldownBucket.MakeId(ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), userId, channelId, guildId, memberId);
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld, out var mem);
		if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
			return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
		bucket = new(this.MaxUses, this.Reset, ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), usr, chn, gld, mem);
		ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.ApplicationCommands/Attributes/DontInjectAttribute.cs">public class DontInjectAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireAnyPermissionsAttribute.cs">public sealed class RequireAnyPermissionsAttribute : ApplicationCommandCheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			throw new InvalidOperationException(&quot;This check cannot be used in a DM.&quot;);
		var pusr = ctx.Channel.PermissionsFor(usr);
		var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
		var pbot = ctx.Channel.PermissionsFor(bot);
		var usrok = ctx.Guild.OwnerId == usr.Id || pusr.HasPermission(Permissions.Administrator);
		var botok = ctx.Guild.OwnerId == bot.Id || pusr.HasPermission(Permissions.Administrator);
			usrok = this.AnyPermissions.Any(x =&gt; (pusr &amp; x) != 0);
			botok = this.AnyPermissions.Any(x =&gt; (pbot &amp; x) != 0);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireBotPermissionsAttribute.cs">public sealed class ApplicationCommandRequireBotPermissionsAttribute : ApplicationCommandCheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
		var pbot = ctx.Channel.PermissionsFor(bot);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireDirectMessageAttribute.cs">public sealed class ApplicationCommandRequireDirectMessageAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		=&gt; Task.FromResult(ctx.Channel is DiscordDmChannel);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireGuildAttribute.cs">public sealed class ApplicationCommandRequireGuildAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		=&gt; Task.FromResult(ctx.Guild != null);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireGuildOwnerAttribute.cs">public sealed class ApplicationCommandRequireGuildOwnerAttributeAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		=&gt; Task.FromResult(ctx.Guild is not null &amp;&amp; ctx.Guild.OwnerId == ctx.User.Id);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireNsfwAttribute.cs">public sealed class ApplicationCommandRequireNsfwAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		=&gt; Task.FromResult(ctx.Guild == null || ctx.Channel.IsNsfw);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequirePermissionsAttribute.cs">public sealed class ApplicationCommandRequirePermissionsAttribute : ApplicationCommandCheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		var pusr = ctx.Channel.PermissionsFor(usr);
		var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
		var pbot = ctx.Channel.PermissionsFor(bot);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireSkuEntitlementAttribute.cs">public sealed class ApplicationCommandRequireSkuEntitlementAttribute(ulong skuId) : ApplicationCommandCheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		if (ctx.Interaction.Entitlements.Any(x =&gt; x.SkuId == this.SkuId))
			return await Task.FromResult(true).ConfigureAwait(false);
		await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AddComponents(new DiscordPremiumButtonComponent(this.SkuId))).ConfigureAwait(false);
		return await Task.FromResult(false).ConfigureAwait(false);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamAdmin.cs">public sealed class ApplicationCommandRequireTeamAdminAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			return Task.FromResult(app.Owner.Id == ctx.User.Id);
		var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
		return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamDeveloper.cs">public sealed class ApplicationCommandRequireTeamDeveloperAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			return Task.FromResult(app.Owner.Id == ctx.User.Id);
		var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
		return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;developer&quot; or &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamMember.cs">public sealed class ApplicationCommandRequireTeamMemberAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		return app.Team is null ? Task.FromResult(app.Owner.Id == ctx.User.Id) : Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id));</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamOwner.cs">public sealed class ApplicationCommandRequireTeamOwnerAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			return Task.FromResult(app.Owner.Id == ctx.User.Id);
		var teamMember = app.Team.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
		return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamReadOnly.cs">public sealed class ApplicationCommandRequireTeamReadOnlyAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			return Task.FromResult(app.Owner.Id == ctx.User.Id);
		var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
		return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;read-only&quot; or &quot;developer&quot; or &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireUserPermissionsAttribute.cs">public sealed class ApplicationCommandRequireUserPermissionsAttribute : ApplicationCommandCheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
			return Task.FromResult(this.IgnoreDms);
			return Task.FromResult(false);
			return Task.FromResult(true);
		var pusr = ctx.Channel.PermissionsFor(usr);
			? Task.FromResult(true)
				: Task.FromResult(false);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/AutocompleteAttribute.cs">public class AutocompleteAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChannelTypesAttribute.cs">public class ChannelTypesAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceAttribute.cs">public class ChoiceAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceNameAttribute.cs">public class ChoiceNameAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProvider.cs">public abstract class ChoiceProvider : IChoiceProvider
	public abstract Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProviderAttribute.cs">public class ChoiceProviderAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IAutocompleteProvider.cs">public interface IAutocompleteProvider
	Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext context);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IChoiceProvider.cs">public interface IChoiceProvider
	Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/MinimumMaximumAttribute.cs">public class MinimumValueAttribute : Attribute
public class MaximumValueAttribute : Attribute
public class MinimumLengthAttribute : Attribute
			throw new ArgumentException(&quot;Minimum cannot be more than 6000.&quot;);
public class MaximumLengthAttribute : Attribute
			throw new ArgumentException(&quot;Maximum length cannot be less than 1 and cannot be more than 6000.&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/OptionAttribute.cs">public class OptionAttribute : Attribute
			throw new ArgumentException(&quot;Slash command option names cannot go over 32 characters.&quot;);
			throw new ArgumentException(&quot;Slash command option descriptions cannot go over 100 characters.&quot;);
		this.Name = name.ToLower();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandAttribute.cs">public class SlashCommandAttribute : Attribute
		this.Name = name.ToLower();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandCooldownAttribute.cs">public sealed class SlashCommandCooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : ApplicationCommandCheckBaseAttribute, ICooldown&lt;BaseContext, CooldownBucket&gt;
	public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
	public CooldownBucket GetBucket(BaseContext ctx)
		var bid = this.GetBucketId(ctx, out _, out _, out _, out _);
		ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
	public TimeSpan GetRemainingCooldown(BaseContext ctx)
		var bucket = this.GetBucket(ctx);
	public async Task&lt;bool&gt; RespondRatelimitHitAsync(BaseContext ctx, bool noHit, CooldownBucket bucket)
				await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;));
				await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;).AsEphemeral());
		var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
		var providerInstance = Activator.CreateInstance(this.ResponderType);
		await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
	private string GetBucketId(BaseContext ctx, out ulong userId, out ulong channelId, out ulong guildId, out ulong memberId)
		if (this.BucketType.HasFlag(CooldownBucketType.User))
		if (this.BucketType.HasFlag(CooldownBucketType.Channel))
		if (ctx.Guild is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Guild))
		if (ctx.Guild is not null &amp;&amp; ctx.Member is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Member))
		var bid = CooldownBucket.MakeId(ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), userId, channelId, guildId, memberId);
	public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
		var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld, out var mem);
		if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
			return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
		bucket = new(this.MaxUses, this.Reset, ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), usr, chn, gld, mem);
		ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandGroupAttribute.cs">public class SlashCommandGroupAttribute : Attribute
		this.Name = name.ToLower();</file><file path="DisCatSharp.ApplicationCommands/Checks/ApplicationCommandEqualityChecks.cs">internal static class ApplicationCommandEqualityChecks
	internal static bool IsEqualTo(
		DiscordApplicationCommand sourceApplicationCommand = new(
		client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel,
			JsonConvert.SerializeObject(sourceApplicationCommand),
			JsonConvert.SerializeObject(targetApplicationCommand));
		return ac1.Type == targetApplicationCommand.Type &amp;&amp; sourceApplicationCommand.SoftEqual(targetApplicationCommand,
	internal static bool SoftEqual(
					     &amp;&amp; source.AllowedContexts.NullableSequenceEqual(target.AllowedContexts) &amp;&amp;
					     source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes) &amp;&amp;
					     source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations)
					     source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes)
					     &amp;&amp; source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations)
	internal static bool NullableSequenceEqual&lt;T&gt;(this List&lt;T&gt;? source, List&lt;T&gt;? target)
			? source.All(target.Contains) &amp;&amp; source.Count == target.Count
	internal static bool AreDictionariesEqual(this Dictionary&lt;string, string&gt; sourceDictionary, Dictionary&lt;string, string&gt; targetDictionary)
			if (!targetDictionary.TryGetValue(kvp.Key, out var value) || value != kvp.Value)
	internal static bool DeepEqual(
		                source.AllowedContexts.NullableSequenceEqual(target.AllowedContexts) &amp;&amp;
		                source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes);
			            source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations) &amp;&amp;
			            source.RawDescriptionLocalizations.AreDictionariesEqual(target.RawDescriptionLocalizations);
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;Inequality found in options of {name} - {reason}&quot;, name, reason);
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;Inequality found in root of {name}&quot;, name);
	private static (bool Equal, string? Reason) DeepEqualOptions(
				              sourceOption.RawNameLocalizations.AreDictionariesEqual(targetOption.RawNameLocalizations) &amp;&amp;
				              sourceOption.RawDescriptionLocalizations.AreDictionariesEqual(targetOption
				var j1 = JsonConvert.SerializeObject(sourceOption.Choices.OrderBy(x =&gt; x.Name), Formatting.None);
				var j2 = JsonConvert.SerializeObject(targetOption.Choices.OrderBy(x =&gt; x.Name), Formatting.None);
			     !sourceOption.ChannelTypes.OrderBy(x =&gt; x).All(targetOption.ChannelTypes.OrderBy(x =&gt; x).Contains)))</file><file path="DisCatSharp.ApplicationCommands/Context/ApplicationCommandsTranslationContext.cs">public sealed class ApplicationCommandsTranslationContext
	public void AddGroupTranslation(string translationJson)
	public void AddSingleTranslation(string translationJson)</file><file path="DisCatSharp.ApplicationCommands/Context/AutocompleteContext.cs">public sealed class AutocompleteContext
	public IServiceProvider Services { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);</file><file path="DisCatSharp.ApplicationCommands/Context/BaseContext.cs">public class BaseContext : DisCatSharpCommandContext
		=&gt; $&quot;{this.CommandName}{(string.IsNullOrWhiteSpace(this.SubCommandName) ? &quot;&quot; : $&quot; {this.SubCommandName}&quot;)}{(string.IsNullOrWhiteSpace(this.SubSubCommandName) ? &quot;&quot; : $&quot; {this.SubSubCommandName}&quot;)}&quot;;
	public IServiceProvider Services { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);
	public async Task&lt;DiscordInteractionCallbackResponse&gt; CreateResponseAsync(InteractionResponseType type, DiscordInteractionResponseBuilder? builder = null)
		=&gt; await this.Interaction.CreateResponseAsync(type, builder);
	public Task CreateModalResponseAsync(DiscordInteractionModalBuilder builder)
		=&gt; this.Interaction.Type is not InteractionType.Ping &amp;&amp; this.Interaction.Type is not InteractionType.ModalSubmit ? this.Interaction.CreateInteractionModalResponseAsync(builder) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with a modal.&quot;);
	public Task CreateInteractionIframeResponseAsync(string customId, string title, IframeModalSize modalSize = IframeModalSize.Normal, string? iFramePath = null)
		=&gt; this.Interaction.Type is not InteractionType.Ping ? this.Interaction.CreateInteractionIframeResponseAsync(customId, title, modalSize, iFramePath) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with an iframe.&quot;);
	public Task&lt;DiscordMessage&gt; EditResponseAsync(DiscordWebhookBuilder builder)
		=&gt; this.Interaction.EditOriginalResponseAsync(builder);
	public Task&lt;DiscordMessage&gt; EditResponseAsync(string content)
		=&gt; this.Interaction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(content));
	public Task DeleteResponseAsync()
		=&gt; this.Interaction.DeleteOriginalResponseAsync();
	public Task&lt;DiscordMessage&gt; FollowUpAsync(DiscordFollowupMessageBuilder builder)
		=&gt; this.Interaction.CreateFollowupMessageAsync(builder);
	public Task&lt;DiscordMessage&gt; FollowUpAsync(string content)
		=&gt; this.FollowUpAsync(new DiscordFollowupMessageBuilder().WithContent(content));
	public Task&lt;DiscordMessage&gt; EditFollowupAsync(ulong followupMessageId, DiscordWebhookBuilder builder)
		=&gt; this.Interaction.EditFollowupMessageAsync(followupMessageId, builder);
	public Task&lt;DiscordMessage&gt; EditFollowupAsync(ulong followupMessageId, string content)
		=&gt; this.EditFollowupAsync(followupMessageId, new DiscordWebhookBuilder().WithContent(content));
	public Task DeleteFollowupAsync(ulong followupMessageId)
		=&gt; this.Interaction.DeleteFollowupMessageAsync(followupMessageId);
	public Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong followupMessageId)
		=&gt; this.Interaction.GetFollowupMessageAsync(followupMessageId);
	public Task&lt;DiscordMessage&gt; GetOriginalResponseAsync()
		=&gt; this.Interaction.GetOriginalResponseAsync();</file><file path="DisCatSharp.ApplicationCommands/Context/ContextMenuContext.cs">public sealed class ContextMenuContext(DisCatSharpCommandType type) : BaseContext(type)</file><file path="DisCatSharp.ApplicationCommands/Context/InteractionContext.cs">public sealed class InteractionContext() : BaseContext(DisCatSharpCommandType.SlashCommand)</file><file path="DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.ApplicationCommands&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.ApplicationCommands&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.ApplicationCommands&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Application Commands Extension

			Use it on top of your DisCatSharp powered bot and unleash the power of application commands in discord.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/application_commands/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Application Commands,Context Menu Commands&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.ApplicationCommands/Entities/ChoiceTranslator.cs">public sealed class ChoiceTranslator
	public static ChoiceTranslator FromApplicationCommandChoice(DiscordApplicationCommandOptionChoice choice)
		var translator = new ChoiceTranslator</file><file path="DisCatSharp.ApplicationCommands/Entities/CommandTranslator.cs">public sealed class CommandTranslator</file><file path="DisCatSharp.ApplicationCommands/Entities/FakeApplicationCommandObjects.cs">internal sealed class CommandGroupWithSubGroups : BaseCommand
internal sealed class CommandGroup : BaseCommand
internal sealed class Command : BaseCommand
			this.Options = options.Select(OptionTranslator.FromApplicationCommandOption).ToList();
internal class BaseCommand</file><file path="DisCatSharp.ApplicationCommands/Entities/GroupTranslator.cs">public sealed class GroupTranslator</file><file path="DisCatSharp.ApplicationCommands/Entities/ICooldownResponder.cs">public interface ICooldownResponder
	Task Responder(BaseContext context, CooldownBucket cooldownBucket);</file><file path="DisCatSharp.ApplicationCommands/Entities/OptionTranslator.cs">public sealed class OptionTranslator
	public static OptionTranslator FromApplicationCommandOption(DiscordApplicationCommandOption option)
		var optionTranslator = new OptionTranslator
			optionTranslator.Choices = option.Choices.Select(ChoiceTranslator.FromApplicationCommandChoice).ToList();</file><file path="DisCatSharp.ApplicationCommands/Entities/RegisteredDiscordApplicationCommand.cs">public sealed class RegisteredDiscordApplicationCommand : DiscordApplicationCommand
			if (ApplicationCommandsExtension.CommandMethods.Any(x =&gt; x.CommandId == this.Id))
				this.CommandMethod = ApplicationCommandsExtension.CommandMethods.First(x =&gt; x.CommandId == this.Id).Method;
				this.CustomAttributes = this.CommandMethod.GetCustomAttributes().Where(x =&gt; !x.GetType().Namespace.StartsWith(&quot;DisCatSharp&quot;, StringComparison.Ordinal)).ToList();
			else if (ApplicationCommandsExtension.ContextMenuCommands.Any(x =&gt; x.CommandId == this.Id))
				this.CommandMethod = ApplicationCommandsExtension.ContextMenuCommands.First(x =&gt; x.CommandId == this.Id).Method;
			else if (ApplicationCommandsExtension.GroupCommands.Any(x =&gt; x.CommandId == this.Id))
				this.CommandType = ApplicationCommandsExtension.GroupCommands.First(x =&gt; x.CommandId == this.Id).Methods.First().Value.DeclaringType;
				this.CustomAttributes = this.CommandType.GetCustomAttributes().Where(x =&gt; !x.GetType().Namespace.StartsWith(&quot;DisCatSharp&quot;, StringComparison.Ordinal)).ToList();
			ApplicationCommandsExtension.Logger.LogError(&quot;Failed to generate reflection properties for &apos;{cmd}&apos;&quot;, parent.Name);</file><file path="DisCatSharp.ApplicationCommands/Entities/SubGroupTranslator.cs">public sealed class SubGroupTranslator</file><file path="DisCatSharp.ApplicationCommands/Enums/ApplicationCommandFinalType.cs"></file><file path="DisCatSharp.ApplicationCommands/Enums/ApplicationCommandModuleLifespan.cs"></file><file path="DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuErrorEventArgs.cs">public class ContextMenuErrorEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuExecutedEventArgs.cs">public sealed class ContextMenuExecutedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleReadyEventArgs.cs">public sealed class ApplicationCommandsModuleReadyEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleStartupFinishedEventArgs.cs">public sealed class ApplicationCommandsModuleStartupFinishedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/GlobalApplicationCommandsRegisteredEventArgs.cs">public sealed class GlobalApplicationCommandsRegisteredEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/GuildApplicationCommandsRegisteredEventArgs.cs">public sealed class GuildApplicationCommandsRegisteredEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandErrorEventArgs.cs">public class SlashCommandErrorEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandExecutedEventArgs.cs">public class SlashCommandExecutedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.ApplicationCommands/Exceptions/ContextMenu/ContextMenuExecutionChecksFailedException.cs">public sealed class ContextMenuExecutionChecksFailedException : Exception</file><file path="DisCatSharp.ApplicationCommands/Exceptions/SlashCommand/SlashExecutionChecksFailedException.cs">public class SlashExecutionChecksFailedException : Exception</file><file path="DisCatSharp.ApplicationCommands/ExtensionMethods.cs">public static class ExtensionMethods
	public static ApplicationCommandsExtension UseApplicationCommands(
			throw new InvalidOperationException(&quot;Application commands are already enabled for that client.&quot;);
		var scomm = new ApplicationCommandsExtension(config);
		client.AddExtension(scomm);
	public static ApplicationCommandsExtension GetApplicationCommands(this DiscordClient client)
	public static async Task&lt;IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt;&gt; GetApplicationCommandsAsync(this DiscordShardedClient client)
		await client.InitializeShardsAsync().ConfigureAwait(false);
		return client.ShardClients.Values.ToDictionary(shard =&gt; shard.ShardId, shard =&gt; shard.GetExtension&lt;ApplicationCommandsExtension&gt;()!);
	public static void RegisterGlobalCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
	public static void RegisterGlobalCommands(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Type type, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
		if (!typeof(ApplicationCommandsModule).IsAssignableFrom(type))
			throw new ArgumentException(&quot;Command classes have to inherit from ApplicationCommandsModule&quot;, nameof(type));
			extension.RegisterGlobalCommands(type, translationSetup);
	public static void RegisterGuildCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
	public static void RegisterGuildCommands(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Type type, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt; translationSetup = null)
			extension.RegisterGuildCommands(type, guildId, translationSetup);
	public static async Task&lt;IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt;&gt; UseApplicationCommandsAsync(this DiscordShardedClient client, ApplicationCommandsConfiguration? config = null)
			scomm ??= shard.UseApplicationCommands(config);
	public static string GetName&lt;T&gt;(this T e) where T : IConvertible
		var type = e.GetType();
		var values = Enum.GetValues(type);
		        where val == e.ToInt32(CultureInfo.InvariantCulture)
		        let memInfo = type.GetMember(type.GetEnumName(val))
			        .GetCustomAttributes(typeof(ChoiceNameAttribute), false)
			        .FirstOrDefault() is ChoiceNameAttribute nameAttribute
			        : type.GetEnumName(val)).FirstOrDefault()!;</file><file path="DisCatSharp.ApplicationCommands/GlobalSuppressions.cs"></file><file path="DisCatSharp.ApplicationCommands/Workers/ApplicationCommandWorker.cs">internal class CommandWorker
	&gt; ParseContextMenuCommands(Type type, IEnumerable&lt;MethodInfo&gt; methods, List&lt;CommandTranslator&gt;? translator = null)
			var command = new DiscordApplicationCommand(contextAttribute.Name, null, null, contextAttribute.Type, nameLocalizations, null, contextAttribute.DefaultMemberPermissions, contextAttribute.IsNsfw, contextAttribute.AllowedContexts, contextAttribute.IntegrationTypes);
			var parameters = contextMethod.GetParameters();
			if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.FirstOrDefault()?.ParameterType, typeof(ContextMenuContext)))
				throw new ArgumentException($&quot;The first argument of the command &apos;{contextAttribute.Name}&apos; has to be an ContextMenuContext!&quot;);
				throw new ArgumentException($&quot;The context menu command &apos;{contextAttribute.Name}&apos; cannot have parameters!&quot;);
			contextMenuCommands.Add(new()
			commands.Add(command);
			commandTypeSources.Add(new(type, type));
		return Task.FromResult((commands, commandTypeSources, contextMenuCommands, translator is not null));
	&gt; ParseBasicSlashCommandsAsync(Type type, IEnumerable&lt;MethodInfo&gt; methods, ulong? guildId = null, List&lt;CommandTranslator&gt;? translator = null)
				var parameters = method.GetParameters();
				if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.FirstOrDefault()?.ParameterType, typeof(InteractionContext)))
					throw new ArgumentException($&quot;The first argument of the command &apos;{commandAttribute.Name}&apos; has to be an InteractionContext!&quot;);
				var options = await ApplicationCommandsExtension.ParseParametersAsync(parameters.Skip(1), commandAttribute.Name, guildId).ConfigureAwait(false);
				commandMethods.Add(new()
										choices.Add(new(choice.Name, choice.Value, commandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations));
										throw new AggregateException($&quot;Failed to register choice &apos;{choice.Name}&apos; in command &apos;{commandAttribute.Name}&apos;&quot;, ex);
							localizedOptions.Add(new(option.Name, option.Description, option.Type, option.Required,
								commandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, commandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
							throw new AggregateException($&quot;Failed to register option &apos;{option.Name}&apos; in command &apos;{commandAttribute.Name}&apos;&quot;, ex);
				var payload = new DiscordApplicationCommand(commandAttribute.Name, commandAttribute.Description, (localizedOptions is not null &amp;&amp; localizedOptions.Count is not 0 ? localizedOptions : null) ?? (options is not null &amp;&amp; options.Count is not 0 ? options : null), ApplicationCommandType.ChatInput, nameLocalizations, descriptionLocalizations, commandAttribute.DefaultMemberPermissions,
				commands.Add(payload);
				throw new AggregateException($&quot;Failed to register command with method name &apos;{method.Name}&apos;&quot;, ex);
internal class NestedCommandWorker
	&gt; ParseSlashGroupsAsync(Type type, List&lt;TypeInfo&gt; types, ulong? guildId = null, List&lt;GroupTranslator&gt;? translator = null)
			var submethods = subclassInfo.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null).ToList();
			var subclasses = subclassInfo.DeclaredNestedTypes.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandGroupAttribute&gt;() is not null).ToList();
			var payload = new DiscordApplicationCommand(groupAttribute.Name, groupAttribute.Description, nameLocalizations: nameLocalizations, descriptionLocalizations: descriptionLocalizations, defaultMemberPermissions: groupAttribute.DefaultMemberPermissions, isNsfw: groupAttribute.IsNsfw, allowedContexts: groupAttribute.AllowedContexts,
				var parameters = submethod.GetParameters();
				if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.First().ParameterType, typeof(InteractionContext)))
								choices.AddRange(option.Choices.Select(choice =&gt; new DiscordApplicationCommandOptionChoice(choice.Name, choice.Value, subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations)));
								subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
				var subpayload = new DiscordApplicationCommandOption(commandAttribute.Name, commandAttribute.Description, ApplicationCommandOptionType.SubCommand, false, null, localizedOptions ?? options, nameLocalizations: subNameLocalizations, descriptionLocalizations: subDescriptionLocalizations);
				commandTypeSources.Add(new(subclassInfo, type));
				commandMethods.Add(new(commandAttribute.Name, submethod));
				groupCommands.Add(new()
			var command = new SubGroupCommand
				var subsubmethods = subclass.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null);
					var subCommandTranslation = subGroupCommandTranslation?.SubGroups.Single(sc =&gt; sc.Name == subgroupAttribute.Name);
					var parameters = subsubmethod.GetParameters();
						throw new ArgumentException($&quot;The first argument of the command &apos;{subgroupAttribute.Name}&apos; has to be an InteractionContext!&quot;);
					suboptions = [.. suboptions, .. await ApplicationCommandsExtension.ParseParametersAsync(parameters.Skip(1), subgroupAttribute.Name, guildId).ConfigureAwait(false)];
					var subSubCommandTranslation = subCommandTranslation?.Commands.Single(sc =&gt; sc.Name == commatt.Name);
								choices.AddRange(option.Choices.Select(choice =&gt; new DiscordApplicationCommandOptionChoice(choice.Name, choice.Value, subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations)));
								subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
					var subsubpayload = new DiscordApplicationCommandOption(commatt.Name, commatt.Description, ApplicationCommandOptionType.SubCommand, false, null, (localizedOptions is not null &amp;&amp; localizedOptions.Count is not 0 ? localizedOptions : null) ?? (suboptions is not null &amp;&amp; suboptions.Count is not 0 ? suboptions : null), nameLocalizations: subSubNameLocalizations, descriptionLocalizations: subSubDescriptionLocalizations);
					options.Add(subsubpayload);
					commandMethods.Add(new(commatt.Name, subsubmethod));
					currentMethods.Add(new(commatt.Name, subsubmethod));
				var subpayload = new DiscordApplicationCommandOption(subgroupAttribute.Name, subgroupAttribute.Description, ApplicationCommandOptionType.SubCommandGroup, false, null, options, nameLocalizations: subNameLocalizations, descriptionLocalizations: subDescriptionLocalizations);
				command.SubCommands.Add(new()
				commandTypeSources.Add(new(subclass, type));
					singletonModules.Add(ApplicationCommandsExtension.CreateInstance(subclass, ApplicationCommandsExtension.Configuration?.ServiceProvider));
			if (command.SubCommands.Count is not 0) subGroupCommands.Add(command);
				singletonModules.Add(ApplicationCommandsExtension.CreateInstance(subclassInfo, ApplicationCommandsExtension.Configuration?.ServiceProvider));</file><file path="DisCatSharp.ApplicationCommands/Workers/RegistrationWorker.cs">internal class RegistrationWorker
	internal static async Task&lt;List&lt;DiscordApplicationCommand&gt;?&gt; RegisterGlobalCommandsAsync(DiscordClient client, List&lt;DiscordApplicationCommand&gt; commands, DiscordApplicationCommand? entryPointCommand = null)
		if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Creating, re-using and overwriting application commands&quot;);
				var discordBackendCommand = await client.CreateGlobalApplicationCommandAsync(cmd).ConfigureAwait(false);
				commands.Add(discordBackendCommand);
				var discordBackendCommand = await client.EditGlobalApplicationCommandAsync(key, action =&gt;
						action.Options = Optional.FromNullable(command.Options);
				}).ConfigureAwait(false);
			commands.AddRange(unchangedCommands);
		else if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; (unchangedCommands!.NotEmptyAndNotNull() || changedCommands!.NotEmptyAndNotNull()))
			if (changedCommands!.NotEmptyAndNotNull())
			if (unchangedCommands!.NotEmptyAndNotNull())
		else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Editing &amp; re-using application commands&quot;);
		else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Overwriting all application commands&quot;);
				overwriteList.Add(cmd);
			var discordBackendCommands = await client.BulkOverwriteGlobalApplicationCommandsAsync(overwriteList).ConfigureAwait(false);
			commands.AddRange(discordBackendCommands);
		else if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Creating all application commands&quot;);
			var cmds = await client.BulkOverwriteGlobalApplicationCommandsAsync(globalCommandsCreateList).ConfigureAwait(false);
			commands.AddRange(cmds);
		else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Re-using all application commands&quot;);
		if (!globalCommandsDeleteList.NotEmptyAndNotNull())
			return commands.NotEmpty() ? commands : null;
		client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Deleting missing application commands&quot;);
				await client.DeleteGlobalApplicationCommandAsync(cmdId).ConfigureAwait(false);
				client.Logger.LogError(&quot;Could not delete global command {cmd}. Please clean up manually&quot;, cmdId);
	internal static async Task&lt;List&lt;DiscordApplicationCommand&gt;?&gt; RegisterGuildCommandsAsync(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt; commands)
		if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Creating, re-using and overwriting application commands. Guild ID: {guild}&quot;, guildId);
				var discordBackendCommand = await client.CreateGuildApplicationCommandAsync(guildId, cmd).ConfigureAwait(false);
				var discordBackendCommand = await client.EditGuildApplicationCommandAsync(guildId, key, action =&gt;
		else if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; (unchangedCommands!.NotEmptyAndNotNull() || changedCommands!.NotEmptyAndNotNull()))
		else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Editing &amp; re-using application commands. Guild ID: {guild}&quot;, guildId);
		else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Overwriting all application commands. Guild ID: {guild}&quot;, guildId);
			var discordBackendCommands = await client.BulkOverwriteGuildApplicationCommandsAsync(guildId, overwriteList).ConfigureAwait(false);
		else if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Creating all application commands. Guild ID: {guild}&quot;, guildId);
			var cmds = await client.BulkOverwriteGuildApplicationCommandsAsync(guildId, guildCommandsCreateList).ConfigureAwait(false);
		else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Re-using all application commands Guild ID: {guild}&quot;, guildId);
		if (!guildCommandsDeleteList.NotEmptyAndNotNull())
			client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Deleting missing application commands. Guild ID: {guild}&quot;, guildId);
				await client.DeleteGuildApplicationCommandAsync(guildId, cmdId).ConfigureAwait(false);
				client.Logger.LogError(&quot;Could not delete guild command {cmd} in guild {guild}. Please clean up manually&quot;, cmdId, guildId);
	private static List&lt;ulong&gt;? BuildGuildDeleteList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
		    || !ApplicationCommandsExtension.GuildDiscordCommands!.TryGetFirstValueByKey(guildId, out var discord)
			invalidCommandIds.AddRange(discord.Select(cmd =&gt; cmd.Id));
			invalidCommandIds.AddRange(from cmd in discord where updateList.All(ul =&gt; ul.Name != cmd.Name) select cmd.Id);
	private static List&lt;DiscordApplicationCommand&gt;? BuildGuildCreateList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
		var success = ApplicationCommandsExtension.GuildDiscordCommands.TryGetFirstValueByKey(guildId, out var discord);
		newCommands.AddRange(updateList.Where(cmd =&gt; discord.All(d =&gt; d.Name != cmd.Name)));
		) BuildGuildOverwriteList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
		    || ApplicationCommandsExtension.GuildDiscordCommands.All(l =&gt; l.Key != guildId) || updateList is null
			if (discord!.TryGetFirstValueWhere(d =&gt; d?.Name == cmd.Name, out var command))
				if (command.IsEqualTo(cmd, client, true))
						client.Logger.LogDebug(&quot;[AC] Command {cmdName} unchanged&quot;, cmd.Name);
					unchangedCommands.Add(cmd);
						client.Logger.LogDebug(&quot;[AC] Command {cmdName} changed&quot;, cmd.Name);
					updateCommands.Add(command.Id, cmd);
	private static List&lt;ulong&gt;? BuildGlobalDeleteList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null, DiscordApplicationCommand? entryPointCommand = null)
		if (entryPointCommand is not null &amp;&amp; invalidCommandIds.Contains(entryPointCommand.Id))
			invalidCommandIds.Remove(entryPointCommand.Id);
	private static List&lt;DiscordApplicationCommand&gt;? BuildGlobalCreateList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null, DiscordApplicationCommand? entryPointCommand = null)
		if (entryPointCommand is not null &amp;&amp; newCommands.All(command =&gt; command.Name != &quot;launch&quot;))
			newCommands.Add(entryPointCommand);
		) BuildGlobalOverwriteList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null)
				if (command.IsEqualTo(cmd, client, false))
					changedCommands.Add(command.Id, cmd);</file><file path="DisCatSharp.Attributes/DeprecatedAttribute.cs">public sealed class DeprecatedAttribute : Attribute</file><file path="DisCatSharp.Attributes/DisCatSharp.Attributes.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;
		&lt;GeneratePackageOnBuild&gt;True&lt;/GeneratePackageOnBuild&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Attributes&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Attributes&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Attributes&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp.Attributes

			Special Attributes for DisCatSharp.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,DisCatSharp Attributes&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Attributes/DisCatSharp.Attributes.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Attributes/DiscordDeprecatedAttribute.cs">public sealed class DiscordDeprecatedAttribute : Attribute</file><file path="DisCatSharp.Attributes/DiscordInExperimentAttribute.cs">public sealed class DiscordInExperimentAttribute : Attribute</file><file path="DisCatSharp.Attributes/DiscordUnreleasedAttribute.cs">public sealed class DiscordUnreleasedAttribute : Attribute</file><file path="DisCatSharp.Attributes/ExperimentalAttribute.cs">public sealed class ExperimentalAttribute : Attribute</file><file path="DisCatSharp.Attributes/Features.cs">public sealed class FeatureDescriptionAttribute : Attribute</file><file path="DisCatSharp.Attributes/GlobalSuppressions.cs"></file><file path="DisCatSharp.Attributes/Properties/AssemblyProperties.cs"></file><file path="DisCatSharp.Attributes/RequiresFeatureAttribute.cs">public sealed class RequiresFeatureAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/AliasesAttribute.cs">public sealed class AliasesAttribute : Attribute
		if (aliases.Any(xa =&gt; xa == null || xa.Any(xc =&gt; char.IsWhiteSpace(xc))))
			throw new ArgumentException(&quot;Aliases cannot contain whitespace characters or null strings.&quot;, nameof(aliases));</file><file path="DisCatSharp.CommandsNext/Attributes/CheckBaseAttribute.cs">public abstract class CheckBaseAttribute : Attribute
	public abstract Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help);</file><file path="DisCatSharp.CommandsNext/Attributes/CommandAttribute.cs">public sealed class CommandAttribute : Attribute
		if (string.IsNullOrWhiteSpace(name))
			throw new ArgumentNullException(nameof(name), &quot;Command names cannot be null, empty, or all-whitespace.&quot;);
		if (name.Any(xc =&gt; char.IsWhiteSpace(xc)))
			throw new ArgumentException(&quot;Command names cannot contain whitespace characters.&quot;, nameof(name));
public sealed class GroupCommandAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/CooldownAttribute.cs">public sealed class CooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : CheckBaseAttribute, ICooldown&lt;CommandContext, CooldownBucket&gt;
	public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
	public CooldownBucket GetBucket(CommandContext ctx)
		var bid = this.GetBucketId(ctx, out _, out _, out _);
		ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
	public TimeSpan GetRemainingCooldown(CommandContext ctx)
		var bucket = this.GetBucket(ctx);
	public async Task&lt;bool&gt; RespondRatelimitHitAsync(CommandContext ctx, bool noHit, CooldownBucket bucket)
				await ctx.Message.CreateReactionAsync(DiscordEmoji.FromName(ctx.Client, &quot;:x:&quot;, false));
		var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
		var providerInstance = Activator.CreateInstance(this.ResponderType);
		await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
	private string GetBucketId(CommandContext ctx, out ulong userId, out ulong channelId, out ulong guildId)
		if (this.BucketType.HasFlag(CooldownBucketType.User))
		if (this.BucketType.HasFlag(CooldownBucketType.Channel))
		if (this.BucketType.HasFlag(CooldownBucketType.Guild) &amp;&amp; ctx.Guild is null)
		if (ctx.Guild is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Guild))
		var bid = CooldownBucket.MakeId(ctx.Command.QualifiedName, &quot;text&quot;, userId, channelId, guildId);
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld);
		if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
			return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
		ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.CommandsNext/Attributes/DescriptionAttribute.cs">public sealed class DescriptionAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/DontInjectAttribute.cs">public class DontInjectAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/GroupAttribute.cs">public sealed class GroupAttribute : Attribute
		if (string.IsNullOrWhiteSpace(name))
			throw new ArgumentNullException(nameof(name), &quot;Group names cannot be null, empty, or all-whitespace.&quot;);
		if (name.Any(xc =&gt; char.IsWhiteSpace(xc)))
			throw new ArgumentException(&quot;Group names cannot contain whitespace characters.&quot;, nameof(name));</file><file path="DisCatSharp.CommandsNext/Attributes/HiddenAttribute.cs">public sealed class HiddenAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/ModuleLifespanAttribute.cs">public class ModuleLifespanAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/PriorityAttribute.cs">public sealed class PriorityAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/RemainingTextAttribute.cs">public class RemainingTextAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/RequireBoostingAttribute.cs">public sealed class RequireBoostingAttribute : CheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
			var guild = await ctx.Client.GetGuildAsync(this.GuildId).ConfigureAwait(false);
			var member = await guild.GetMemberAsync(ctx.User.Id).ConfigureAwait(false);
			return member != null &amp;&amp; member.PremiumSince.HasValue ? await Task.FromResult(member.PremiumSince.Value.UtcDateTime.Date &lt; DateTime.UtcNow.Date.AddDays(-this.Since)).ConfigureAwait(false) : await Task.FromResult(false).ConfigureAwait(false);
		return ctx.Member != null &amp;&amp; ctx.Member.PremiumSince.HasValue ? await Task.FromResult(ctx.Member.PremiumSince.Value.UtcDateTime.Date &lt; DateTime.UtcNow.Date.AddDays(-this.Since)).ConfigureAwait(false) : await Task.FromResult(false).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireBotPermissionsAttribute.cs">public sealed class RequireBotPermissionsAttribute : CheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
			channel = await ctx.Client.GetChannelAsync(ctx.Channel.Id, true).ConfigureAwait(false);
		var pbot = channel.PermissionsFor(bot);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireCertifiedModeratorAttribute.cs">public sealed class RequireCertifiedModeratorAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; ctx.User.Flags.HasValue ? Task.FromResult(ctx.User.Flags.Value.HasFlag(UserFlags.CertifiedModerator)) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireCommunityAttribute.cs">public sealed class RequireCommunityAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.IsCommunity);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireDirectMessageAttribute.cs">public sealed class RequireDirectMessageAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		=&gt; Task.FromResult(ctx.Channel is DiscordDmChannel);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireGuildAttribute.cs">public sealed class RequireGuildAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		=&gt; Task.FromResult(ctx.Guild != null);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireGuildOwnerAttribute.cs">public sealed class RequireGuildOwnerAttribute : CheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		var guild = await Task.FromResult(ctx.Guild != null).ConfigureAwait(false);
			var owner = await Task.FromResult(ctx.Member == ctx.Guild.Owner).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireMemberVerificationGateAttribute.cs">public sealed class RequireMemberVerificationGateAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.HasMemberVerificationGate);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireNsfwAttribute.cs">public sealed class RequireNsfwAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		=&gt; Task.FromResult(ctx.Channel.Guild == null || ctx.Channel.IsNsfw);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireOwnerAttribute.cs">public sealed class RequireOwnerAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		return app != null ? Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id)) : Task.FromResult(ctx.User.Id == me.Id);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireOwnerOrIdAttribute.cs">public sealed class RequireOwnerOrIdAttribute : CheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		var owner = app != null ? await Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id)).ConfigureAwait(false) : await Task.FromResult(ctx.User.Id == me.Id).ConfigureAwait(false);
		var allowed = this.UserIds.Contains(ctx.User.Id);</file><file path="DisCatSharp.CommandsNext/Attributes/RequirePermissionsAttribute.cs">public sealed class RequirePermissionsAttribute : CheckBaseAttribute
	public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
			channel = await ctx.Client.GetChannelAsync(ctx.Channel.Id, true).ConfigureAwait(false);
		var pusr = channel.PermissionsFor(usr);
		var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
		var pbot = channel.PermissionsFor(bot);</file><file path="DisCatSharp.CommandsNext/Attributes/RequirePrefixesAttribute.cs">public sealed class RequirePrefixesAttribute : CheckBaseAttribute
			throw new ArgumentNullException(nameof(prefixes), &quot;The allowed prefix collection cannot be null or empty.&quot;);
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		=&gt; Task.FromResult((help &amp;&amp; this.ShowInHelp) || this.Prefixes.Contains(ctx.Prefix, ctx.CommandsNext.GetStringComparer()));</file><file path="DisCatSharp.CommandsNext/Attributes/RequireReferencedMessageAttribute.cs">public sealed class RequireReferencedMessageAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
		=&gt; Task.FromResult(help || ctx.Message.ReferencedMessage != null);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireRolesAttribute.cs">public sealed class RequireRolesAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
			return Task.FromResult(false);
		var rns = ctx.Member.Roles.Select(xr =&gt; xr.Name);
		var rnc = rns.Count();
		var ins = rns.Intersect(this.RoleNames, ctx.CommandsNext.GetStringComparer());
		var inc = ins.Count();
			RoleCheckMode.All =&gt; Task.FromResult(this.RoleNames.Count == inc),
			RoleCheckMode.SpecifiedOnly =&gt; Task.FromResult(rnc == inc),
			RoleCheckMode.None =&gt; Task.FromResult(inc == 0),
			_ =&gt; Task.FromResult(inc &gt; 0)</file><file path="DisCatSharp.CommandsNext/Attributes/RequireStaffAttribute.cs">public sealed class RequireStaffAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; ctx.User.Flags.HasValue ? Task.FromResult(ctx.User.Flags.Value.HasFlag(UserFlags.Staff)) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireUserPermissionsAttribute.cs">public sealed class RequireUserPermissionsAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
			return Task.FromResult(this.IgnoreDms);
			return Task.FromResult(false);
			return Task.FromResult(true);
		var pusr = ctx.Channel.PermissionsFor(usr);
		return (pusr &amp; this.Permissions) == this.Permissions ? Task.FromResult(true) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireWelcomeScreenAttribute.cs">public sealed class RequireWelcomeScreenAttribute : CheckBaseAttribute
	public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.HasWelcomeScreen);</file><file path="DisCatSharp.CommandsNext/BaseCommandModule.cs">public abstract class BaseCommandModule
	public virtual Task BeforeExecutionAsync(CommandContext ctx)
		=&gt; Task.Delay(0);
	public virtual Task AfterExecutionAsync(CommandContext ctx)</file><file path="DisCatSharp.CommandsNext/CommandsNextConfiguration.cs">public sealed class CommandsNextConfiguration
	public IServiceProvider ServiceProvider { internal get; set; } = new ServiceCollection().BuildServiceProvider(true);</file><file path="DisCatSharp.CommandsNext/CommandsNextEvents.cs">public static class CommandsNextEvents</file><file path="DisCatSharp.CommandsNext/CommandsNextExtension.cs">public class CommandsNextExtension : BaseExtension
	private readonly CommandsNextConfiguration _config;
	private readonly MethodInfo _convertGeneric;
	private readonly HelpFormatterFactory _helpFormatter;
			[typeof(string)] = new StringConverter(),
			[typeof(bool)] = new BoolConverter(),
			[typeof(sbyte)] = new Int8Converter(),
			[typeof(byte)] = new Uint8Converter(),
			[typeof(short)] = new Int16Converter(),
			[typeof(ushort)] = new Uint16Converter(),
			[typeof(int)] = new Int32Converter(),
			[typeof(uint)] = new Uint32Converter(),
			[typeof(long)] = new Int64Converter(),
			[typeof(ulong)] = new Uint64Converter(),
			[typeof(float)] = new Float32Converter(),
			[typeof(double)] = new Float64Converter(),
			[typeof(decimal)] = new Float128Converter(),
			[typeof(DateTime)] = new DateTimeConverter(),
			[typeof(DateTimeOffset)] = new DateTimeOffsetConverter(),
			[typeof(TimeSpan)] = new TimeSpanConverter(),
			[typeof(Uri)] = new UriConverter(),
			[typeof(DiscordUser)] = new DiscordUserConverter(),
			[typeof(DiscordMember)] = new DiscordMemberConverter(),
			[typeof(DiscordRole)] = new DiscordRoleConverter(),
			[typeof(DiscordChannel)] = new DiscordChannelConverter(),
			[typeof(DiscordGuild)] = new DiscordGuildConverter(),
			[typeof(DiscordMessage)] = new DiscordMessageConverter(),
			[typeof(DiscordEmoji)] = new DiscordEmojiConverter(),
			[typeof(DiscordThreadChannel)] = new DiscordThreadChannelConverter(),
			[typeof(DiscordInvite)] = new DiscordInviteConverter(),
			[typeof(DiscordColor)] = new DiscordColorConverter(),
			[typeof(DiscordScheduledEvent)] = new DiscordScheduledEventConverter()
		foreach (var xt in this.ArgumentConverters.Keys.ToArray())
			var xti = xt.GetTypeInfo();
			var xcvt = typeof(NullableConverter&lt;&gt;).MakeGenericType(xt);
			var xnt = typeof(Nullable&lt;&gt;).MakeGenericType(xt);
			if (this.ArgumentConverters.ContainsKey(xcvt))
			var xcv = Activator.CreateInstance(xcvt) as IArgumentConverter;
		var t = this.GetType();
		var ms = t.GetTypeInfo().DeclaredMethods;
		var m = ms.FirstOrDefault(xm =&gt; xm is { Name: &quot;ConvertArgumentToObj&quot;, ContainsGenericParameters: true } and { IsStatic: false, IsPrivate: true });
	public void SetHelpFormatter&lt;T&gt;() where T : BaseHelpFormatter =&gt; this._helpFormatter.SetFormatterType&lt;T&gt;();
	protected internal override void Setup(DiscordClient client)
			throw new InvalidOperationException(&quot;What did I tell you?&quot;);
			this.Client.Logger.LogWarning(CommandsNextEvents.Misc, &quot;Not attaching default command handler - if this is intentional, you can ignore this message&quot;);
			this.RegisterCommands(typeof(DefaultHelpModule), null, null, out var tcmds);
				var checks = this._config.DefaultHelpChecks.ToArray();
					cb.WithExecutionChecks(checks);
					this.AddToCommandDictionary(xc.Build(null));
	public CommandContext CreateFakeContext(DiscordUser actor, DiscordChannel channel, string messageContents, string prefix, Command cmd, string rawArguments = null)
		var epoch = new DateTimeOffset(2015, 1, 1, 0, 0, 0, TimeSpan.Zero);
		var msg = new DiscordMessage
			MentionEveryone = messageContents.Contains(&quot;@everyone&quot;),
			TimestampRaw = now.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;),
		if (!string.IsNullOrWhiteSpace(msg.Content))
				mentionedUsers = Utilities.GetUserMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.Members.GetValueOrDefault(xid)).Cast&lt;DiscordUser&gt;().ToList();
				mentionedRoles = Utilities.GetRoleMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.GetRole(xid)).ToList();
				mentionedChannels = Utilities.GetChannelMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.GetChannel(xid)).ToList();
				mentionedUsers = Utilities.GetUserMentions(msg.Content).Select(this.Client.GetCachedOrEmptyUserInternal).ToList();
		var ctx = new CommandContext
			var scope = ctx.Services.CreateScope();
	public class DefaultHelpModule : BaseCommandModule
		public async Task DefaultHelpAsync(CommandContext ctx, [Description(&quot;Command to provide help for.&quot;)] params string[] command)
			var topLevel = ctx.CommandsNext._topLevelCommands.Values.Distinct();
			var helpBuilder = ctx.CommandsNext._helpFormatter.Create(ctx);
				Command cmd = null;
						? searchIn.FirstOrDefault(xc =&gt; xc.Name == c || (xc.Aliases != null &amp;&amp; xc.Aliases.Contains(c)))
						: searchIn.FirstOrDefault(xc =&gt; string.Equals(xc.Name, c, StringComparison.InvariantCultureIgnoreCase) || (xc.Aliases != null &amp;&amp; xc.Aliases.Select(xs =&gt; xs.ToLowerInvariant()).Contains(c.ToLowerInvariant())));
					var failedChecks = await cmd.RunChecksAsync(ctx, true).ConfigureAwait(false);
					if (failedChecks.Any())
						throw new ChecksFailedException(cmd, ctx, failedChecks);
					throw new CommandNotFoundException(string.Join(&quot; &quot;, command));
				helpBuilder.WithCommand(cmd);
					var commandsToSearch = group.Children.Where(xc =&gt; !xc.IsHidden);
						if (candidateCommand.ExecutionChecks == null || !candidateCommand.ExecutionChecks.Any())
							eligibleCommands.Add(candidateCommand);
						var candidateFailedChecks = await candidateCommand.RunChecksAsync(ctx, true).ConfigureAwait(false);
						if (!candidateFailedChecks.Any())
						helpBuilder.WithSubcommands(eligibleCommands.OrderBy(xc =&gt; xc.Name));
				var commandsToSearch = topLevel.Where(xc =&gt; !xc.IsHidden);
					if (sc.ExecutionChecks == null || !sc.ExecutionChecks.Any())
						eligibleCommands.Add(sc);
					var candidateFailedChecks = await sc.RunChecksAsync(ctx, true).ConfigureAwait(false);
			var helpMessage = helpBuilder.Build();
			var builder = new DiscordMessageBuilder().WithContent(helpMessage.Content).AddEmbed(helpMessage.Embed);
				await ctx.RespondAsync(builder).ConfigureAwait(false);
				await ctx.Member.SendMessageAsync(builder).ConfigureAwait(false);
	private async Task HandleCommandsAsync(DiscordClient sender, MessageCreateEventArgs e)
			mpos = e.Message.GetMentionPrefixLength(this.Client.CurrentUser);
			foreach (var pfix in this._config.StringPrefixes.Where(pfix =&gt; mpos == -1 &amp;&amp; !string.IsNullOrWhiteSpace(pfix)))
				mpos = e.Message.GetStringPrefixLength(pfix, this._config.CaseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase);
			mpos = await this._config.PrefixResolver(e.Message).ConfigureAwait(false);
		var fname = cnt.ExtractNextArgument(ref __);
		var cmd = this.FindCommand(cnt, out var args);
		var ctx = this.CreateContext(e.Message, pfx, cmd, args);
			await this._error.InvokeAsync(this, new(this.Client.ServiceProvider)
				Exception = new CommandNotFoundException(fname)
			}).ConfigureAwait(false);
		_ = Task.Run(async () =&gt; await this.ExecuteCommandAsync(ctx).ConfigureAwait(false));
	public Command FindCommand(string commandString, out string? rawArguments)
		var next = commandString.ExtractNextArgument(ref pos);
		if (!this.RegisteredCommands.TryGetValue(next, out var cmd))
			next = next.ToLowerInvariant();
			var cmdKvp = this.RegisteredCommands.FirstOrDefault(x =&gt; x.Key.ToLowerInvariant() == next);
			rawArguments = commandString[pos..].Trim();
			next = commandString.ExtractNextArgument(ref pos);
				cmd = cm2.Children.FirstOrDefault(x =&gt; x.Name.ToLowerInvariant() == next || x.Aliases?.Any(xx =&gt; xx.ToLowerInvariant() == next) == true);
				cmd = cm2.Children.FirstOrDefault(x =&gt; x.Name == next || x.Aliases?.Contains(next) == true);
	public CommandContext CreateContext(DiscordMessage msg, string prefix, Command cmd, string? rawArguments = null)
	public async Task ExecuteCommandAsync(CommandContext ctx)
			await this.RunAllChecksAsync(cmd, ctx).ConfigureAwait(false);
			var res = await cmd.ExecuteAsync(ctx).ConfigureAwait(false);
				await this._executed.InvokeAsync(this, new(this.Client.ServiceProvider)
				ctx.ServiceScopeContext.Dispose();
	private async Task RunAllChecksAsync(Command cmd, CommandContext ctx)
			await this.RunAllChecksAsync(cmd.Parent, ctx).ConfigureAwait(false);
		var fchecks = await cmd.RunChecksAsync(ctx, false).ConfigureAwait(false);
		if (fchecks.Any())
			throw new ChecksFailedException(cmd, ctx, fchecks);
	public void RegisterCommands(Assembly assembly)
		var types = assembly.ExportedTypes.Where(xt =&gt;
			return xti.IsModuleCandidateType() &amp;&amp; !xti.IsNested;
			this.RegisterCommands(xt);
	public void RegisterCommands&lt;T&gt;() where T : BaseCommandModule
		this.RegisterCommands(t);
	public void RegisterCommands(Type t)
			throw new ArgumentNullException(nameof(t), &quot;Type cannot be null.&quot;);
		if (!t.IsModuleCandidateType())
			throw new ArgumentNullException(nameof(t), &quot;Type must be a class, which cannot be abstract or static.&quot;);
		this.RegisterCommands(t, null, null, out var tempCommands);
				this.AddToCommandDictionary(command.Build(null));
	private void RegisterCommands(Type t, CommandGroupBuilder currentParent, IEnumerable&lt;CheckBaseAttribute&gt; inheritedChecks, out List&lt;CommandBuilder&gt; foundCommands)
		var ti = t.GetTypeInfo();
		var module = new CommandModuleBuilder()
			.WithType(t)
			.WithLifespan(moduleLifespan)
			.Build(this.Services);
			throw new InvalidOperationException(&quot;In a transient module, child modules can only be transient.&quot;);
		var groupBuilder = new CommandGroupBuilder(module);
		var moduleAttributes = ti.GetCustomAttributes();
						if (moduleName.EndsWith(&quot;Group&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Group&quot;)
						else if (moduleName.EndsWith(&quot;Module&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Module&quot;)
						else if (moduleName.EndsWith(&quot;Commands&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Commands&quot;)
						moduleName = moduleName.ToLowerInvariant();
					groupBuilder.WithName(moduleName);
							groupBuilder.WithExecutionCheck(chk);
					foreach (var mi in ti.DeclaredMethods.Where(x =&gt; x.IsCommandCandidate(out _) &amp;&amp; x.GetCustomAttribute&lt;GroupCommandAttribute&gt;() != null))
						groupBuilder.WithOverload(new(mi));
						groupBuilder.WithAlias(this._config.CaseSensitive ? xalias : xalias.ToLowerInvariant());
					groupBuilder.WithHiddenStatus(true);
					groupBuilder.WithDescription(d.Description);
					moduleChecks.Add(c);
					groupBuilder.WithExecutionCheck(c);
					groupBuilder.WithCustomAttribute(xa);
				moduleChecks.AddRange(inheritedChecks);
			if (!m.IsCommandCandidate(out _))
			var attrs = m.GetCustomAttributes();
			if (attrs.FirstOrDefault(xa =&gt; xa is CommandAttribute) is not CommandAttribute cattr)
				if (commandName.EndsWith(&quot;Async&quot;, StringComparison.Ordinal) &amp;&amp; commandName != &quot;Async&quot;)
				commandName = commandName.ToLowerInvariant();
			if (!commandBuilders.TryGetValue(commandName, out var commandBuilder))
				commandBuilders.Add(commandName, commandBuilder = new CommandBuilder(module).WithName(commandName));
						currentParent.WithChild(commandBuilder);
						commands.Add(commandBuilder);
					groupBuilder.WithChild(commandBuilder);
			commandBuilder.WithOverload(new(m));
					commandBuilder.WithExecutionCheck(chk);
							commandBuilder.WithAlias(this._config.CaseSensitive ? xalias : xalias.ToLowerInvariant());
						commandBuilder.WithExecutionCheck(p);
						commandBuilder.WithDescription(d.Description);
						commandBuilder.WithHiddenStatus(true);
						commandBuilder.WithCustomAttribute(xa);
			.Where(xt =&gt; xt.IsModuleCandidateType() &amp;&amp; xt.DeclaredConstructors.Any(xc =&gt; xc.IsPublic));
			this.RegisterCommands(type.AsType(),
					groupBuilder.WithChild(xtcmd);
				commands.AddRange(tempCommands);
			commands.Add(groupBuilder);
			currentParent.WithChild(groupBuilder);
	public void RegisterCommands(params CommandBuilder[] cmds)
			this.AddToCommandDictionary(cmd.Build(null));
	public void UnregisterCommands(params Command[] cmds)
		if (cmds.Any(x =&gt; x.Parent != null))
			throw new InvalidOperationException(&quot;Cannot unregister nested commands.&quot;);
		var keys = this.RegisteredCommands.Where(x =&gt; cmds.Contains(x.Value)).Select(x =&gt; x.Key).ToList();
			this._topLevelCommands.Remove(key);
	private void AddToCommandDictionary(Command cmd)
		if (this._topLevelCommands.ContainsKey(cmd.Name) || (cmd.Aliases != null &amp;&amp; cmd.Aliases.Any(xs =&gt; this._topLevelCommands.ContainsKey(xs))))
			throw new DuplicateCommandException(cmd.QualifiedName);
	public async Task&lt;T&gt; ConvertArgument&lt;T&gt;(string value, CommandContext ctx)
		if (!this.ArgumentConverters.ContainsKey(t))
			throw new ArgumentException(&quot;There is no converter specified for given type.&quot;, nameof(T));
			throw new ArgumentException(&quot;Invalid converter registered for this type.&quot;, nameof(T));
		var cvr = await cv.ConvertAsync(value, ctx).ConfigureAwait(false);
		return !cvr.HasValue ? throw new ArgumentException(&quot;Could not convert specified value to given type.&quot;, nameof(value)) : cvr.Value;
	public async Task&lt;object&gt; ConvertArgument(string value, CommandContext ctx, Type type)
		var m = this._convertGeneric.MakeGenericMethod(type);
			return await (m.Invoke(this, [value, ctx]) as Task&lt;object&gt;).ConfigureAwait(false);
	public void RegisterConverter&lt;T&gt;(IArgumentConverter&lt;T&gt; converter)
			throw new ArgumentNullException(nameof(converter), &quot;Converter cannot be null.&quot;);
		var nullableConverterType = typeof(NullableConverter&lt;&gt;).MakeGenericType(t);
		var nullableType = typeof(Nullable&lt;&gt;).MakeGenericType(t);
		if (this.ArgumentConverters.ContainsKey(nullableType))
		var nullableConverter = Activator.CreateInstance(nullableConverterType) as IArgumentConverter;
	public void UnregisterConverter&lt;T&gt;()
		this.ArgumentConverters.Remove(t);
		this._userFriendlyTypeNames.Remove(t);
		if (!this.ArgumentConverters.ContainsKey(nullableType))
		this.ArgumentConverters.Remove(nullableType);
		this._userFriendlyTypeNames.Remove(nullableType);
	public void RegisterUserFriendlyTypeName&lt;T&gt;(string value)
		if (string.IsNullOrWhiteSpace(value))
			throw new ArgumentNullException(nameof(value), &quot;Name cannot be null or empty.&quot;);
			throw new InvalidOperationException(&quot;Cannot register a friendly name for a type which has no associated converter.&quot;);
	public string GetUserFriendlyTypeName(Type t)
		if (this._userFriendlyTypeNames.TryGetValue(t, out var userFriendlyTypeName))
		if (!ti.IsGenericTypeDefinition || t.GetGenericTypeDefinition() != typeof(Nullable&lt;&gt;)) return t.Name;
		return this._userFriendlyTypeNames.TryGetValue(tn, out var name) ? name : tn.Name;
	private async Task&lt;object&gt; ConvertArgumentToObj&lt;T&gt;(string value, CommandContext ctx)
		=&gt; await this.ConvertArgument&lt;T&gt;(value, ctx).ConfigureAwait(false);
	internal IEqualityComparer&lt;string&gt; GetStringComparer()
		add =&gt; this._executed.Register(value);
		remove =&gt; this._executed.Unregister(value);
		add =&gt; this._error.Register(value);
		remove =&gt; this._error.Unregister(value);
	private Task OnCommandExecuted(CommandExecutionEventArgs e)
		=&gt; this._executed.InvokeAsync(this, e);
	private Task OnCommandErrored(CommandErrorEventArgs e)
		=&gt; this._error.InvokeAsync(this, e);</file><file path="DisCatSharp.CommandsNext/CommandsNextUtilities.cs">public static class CommandsNextUtilities
	public static int GetStringPrefixLength(this DiscordMessage msg, string str, StringComparison comparisonType = StringComparison.Ordinal)
			: !content.StartsWith(str, comparisonType)
	public static int GetMentionPrefixLength(this DiscordMessage msg, DiscordUser user)
		if (!content.StartsWith(&quot;&lt;@&quot;, StringComparison.Ordinal))
		var cni = content.IndexOf(&apos;&gt;&apos;);
		var m = DiscordRegEx.UserRegex().Match(cnp);
		var userId = ulong.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
	internal static string ExtractNextArgument(this string str, ref int startPos)
		if (string.IsNullOrWhiteSpace(str))
			if (!char.IsWhiteSpace(str[i]))
			if (char.IsWhiteSpace(str[i]) &amp;&amp; !inQuote &amp;&amp; !inTripleBacktick &amp;&amp; !inBacktick &amp;&amp; !inEscape)
					if (str.IndexOf(&quot;\\`&quot;, i) == i || str.IndexOf(&quot;\\\&quot;&quot;, i) == i || str.IndexOf(&quot;\\\\&quot;, i) == i || (str.Length &gt;= i &amp;&amp; char.IsWhiteSpace(str[i + 1])))
						removeIndices.Add(i - startPosition);
				else if ((inBacktick || inTripleBacktick) &amp;&amp; str.IndexOf(&quot;\\`&quot;, i) == i)
				var tripleBacktick = str.IndexOf(&quot;```&quot;, i) == i;
				return startPosition != endPosition ? str[startPosition..endPosition].CleanupString(removeIndices) : null;
		return startPos != startPosition ? str[startPosition..].CleanupString(removeIndices) : null;
	internal static string CleanupString(this string s, IList&lt;int&gt; indices)
		if (!indices.Any())
		var li = indices.Last();
			s = s.Remove(li - ll + 1, ll);
		return s.Remove(li - ll + 1, ll);
	internal static async Task&lt;ArgumentBindingResult&gt; BindArguments(CommandContext ctx, bool ignoreSurplus)
						rawArgumentList.Add(argValue);
				argValue = argString[foundAt..].Trim();
				return new(new ArgumentException(&quot;Not enough arguments supplied to the command.&quot;));
				rawArgumentList.Add(null);
			return new(new ArgumentException(&quot;Too many arguments were supplied to this command.&quot;));
				var array = Array.CreateInstance(arg.Type, rawArgumentList.Count - i);
						array.SetValue(await ctx.CommandsNext.ConvertArgument(rawArgumentList[i], ctx, arg.Type).ConfigureAwait(false), i - start);
				args[i + 2] = rawArgumentList[i] != null ? await ctx.CommandsNext.ConvertArgument(rawArgumentList[i], ctx, arg.Type).ConfigureAwait(false) : arg.DefaultValue;
	internal static bool IsModuleCandidateType(this Type type)
		=&gt; type.GetTypeInfo().IsModuleCandidateType();
	internal static bool IsModuleCandidateType(this TypeInfo ti)
		var timodule = tmodule.GetTypeInfo();
		if (!timodule.IsAssignableFrom(ti))
		if (ti.IsGenericType &amp;&amp; ti.Name.Contains(&quot;AnonymousType&quot;) &amp;&amp; (ti.Name.StartsWith(&quot;&lt;&gt;&quot;, StringComparison.Ordinal) || ti.Name.StartsWith(&quot;VB$&quot;, StringComparison.Ordinal)) &amp;&amp; (ti.Attributes &amp; TypeAttributes.NotPublic) == TypeAttributes.NotPublic)
		var tdelegate = typeof(Delegate).GetTypeInfo();
		if (tdelegate.IsAssignableFrom(ti))
		return ti.DeclaredMethods.Any(xmi =&gt; xmi.IsCommandCandidate(out _)) || ti.DeclaredNestedTypes.Any(xti =&gt; xti.IsModuleCandidateType());
	internal static bool IsCommandCandidate(this MethodInfo method, out ParameterInfo[] parameters)
		parameters = method.GetParameters();
		return parameters.Length != 0 &amp;&amp; parameters.First().ParameterType == typeof(CommandContext) &amp;&amp; method.ReturnType == typeof(Task);
	internal static object CreateInstance(this Type t, IServiceProvider services)
		var ti = t.GetTypeInfo();
			.Where(xci =&gt; xci.IsPublic)
			.ToArray();
			throw new ArgumentException(&quot;Specified type does not contain a public constructor or contains more than one public constructor.&quot;);
		var constructorArgs = constructor.GetParameters();
			throw new InvalidOperationException(&quot;Dependency collection needs to be specified for parameterized constructors.&quot;);
				args[i] = services.GetRequiredService(constructorArgs[i].ParameterType);
		var moduleInstance = Activator.CreateInstance(t, args);
		var props = t.GetRuntimeProperties().Where(xp =&gt; xp.CanWrite &amp;&amp; xp.SetMethod != null &amp;&amp; !xp.SetMethod.IsStatic &amp;&amp; xp.SetMethod.IsPublic);
			var service = services.GetService(prop.PropertyType);
			prop.SetValue(moduleInstance, service);
		var fields = t.GetRuntimeFields().Where(xf =&gt; !xf.IsInitOnly &amp;&amp; xf is { IsStatic: false, IsPublic: true });
			var service = services.GetService(field.FieldType);
			field.SetValue(moduleInstance, service);</file><file path="DisCatSharp.CommandsNext/Converters/ArgumentBindingResult.cs"></file><file path="DisCatSharp.CommandsNext/Converters/BaseHelpFormatter.cs">public abstract class BaseHelpFormatter
	public abstract BaseHelpFormatter WithCommand(Command command);
	public abstract BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; subcommands);
	public abstract CommandHelpMessage Build();</file><file path="DisCatSharp.CommandsNext/Converters/DefaultHelpFormatter.cs">public class DefaultHelpFormatter : BaseHelpFormatter
	private Command _command;
		this.EmbedBuilder = new DiscordEmbedBuilder()
			.WithTitle(&quot;Help&quot;)
			.WithColor(0x007FFF);
	public override BaseHelpFormatter WithCommand(Command command)
		this.EmbedBuilder.WithDescription($&quot;{command.Name.InlineCode()}: {command.Description ?? &quot;No description provided.&quot;}&quot;);
			this.EmbedBuilder.WithDescription($&quot;{this.EmbedBuilder.Description}\n\nThis group can be executed as a standalone command.&quot;);
			this.EmbedBuilder.AddField(new(&quot;Aliases&quot;, string.Join(&quot;, &quot;, command.Aliases.Select(Formatter.InlineCode))));
			var sb = new StringBuilder();
			foreach (var ovl in command.Overloads.OrderByDescending(x =&gt; x.Priority))
				sb.Append(&apos;`&apos;).Append(command.QualifiedName);
					sb.Append(arg.IsOptional || arg.IsCatchAll ? &quot; [&quot; : &quot; &lt;&quot;).Append(arg.Name).Append(arg.IsCatchAll ? &quot;...&quot; : &quot;&quot;).Append(arg.IsOptional || arg.IsCatchAll ? &apos;]&apos; : &apos;&gt;&apos;);
				sb.Append(&quot;`\n&quot;);
					sb.Append(&apos;`&apos;).Append(arg.Name).Append(&quot; (&quot;).Append(this.CommandsNext.GetUserFriendlyTypeName(arg.Type)).Append(&quot;)`: &quot;).Append(arg.Description ?? &quot;No description provided.&quot;).Append(&apos;\n&apos;);
				sb.Append(&apos;\n&apos;);
			this.EmbedBuilder.AddField(new(&quot;Arguments&quot;, sb.ToString().Trim()));
	public override BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; subcommands)
		this.EmbedBuilder.AddField(new(this._command != null ? &quot;Subcommands&quot; : &quot;Commands&quot;, string.Join(&quot;, &quot;, subcommands.Select(x =&gt; x.Name.InlineCode()))));
	public override CommandHelpMessage Build()
			this.EmbedBuilder.WithDescription(&quot;Listing all top-level commands and groups. Specify a command to see more information.&quot;);
		return new(embed: this.EmbedBuilder.Build());</file><file path="DisCatSharp.CommandsNext/Converters/EntityConverters.cs">public class DiscordUserConverter : IArgumentConverter&lt;DiscordUser&gt;
	async Task&lt;Optional&lt;DiscordUser&gt;&gt; IArgumentConverter&lt;DiscordUser&gt;.ConvertAsync(string value, CommandContext ctx)
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var uid))
			var result = await ctx.Client.GetUserAsync(uid).ConfigureAwait(false);
			return Optional.FromNullable(result);
		var m = DiscordRegEx.UserRegex().Match(value);
		if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out uid))
			value = value.ToLowerInvariant();
		var di = value.IndexOf(&apos;#&apos;);
			.SelectMany(xkvp =&gt; xkvp.Members.Values)
			.Where(xm =&gt; (cs ? xm.Username : xm.Username.ToLowerInvariant()) == un &amp;&amp; ((dv != null &amp;&amp; xm.Discriminator == dv) || dv == null));
		var usr = us.FirstOrDefault();
public class DiscordMemberConverter : IArgumentConverter&lt;DiscordMember&gt;
	async Task&lt;Optional&lt;DiscordMember&gt;&gt; IArgumentConverter&lt;DiscordMember&gt;.ConvertAsync(string value, CommandContext ctx)
			var result = await ctx.Guild.GetMemberAsync(uid).ConfigureAwait(false);
		var searchResult = await ctx.Guild.SearchMembersAsync(value).ConfigureAwait(false);
		if (searchResult.Any())
			return Optional.Some(searchResult.First());
			.Where(xm =&gt; ((cs ? xm.Username : xm.Username.ToLowerInvariant()) == un &amp;&amp; ((dv != null &amp;&amp; xm.Discriminator == dv) || dv == null))
		return Optional.FromNullable(us.FirstOrDefault());
public class DiscordChannelConverter : IArgumentConverter&lt;DiscordChannel&gt;
	async Task&lt;Optional&lt;DiscordChannel&gt;&gt; IArgumentConverter&lt;DiscordChannel&gt;.ConvertAsync(string value, CommandContext ctx)
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var cid))
			var result = await ctx.Client.GetChannelAsync(cid).ConfigureAwait(false);
		var m = DiscordRegEx.ChannelRegex().Match(value);
		if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out cid))
		var chn = ctx.Guild?.Channels.Values.FirstOrDefault(xc =&gt; (cs ? xc.Name : xc.Name.ToLowerInvariant()) == value);
		return Optional.FromNullable(chn);
public class DiscordThreadChannelConverter : IArgumentConverter&lt;DiscordThreadChannel&gt;
	async Task&lt;Optional&lt;DiscordThreadChannel&gt;&gt; IArgumentConverter&lt;DiscordThreadChannel&gt;.ConvertAsync(string value, CommandContext ctx)
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var tid))
			var result = await ctx.Client.GetThreadAsync(tid).ConfigureAwait(false);
		if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out tid))
		var tchn = ctx.Guild?.Threads.Values.FirstOrDefault(xc =&gt; (cs ? xc.Name : xc.Name.ToLowerInvariant()) == value);
		return Optional.FromNullable(tchn);
public class DiscordRoleConverter : IArgumentConverter&lt;DiscordRole&gt;
	Task&lt;Optional&lt;DiscordRole&gt;&gt; IArgumentConverter&lt;DiscordRole&gt;.ConvertAsync(string value, CommandContext ctx)
			return Task.FromResult(Optional&lt;DiscordRole&gt;.None);
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var rid))
			var result = ctx.Guild.GetRole(rid);
			return Task.FromResult(Optional.FromNullable(result));
		var m = DiscordRegEx.RoleRegex().Match(value);
		if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out rid))
		var rol = ctx.Guild.Roles.Values.FirstOrDefault(xr =&gt; (cs ? xr.Name : xr.Name.ToLowerInvariant()) == value);
		return Task.FromResult(Optional.FromNullable(rol));
public class DiscordGuildConverter : IArgumentConverter&lt;DiscordGuild&gt;
	Task&lt;Optional&lt;DiscordGuild&gt;&gt; IArgumentConverter&lt;DiscordGuild&gt;.ConvertAsync(string value, CommandContext ctx)
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var gid))
			return ctx.Client.Guilds.TryGetValue(gid, out var result)
				? Task.FromResult(Optional.Some(result))
				: Task.FromResult(Optional&lt;DiscordGuild&gt;.None);
		var gld = ctx.Client.Guilds.Values.FirstOrDefault(xg =&gt; (cs ? xg.Name : xg.Name.ToLowerInvariant()) == value);
		return Task.FromResult(Optional.FromNullable(gld));
public class DiscordInviteConverter : IArgumentConverter&lt;DiscordInvite&gt;
	async Task&lt;Optional&lt;DiscordInvite&gt;&gt; IArgumentConverter&lt;DiscordInvite&gt;.ConvertAsync(string value, CommandContext ctx)
		var m = DiscordRegEx.InviteRegex().Match(value);
			ulong? eventId = ulong.TryParse(m.Groups[&quot;event&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
			var result = await ctx.Client.GetInviteByCodeAsync(m.Groups[&quot;code&quot;].Value, scheduledEventId: eventId).ConfigureAwait(false);
		var inv = await ctx.Client.GetInviteByCodeAsync(value).ConfigureAwait(false);
		return Optional.FromNullable(inv);
public class DiscordMessageConverter : IArgumentConverter&lt;DiscordMessage&gt;
	async Task&lt;Optional&lt;DiscordMessage&gt;&gt; IArgumentConverter&lt;DiscordMessage&gt;.ConvertAsync(string value, CommandContext ctx)
		if (string.IsNullOrWhiteSpace(value))
		var msguri = value.StartsWith(&quot;&lt;&quot;, StringComparison.Ordinal) &amp;&amp; value.EndsWith(&quot;&gt;&quot;, StringComparison.Ordinal) ? value[1..^1] : value;
		if (Uri.TryCreate(msguri, UriKind.Absolute, out var uri))
			var uripath = DiscordRegEx.MessageLinkRegex().Match(uri.AbsoluteUri);
			    || !ulong.TryParse(uripath.Groups[&quot;channel&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var cid)
			    || !ulong.TryParse(uripath.Groups[&quot;message&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out mid))
			var chn = await ctx.Client.GetChannelAsync(cid).ConfigureAwait(false);
			var msg = await chn.GetMessageAsync(mid).ConfigureAwait(false);
			return Optional.FromNullable(msg);
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out mid))
			var result = await ctx.Channel.GetMessageAsync(mid).ConfigureAwait(false);
public class DiscordScheduledEventConverter : IArgumentConverter&lt;DiscordScheduledEvent&gt;
	async Task&lt;Optional&lt;DiscordScheduledEvent&gt;&gt; IArgumentConverter&lt;DiscordScheduledEvent&gt;.ConvertAsync(string value, CommandContext ctx)
			var uripath = DiscordRegEx.EventRegex().Match(uri.AbsoluteUri);
			    &amp;&amp; ulong.TryParse(uripath.Groups[&quot;guild&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
			    &amp;&amp; ulong.TryParse(uripath.Groups[&quot;event&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
				var guild = await ctx.Client.GetGuildAsync(gid).ConfigureAwait(false);
				var ev = await guild.GetScheduledEventAsync(seid).ConfigureAwait(false);
				return Optional.FromNullable(ev);
				var invite = await ctx.CommandsNext.ConvertArgument&lt;DiscordInvite&gt;(value, ctx).ConfigureAwait(false);
				return Optional.FromNullable(invite.GuildScheduledEvent);
		if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out seid))
			var result = await ctx.Guild.GetScheduledEventAsync(seid).ConfigureAwait(false);
public class DiscordEmojiConverter : IArgumentConverter&lt;DiscordEmoji&gt;
	Task&lt;Optional&lt;DiscordEmoji&gt;&gt; IArgumentConverter&lt;DiscordEmoji&gt;.ConvertAsync(string value, CommandContext ctx)
		if (DiscordEmoji.TryFromUnicode(ctx.Client, value, out var emoji))
			return Task.FromResult(Optional.Some(result));
		var m = DiscordRegEx.EmojiRegex().Match(value);
			return !ulong.TryParse(sid, NumberStyles.Integer, CultureInfo.InvariantCulture, out var id)
				? Task.FromResult(Optional&lt;DiscordEmoji&gt;.None)
				: DiscordEmoji.TryFromGuildEmote(ctx.Client, id, out emoji)
					? Task.FromResult(Optional.Some(emoji))
					: Task.FromResult(Optional.Some(new DiscordEmoji
		return Task.FromResult(Optional&lt;DiscordEmoji&gt;.None);
public class DiscordColorConverter : IArgumentConverter&lt;DiscordColor&gt;
	Task&lt;Optional&lt;DiscordColor&gt;&gt; IArgumentConverter&lt;DiscordColor&gt;.ConvertAsync(string value, CommandContext ctx)
		var m = CommonRegEx.HexColorStringRegex().Match(value);
		if (m.Success &amp;&amp; int.TryParse(m.Groups[1].Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var clr))
			return Task.FromResult(Optional.Some&lt;DiscordColor&gt;(clr));
		m = CommonRegEx.RgbColorStringRegex().Match(value);
			var p1 = byte.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var r);
			var p2 = byte.TryParse(m.Groups[2].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var g);
			var p3 = byte.TryParse(m.Groups[3].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var b);
				? Task.FromResult(Optional&lt;DiscordColor&gt;.None)
				: Task.FromResult(Optional.Some(new DiscordColor(r, g, b)));
		return Task.FromResult(Optional&lt;DiscordColor&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/EnumConverter.cs">public class EnumConverter&lt;T&gt; : IArgumentConverter&lt;T&gt; where T : struct, IComparable, IConvertible, IFormattable
	Task&lt;Optional&lt;T&gt;&gt; IArgumentConverter&lt;T&gt;.ConvertAsync(string value, CommandContext ctx)
		var ti = t.GetTypeInfo();
			? throw new InvalidOperationException(&quot;Cannot convert non-enum value to an enum.&quot;)
			: Enum.TryParse(value, !ctx.Config.CaseSensitive, out T ev)
				? Task.FromResult(Optional.Some(ev))
				: Task.FromResult(Optional&lt;T&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/HelpFormatterFactory.cs">internal class HelpFormatterFactory
	private ObjectFactory _factory;
	public void SetFormatterType&lt;T&gt;() where T : BaseHelpFormatter =&gt; this._factory = ActivatorUtilities.CreateFactory(typeof(T), [typeof(CommandContext)]);
	public BaseHelpFormatter Create(CommandContext ctx) =&gt; this._factory(ctx.Services, [ctx]) as BaseHelpFormatter;</file><file path="DisCatSharp.CommandsNext/Converters/IArgumentConverter.cs">public interface IArgumentConverter
public interface IArgumentConverter&lt;T&gt; : IArgumentConverter
	Task&lt;Optional&lt;T&gt;&gt; ConvertAsync(string value, CommandContext ctx);</file><file path="DisCatSharp.CommandsNext/Converters/NullableConverter.cs">public class NullableConverter&lt;T&gt; : IArgumentConverter&lt;T?&gt; where T : struct
	async Task&lt;Optional&lt;T?&gt;&gt; IArgumentConverter&lt;T?&gt;.ConvertAsync(string value, CommandContext ctx)
			value = value.ToLowerInvariant();
		if (ctx.CommandsNext.ArgumentConverters.TryGetValue(typeof(T), out var cv))
			var val = await cvx.ConvertAsync(value, ctx).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Converters/NumericConverters.cs">public class BoolConverter : IArgumentConverter&lt;bool&gt;
	Task&lt;Optional&lt;bool&gt;&gt; IArgumentConverter&lt;bool&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		bool.TryParse(value, out var result)
			? Task.FromResult(Optional.Some(result))
			: Task.FromResult(Optional&lt;bool&gt;.None);
public class Int8Converter : IArgumentConverter&lt;sbyte&gt;
	Task&lt;Optional&lt;sbyte&gt;&gt; IArgumentConverter&lt;sbyte&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		sbyte.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;sbyte&gt;.None);
public class Uint8Converter : IArgumentConverter&lt;byte&gt;
	Task&lt;Optional&lt;byte&gt;&gt; IArgumentConverter&lt;byte&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		byte.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;byte&gt;.None);
public class Int16Converter : IArgumentConverter&lt;short&gt;
	Task&lt;Optional&lt;short&gt;&gt; IArgumentConverter&lt;short&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		short.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;short&gt;.None);
public class Uint16Converter : IArgumentConverter&lt;ushort&gt;
	Task&lt;Optional&lt;ushort&gt;&gt; IArgumentConverter&lt;ushort&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		ushort.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;ushort&gt;.None);
public class Int32Converter : IArgumentConverter&lt;int&gt;
	Task&lt;Optional&lt;int&gt;&gt; IArgumentConverter&lt;int&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;int&gt;.None);
public class Uint32Converter : IArgumentConverter&lt;uint&gt;
	Task&lt;Optional&lt;uint&gt;&gt; IArgumentConverter&lt;uint&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		uint.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;uint&gt;.None);
public class Int64Converter : IArgumentConverter&lt;long&gt;
	Task&lt;Optional&lt;long&gt;&gt; IArgumentConverter&lt;long&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;long&gt;.None);
public class Uint64Converter : IArgumentConverter&lt;ulong&gt;
	Task&lt;Optional&lt;ulong&gt;&gt; IArgumentConverter&lt;ulong&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;ulong&gt;.None);
public class Float32Converter : IArgumentConverter&lt;float&gt;
	Task&lt;Optional&lt;float&gt;&gt; IArgumentConverter&lt;float&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;float&gt;.None);
public class Float64Converter : IArgumentConverter&lt;double&gt;
	Task&lt;Optional&lt;double&gt;&gt; IArgumentConverter&lt;double&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;double&gt;.None);
public class Float128Converter : IArgumentConverter&lt;decimal&gt;
	Task&lt;Optional&lt;decimal&gt;&gt; IArgumentConverter&lt;decimal&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		decimal.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
			: Task.FromResult(Optional&lt;decimal&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/StringConverter.cs">public class StringConverter : IArgumentConverter&lt;string&gt;
	Task&lt;Optional&lt;string&gt;&gt; IArgumentConverter&lt;string&gt;.ConvertAsync(string value, CommandContext ctx)
		=&gt; Task.FromResult(Optional.Some(value));
public class UriConverter : IArgumentConverter&lt;Uri&gt;
	Task&lt;Optional&lt;Uri&gt;&gt; IArgumentConverter&lt;Uri&gt;.ConvertAsync(string value, CommandContext ctx)
			if (value.StartsWith(&quot;&lt;&quot;, StringComparison.Ordinal) &amp;&amp; value.EndsWith(&quot;&gt;&quot;, StringComparison.Ordinal))
			return Task.FromResult(Optional.Some(new Uri(value)));
			return Task.FromResult(Optional&lt;Uri&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/TimeConverters.cs">public sealed class DateTimeConverter : IArgumentConverter&lt;DateTime&gt;
	Task&lt;Optional&lt;DateTime&gt;&gt; IArgumentConverter&lt;DateTime&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		DateTime.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.None, out var result)
			? Task.FromResult(Optional.Some(result))
			: Task.FromResult(Optional&lt;DateTime&gt;.None);
public sealed class DateTimeOffsetConverter : IArgumentConverter&lt;DateTimeOffset&gt;
	Task&lt;Optional&lt;DateTimeOffset&gt;&gt; IArgumentConverter&lt;DateTimeOffset&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
		DateTimeOffset.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.None, out var result)
			: Task.FromResult(Optional&lt;DateTimeOffset&gt;.None);
public sealed class TimeSpanConverter : IArgumentConverter&lt;TimeSpan&gt;
	Task&lt;Optional&lt;TimeSpan&gt;&gt; IArgumentConverter&lt;TimeSpan&gt;.ConvertAsync(string value, CommandContext ctx)
			return Task.FromResult(Optional.Some(TimeSpan.Zero));
		if (int.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out _))
			return Task.FromResult(Optional&lt;TimeSpan&gt;.None);
			value = value.ToLowerInvariant();
		if (TimeSpan.TryParse(value, CultureInfo.InvariantCulture, out var result))
			return Task.FromResult(Optional.Some(result));
		var mtc = CommonRegEx.TimeSpanRegex().Match(value);
			if (string.IsNullOrWhiteSpace(gpc))
			int.TryParse(gpc[..^1], NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);</file><file path="DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.CommandsNext&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.CommandsNext&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.CommandsNext&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Commands Next Extension

			Allow your users to use text commands in your bot.

			Note: Requires the Message Content Intent enabled for your discord application.
			Documentation: https://docs.dcs.aitsys.dev/articles/modules/commandsnext/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Text Commands&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandBuilder.cs">public class CommandBuilder
	public CommandBuilder WithName(string name)
		if (name == null || name.ToCharArray().Any(xc =&gt; char.IsWhiteSpace(xc)))
			throw new ArgumentException(&quot;Command name cannot be null or contain any whitespace characters.&quot;, nameof(name));
			throw new InvalidOperationException(&quot;This command already has a name.&quot;);
		if (this._aliasList.Contains(name))
			throw new ArgumentException(&quot;Command name cannot be one of its aliases.&quot;, nameof(name));
	public CommandBuilder WithAliases(params string[] aliases)
			throw new ArgumentException(&quot;You need to pass at least one alias.&quot;, nameof(aliases));
			this.WithAlias(alias);
	public CommandBuilder WithAlias(string alias)
		if (alias.ToCharArray().Any(xc =&gt; char.IsWhiteSpace(xc)))
			throw new ArgumentException(&quot;Aliases cannot contain whitespace characters or null strings.&quot;, nameof(alias));
		if (this.Name == alias || this._aliasList.Contains(alias))
			throw new ArgumentException(&quot;Aliases cannot contain the command name, and cannot be duplicate.&quot;, nameof(alias));
		this._aliasList.Add(alias);
	public CommandBuilder WithDescription(string description)
	public CommandBuilder WithHiddenStatus(bool hidden)
	public CommandBuilder WithExecutionChecks(params CheckBaseAttribute[] checks)
		this._executionCheckList.AddRange(checks.Except(this._executionCheckList));
	public CommandBuilder WithExecutionCheck(CheckBaseAttribute check)
		if (!this._executionCheckList.Contains(check))
			this._executionCheckList.Add(check);
	public CommandBuilder WithOverloads(params CommandOverloadBuilder[] overloads)
			this.WithOverload(overload);
	public CommandBuilder WithOverload(CommandOverloadBuilder overload)
		if (this._overloadArgumentSets.Contains(overload.ArgumentSet))
			throw new DuplicateOverloadException(this.Name, overload.Arguments.Select(x =&gt; x.Type).ToList(), overload.ArgumentSet);
		this._overloadArgumentSets.Add(overload.ArgumentSet);
		this._overloadList.Add(overload);
	public CommandBuilder WithCustomAttribute(Attribute attribute)
		this._customAttributeList.Add(attribute);
	public CommandBuilder WithCustomAttributes(params Attribute[] attributes)
			this.WithCustomAttribute(attr);
	internal virtual Command Build(CommandGroup parent)
		var cmd = new Command
			Overloads = new ReadOnlyCollection&lt;CommandOverload&gt;(this.Overloads.Select(xo =&gt; xo.Build()).ToList()),</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandGroupBuilder.cs">public sealed class CommandGroupBuilder : CommandBuilder
	public CommandGroupBuilder WithChild(CommandBuilder child)
		this._childrenList.Add(child);
	internal override Command Build(CommandGroup parent)
		var cmd = new CommandGroup
			Overloads = new ReadOnlyCollection&lt;CommandOverload&gt;(this.Overloads.Select(xo =&gt; xo.Build()).ToList()),
			cs.Add(xc.Build(cmd));</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandModuleBuilder.cs">public sealed class CommandModuleBuilder
	public CommandModuleBuilder WithType(Type t)
		if (!t.IsModuleCandidateType())
			throw new ArgumentException(&quot;Specified type is not a valid module type.&quot;, nameof(t));
	public CommandModuleBuilder WithLifespan(ModuleLifespan lifespan)
	internal ICommandModule Build(IServiceProvider services) =&gt;
			ModuleLifespan.Singleton =&gt; new SingletonCommandModule(this.Type, services),
			ModuleLifespan.Transient =&gt; new TransientCommandModule(this.Type),
			_ =&gt; throw new NotSupportedException(&quot;Module lifespans other than transient and singleton are not supported.&quot;)</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandOverloadBuilder.cs">public sealed class CommandOverloadBuilder
		: this(method.GetMethodInfo(), method.Target)
		if (!method.IsCommandCandidate(out var prms))
			throw new ArgumentException(&quot;Specified method is not suitable for a command.&quot;, nameof(method));
		var iep = Expression.Parameter(target?.GetType() ?? method.DeclaringType, &quot;instance&quot;);
		ea[1] = Expression.Parameter(typeof(CommandContext), &quot;ctx&quot;);
		var setb = new StringBuilder();
		foreach (var arg in prms.Skip(1))
			setb.Append(arg.ParameterType).Append(&apos;;&apos;);
			var ca = new CommandArgument
			var attrs = arg.GetCustomAttributes();
						ca.Type = arg.ParameterType.GetElementType();
						attrsCustom.Add(xa);
				throw new InvalidOverloadException(&quot;Non-optional argument cannot appear after an optional one&quot;, method, arg);
				throw new InvalidOverloadException(&quot;Cannot use array arguments without params modifier.&quot;, method, arg);
			args.Add(ca);
			ea[i++] = Expression.Parameter(arg.ParameterType, arg.Name);
		var ec = Expression.Call(iep, method, ea.Skip(1));
		var el = Expression.Lambda(ec, ea);
		this.ArgumentSet = setb.ToString();
		this.Callable = el.Compile();
	public CommandOverloadBuilder WithPriority(int priority)
	internal CommandOverload Build()
		var ovl = new CommandOverload</file><file path="DisCatSharp.CommandsNext/Entities/Command.cs">public class Command
		=&gt; this.Parent != null ? string.Concat(this.Parent.QualifiedName, &quot; &quot;, this.Name) : this.Name;
	public virtual async Task&lt;CommandResult&gt; ExecuteAsync(CommandContext ctx)
		CommandResult res = default;
			foreach (var ovl in this.Overloads.OrderByDescending(x =&gt; x.Priority))
				var args = await CommandsNextUtilities.BindArguments(ctx, ctx.Config.IgnoreExtraArguments).ConfigureAwait(false);
					await bcmBefore.BeforeExecutionAsync(ctx).ConfigureAwait(false);
				var ret = (Task)ovl.Callable.DynamicInvoke(args.Converted);
				await ret.ConfigureAwait(false);
					await bcmAfter.AfterExecutionAsync(ctx).ConfigureAwait(false);
				throw new ArgumentException(&quot;Could not find a suitable overload for the command.&quot;);
	public async Task&lt;IEnumerable&lt;CheckBaseAttribute&gt;&gt; RunChecksAsync(CommandContext ctx, bool help)
		if (this.ExecutionChecks != null &amp;&amp; this.ExecutionChecks.Any())
				if (!await ec.ExecuteCheckAsync(ctx, help).ConfigureAwait(false))
					fchecks.Add(ec);
	public override bool Equals(object obj)
	public override int GetHashCode() =&gt; this.QualifiedName.GetHashCode();
	public override string ToString() =&gt;</file><file path="DisCatSharp.CommandsNext/Entities/CommandArgument.cs">public sealed class CommandArgument</file><file path="DisCatSharp.CommandsNext/Entities/CommandGroup.cs">public class CommandGroup : Command
	public override async Task&lt;CommandResult&gt; ExecuteAsync(CommandContext ctx)
		var cn = ctx.RawArgumentString.ExtractNextArgument(ref findPos);
				? this.Children.FirstOrDefault(xc =&gt; xc.Name == cn || (xc.Aliases != null &amp;&amp; xc.Aliases.Contains(cn)))
				: this.Children.FirstOrDefault(xc =&gt; string.Equals(xc.Name, cn, StringComparison.InvariantCultureIgnoreCase) || (xc.Aliases != null &amp;&amp; xc.Aliases.Select(xs =&gt; xs.ToLowerInvariant()).Contains(cn.ToLowerInvariant())));
				var xctx = new CommandContext
				var fchecks = await cmd.RunChecksAsync(xctx, false).ConfigureAwait(false);
				return fchecks.Any()
						Exception = new ChecksFailedException(cmd, xctx, fchecks),
					: await cmd.ExecuteAsync(xctx).ConfigureAwait(false);
				Exception = new InvalidOperationException(&quot;No matching subcommands were found, and this group is not executable.&quot;),
			: await base.ExecuteAsync(ctx).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Entities/CommandHelpMessage.cs"></file><file path="DisCatSharp.CommandsNext/Entities/CommandModule.cs">public interface ICommandModule
	BaseCommandModule GetInstance(IServiceProvider services);
public class TransientCommandModule : ICommandModule
	public BaseCommandModule GetInstance(IServiceProvider services)
		=&gt; this.ModuleType.CreateInstance(services) as BaseCommandModule;
public class SingletonCommandModule : ICommandModule
		this.Instance = t.CreateInstance(services) as BaseCommandModule;</file><file path="DisCatSharp.CommandsNext/Entities/CommandOverload.cs">public sealed class CommandOverload</file><file path="DisCatSharp.CommandsNext/Entities/CommandResult.cs"></file><file path="DisCatSharp.CommandsNext/Entities/ICooldownResponder.cs">public interface ICooldownResponder
	Task Responder(CommandContext context, CooldownBucket cooldownBucket);</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandContext.cs">public sealed class CommandContext : DisCatSharpCommandContext
		this._lazyMember = new(() =&gt; this.Guild is not null &amp;&amp; this.Guild.Members.TryGetValue(this.User.Id, out var member) ? member : this.Guild?.GetMemberAsync(this.User.Id).ConfigureAwait(false).GetAwaiter().GetResult());
	public Task&lt;DiscordMessage&gt; RespondAsync(string content)
		=&gt; this.Message.RespondAsync(content);
	public Task&lt;DiscordMessage&gt; RespondAsync(DiscordEmbed embed)
		=&gt; this.Message.RespondAsync(embed);
	public Task&lt;DiscordMessage&gt; RespondAsync(string content, DiscordEmbed embed)
		=&gt; this.Message.RespondAsync(content, embed);
	public Task&lt;DiscordMessage&gt; RespondAsync(DiscordMessageBuilder builder)
		=&gt; this.Message.RespondAsync(builder);
	public Task&lt;DiscordMessage&gt; RespondAsync(Action&lt;DiscordMessageBuilder&gt; action)
		=&gt; this.Message.RespondAsync(action);
	public Task TriggerTypingAsync()
		=&gt; this.Channel.TriggerTypingAsync();
		public void Dispose()</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandErrorEventArgs.cs">public class CommandErrorEventArgs : CommandEventArgs</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandEventArgs.cs">public class CommandEventArgs : DiscordEventArgs</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandExecutionEventArgs.cs">public class CommandExecutionEventArgs : CommandEventArgs</file><file path="DisCatSharp.CommandsNext/Exceptions/ChecksFailedException.cs">public class ChecksFailedException : Exception</file><file path="DisCatSharp.CommandsNext/Exceptions/CommandNotFoundException.cs">public sealed class CommandNotFoundException : Exception
	public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}&quot;; // much like System.ArgumentNullException works</file><file path="DisCatSharp.CommandsNext/Exceptions/DuplicateCommandException.cs">public class DuplicateCommandException : Exception
	public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}&quot;; // much like System.ArgumentException works</file><file path="DisCatSharp.CommandsNext/Exceptions/DuplicateOverloadException.cs">public class DuplicateOverloadException : Exception
	public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}\nArgument types: {this._argumentSetKey}&quot;; // much like System.ArgumentException works</file><file path="DisCatSharp.CommandsNext/Exceptions/InvalidOverloadException.cs">public sealed class InvalidOverloadException : Exception
	public override string ToString() =&gt;
			? $&quot;{this.GetType()}: {this.Message}\nMethod: {this.Method} (declared in {this.Method.DeclaringType})&quot;
			: $&quot;{this.GetType()}: {this.Message}\nMethod: {this.Method} (declared in {this.Method.DeclaringType})\nArgument: {this.Parameter.ParameterType} {this.Parameter.Name}&quot;;</file><file path="DisCatSharp.CommandsNext/ExtensionMethods.cs">public static class ExtensionMethods
	public static CommandsNextExtension UseCommandsNext(this DiscordClient client, CommandsNextConfiguration cfg)
			throw new InvalidOperationException(&quot;CommandsNext is already enabled for that client.&quot;);
		if (!Utilities.HasMessageIntents(client.Configuration.Intents))
			client.Logger.LogCritical(CommandsNextEvents.Intents, &quot;The CommandsNext extension is registered but there are no message intents enabled. It is highly recommended to enable them.&quot;);
		if (!client.Configuration.Intents.HasIntent(DiscordIntents.Guilds))
			client.Logger.LogCritical(CommandsNextEvents.Intents, &quot;The CommandsNext extension is registered but the guilds intent is not enabled. It is highly recommended to enable it.&quot;);
		cfg.ServiceProvider ??= client.ServiceProvider ?? new ServiceCollection().BuildServiceProvider(true);
		var cnext = new CommandsNextExtension(cfg);
		client.AddExtension(cnext);
	public static async Task&lt;IReadOnlyDictionary&lt;int, CommandsNextExtension&gt;&gt; UseCommandsNextAsync(this DiscordShardedClient client, CommandsNextConfiguration cfg)
		await client.InitializeShardsAsync().ConfigureAwait(false);
		foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
			cnext ??= shard.UseCommandsNext(cfg);
	public static CommandsNextExtension GetCommandsNext(this DiscordClient client)
	public static async Task&lt;IReadOnlyDictionary&lt;int, CommandsNextExtension&gt;&gt; GetCommandsNextAsync(this DiscordShardedClient client)
			extensions.Add(shard.ShardId, shard.GetExtension&lt;CommandsNextExtension&gt;());
	public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, Assembly assembly)
			extension.RegisterCommands(assembly);
	public static void RegisterCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions) where T : BaseCommandModule
	public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, Type t)
			extension.RegisterCommands(t);
	public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, params CommandBuilder[] cmds)
			extension.RegisterCommands(cmds);
	public static void UnregisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, params Command[] cmds)
			extension.UnregisterCommands(cmds);
	public static void RegisterConverter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, IArgumentConverter&lt;T&gt; converter)
			extension.RegisterConverter(converter);
	public static void UnregisterConverter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions)
	public static void RegisterUserFriendlyTypeName&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, string value)
	public static void SetHelpFormatter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions) where T : BaseHelpFormatter</file><file path="DisCatSharp.CommandsNext/GlobalSuppressions.cs"></file><file path="DisCatSharp.Common/DisCatSharp.Common.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Common&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Common&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;True&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Common&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Common Extension

			Common tools for DisCatSharp, like regexes and converters!
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Common Tools&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Maui.Graphics&quot; Version=&quot;9.0.40&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Maui.Graphics.Skia&quot; Version=&quot;9.0.40&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Collections.Immutable&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Runtime.CompilerServices.Unsafe&quot; Version=&quot;6.1.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.ValueTuple&quot; Version=&quot;4.5.0&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Common/DisCatSharp.Common.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Common/GlobalSuppressions.cs"></file><file path="DisCatSharp.Common/RegularExpressions/CommonRegEx.cs">public static partial class CommonRegEx
	public static partial Regex HexColorStringRegex();
	public static partial Regex RgbColorStringRegex();
	public static partial Regex TimeSpanRegex();
	public static partial Regex AdvancedYoutubeRegex();
	public static partial Regex MdStripRegex();
	public static partial Regex MdSanitizeRegex();
	public static partial Regex HttpRouteRegex();</file><file path="DisCatSharp.Common/RegularExpressions/DiscordRegEx.cs">public static partial class DiscordRegEx
	public static partial Regex InviteRegex();
	public static partial Regex MessageLinkRegex();
	public static partial Regex EmojiRegex();
	public static partial Regex AnimatedEmojiRegex();
	public static partial Regex StaticEmojiRegex();
	public static partial Regex TimestampRegex();
	public static partial Regex DefaultStyledTimestampRegex();
	public static partial Regex StyledTimestampRegex();
	public static partial Regex RoleRegex();
	public static partial Regex ChannelRegex();
	public static partial Regex UserRegex();
	public static partial Regex IdRegex();
	public static partial Regex UserWithNicknameRegex();
	public static partial Regex UserWithOptionalNicknameRegex();
	public static partial Regex UserWithoutNicknameRegex();
	public static partial Regex EventRegex();
	public static partial Regex ApplicationCommandNameRegex();
	public static partial Regex WebhookRegex();
	public static partial Regex SoundRegex();</file><file path="DisCatSharp.Common/Serialization/DateTimeFormatAttribute.cs">public sealed class DateTimeFormatAttribute : SerializationAttribute
			throw new ArgumentOutOfRangeException(nameof(kind), &quot;Specified format kind is not legal or supported.&quot;);
		if (string.IsNullOrWhiteSpace(format))
			throw new ArgumentNullException(nameof(format), &quot;Specified format cannot be null or empty.&quot;);</file><file path="DisCatSharp.Common/Serialization/DecomposerAttribute.cs">public sealed class DecomposerAttribute : SerializationAttribute
		if (!typeof(IDecomposer).IsAssignableFrom(type) || !type.IsClass || type.IsAbstract) // abstract covers static - static = abstract + sealed
			throw new ArgumentException(&quot;Invalid type specified. Must be a non-abstract class which implements DisCatSharp.Common.Serialization.IDecomposer interface.&quot;, nameof(type));</file><file path="DisCatSharp.Common/Serialization/EnumAttributes.cs"></file><file path="DisCatSharp.Common/Serialization/Int53Attribute.cs">public sealed class Int53Attribute : SerializationAttribute</file><file path="DisCatSharp.Common/Serialization/SerializationAttribute.cs"></file><file path="DisCatSharp.Common/Serialization/TimeSpanAttributes.cs"></file><file path="DisCatSharp.Common/Serialization/TimeSpanFormatAttribute.cs">public sealed class TimeSpanFormatAttribute : SerializationAttribute
			throw new ArgumentOutOfRangeException(nameof(kind), &quot;Specified format kind is not legal or supported.&quot;);
		if (string.IsNullOrWhiteSpace(format))
			throw new ArgumentNullException(nameof(format), &quot;Specified format cannot be null or empty.&quot;);</file><file path="DisCatSharp.Common/Serialization/UnixTimestampAttributes.cs"></file><file path="DisCatSharp.Common/Types/CharSpanLookupDictionary.cs">public sealed class CharSpanLookupDictionary&lt;TValue&gt; :
	IDictionary&lt;string, TValue?&gt;,
	IReadOnlyDictionary&lt;string, TValue?&gt;,
	IDictionary
			this.Add(k, v);
		get =&gt; !this.TryRetrieveInternal(key, out var value)
			? throw new KeyNotFoundException(&quot;The given key was not present in the dictionary.&quot;)
				fixed (char* chars = &amp;key.GetPinnableReference())
					this.TryInsertInternal(new(chars, 0, key.Length), value, true);
	ICollection IDictionary.Keys =&gt; this.GetKeysInternal();
	ICollection IDictionary.Values =&gt; this.GetValuesInternal();
			? throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;)
			: !this.TryRetrieveInternal(tkey.AsSpan(), out var value)
				? throw new KeyNotFoundException($&quot;The given key &apos;{tkey}&apos; was not present in the dictionary.&quot;)
				throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;);
					throw new ArgumentException($&quot;Value needs to be an instance of {typeof(TValue)}.&quot;);
			this.TryInsertInternal(tkey, tvalue, true);
	void IDictionary.Add(object key, object? value)
		this.Add(tkey, tvalue);
	void IDictionary.Remove(object key)
		this.TryRemove(tkey, out _);
	bool IDictionary.Contains(object key)
		=&gt; key is not string tkey ? throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;) : this.ContainsKey(tkey);
	IDictionaryEnumerator IDictionary.GetEnumerator()
		=&gt; new Enumerator(this);
	void ICollection.CopyTo(Array array, int arrayIndex)
			(this as ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;).CopyTo(tarray, arrayIndex);
			throw new ArgumentException($&quot;Array needs to be an instance of {typeof(TValue[])} or object[].&quot;);
				array.SetValue(new KeyValuePair&lt;string, TValue?&gt;(kdv.Key, kdv.Value), i++);
	ICollection&lt;string&gt; IDictionary&lt;string, TValue?&gt;.Keys =&gt; this.GetKeysInternal();
	ICollection&lt;TValue?&gt; IDictionary&lt;string, TValue?&gt;.Values =&gt; this.GetValuesInternal();
			ArgumentNullException.ThrowIfNull(key);
			return !this.TryRetrieveInternal(key.AsSpan(), out var value)
				? throw new KeyNotFoundException($&quot;The given key &apos;{key}&apos; was not present in the dictionary.&quot;)
			this.TryInsertInternal(key, value, true);
	public void Add(string key, TValue? value)
		if (!this.TryInsertInternal(key, value, false))
			throw new ArgumentException(&quot;Given key is already present in the dictionary.&quot;, nameof(key));
	public bool TryGetValue(string key, out TValue? value)
		return this.TryRetrieveInternal(key.AsSpan(), out value);
	public bool ContainsKey(string key)
		=&gt; this.ContainsKeyInternal(key.AsSpan());
	public void Clear()
		this._internalBuckets.Clear();
	public IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt; GetEnumerator()
		=&gt; new Enumerator(this!);
	bool IDictionary&lt;string, TValue?&gt;.Remove(string key)
		=&gt; this.TryRemove(key.AsSpan(), out _);
	void ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Add(KeyValuePair&lt;string, TValue?&gt; item)
		=&gt; this.Add(item.Key, item.Value);
	bool ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Remove(KeyValuePair&lt;string, TValue?&gt; item)
		=&gt; this.TryRemove(item.Key, out _);
	bool ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Contains(KeyValuePair&lt;string, TValue?&gt; item)
		=&gt; this.TryGetValue(item.Key, out var value) &amp;&amp; EqualityComparer&lt;TValue?&gt;.Default.Equals(value, item.Value);
	void ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.CopyTo(KeyValuePair&lt;string, TValue?&gt;[] array, int arrayIndex)
			throw new ArgumentException(&quot;Target array is too small.&quot;, nameof(array));
	IEnumerator IEnumerable.GetEnumerator()
		=&gt; this.GetEnumerator();
	public IEnumerable&lt;string&gt; Keys =&gt; this.GetKeysInternal();
	public IEnumerable&lt;TValue?&gt; Values =&gt; this.GetValuesInternal();
	public void Add(ReadOnlySpan&lt;char&gt; key, TValue? value)
				if (!this.TryInsertInternal(new(chars, 0, key.Length), value, false))
	public bool TryAdd(string key, TValue? value)
		=&gt; this.TryInsertInternal(key, value, false);
	public bool TryAdd(ReadOnlySpan&lt;char&gt; key, TValue? value)
				return this.TryInsertInternal(new(chars, 0, key.Length), value, false);
	public bool TryGetValue(ReadOnlySpan&lt;char&gt; key, out TValue? value)
		=&gt; this.TryRetrieveInternal(key, out value);
	public bool TryRemove(string key, out TValue? value)
		return this.TryRemoveInternal(key.AsSpan(), out value);
	public bool TryRemove(ReadOnlySpan&lt;char&gt; key, out TValue? value)
		=&gt; this.TryRemoveInternal(key, out value);
	public bool ContainsKey(ReadOnlySpan&lt;char&gt; key)
		=&gt; this.ContainsKeyInternal(key);
	private bool TryInsertInternal(string key, TValue? value, bool replace)
			throw new ArgumentNullException(nameof(key), &quot;Key cannot be null.&quot;);
		var hash = key.CalculateKnuthHash();
		if (!this._internalBuckets.ContainsKey(hash))
			this._internalBuckets.Add(hash, new(key, hash, value));
	private bool TryRetrieveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
		if (!this._internalBuckets.TryGetValue(hash, out var kdv))
			if (key.SequenceEqual(kdv.Key.AsSpan()))
	private bool TryRemoveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
			case null when key.SequenceEqual(kdv.Key.AsSpan()):
				this._internalBuckets.Remove(hash);
	private bool ContainsKeyInternal(ReadOnlySpan&lt;char&gt; key)
	private ImmutableArray&lt;string&gt; GetKeysInternal()
				builder.Add(kdv.Key);
		return builder.MoveToImmutable();
	private ImmutableArray&lt;TValue?&gt; GetValuesInternal()
				builder.Add(kdv.Value);
	private sealed class Enumerator :
		IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt;,
		IDictionaryEnumerator
			this._internalEnumerator = this._internalDictionary._internalBuckets.GetEnumerator();
		public bool MoveNext()
				if (!this._internalEnumerator.MoveNext())
		public void Reset()
			this._internalEnumerator.Reset();
		public void Dispose() =&gt; this.Reset();</file><file path="DisCatSharp.Common/Types/CharSpanLookupReadOnlyDictionary.cs">public sealed class CharSpanLookupReadOnlyDictionary&lt;TValue&gt; : IReadOnlyDictionary&lt;string, TValue?&gt;
		ArgumentNullException.ThrowIfNull(values);
		=&gt; !this.TryRetrieveInternal(key, out var value)
			? throw new KeyNotFoundException(&quot;The given key was not present in the dictionary.&quot;)
	public IEnumerable&lt;string&gt; Keys =&gt; this.GetKeysInternal();
	public IEnumerable&lt;TValue?&gt; Values =&gt; this.GetValuesInternal();
			ArgumentNullException.ThrowIfNull(key);
			return !this.TryRetrieveInternal(key.AsSpan(), out var value)
				? throw new KeyNotFoundException($&quot;The given key &apos;{key}&apos; was not present in the dictionary.&quot;)
	public bool TryGetValue(string key, out TValue? value)
		return this.TryRetrieveInternal(key.AsSpan(), out value);
	public bool ContainsKey(string key)
		=&gt; this.ContainsKeyInternal(key.AsSpan());
	public IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt; GetEnumerator()
		=&gt; new Enumerator(this!);
	IEnumerator IEnumerable.GetEnumerator()
		=&gt; this.GetEnumerator();
	public bool TryGetValue(ReadOnlySpan&lt;char&gt; key, out TValue? value)
		=&gt; this.TryRetrieveInternal(key, out value);
	public bool ContainsKey(ReadOnlySpan&lt;char&gt; key)
		=&gt; this.ContainsKeyInternal(key);
	private bool TryRetrieveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
		var hash = key.CalculateKnuthHash();
		if (!this._internalBuckets.TryGetValue(hash, out var kdv))
			if (key.SequenceEqual(kdv.Key.AsSpan()))
	private bool ContainsKeyInternal(ReadOnlySpan&lt;char&gt; key)
	private ImmutableArray&lt;string&gt; GetKeysInternal()
				builder.Add(kdv.Key);
		return builder.MoveToImmutable();
	private ImmutableArray&lt;TValue?&gt; GetValuesInternal()
				builder.Add(kdv.Value);
	private static ReadOnlyDictionary&lt;ulong, KeyedValue?&gt; PrepareItems(IEnumerable&lt;KeyValuePair&lt;string, TValue?&gt;&gt; items, out int count)
				throw new ArgumentException(&quot;Keys cannot be null.&quot;, nameof(items));
			var hash = k.CalculateKnuthHash();
			if (!dict.ContainsKey(hash))
				dict.Add(hash, new(k, hash, v));
					throw new ArgumentException(&quot;Given key is already present in the dictionary.&quot;, nameof(items));
	private sealed class Enumerator : IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt;
			this._internalEnumerator = this._internalDictionary._internalBuckets.GetEnumerator();
		public bool MoveNext()
				if (!this._internalEnumerator.MoveNext())
		public void Reset()
			this._internalEnumerator.Reset();
			this._internalEnumerator.Dispose();
		public void Dispose()
			=&gt; this.Reset();</file><file path="DisCatSharp.Common/Types/ContinuousMemoryBuffer.cs">public sealed class ContinuousMemoryBuffer&lt;T&gt; : IMemoryBuffer&lt;T&gt; where T : unmanaged
		this._buffOwner = this._pool.Rent(initialSize);
	public void Write(ReadOnlySpan&lt;T&gt; data)
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
		var bytes = MemoryMarshal.AsBytes(data);
		this.EnsureSize(this._pos + bytes.Length);
		bytes.CopyTo(this._buff[this._pos..].Span);
	public void Write(T[] data, int start, int count)
		=&gt; this.Write(data.AsSpan(start, count));
	public void Write(ArraySegment&lt;T&gt; data)
		=&gt; this.Write(data.AsSpan());
	public void Write(Stream stream)
			this.WriteStreamSeekable(stream);
			this.WriteStreamUnseekable(stream);
	public bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten)
			throw new ArgumentOutOfRangeException(nameof(source), &quot;Cannot copy data from beyond the buffer.&quot;);
		var dbuff = MemoryMarshal.AsBytes(destination);
		sbuff.CopyTo(dbuff);
	public bool Read(T[] data, int start, int count, ulong source, out int itemsWritten)
		=&gt; this.Read(data.AsSpan(start, count), source, out itemsWritten);
	public bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten)
		=&gt; this.Read(data.AsSpan(), source, out itemsWritten);
	public T[] ToArray()
		return MemoryMarshal.Cast&lt;byte, T&gt;(this._buff[..this._pos].Span).ToArray();
	public void CopyTo(Stream destination)
		var buff = this._buff[..this._pos].ToArray();
		destination.Write(buff, 0, buff.Length);
	public void Clear()
	public void Dispose()
			this._buff.Span.Clear();
		this._buffOwner.Dispose();
	private void WriteStreamSeekable(Stream stream)
			throw new ArgumentException(&quot;Stream is too long.&quot;, nameof(stream));
		this.EnsureSize(this._pos + (int)stream.Length);
		var memo = ArrayPool&lt;byte&gt;.Shared.Rent((int)stream.Length);
			var br = stream.Read(memo, 0, memo.Length);
			memo.AsSpan(0, br).CopyTo(this._buff[this._pos..].Span);
			ArrayPool&lt;byte&gt;.Shared.Return(memo);
	private void WriteStreamUnseekable(Stream stream)
		var memo = ArrayPool&lt;byte&gt;.Shared.Rent(4096);
			while ((br = stream.Read(memo, 0, memo.Length)) != 0)
				this.EnsureSize(this._pos + br);
	private void EnsureSize(int newCapacity)
		var newBuffOwner = this._pool.Rent(newActualCapacity);
		this._buff.Span.CopyTo(newBuff.Span);</file><file path="DisCatSharp.Common/Types/IMemoryBuffer.cs">public interface IMemoryBuffer&lt;T&gt; : IDisposable where T : unmanaged
	void Write(ReadOnlySpan&lt;T&gt; data);
	void Write(T[] data, int start, int count);
	void Write(ArraySegment&lt;T&gt; data);
	void Write(Stream stream);
	bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten);
	bool Read(T[] data, int start, int count, ulong source, out int itemsWritten);
	bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten);
	T[] ToArray();
	void CopyTo(Stream destination);
	void Clear();</file><file path="DisCatSharp.Common/Types/LinqMethods.cs">public static class LinqMethods
	public static bool TryGetFirstValueWhere&lt;TSource&gt;(this List&lt;TSource?&gt;? list, Func&lt;TSource?, bool&gt; predicate, [NotNullWhen(true)] out TSource? value)
		ArgumentNullException.ThrowIfNull(predicate);
		if (list.EmptyOrNull())
		value = list.Where(predicate).FirstOrDefault();
	public static bool TryGetFirstValueByKey&lt;TKey, TValue&gt;(this Dictionary&lt;TKey, TValue?&gt;? dict, TKey key, [NotNullWhen(true)] out TValue? value)
		where TKey : notnull
			return dict.TryGetValue(key, out value);</file><file path="DisCatSharp.Common/Types/MemoryBuffer.cs">public sealed class MemoryBuffer&lt;T&gt; : IMemoryBuffer&lt;T&gt; where T : unmanaged
			throw new ArgumentException(&quot;Segment size must match size of individual item.&quot;);
		this._segments = Enumerable.Range(0, initialSegmentCount)
			.Select(x =&gt; this._pool.Rent(this._segmentSize))
			.ToList();
		this._segments.Aggregate(0UL, (a, x) =&gt; a + (ulong)x.Memory.Length); // .Sum() does only int
	public void Write(ReadOnlySpan&lt;T&gt; data)
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
		var src = MemoryMarshal.AsBytes(data);
		this.Grow(src.Length);
			src[..avs].CopyTo(dmem.Span);
	public void Write(T[] data, int start, int count)
		=&gt; this.Write(data.AsSpan(start, count));
	public void Write(ArraySegment&lt;T&gt; data)
		=&gt; this.Write(data.AsSpan());
	public void Write(Stream stream)
			this.WriteStreamSeekable(stream);
			this.WriteStreamUnseekable(stream);
	public bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten)
			throw new ArgumentOutOfRangeException(nameof(source), &quot;Cannot copy data from beyond the buffer.&quot;);
		var dst = MemoryMarshal.AsBytes(destination);
			src.CopyTo(dst);
	public bool Read(T[] data, int start, int count, ulong source, out int itemsWritten)
		=&gt; this.Read(data.AsSpan(start, count), source, out itemsWritten);
	public bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten)
		=&gt; this.Read(data.AsSpan(), source, out itemsWritten);
	public T[] ToArray()
		this.Read(bytes, 0, out _);
	public void CopyTo(Stream destination)
		var longest = this._segments.Max(x =&gt; x.Memory.Length);
			var spn = buff.AsSpan(0, mem.Length);
			mem.CopyTo(spn);
			destination.Write(buff, 0, spn.Length);
	public void Clear()
	public void Dispose()
				segment.Memory.Span.Clear();
			segment.Dispose();
	private void WriteStreamSeekable(Stream stream)
		this.Grow(len);
			_ = stream.Read(buff, 0, slen);
			buff.AsSpan(0, slen).CopyTo(dmem.Span);
	private void WriteStreamUnseekable(Stream stream)
		var buffs = buff.AsSpan();
		while ((read = stream.Read(buff, 0, buff.Length - this._lastSegmentLength)) != 0)
			this.Write(MemoryMarshal.Cast&lt;byte, T&gt;(buffs[..read]));
	private void Grow(int minAmount)
			this._segments.Add(this._pool.Rent(this._segmentSize));</file><file path="DisCatSharp.Common/Types/SecureRandom.cs">public sealed class SecureRandom : Random, IDisposable
	private readonly RandomNumberGenerator _rng = RandomNumberGenerator.Create();
	public void Dispose()
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
		this._rng.Dispose();
		GC.SuppressFinalize(this);
		this.Dispose();
	public void GetBytes(byte[] buffer) =&gt; this._rng.GetBytes(buffer);
	public void GetNonZeroBytes(byte[] buffer) =&gt; this._rng.GetNonZeroBytes(buffer);
	public void GetBytes(Span&lt;byte&gt; buffer)
		var buff = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length);
			var buffSpan = buff.AsSpan(0, buffer.Length);
			this._rng.GetBytes(buff);
			buffSpan.CopyTo(buffer);
			ArrayPool&lt;byte&gt;.Shared.Return(buff);
	public void GetNonZeroBytes(Span&lt;byte&gt; buffer)
			this._rng.GetNonZeroBytes(buff);
	public sbyte GetInt8(sbyte min = 0, sbyte max = sbyte.MaxValue)
			throw new ArgumentException(&quot;Maximum needs to be greater than minimum.&quot;, nameof(max));
		return (sbyte)((Math.Abs(this.Generate&lt;sbyte&gt;()) % (max - min)) + min - offset);
	public byte GetUInt8(byte min = 0, byte max = byte.MaxValue)
			? throw new ArgumentException(&quot;Maximum needs to be greater than minimum.&quot;, nameof(max))
	public short GetInt16(short min = 0, short max = short.MaxValue)
		return (short)((Math.Abs(this.Generate&lt;short&gt;()) % (max - min)) + min - offset);
	public ushort GetUInt16(ushort min = 0, ushort max = ushort.MaxValue)
	public int GetInt32(int min = 0, int max = int.MaxValue)
		return (Math.Abs(this.Generate&lt;int&gt;()) % (max - min)) + min - offset;
	public uint GetUInt32(uint min = 0, uint max = uint.MaxValue)
	public long GetInt64(long min = 0, long max = long.MaxValue)
		return (Math.Abs(this.Generate&lt;long&gt;()) % (max - min)) + min - offset;
	public ulong GetUInt64(ulong min = 0, ulong max = ulong.MaxValue)
	public float GetSingle()
		var (i1, i2) = ((float)this.GetInt32(), (float)this.GetInt32());
	public double GetDouble()
		var (i1, i2) = ((double)this.GetInt64(), (double)this.GetInt64());
	public override int Next()
		=&gt; this.GetInt32();
	public override int Next(int maxValue)
		=&gt; this.GetInt32(0, maxValue);
	public override int Next(int minValue, int maxValue)
		=&gt; this.GetInt32(minValue, maxValue);
	public override double NextDouble()
		=&gt; this.GetDouble();
	public override void NextBytes(byte[] buffer)
		=&gt; this.GetBytes(buffer);
	public new void NextBytes(Span&lt;byte&gt; buffer)
	protected override double Sample()
	private T Generate&lt;T&gt;() where T : struct
		this.GetBytes(buff);</file><file path="DisCatSharp.Common/Types/Serialization/ComplexDecomposer.cs">public sealed class ComplexDecomposer : IDecomposer
	public bool CanDecompose(Type t)
	public bool CanRecompose(Type t)
		   || s_doubleEnumerable.IsAssignableFrom(t)
		   || s_objectEnumerable.IsAssignableFrom(t);
	public bool TryDecompose(object obj, Type tobj, out object? decomposed, out Type tdecomposed)
	public bool TryRecompose(object obj, Type tobj, Type trecomposed, out object? recomposed)
		if (s_doubleEnumerable.IsAssignableFrom(tobj) &amp;&amp; obj is IEnumerable&lt;double&gt; ied)
			if (!ied.TryFirstTwo(out var values))
			recomposed = new Complex(real, imag);
		if (s_objectEnumerable.IsAssignableFrom(tobj) &amp;&amp; obj is IEnumerable&lt;object&gt; ieo)
			if (!ieo.TryFirstTwo(out var values))
			recomposed = new Complex(dreal, dimag);</file><file path="DisCatSharp.Common/Types/Serialization/IDecomposer.cs">public interface IDecomposer
	bool CanDecompose(Type t);
	bool CanRecompose(Type t);
	bool TryDecompose(object obj, Type tobj, out object? decomposed, out Type tdecomposed);
	bool TryRecompose(object obj, Type tobj, Type trecomposed, out object? recomposed);</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEvent.cs">public abstract class AsyncEvent
public sealed class AsyncEvent&lt;TSender, TArgs&gt;(string name, TimeSpan maxExecutionTime, AsyncEventExceptionHandler&lt;TSender, TArgs&gt;? exceptionHandler) : AsyncEvent(name)
	where TArgs : AsyncEventArgs
	private readonly Lock _lock = new();
	public void Register(AsyncEventHandler&lt;TSender, TArgs&gt; handler)
		ArgumentNullException.ThrowIfNull(handler);
			this._handlers = this._handlers.Add(handler);
	public void Unregister(AsyncEventHandler&lt;TSender, TArgs&gt; handler)
			this._handlers = this._handlers.Remove(handler);
	public void UnregisterAll() =&gt; this._handlers = [];
	public async Task InvokeAsync(TSender sender, TArgs e, AsyncEventExceptionMode exceptionMode = AsyncEventExceptionMode.Default)
		var timeout = this.MaximumExecutionTime &gt; TimeSpan.Zero ? Task.Delay(this.MaximumExecutionTime) : null;
					var result = await Task.WhenAny(timeout, handlerTask).ConfigureAwait(false);
							this.HandleException(timeoutEx, handler, sender, e);
							exceptions.Add(timeoutEx);
						await handlerTask.ConfigureAwait(false);
					this.HandleException(ex, handler, sender, e);
					exceptions.Add(ex);
			throw new AggregateException(&quot;Exceptions were thrown during execution of the event&apos;s handlers.&quot;, exceptions);
	private void HandleException(Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs args)</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventArgs.cs">public class AsyncEventArgs : EventArgs</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionHandler.cs">	where TArgs : AsyncEventArgs;</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionMode.cs"></file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventHandler.cs">public delegate Task AsyncEventHandler&lt;in TSender, in TArgs&gt;(TSender sender, TArgs e) where TArgs : AsyncEventArgs;</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventTimeoutException.cs">public abstract class AsyncEventTimeoutException : Exception
	where TArgs : AsyncEventArgs
	public new AsyncEvent&lt;TSender, TArgs&gt; Event =&gt; base.Event as AsyncEvent&lt;TSender, TArgs&gt; ?? throw new NullReferenceException();
	public new AsyncEventHandler&lt;TSender, TArgs&gt; Handler =&gt; base.Handler as AsyncEventHandler&lt;TSender, TArgs&gt; ?? throw new NullReferenceException();</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncManualResetEvent.cs">internal class AsyncManualResetEvent
		if (initialState) this._tsc.TrySetResult(true);
	public Task WaitAsync() =&gt; this._tsc.Task;
	public Task SetAsync() =&gt; Task.Run(() =&gt; this._tsc.TrySetResult(true));
	public void Reset()
			if (!tsc.Task.IsCompleted || Interlocked.CompareExchange(ref this._tsc, new(), tsc) == tsc)</file><file path="DisCatSharp.Common/Utilities/AsyncExecutor.cs">public class AsyncExecutor
	public void Execute(Task task)
		task.ContinueWith(TaskCompletionHandler!, taskState);
		taskState.Lock.WaitOne();
				throw new NullReferenceException();
				stateRef.Exception = new TaskCanceledException(t);
			stateRef.Lock.Set();
	public T? Execute&lt;T&gt;(Task&lt;T&gt; task)
	private sealed class StateRef&lt;T&gt;(AutoResetEvent @lock)</file><file path="DisCatSharp.Common/Utilities/AsyncManualResetEvent.cs">public sealed class AsyncManualResetEvent
			this._resetTcs.TrySetResult(initialState);
	public Task SetAsync()
		=&gt; Task.Run(() =&gt; this._resetTcs.TrySetResult(true));
	public Task WaitAsync()
	public void Reset()
			if (!tcs.Task.IsCompleted || Interlocked.CompareExchange(ref this._resetTcs, new(), tcs) == tcs)</file><file path="DisCatSharp.Common/Utilities/EnsureObjectStates.cs">public static class EnsureObjectStates
	public static bool EmptyOrNull&lt;T1, T2&gt;([NotNullWhen(false)] this Dictionary&lt;T1, T2?&gt;? dictionary) where T1 : notnull
	public static bool NotEmptyAndNotNull&lt;T1, T2&gt;([NotNullWhen(true)] this Dictionary&lt;T1, T2?&gt;? dictionary) where T1 : notnull
	public static bool EmptyOrNull&lt;T&gt;([NotNullWhen(false)] this List&lt;T?&gt;? list)
	public static bool NotEmptyAndNotNull&lt;T&gt;([NotNullWhen(true)] this List&lt;T?&gt;? list)
	public static bool Empty&lt;T1, T2&gt;(this Dictionary&lt;T1, T2?&gt; dictionary) where T1 : notnull
	public static bool NotEmpty&lt;T1, T2&gt;(this Dictionary&lt;T1, T2?&gt; dictionary) where T1 : notnull
	public static bool Empty&lt;T&gt;(this List&lt;T&gt; list) where T : notnull
	public static bool NotEmpty&lt;T&gt;(this List&lt;T&gt; list) where T : notnull</file><file path="DisCatSharp.Common/Utilities/Extensions.cs">public static class Extensions
	public static void Deconstruct&lt;TKey, TValue&gt;(this KeyValuePair&lt;TKey, TValue&gt; kvp, out TKey key, out TValue value)
	public static int CalculateLength(this sbyte num)
		=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == sbyte.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
	public static int CalculateLength(this byte num)
		=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(num)) + 1;
	public static int CalculateLength(this short num)
		=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == short.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
	public static int CalculateLength(this ushort num)
	public static int CalculateLength(this int num)
		=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == int.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
	public static int CalculateLength(this uint num)
	public static int CalculateLength(this long num)
		=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == long.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
	public static int CalculateLength(this ulong num)
	public static bool IsInRange(this sbyte num, sbyte min, sbyte max, bool inclusive = true)
	public static bool IsInRange(this byte num, byte min, byte max, bool inclusive = true)
	public static bool IsInRange(this short num, short min, short max, bool inclusive = true)
	public static bool IsInRange(this ushort num, ushort min, ushort max, bool inclusive = true)
	public static bool IsInRange(this int num, int min, int max, bool inclusive = true)
	public static bool IsInRange(this uint num, uint min, uint max, bool inclusive = true)
	public static bool IsInRange(this long num, long min, long max, bool inclusive = true)
	public static bool IsInRange(this ulong num, ulong min, ulong max, bool inclusive = true)
	public static bool IsInRange(this float num, float min, float max, bool inclusive = true)
	public static bool IsInRange(this double num, double min, double max, bool inclusive = true)
	public static bool IsBasicAlphanumeric(this char c)
	public static bool IsBasicDigit(this char c)
	public static bool IsBasicLetter(this char c)
	public static bool EndsWithCharacter(this string s, char c)
	public static bool StartsWithCharacter(this string s, char c)
	public static ulong CalculateKnuthHash(this ReadOnlySpan&lt;char&gt; chars)
	public static ulong CalculateKnuthHash(this Span&lt;char&gt; chars)
	public static ulong CalculateKnuthHash(this ReadOnlyMemory&lt;char&gt; chars)
	public static ulong CalculateKnuthHash(this Memory&lt;char&gt; chars)
	public static ulong CalculateKnuthHash(this ArraySegment&lt;char&gt; chars)
		=&gt; Knuth(chars.AsSpan());
	public static ulong CalculateKnuthHash(this char[] chars)
	public static ulong CalculateKnuthHash(this char[] chars, int start, int count)
		=&gt; Knuth(chars.AsSpan(start, count));
	public static ulong CalculateKnuthHash(this string chars)
	public static ulong CalculateKnuthHash(this string chars, int start, int count)
	public static bool TryFirstTwo&lt;T&gt;(this IEnumerable&lt;T&gt; enumerable, out (T first, T second) values)
		using var enumerator = enumerable.GetEnumerator();
		if (!enumerator.MoveNext())
	private static ulong Knuth(ReadOnlySpan&lt;char&gt; chars)
	public static bool RemoveFirst&lt;T&gt;(this IList&lt;T&gt; list, Predicate&lt;T&gt; predicate)
				list.RemoveAt(i);
	public static void Populate&lt;T&gt;(this T[] arr, T value)
	public static string Base64Encode(this string text)
		ArgumentNullException.ThrowIfNull(text, nameof(text));
		var textBytes = Encoding.UTF8.GetBytes(text);
		return Convert.ToBase64String(textBytes);
	public static string Base64Decode(this string base64)
		ArgumentNullException.ThrowIfNull(base64, nameof(base64));
		base64 = WebUtility.UrlDecode(base64).Trim();
		base64 = base64.Replace(&apos;-&apos;, &apos;+&apos;).Replace(&apos;_&apos;, &apos;/&apos;);
			base64 = base64.TrimEnd(&apos;=&apos;);
		var base64Bytes = Convert.FromBase64String(base64);
		return Encoding.UTF8.GetString(base64Bytes);
	public static async Task&lt;string&gt; GenerateStringFromStream(this Stream inputStream)
		ArgumentNullException.ThrowIfNull(inputStream, nameof(inputStream));
		using var reader = new StreamReader(inputStream, Encoding.UTF8);
		return await reader.ReadToEndAsync().ConfigureAwait(false);
	public static async Task&lt;MemoryStream&gt; GenerateStreamFromString(this string inputString)
		ArgumentNullException.ThrowIfNull(inputString, nameof(inputString));
		var stream = new MemoryStream();
		await using var writer = new StreamWriter(stream);
		await writer.WriteAsync(inputString).ConfigureAwait(false);
		await writer.FlushAsync().ConfigureAwait(false);</file><file path="DisCatSharp.Common/Utilities/ReflectionUtilities.cs">public static class ReflectionUtilities
	public static object CreateEmpty(this Type t)
		=&gt; RuntimeHelpers.GetUninitializedObject(t);
	public static T CreateEmpty&lt;T&gt;()
		=&gt; (T)RuntimeHelpers.GetUninitializedObject(typeof(T));
	public static IReadOnlyDictionary&lt;string, object?&gt; ToDictionary&lt;T&gt;(this T obj)
			? throw new NullReferenceException()
			: (IReadOnlyDictionary&lt;string, object?&gt;)new CharSpanLookupReadOnlyDictionary&lt;object?&gt;(typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
				.Select(x =&gt; new KeyValuePair&lt;string, object?&gt;(x.Name, x.GetValue(obj))));</file><file path="DisCatSharp.Common/Utilities/RuntimeInformation.cs">public static class RuntimeInformation
		var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
		var mscorlib = loadedAssemblies.Select(x =&gt; new
				AssemblyName = x.GetName()
			.FirstOrDefault(x =&gt; x.AssemblyName.Name is &quot;mscorlib&quot; or &quot;System.Private.CoreLib&quot;);
		var assemblyFile = new FileInfo(location);
			var versionFile = new FileInfo(Path.Combine(assemblyFile.Directory.FullName, &quot;.version&quot;));
				var lines = File.ReadAllLines(versionFile.FullName, new UTF8Encoding(false));
			if (!string.IsNullOrWhiteSpace(infVersionString))
				Version = infVersionString.Split(&apos; &apos;).First();</file><file path="DisCatSharp.Common/Utilities/WaveformConverter.cs">public sealed class WaveformConverter : JsonConverter&lt;byte[]?&gt;
	public override void WriteJson(JsonWriter writer, byte[]? value, JsonSerializer serializer)
			writer.WriteValue(Convert.ToBase64String(value));
			writer.WriteNull();
	public override byte[]? ReadJson(JsonReader reader, Type objectType, byte[]? existingValue, bool hasExistingValue, JsonSerializer serializer)
			return Convert.FromBase64String(base64String);</file><file path="DisCatSharp.Common/Utilities/WaveformVisualizer.cs">public sealed class WaveformVisualizer
	private readonly Color _defaultBackgroundColor = Colors.Black;
	private static byte[] DecodeWaveform(string base64Waveform)
		=&gt; Convert.FromBase64String(base64Waveform);
	public WaveformVisualizer WithWaveformByteData(byte[] waveformByteData)
	public WaveformVisualizer WithWaveformData(string base64Waveform)
	public WaveformVisualizer CreateWaveformImage(int width = 500, int height = 100)
		ArgumentNullException.ThrowIfNull(this.WAVEFORM_BYTE_DATA, nameof(this.WithWaveformByteData));
			throw new ArgumentException(&quot;Waveform data is empty.&quot;, nameof(this.WithWaveformByteData));
		var image = new PlatformBitmapExportService().CreateContext(width, height);
		canvas.FillRectangle(0, 0, width, height);
			.Select((color, index) =&gt; new PaintGradientStop((float)index / (this._defaultColors.Length - 1), color))
			.ToArray();
		var gradient = new LinearGradientPaint(gradientStops, new PointF(0, 0), new PointF(0, height));
		canvas.SetFillPaint(gradient, new(0, 0, width, height));
			var barHeight = Math.Max(2, this.WAVEFORM_BYTE_DATA[i] * yScale);
			canvas.FillRoundedRectangle(x1, y1, barWidth, barHeight * 2, barWidth / 4);
			canvas.SetShadow(new(2, 2), 5, this._defaultBackgroundColor.WithAlpha(0.5f));
	public WaveformVisualizer CreateColorfulWaveformImage(int width = 500, int height = 100, Color? backgroundColor = null, params Color[]? barColors)
			var gradient = new LinearGradientPaint(gradientStops, new PointF(x1, y1), new PointF(x1, y2));
			canvas.SetFillPaint(gradient, new(x1, y1, barWidth, barHeight * 2));
			canvas.SetShadow(new(2, 2), 5, backgroundColor.WithAlpha(0.5f));
	public async Task&lt;WaveformVisualizer&gt; SaveImageAsync(string filePath)
		ArgumentNullException.ThrowIfNull(this.Image, nameof(this.Image));
		await using var stream = File.OpenWrite(filePath);
		await this.Image.SaveAsync(stream);
	public Stream AsStream(ImageFormat format = ImageFormat.Png)
			? this.Image.AsStream(format)
			: throw new NullReferenceException(&quot;Image was null, did you even generate a waveform image?&quot;);</file><file path="DisCatSharp.Configuration/ConfigurationExtensions.cs">internal static class ConfigurationExtensions
	public static string ConfigPath(this IConfiguration config, params string[] values) =&gt; string.Join(&quot;:&quot;, values);
	private static void HydrateInstance(ref object config, ConfigSection section)
		var props = config.GetType().GetProperties();
			var entry = section.GetValue(prop.Name);
				if (!string.IsNullOrEmpty(entry))
					prop.SetValue(config, entry);
			if (typeof(IEnumerable).IsAssignableFrom(prop.PropertyType) &amp;&amp; prop.PropertyType != typeof(string))
				if (string.IsNullOrEmpty(entry))
					var subSection = section.Config.GetSection(section.GetPath(prop.Name));
					if (subSection.Exists())
						value = subSection.Get(prop.PropertyType);
					value = JsonConvert.DeserializeObject(entry, prop.PropertyType);
					prop.SetValue(config, value);
				if (Nullable.GetUnderlyingType(targetType) != null)
					targetType = Nullable.GetUnderlyingType(targetType);
					value = Convert.ChangeType(entry, targetType);
					value = Enum.Parse(targetType, entry.Replace(&apos;|&apos;, &apos;,&apos;));
					value = TimeSpan.Parse(entry);
					value = DateTime.Parse(entry);
					value = DateTimeOffset.Parse(entry);
					throw new NotSupportedException($&quot;Type &apos;{targetType.Name}&apos; is not supported.&quot;);
				Console.Error.WriteLine(
					$&quot;Unable to convert value of &apos;{entry}&apos; to type &apos;{prop.PropertyType.Name}&apos; for property &apos;{prop.Name}&apos; in config &apos;{config.GetType().Name}&apos;:\n\t\t{ex.Message}&quot;);
	public static object ExtractConfig(this ConfigSection section, Func&lt;object&gt; factory)
			throw new ArgumentNullException(nameof(factory), FACTORY_ERROR_MESSAGE);
	public static object ExtractConfig(
	public static TConfig ExtractConfig&lt;TConfig&gt;(this IConfiguration config, IServiceProvider serviceProvider, string sectionName, string? rootSectionName = DEFAULT_ROOT_LIB)
		where TConfig : new()
		var configInstance = ActivatorUtilities.CreateInstance(serviceProvider, typeof(TConfig));
	public static TConfig ExtractConfig&lt;TConfig&gt;(this IConfiguration config, string sectionName, string? rootSectionName = DEFAULT_ROOT_LIB)
		object configInstance = new TConfig();
	public static bool HasSection(this IConfiguration config, params string?[] values)
			return config.GetChildren().Any(x =&gt; x.Key == values[0]);
		if (config.GetChildren().All(x =&gt; x.Key != values[0]))
		var current = config.GetSection(values[0]);
			if (current.GetChildren().All(x =&gt; x.Key != values[i]))
			current = current.GetSection(values[i]);
		return current.GetChildren().Any(x =&gt; x.Key == values[^1]);
	public static DiscordClient BuildClient(
		var section = config.HasSection(botSectionName, &quot;Discord&quot;)
			: config.HasSection(botSectionName, $&quot;Discord{CONFIG_SUFFIX}&quot;)
		return string.IsNullOrEmpty(section)
			: new DiscordClient(config.ExtractConfig&lt;DiscordConfiguration&gt;(serviceProvider, section, botSectionName));</file><file path="DisCatSharp.Configuration/DisCatSharp.Configuration.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;RootNamespace&gt;DisCatSharp.Configuration&lt;/RootNamespace&gt;
		&lt;AssemblyName&gt;DisCatSharp.Configuration&lt;/AssemblyName&gt;
		&lt;GenerateDocumentationFile&gt;True&lt;/GenerateDocumentationFile&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Configuration&lt;/PackageId&gt;
		&lt;Description&gt;Configuration for the DisCatSharp Hosting Extension.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Hosting,Web,Configuration&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Binder&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Configuration/GlobalSuppressions.cs"></file><file path="DisCatSharp.Configuration/Models/ConfigSection.cs">	public bool ContainsKey(string name)
		var path = string.IsNullOrEmpty(this.Root)
			? this.Config.ConfigPath(this.SectionName, name)
			: this.Config.ConfigPath(this.Root, this.SectionName, name);
		return !string.IsNullOrEmpty(this.Config[path]);
	public string GetValue(string propName)
		=&gt; this.Config[this.GetPath(propName)];
	public string GetPath(string value) =&gt;
		string.IsNullOrEmpty(this.Root)
			? this.Config.ConfigPath(this.SectionName, value)
			: this.Config.ConfigPath(this.Root, this.SectionName, value);</file><file path="DisCatSharp.Docs/articles/experimental/gcp_attachments.md">---
uid: experimental_gcp_attachments
title: GCP Attachments
author: DisCatSharp Team
hasDiscordComponents: false
---

# GCP Attachments

## Overview

The GCP (Google Cloud Platform) Attachments feature in DisCatSharp allows for directzly uploading files to Discord via Google Cloud Storage. This feature is experimental, and while it offers advanced file management options, it is not officially supported or endorsed by Discord. Use this feature with caution, as it may break or become unsupported in the future.

## Uploading Files

To upload a file to Discord using GCP Attachments, you can use the `UploadFileAsync` method provided in the `DiscordChannelMethodHooks` class. This method handles the file upload and returns the necessary information for later use in a `DiscordMessageBuilder`.

### Example: Uploading a File

```cs
using DisCatSharp.Experimental.Entities;

// ...

public async Task UploadFileExample(DiscordChannel channel, string filePath)
{
    using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
    var uploadInfo = await channel.UploadFileAsync(&quot;my_file.txt&quot;, fileStream, &quot;My file description&quot;);

    // Now you can use this upload information to send a message
    var msg = new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file you uploaded!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

## Adding GCP Attachments to a Message

Once a file is uploaded, it can be attached to a message using the `AddGcpAttachment` method in the `DiscordMessageBuilderMethodHooks` class. This method takes a `GcpAttachmentUploadInformation` object, which contains the details of the uploaded file.

### Example: Sending a Message with an Uploaded File

```cs
using DisCatSharp.Experimental.Entities;

// ...

public async Task SendFileMessage(DiscordChannel channel, GcpAttachmentUploadInformation uploadInfo)
{
    var msg = await new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

## Conclusion

The GCP Attachments feature provides powerful file management capabilities for advanced use cases. However, due to its experimental nature, developers should use it carefully and be aware of the risks associated with using unsupported features.</file><file path="DisCatSharp.Docs/articles/experimental/index.md">---
uid: experimental_preamble
title: Experimental Features in DisCatSharp
author: DisCatSharp Team
hasDiscordComponents: false
---

# Experimental Features in DisCatSharp

## Overview

DisCatSharp introduces several experimental features to provide advanced capabilities and customization options. These features are not officially supported or endorsed by Discord, and they may break or change without notice. Use these features at your own risk, and be prepared for potential instability.

### Important Notes

- **Experimental Nature**: Features in the experimental package are subject to change or removal in future updates.
- **No Official Support**: Discord does not officially support these features, meaning they may not work as expected, and updates from Discord might break functionality.
- **Potential for Breaking Changes**: Given the experimental status, updates to the library could introduce breaking changes without warning.

### Enabling Experimental Features

To use experimental features, you need to reference the `DisCatSharp.Experimental` namespace. Some experimental methods require specific features or treatments to be enabled on your Discord account or guild.

### Examples of Experimental Features

#### Elasticsearch-Based Member Search

This feature allows you to perform advanced member searches within a guild using Elasticsearch. This functionality is especially useful for large servers where filtering members by various criteria is necessary.

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    Limit = 100,
    Sort = MemberSortType.JoinedAtDesc
};

var searchResponse = await guild.SearchMembersAsync(searchParams);
```

#### GCP Attachments

The GCP Attachments feature allows you to directly upload files to Discord via Google Cloud Storage. This is particularly useful for managing large files. However, this feature is experimental and should be used with caution.

```cs
using DisCatSharp.Experimental.Entities;

// Uploading a file to Discord using GCP
public async Task UploadFileExample(DiscordChannel channel, string filePath)
{
    using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
    var uploadInfo = await channel.UploadFileAsync(&quot;my_file.txt&quot;, fileStream, &quot;My file description&quot;);

    // Sending the file as an attachment in a message
    var msg = new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file you uploaded!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

### Handling Errors in Experimental Features

Since experimental features can be unstable, it&apos;s essential to handle exceptions appropriately. Some common exceptions include:

- **ValidationException**: Thrown when input parameters do not meet the expected format or constraints.
- **NotIndexedException**: Thrown when the Elasticsearch index is not yet available for the guild.
- **UnauthorizedException**: Thrown when the bot lacks the necessary permissions to perform the requested action.

### Conclusion

Experimental features in DisCatSharp offer powerful new capabilities but come with risks. Ensure you test thoroughly in a development environment before deploying these features in production. Always keep an eye on library updates, as breaking changes can occur.</file><file path="DisCatSharp.Docs/articles/experimental/search_guild_members.md">---
uid: experimental_search_guild_members
title: ElasticSearch-Based Member Search
author: DisCatSharp Team
hasDiscordComponents: false
---

# ElasticSearch-Based Member Search

## Overview

With the introduction of ElasticSearch in DisCatSharp, the member search functionality has become more powerful, allowing for complex queries to find members within a guild. This feature leverages ElasticSearch to return supplemental guild member objects that match specific criteria. It’s a significant upgrade from the previous search methods but requires a good understanding of ElasticSearch&apos;s capabilities and limitations.

### Prerequisites

- Requires the `MANAGE_GUILD` permission.
- The guild must be indexed in ElasticSearch. If the guild is not yet indexed, the request will return a `202 Accepted` response, indicating that the results are not immediately available. We will throw a `NotIndexedException` here.

### Validating Search Parameters

Given the complexity of the queries, a robust validation system has been implemented to ensure that user input adheres to the expected formats and limits. The validation checks:

- **Limit**: Ensures the `limit` parameter is between 1 and 1000.
- **OR Queries**: Validates that `OR` queries are only used where allowed and checks the number of items and types.
- **AND Queries**: Validates that `AND` queries are only used where allowed and checks the number of items and types.
- **Range Queries**: Ensures that `range` queries are only used with valid types like `snowflake` or `integer`.

If the search parameters do not meet these conditions, a `ValidationException` is thrown.

### Using the Member Search

To use the member search, you need to construct a `DiscordGuildMemberSearchParams` object and pass it to the `SearchMembersAsync` method on a `DiscordGuild` object.

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    Limit = 10,
    OrQuery = new DiscordMemberFilter
    {
        Usernames = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;username1&quot;, &quot;username2&quot; } },
        RoleIds = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;123456789012345678&quot; } }
    }
};

try
{
    var searchResponse = await guild.SearchMembersAsync(searchParams);
    foreach (var member in searchResponse.Members)
    {
        // Process each member
    }
}
catch (ValidationException ex)
{
    Console.WriteLine($&quot;Validation error: {ex.ErrorMessage}&quot;);
}
catch (NotIndexedException ex)
{
    Console.WriteLine($&quot;The guild is not yet indexed. Retry after: {ex.RetryAfter} seconds.&quot;);
}
```

### Handling Responses

The `SearchMembersAsync` method returns a `DiscordSearchGuildMembersResponse` object, which contains the following:

- `GuildId`: The ID of the guild searched.
- `Members`: A list of supplemental guild member objects matching the search criteria.
- `PageResultCount`: The number of results returned in the current page.
- `TotalResultCount`: The total number of results found.

### Example Scenarios

#### Search by Invite Code

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    OrQuery = new DiscordMemberFilter
    {
        SourceInviteCode = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;inviteCode123&quot; } }
    }
};
var searchResponse = await guild.SearchMembersAsync(searchParams);
```

#### Search by Role and Username

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    AndQuery = new DiscordMemberFilter
    {
        RoleIds = new DiscordQuery { AndQuery = new List&lt;string&gt; { &quot;roleId123&quot; } }
    },
    OrQuery = new DiscordMemberFilter
    {
        Usernames = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;username1&quot; } }
    }
};
var searchResponse = await guild.SearchMembersAsync(searchParams);
```</file><file path="DisCatSharp.Docs/articles/faq.md">---
uid: faq
title: Frequently Asked Questions
author: DisCatSharp Team
---

# Frequently Asked Questions

## Why don&apos;t you provide light mode for the documentation?

Because light attracts bugs.

Jokes aside, I mainly use dark mode, and I don&apos;t want to maintain two versions of the documentation. CSS is painful enough.

## What is a snowflake

Discord calls their IDs snowflakes.

A snowflake explanation can be seen in the following image:

![snowflake](/images/snowflake.png)

## What is a gateway

Discord uses a websocket connection to send and receive data. This is called the gateway. The gateway is used to send and receive events, and to send and receive messages.

![gateway](/images/gateway.png)

## Code I copied from an article isn&apos;t compiling or working as expected. Why?

_Please use the code snippets as a reference; don&apos;t blindly copy-paste code!_

The snippets of code in the articles are meant to serve as examples to help you understand how to use a part of the library.

Although most will compile and work at the time of writing, changes to the library over time can make some snippets obsolete.

Many issues can be resolved with Intellisense by searching for similarly named methods and verifying method parameters.

## Connecting to a voice channel with VoiceNext will either hang or throw an exception.

To troubleshoot, please ensure that:

-   You are using the latest version of DisCatSharp.
-   You have properly enabled VoiceNext with your instance of @DisCatSharp.DiscordClient.
-   You are _not_ using VoiceNext in an event handler.
-   You have [opus and libsodium](xref:modules_audio_voicenext_prerequisites) available in your target environment.

## Why am I getting _heartbeat skipped_ message in my console?

There are two possible reasons:

### Connection issue between your bot application and Discord.

Check your internet connection and ensure that the machine your bot is hosted on has a stable internet connection.&lt;br/&gt;
If your local network has no issues, the problem could be with either Discord or Cloudflare. In which case, it&apos;s out of your control.

### Complex, long-running code in an event handler.

Any event handlers that have the potential to run for more than a few seconds could cause a deadlock, and cause several heartbeats to be skipped.
Please take a look at our short article on [handling exceptions](xref:topics_events) to learn how to avoid this.

## Why am I getting a 4XX error and how can I fix it?

| HTTP Error Code | Cause                       | Resolution                                                                                                                                                      |
| :-------------: | :-------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|      `401`      | Invalid token.              | Verify your token and make sure no errors were made.&lt;br/&gt;The client secret found on the &apos;general information&apos; tab of your application page _is not_ your token. |
|      `403`      | Not enough permissions.     | Verify permissions and ensure your bot account has a role higher than the target user.&lt;br/&gt;Administrator permissions _do not_ bypass the role hierarchy.        |
|      `404`      | Requested object not found. | This usually means the entity does not exist. You should reattempt then inform your user.                                                                       |

## I cannot modify a specific user or role. Why is this?

In order to modify a user, the highest role of your bot account must be higher than the target user.&lt;br/&gt;
Changing the properties of a role requires that your bot account have a role higher than that role.

## Does CommandsNext support dependency injection?

It does! Please take a look at our [article](xref:modules_commandsnext_dependency_injection) on the subject.

Basically every module of DisCatSharp supports dependency injection.

## Can I use a user token?

Automating a user account is against Discord&apos;s [Terms of Service](https://dis.gd/terms) and is not supported by DisCatSharp.

## How can I set a custom status?

You can use either of the following

-   The overload for [ConnectAsync](xref:DisCatSharp.DiscordClient.ConnectAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) which accepts a [DiscordActivity](xref:DisCatSharp.Entities.DiscordActivity).
-   [UpdateStatusAsync](xref:DisCatSharp.DiscordClient.UpdateStatusAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) OR [UpdateStatusAsync](xref:DisCatSharp.DiscordShardedClient.UpdateStatusAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) (for the sharded client) at any point after `Ready` has been fired.

## Am I able to retrieve a @DisCatSharp.Entities.DiscordRole by name?

Yes. Use LINQ on the `Roles` property of your instance of [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild) and compare against the `Name` of each [DiscordRole](xref:DisCatSharp.Entities.DiscordRole).

## Why are my events not firing?

This is because in the Discord V8+ API, they require @DisCatSharp.Enums.DiscordIntents to be enabled on [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration) and the
Discord Application Portal. We have an [article](xref:topics_intents) that covers all that has to be done to set this up.</file><file path="DisCatSharp.Docs/articles/getting_started/bot_account.md">---
uid: getting_started_bot_account
title: Creating a Bot Account
author: DisCatSharp Team
---

# Creating a Bot Account

## Create an Application

&gt; [!NOTE]
&gt; You can also use discords official [getting started](https://discord.com/developers/docs/getting-started#building-your-first-discord-app) tutorial till step 2.

Before you&apos;re able to create a [bot account](https://discord.com/developers/docs/topics/oauth2#bots) to interact with the Discord API, you&apos;ll need to create a new OAuth2 application.
[Create](https://discord.com/developers/applications?new_application=true) a new application in the [Discord Developer Portal](https://discord.com/developers/).

![Discord Developer Portal](/images/getting_started_bot_account_01.png)

&lt;br/&gt;
You&apos;ll then be prompted to enter a name for your application.&lt;br/&gt;

![Naming Application](/images/getting_started_bot_account_02.png &quot;Naming Application&quot;)

The name of your application will be the name displayed to users when they add your bot to their Discord server.&lt;br/&gt;
With that in mind, it would be a good idea for your application name to match the desired name of your bot.

Enter your desired application name into the text box, accept the [Developer Terms of Service](https://discord.com/developers/docs/policies-and-agreements/terms-of-service) and [Developer Policy](https://discord.com/developers/docs/policies-and-agreements/developer-policy) and hit the `Create` button.

After you hit `Create`, you&apos;ll be taken to the application page for your newly created application.

![Application Page](/images/getting_started_bot_account_03.png)

That was easy, wasn&apos;t it?

Before you move on, you may want to upload an icon for your application and provide a short description of what your bot will do.
As with the name of your application, the application icon and description will be displayed to users when adding your bot.

# Using Your Bot Account

## Invite Your Bot

Now that you have a bot account, you&apos;ll probably want to invite it to a server!

A bot account joins a server through a special invite link that&apos;ll take users through the OAuth2 flow;
you&apos;ll probably be familiar with this if you&apos;ve ever added a public Discord bot to a server.
To get the invite link for your bot, head on over to the `OAuth2` page of your application and select the `URL Generator` page.

![OAuth2 URL Generator](/images/getting_started_bot_account_06.png &quot;OAuth2 URL Generator&quot;)

&lt;br/&gt;
We&apos;ll be using the *OAuth2 URL Generator* on this page.&lt;br/&gt;
Simply tick `bot` under the *scopes* panel; your bot invite link will be generated directly below.

![OAuth2 Scopes](/images/getting_started_bot_account_07.png &quot;OAuth2 Scopes&quot;)

&lt;br/&gt;
By default, the generated link will not grant any permissions to your bot when it joins a new server.&lt;br/&gt;
If your bot requires specific permissions to function, you&apos;d select them in the *bot permissions* panel.

![Permissions](/images/getting_started_bot_account_08.png &quot;Permissions Panel&quot;)

The invite link in the _scopes_ panel will update each time you change the permissions.&lt;br/&gt;
Be sure to copy it again after any changes!

## Get Bot Token

Instead of logging in to Discord with a username and password, bot accounts use a long string called a _token_ to authenticate.
You&apos;ll want to retrieve the token for your bot account so you can use it with DisCatSharp.

Head back to the bot page and click on `Reset Token` just below the bot&apos;s username field.

![Token Reset](/images/getting_started_bot_account_09.png &quot;Token Reset&quot;)

Click on `Yes, do it!` to confirm the reset.

![Token Reset Confirm](/images/getting_started_bot_account_10.png &quot;Token Reset Confirmation&quot;)

Go ahead and copy your bot token and save it somewhere. You&apos;ll be using it soon!

&gt; [!IMPORTANT]
&gt; Handle your bot token with care! Anyone who has your token will have access to your bot account.
&gt; Be sure to store it in a secure location and _never_ give it to _anybody_.
&gt;
&gt; If you ever believe your token has been compromised, be sure to hit the `Reset Token` button (as seen above) to invalidate your old token and get a brand new token.

## Write Some Code

You&apos;ve got a bot account set up and a token ready for use.&lt;br/&gt;
Sounds like it&apos;s time for you to [write your first bot](xref:getting_started_first_bot)!</file><file path="DisCatSharp.Docs/articles/getting_started/first_bot.md">---
uid: getting_started_first_bot
title: Your First Bot
author: DisCatSharp Team
hasDiscordComponents: true
---

# Your First Bot

&gt; [!NOTE]
&gt; This article assumes the following:
&gt;
&gt; -   You have [created a bot account](xref:getting_started_bot_account &quot;Creating a Bot Account&quot;) and have a bot token.
&gt; -   You have [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) installed on your computer.

## Create a Project

Open up Visual Studio and click on `Create a new project` towards the bottom right.

![Visual Studio Start Screen](/images/getting_started_first_bot_01.png)

&lt;br/&gt;
Select `Console App` then click on the `Next` button.

![New Project Screen](/images/getting_started_first_bot_02.png)

&lt;br/&gt;
Next, you&apos;ll give your project a name. For this example, we&apos;ll name it `MyFirstBot`.&lt;br/&gt;
If you&apos;d like, you can also change the directory that your project will be created in.

Enter your desired project name, then click on the `Create` button.

![Name Project Screen](/images/getting_started_first_bot_03.png)

&lt;br/&gt;
Now select `.NET 7.0` or `.NET 8.0` from the dropdown menu, tick the `Do not use top-level statements` checkbox and click on the `Next` button.

![Framework Project Screen](/images/getting_started_first_bot_04.png)

&lt;br/&gt;
Voilà! Your project has been created!
![Visual Studio IDE](/images/getting_started_first_bot_05.png)

## Install Package

Now that you have a project created, you&apos;ll want to get DisCatSharp installed.
Locate the _solution explorer_ on the right side, then right click on `Dependencies` and select `Manage NuGet Packages` from the context menu.

![Dependencies Context Menu](/images/getting_started_first_bot_06.png)

&lt;br/&gt;
You&apos;ll then be greeted by the NuGet package manager.

Select the `Browse` tab towards the top left, then type `DisCatSharp` into the search text box with the Pre-release checkbox checked **ON**.

![NuGet Package Search](/images/getting_started_first_bot_07.png)

&lt;br/&gt;
The first results should be the DisCatSharp packages.

&lt;!--![Search Results](/images/getting_started_first_bot_07.png)--&gt;

|              Package              |                                                       Description                                                       |
| :-------------------------------: | :---------------------------------------------------------------------------------------------------------------------: |
|           `DisCatSharp`           |                                            Main package; Discord API client.                                            |
|    `DisCatSharp.CommandsNext`     |                                       Add-on which provides a command framework.                                        |
|       `DisCatSharp.Common`        |                                                Common tools &amp; converters                                                |
|    `DisCatSharp.Interactivity`    |                                      Add-on which allows for interactive commands.                                      |
|      `DisCatSharp.Lavalink`       |           Client implementation for [Lavalink](xref:modules_audio_lavalink_v4_intro). Useful for music bots.            |
| `DisCatSharp.ApplicationCommands` |                              Add-on which makes dealing with application commands easier.                               |
|      `DisCatSharp.VoiceNext`      |                              Add-on which enables connectivity to Discord voice channels.                               |
|  `DisCatSharp.VoiceNext.Natives`  |                                                   Voice next natives.                                                   |
|  `DisCatSharp.Analyzers.Roselyn`  | Our custom analyzer, providing extended IntelliSense functions. As example warns you about deprecated discord features. |

&lt;br/&gt;
We&apos;ll only need the `DisCatSharp` package for the basic bot we&apos;ll be writing in this article.&lt;br/&gt;
Select it from the list then click the `Install` button to the right.

![Install DisCatSharp](/images/getting_started_first_bot_08.png)

You&apos;re now ready to write some code!

## First Lines of Code

DisCatSharp implements [Task-based Asynchronous Pattern](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern).
Because of this, the majority of DisCatSharp methods must be executed in a method marked as `async` so they can be properly `await`ed.

Due to the way the compiler generates the underlying [IL](https://en.wikipedia.org/wiki/Common_Intermediate_Language) code,
marking our `Main` method as `async` has the potential to cause problems. As a result, we must pass the program execution to an `async` method.

Head back to your _Program.cs_ tab and empty the `Main` method by deleting line 9.

![Code Editor](/images/getting_started_first_bot_09.png)

Now, create a new `static` method named `MainAsync` beneath your `Main` method. Have it return type `Task` and mark it as `async`.
After that, add `MainAsync().GetAwaiter().GetResult();` to your `Main` method.

```cs
static void Main(string[] args)
{
    MainAsync().GetAwaiter().GetResult();
}

static async Task MainAsync()
{

}
```

If you typed this in by hand, Intellisense should have generated the required `using` directive for you.&lt;br/&gt;
However, if you copy-pasted the snippet above, VS will complain about being unable to find the `Task` type.

Hover over `Task` with your mouse and click on `Show potential fixes` from the tooltip.

![Error Tooltip](/images/getting_started_first_bot_10.png)

Then apply the recommended solution.

![Solution Menu](/images/getting_started_first_bot_11.png)

&lt;br/&gt;
We&apos;ll now create a new `DiscordClient` instance in our brand new asynchronous method.

Create a new variable in `MainAsync` and assign it a new `DiscordClient` instance, then pass an instance of `DiscordConfiguration` to its constructor.
Create an object initializer for `DiscordConfiguration` and populate the `Token` property with your bot token then set the `TokenType` property to `TokenType.Bot`.
Next add the `Intents` Property and Populated it with the @DisCatSharp.DiscordIntents.AllUnprivileged and DiscordIntents.MessageContent values.
The message content intent must be enabled in the developer portal as well.
These Intents
are required for certain Events to be fired. Please visit this [article](xref:topics_intents) for more information.

```cs
var discord = new DiscordClient(new DiscordConfiguration()
{
    Token = &quot;My First Token&quot;,
    TokenType = TokenType.Bot,
    Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent
});
```

&gt; [!WARNING]
&gt; We hard-code the token in the above snippet to keep things simple and easy to understand.
&gt;
&gt; Hard-coding your token is _not_ a smart idea, especially if you plan on distributing your source code.
&gt; Instead you should store your token in an external medium, such as a configuration file or environment variable, and read that into your program to be used with DisCatSharp.

Follow that up with `await discord.ConnectAsync();` to connect and login to Discord, and `await Task.Delay(-1);` at the end of the method to prevent the console window from closing prematurely.

```cs
var discord = new DiscordClient();

await discord.ConnectAsync();
await Task.Delay(-1);
```

As before, Intellisense will have auto generated the needed `using` directive for you if you typed this in by hand.&lt;br/&gt;
If you&apos;ve copied the snippet, be sure to apply the recommended suggestion to insert the required directive.

If you hit `F5` on your keyboard to compile and run your program, you&apos;ll be greeted by a happy little console with a single log message from DisCatSharp. Woo hoo!

![Program Console](/images/getting_started_first_bot_12.png)

## Spicing Up Your Bot

Right now our bot doesn&apos;t do a whole lot. Let&apos;s bring it to life by having it respond to a message!

Hook the `MessageCreated` event fired by `DiscordClient` with a
[lambda](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions).&lt;br/&gt;
Mark it as `async` and give it two parameters: `s` and `e`.

```cs
discord.MessageCreated += async (s, e) =&gt;
{

};
```

Then, add an `if` statement into the body of your event lambda that will check if `e.Message.Content` starts with your desired trigger word and respond with
a message using `e.Message.RespondAsync` if it does. For this example, we&apos;ll have the bot to respond with _pong!_ for each message that starts with _ping_.

```cs
discord.MessageCreated += async (s, e) =&gt;
{
    if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;))
		await e.Message.RespondAsync(&quot;pong!&quot;);
};
```

## The Finished Product

Your entire program should now look like this:

```cs
using System;
using System.Threading.Tasks;
using DisCatSharp;
namespace MyFirstBot
{
    class Program
    {
        static void Main(string[] args)
        {
            MainAsync().GetAwaiter().GetResult();
        }

        static async Task MainAsync()
        {
            var discord = new DiscordClient(new DiscordConfiguration()
            {
				Token = &quot;My First Token&quot;,
				TokenType = TokenType.Bot,
				Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent
            });

            discord.MessageCreated += async (s, e) =&gt;
            {
                if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;))
                    await e.Message.RespondAsync(&quot;pong!&quot;);

            };

            await discord.ConnectAsync();
            await Task.Delay(-1);
        }
    }
}
```

Hit `F5` to run your bot, then send _ping_ in any channel your bot account has access to.&lt;br/&gt;
Your bot should respond with _pong!_ for each _ping_ you send.

Congrats, your bot now does something!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;ping&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;ping&lt;/discord-reply&gt;
        pong!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Further Reading

Now that you have a basic bot up and running, you should take a look at the following:

-   [Events](xref:topics_events)
-   [CommandsNext](xref:modules_commandsnext_intro)
-   [ApplicationCommands](xref:modules_application_commands_intro)</file><file path="DisCatSharp.Docs/articles/getting_started/templates.md">---
uid: getting_started_templates
title: Project Templates
author: DisCatSharp Team
---

# Prerequisites

Install the following packages:

-   DisCatSharp.ProjectTemplates

To Install the latest:

```powershell
dotnet new --install DisCatSharp.ProjectTemplates
```

To install a specific version (example uses 10.0.0):

```powershell
dotnet new --install DisCatSharp.ProjectTemplates::10.0.0
```

# Steps

## ![Install Setup](/images/pt_nuget_install.png)

If you&apos;re using Visual Studio, the templates will show up when creating a new project/solution
![Install Setup](/images/pt_project_new.png)

To easily find the DCS templates, you can search for either `Bot` or `Discord`. These tags are generic so if anyone else creates their own
discord or bot template our DCS templates will still be discoverable. We shall be using the solution template for our example.
![Classification](/images/pt_project_new_classification.png)

For example sake, the project name is DCSTest
![Project Name](/images/pt_project_new_name.png)

Input your Discord Token which can be retrieved via Discord&apos;s Developer Portal. The checkboxes represent the various modules in the DCS library. Checking it,
will include it in your project. If it&apos;s an extension, it automatically gets configured/included.
![Parameters](/images/pt_project_new_options.png)

You should see something similar to the following image. It&apos;s worth noting that you need to set the Web project as the `Startup` project. Due to the web being
list last, the `Bot` project is considered the startup. You would think that a class-library which doesn&apos;t have an exe could be considered a startup project....
![Project Structure](/images/pt_scaffolded.png)

At this point in time the template is ready to run!

---

# Templates

## Bot Template

This is a class library in which you place bot related code. It contains its own json file where you can
configure your bot accordingly!

An extension class provides easy to call methods for adding the Bot&apos;s services/configuration into the dependency injection (DI) pipeline.

## Web Template

This is a very minimal project. By itself it only has a default endpoint which displays &quot;Hello World&quot;.

## Solution Template

Combines the bot and web templates. Includes the appropriate references/calls to get your bot up and running with minimal
effort.</file><file path="DisCatSharp.Docs/articles/getting_started/web_app.md">---
uid: getting_started_web_app
title: Bot as Hosted Service
author: DisCatSharp Team
---

# Prerequisites

Install the following packages:

-   DisCatSharp
-   DisCatSharp.Hosting

&gt; [!IMPORTANT]
&gt; Please be aware that this approach relies on Dependency Injection. You can either use one of Microsoft&apos;s default project templates for .Net Core Web App, or get a head start by using the
&gt; `DisCatSharp.Hosting.ProjectTemplates` pack which contains a Bot Template to jumpstart your development. If you do the latter, majority of this is done for you.

# Bot.cs

For the sake of example, create a new class called `Bot` which inherits from `DiscordHostedService`. You&apos;re welcome to replace `Bot` with whatever you want.

&gt; [!NOTE]
&gt; If you want to host a variety of bots it is important to provide a custom name into the `base` constructor. This indicates the `Key` within `IConfiguration` that will be used for
&gt; configuring your bot.

## Default

`DisCatSharp` is the default key used when configuring the bot.

```cs
public class Bot : DiscordHostedService
{
    public Bot(IConfiguration config,
            ILogger&lt;Bot&gt; logger,
            IServiceProvider provider,
            IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime)
    {
    }
}
```

## Custom

For example’s sake the custom bot name is &quot;Bot&quot;, so replace it with whatever you want.

```cs
public class Bot : DiscordHostedService
{
    public Bot(IConfiguration config,
            ILogger&lt;Bot&gt; logger,
            IServiceProvider provider,
            IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;Bot&quot;)
    {
    }
}
```

# Startup.cs

## DisCatSharp.Hosting.DependencyInjection

By using the `DisCatSharp.Hosting.DependencyInjection` module, this 1 line is enough to get
your basic bot running...

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscordHostedService&lt;Bot&gt;();
}
```

## Manual Registration

If you prefer another DI approach / the manual route -- the following two
lines are all you need! For example sake, this bot doesn&apos;t have anything fancy going on.
You&apos;re welcome to create your own interface which inherits from `IDiscordHostedService`.

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;IDiscordHostedService, Bot&gt;();
    services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;IDiscordHostedService&gt;());
}
```

Singleton - we only want 1 instance of Bot to ever run during runtime. &lt;br&gt;
Then we take the registered singleton to run as a `HostedService`.

# How to reference

Within a DI environment, whether it&apos;s via constructor or an `IServiceProvider`

## If explicitly registered as `Bot`

You either put `Bot` as part of your constructor. Or from a provider you do

```cs
Bot bot = provider.GetRequiredService&lt;Bot&gt;();
```

## Interface + Bot

This approach means you are mapping the Interface to your `Bot`. However, you might notice that

```cs
Bot bot = provider.GetRequiredService&lt;Bot&gt;();
```

or via constructor - you will get an exception indicating that `Bot` has not been registered. Well... it&apos;s true. It&apos;s looking for a key within the collection that matches the type you asked for.
When you use the Interface/Implementation combination it behaves **almost** like a dictionary -- `Bot` is not a valid key in this scenario.

So to retrieve your `Bot` reference you have to use the interface.

```cs
IBot bot = provider.GetRequiredService&lt;IBot&gt;();
```

If you go down this path of mapping interface to implementation you shouldn&apos;t be casting your interface to Bot, or whatever. You&apos;d be better off just using the explicitly registered type.
The reasoning behind this approach is to allow you to swap out the implementation type in **ONE** place, and **NOT** have to update any other code.

For instance, logging... there are SO many ways to do logging. You might be familiar with [ILogger](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger). So long as something implements this interface it doesn&apos;t matter. It could be Serilog,
or a custom logger you created, or another package from the internet. If later in a project you are dissatisfied with your custom-built logger (which inherits from `ILogger`) you could
easily swap it out with `Serilog` in one place. This makes swapping between packages extremely easy - a simple 1 to 2 line change compared to a project-wide impact.

# How to Configure

You must provide a token in order for the bot to work.

Add the following to `appsettings.json`

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	}
}
```

## Dependency Injection

The ServiceProvider where you register the `DiscordHostedService` is automatically copied to the DiscordClient.
Therefore, if you want to use any services in your [event handlers](xref:topics_events), you can simply register them before the `DiscordHostedService`:

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;YourService&gt;();

    services.AddDiscordHostedService&lt;Bot&gt;();
}
```

In this case, `YourService` will be available in all your Discord event handlers.

## Initialization errors handling

During the initialization of bots, various exceptions can be thrown. For example: invalid token.
By default, the exception will be displayed in the console, after which the application will shutdown.
You can handle exceptions by overriding method `OnInitializationError` in your `DiscordHostedService`.

```cs
protected override void OnInitializationError(Exception ex)
{
    // your code here

    base.OnInitializationError(ex);
}
```

## Extensions

If you wish to add additional modules/extensions you can do so one of two ways.

1. Use the full namespace name
2. Namespace without the `DisCatSharp` prefix - because we assume the extension starts with DisCatSharp.

To add the extensions `Interactivity` and `CommandsNext`:

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Using&quot;: [&quot;DisCatSharp.Interactivity&quot;, &quot;CommandsNext&quot;],

		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		},

		&quot;Interactivity&quot;: {
			&quot;PollBehaviour&quot;: &quot;KeepEmojis&quot;
		},

		&quot;CommandsNext&quot;: {
			&quot;StringPrefixes&quot;: [&quot;!&quot;]
		}
	}
}
```

&gt; [!NOTE]
&gt; To configure an extension, you simply add a section for it under `DisCatSharp` in `appsettings.json`. You only have
&gt; to include values you **WISH TO OVERRIDE**. There is no need to include all config options if you only need to change 1 value.
&gt; For more info on which values are available checkout the following classes:
&gt;
&gt; -   `ApplicationCommandsConfiguration`
&gt; -   `CommandsNextConfiguration`
&gt; -   `DiscordConfiguration`
&gt; -   `InteractivityConfiguration`
&gt; -   `LavalinkConfiguration`
&gt; -   `VoiceNextConfiguration`
&gt;
&gt; For more information, you can also see the [example](https://github.com/Aiko-IT-Systems/DisCatSharp.Examples/tree/main/Hosting).

## Multiple bots

In case you need to use multiple bots in one application, you need to use different names for them in the `appsettings.json`:

```json
{
	&quot;BotOne&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	},
	&quot;BotTwo&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	}
}
```

Next, you need to create a new `DiscordHostedService` for each of the bots.

```cs
public class BotOne : DiscordHostedService
{
    public BotOne(IConfiguration config, ILogger&lt;DiscordHostedService&gt; logger, IServiceProvider provider,
        IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;BotOne&quot;)
    {
    }
}

public class BotTwo : DiscordHostedService
{
    public BotTwo(IConfiguration config, ILogger&lt;DiscordHostedService&gt; logger, IServiceProvider provider,
        IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;BotTwo&quot;)
    {
    }
}
```

Note: you must also specify the name of the bot in the constructor, which must match the one specified in the config.

Now, you can simply register them in the usual way:

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscordHostedService&lt;BotOne&gt;();
    services.AddDiscordHostedService&lt;BotTwo&gt;();
}
```

---

## Values

It&apos;s worth mentioning the required formats for certain value types

### Enum

-   Single Flag/Value
    -   &quot;`Value`&quot;
-   Multiple Flags
    -   &quot;`Flag1|Flag2|Flag3`&quot;

#### Example

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;Intents&quot;: &quot;GuildMembers|GuildsBans&quot;
		}
	}
}
```

### TimeSpan

Hours:Minutes:Seconds &quot;`HH:mm:ss`&quot;

#### Example

HttpTimeout of 5 minutes

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;HttpTimeout&quot;: &quot;00:05:00&quot;
		}
	}
}
```</file><file path="DisCatSharp.Docs/articles/index.md">---
uid: preamble
title: Article Preamble
author: DisCatSharp Team
---

# How to use articles

Images used in articles might include version numbers, which may not be the latest version of DisCatSharp.

Example code should be treated as pseudo-code, and may not compile.

# Knowledge Prerequisites

Before attempting to write a Discord bot, you should be familiar with the concepts of [Object Oriented Programing](https://en.wikipedia.org/wiki/Object-oriented_programming), [the C# programming language](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/), and [Task-based Asynchronous Pattern](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap).

If you&apos;re brand new to C#, or programming in general, this library may prove difficult for you to use.&lt;/br&gt;
Fortunately, there are resources that can help you get started with the language!

An excellent tutorial series to go through would be [C# Fundamentals for Absolute Beginners](https://channel9.msdn.com/Series/CSharp-Fundamentals-for-Absolute-Beginners) by Bob Tabor.
His videos go through all the getting_started, from setting up your development environment up to some of the more advanced concepts.
If you&apos;re not sure what to do first, Bob&apos;s tutorial series should be your starting point!

Another great resource is Microsoft&apos;s [Introduction to C#](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/), which is an interactive tutorial.

# Supported .NET Implementations

DisCatSharp 10.6 and higher targets .NET 9 primary and backports .NET 8.

# Getting Started

If you&apos;re writing a Discord bot for the first time, you&apos;ll want to start with _[creating a bot account](xref:getting_started_bot_account)_.

Otherwise, if you have a bot account already, start off with the _[writing your first bot](xref:getting_started_first_bot)_ article.

Once you&apos;re up and running, feel free to browse through the [API Documentation](xref:api_index)!</file><file path="DisCatSharp.Docs/articles/misc/hosting.md">---
uid: misc_hosting
title: Hosting Solutions
author: DisCatSharp Team
---

# 24/7 Hosting Solutions

## Free hosting

If you&apos;re looking for free hosts, you&apos;ve likely considered using [Glitch](https://glitch.com/).
We advise against using these platforms as they are designed to host web services, not Discord bots, and instances from either of these companies will shut down if there isn&apos;t enough internet traffic.
Save yourself the headache and don&apos;t bother.

Outside of persuading somebody to host your bot, you won&apos;t find any good free hosting solutions.

## Self Hosting

If you have access to an unused machine, have the technical know-how, and you also have a solid internet connection, you might consider hosting your bot on your own.
Even if you don&apos;t have a space PC on hand, parts to build one are fairly cheap in most regions. You could think of it as a one time investment with no monthly server fees.
Any modern hardware will work just fine, new or used.

Depending on how complex your bot is, you may even consider purchasing a Raspberry Pi ($35).

### Termux

If you don&apos;t have a PC or other gear sitting around, you may use your phone instead. Using [Termux](https://termux.dev/en/) and a program called [proot-distro](https://github.com/termux/proot-distro), we create a Debian virtual machine and configure DotNET to run the bot. For anyone interested, the instructions are detailed below:

#### Requirements

- A phone with Android 7 or higher (5+ is possible but, not recommended as it posses security issues).
- Termux.
- An internet connection.

#### Setup

- Initialize Termux.
```sh
pkg update &amp;&amp; pkg upgrade -y
```
&gt;[!TIP]
&gt; It might ask you for input, just click enter and let the default option be executed.

- Install proot-distro package.
```sh
pkg install proot-distro -y
```

- Install a Debian Virtual Machine (VM).
```sh
proot-distro install debian
```
&gt;[!NOTE]
&gt; Installation time for anything will depend on your internet speed.

- Login into Debian and initialize it.
```sh
proot-distro login debian
```
```sh
apt update -y &amp;&amp; apt upgrade -y
```

- Install git and wget.
```sh
apt install git wget -y
```

- We get the DotNET script.
```sh
wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh &amp;&amp; chmod +x ./dotnet-install.sh
```

- Now, we install the DotNET sdk and runtime.
```sh
./dotnet-install.sh --channel 8.0
```
&gt;[!NOTE]
&gt; If the script doesn&apos;t automatically add `dotnet` to the path environment variable, run `export PATH=$PATH:$HOME/.dotnet` and add this command to the end of your `.bashrc` file which can be found in your user directory. To edit the `.bashrc` file run, `nano ~/.bashrc` and paste in the arguments. The `.bashrc` file is your configuration file for the bash shell environment.

&gt;[!WARNING]
&gt; You might encounter the error code `0x8007000E` when you try to run the bot. To fix it, run `export DOTNET_GCHeapHardLimit=1C0000000` and also put that command into your `~/.bashrc` file. 
&gt; You&apos;ll possibly also get hit with an error message about a &quot;valid ICU package&quot; to fix that, run `export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1` and run the bot again. Or simply add these lines to your `.csproj` file in your project folder:
```xml
&lt;RuntimeHostConfigurationOption Include=&quot;System.Globalization.Invariant&quot; Value=&quot;true&quot; /&gt;
```

##### Cloud Hosted Code

- If you have your code hosted with git or simply are able to download it, get the source code and `cd` into the directory. Example of a git repository on GitHub:
```sh
git clone https://github.com/username/repo.git
cd repo
```
- Add your configuration file then build the project.

##### Local Source Code

- If you do not have your source code hosted remotely, you can move the source code inside the VM by following the given steps: 

- Enable developer options on your phone, find out [here](https://developer.android.com/studio/debug/dev-options) and also enable USB debugging which you can do by going inside `Settings &gt; Developer options &gt; USB debugging` or where ever your phone&apos;s is located.

- Find the option `Default USB configuration` and choose `Transferring files`. Disconnect your phone from the usb and reconnect it again.

- Double click on `Phone` or what it is named, then simply copy your project folder from your pc and paste it in there. If you want to keep it in a custom path, remember the path to the project.

&gt;[!NOTE]
&gt; Transferring of files might take a bit. Be sure to not interrupt the process by shutting down or disconnecting your phone

- First, we setup Termux storage run, `termux-setup-storage` and then it&apos;ll prompt you to give Termux access to your files and folders. Then run, `ls ~/storage/shared` to make sure you have access.

&gt;[!WARNING]
&gt; If you do not give Termux access to your files and folders, nothing will work going from here on.

- Now, exit out of Debian and into normal Termux and make a new environment variable which leads us to the VM&apos;s root directory. Run, `export PROOTDISTROFS=/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs` and run `source $HOME/.bashrc`.

&gt;[!TIP]
&gt; If you don&apos;t have a `.bashrc` file in your $HOME, just run `nano $HOME/.bashrc`, save, and exit. Then run the source command again.

- Now, we&apos;ll move over the source code from our phone to the VM. Simply, run, `mv projectname/ $PROOTDISTROFS/debian/root/`.

&gt;[!WARNING]
&gt; Double-check file paths, as you might accidentally move the wrong files around.

- Now, let&apos;s log back into Debian `proot-distro login debian` and check if the files are here. To check, you can run `ls` to list the current content of the folder.

- Add your configuration file then build the project.

&gt;[!CAUTION]
&gt; If you have folders such as `bin/` and `obj/` from your prior builds on your PC, delete those by running `rm -rf bin/ obj/`. You might run into issues otherwise.

#### Profit

Bot should be working fine, given you follow appropriate steps. For support or any inquires you can join our discord.

## Third-Party Hosting

The simplest, and probably most hassle-free (and maybe cheapest in the long run for dedicated machines) option is to find a provider
that will lend you their machine or a virtual host so you can run your bot in there.

Generally, cheapest hosting options are all GNU/Linux-based, so it&apos;s highly recommended you familiarize yourself with the OS and its
environment, particularly the shell (command line), and concepts such as SSH.

There are several well-known, trusted, and cheap providers:

-   [Host Pls](https://host-pls.com/) - A hosting solution made by Discord bot developers. Based in America, starting from $2.49/mo.
-   [Vultr](https://www.vultr.com/products/cloud-compute/) - Based in the US with datacenters in many regions, including APAC. Starting at $2.50/mo.
-   [DigitalOcean](https://www.digitalocean.com/products/droplets/) - The gold standard, US based. Locations available world wide. Starting from $5.00/mo.
-   [Linode](https://www.linode.com/products/shared/) - US based host with many datacenters around the world. Starting at $5.00/mo.
-   [OVH](https://www.ovhcloud.com/en/vps/) - Very popular VPS host. Based in Canadian with French locations available. Starting from $6.00/mo.
-   [Contabo](https://contabo.com/?show=vps) - Based in Germany; extremely good value for the price. Starting from 4.99€/mo.

Things to keep in mind when looking for a VPS host:

-   The majority of cheap VPS hosts will be running some variant of Linux, and not Windows.
-   The primary Discord API server is located in East US.
    -   If latency matters for you application, choose a host that is closer to this location.

In addition to these, there are several hosting providers that offer free trials or in-service credit:

-   [**Microsoft Azure**](https://azure.microsoft.com/en-us/free/?cdn=disable &quot;Microsoft Azure&quot;): $200 in-service credit,
    to be used within month of registration. Requires credit or debit card for validation. Azure isn&apos;t cheap, but it supports
    both Windows and GNU/Linux-based servers. If you&apos;re enrolled in Microsoft Imagine, it&apos;s possible to get these cheaper or
    free.
-   [**Amazon Web Services**](https://aws.amazon.com/free/ &quot;AWS&quot;): Free for 12 months (with 750 compute hours per month). Not
    cheap once the trial runs out, but it&apos;s also considered industry standard in cloud services.
-   [**Google Cloud Platform**](https://cloud.google.com/free/ &quot;Google Cloud Platform&quot;): $300 in-service credit, to be used
    within year of registration. GCP is based in the US, and offers very scalable products. Like the above, it&apos;s not the
    cheapest of offerings.

## Hosting on Cloud Native Services

With most bots, unless if you host many of them, they dont require a whole machine to run them, just a slice of a machine. This is
where Docker and other cloud native hosting comes into play. There are many different options available to you and you will need
to chose which one will suit you best. Here are a few services that offer Docker or other cloud native solutions that are cheaper than running
a whole VM.

-   [**Azure App Service**](https://azure.microsoft.com/en-us/services/app-service/ &quot;Azure App Service&quot;): Allows for Hosting Website, Continuous Jobs,
    and Docker images on a Windows base or Linux base machine.
-   [**AWS Fargate**](https://aws.amazon.com/fargate/ &quot;AWS Fargate&quot;): Allows for hosting Docker images within Amazon Web Services
-   [**Jelastic**](https://jelastic.com/docker/ &quot;Jelastic&quot;): Allows for hosting Docker images.

# Making your publishing life easier

Now that we have covered where you can possibly host your application, now lets cover how to make your life easier publishing it. Many different
source control solutions out there are free and also offer some type of CI/CD integration (paid and free). Below are some of the
solutions that we recommend:

-   [**Azure Devops**](https://azure.microsoft.com/en-us/services/devops/?nav=min &quot;Azure Devops&quot;): Allows for GIT source control hosting along with integrated CI/CD
    pipelines to auto compile and publish your applications. You can also use their CI/CD service if your code is hosted in a different source control environment like Github.
-   [**Github**](https://github.com/ &quot;GitHub&quot;) Allows for GIT source control hosting. From here you can leverage many different CI/CD options to compile and publish your
    applications.
-   [**Bitbucket**](https://bitbucket.org/ &quot;Bitbucket&quot;): Allows for GIT source control hosting along with integrated CI/CD pipelines to auto compile and publish your applications.</file><file path="DisCatSharp.Docs/articles/misc/nightly_builds.md">---
uid: misc_nightly_builds
title: Nightly Builds
author: DisCatSharp Team
---

# Do you have nightly builds?

We offer nightly builds for DisCatSharp. They contain bugfixes and new features before the official NuGet releases, however they are
not guaranteed to be stable, or work at all.
Open the NuGet interface for your project, check **Prerelease**.

Then just select **Latest prerelease** version of DisCatSharp packages, and install them.

You might need to restart Visual Studio for changes to take effect.

If you find any problems in the nightly versions of the packages, please follow the instructions in [Reporting issues](xref:misc_reporting_issues)
article.

# But I&apos;m running GNU/Linux, Mac OS X, or BSD!

If you&apos;re running on a non-Windows OS, you&apos;ll have to get your hands dirty. Prepare your text editor and file browser.

Run `dotnet restore`, it should be able to restore the packages without problems.

# Do you have direct builds from the main branch?

Yes we do!

To use them, follow these instructions:

```bash
# Register Registry
dotnet nuget add source https://registry.aitsys-infra.tools/nuget/discatsharp-git-releases/index.json -n discatsharp-git-releases -u bytesafe -p 01HJ80HC4S65ADXD4H5SANV23E --store-password-in-clear-text

# Restore from registry
dotnet restore -s discatsharp-git-releases -f --no-cache

# Disable Registry
dotnet nuget remove source discatsharp-git-releases
```

These releases are considered to not be stable at all. Use them with care.

And before you ask, the token is public 😉 We created a read-only account just for this registry.


 &gt;[!NOTE]
 &gt; To get the correct version, look at git, copy the target commit hash and select the corresponding version with {version}-{hash}
 &gt; As example: DisCatSharp: 10.5.0-97ac8e24f400b6053da7e6e4b3dea338eaf1bdef
 &gt; The easiest way to do this is to install any version and modify the .csproj file afterwards.</file><file path="DisCatSharp.Docs/articles/misc/reporting_issues.md">---
uid: misc_reporting_issues
title: Reporting Issues
author: DisCatSharp Team
---

# I broke something, and I need it fixed!

We always try to fix bugs, and make sure that when we release the next version of DisCatSharp, everything is polished and
working. However, DisCatSharp is a large codebase, and we can&apos;t always catch all the bugs, or notice all the regressions
that happen while we fix bugs or implement new issues.

## Issue tracker

If you find a bug, come up with a new idea, or just want to report something, you have multiple ways to do so.

[Discord Guild](https://discord.gg/RXA6u3jxdU &quot;DisCatSharp Support Guild&quot;).
[Issue Tracker](https://github.com/Aiko-IT-Systems/DisCatSharp/issues/new/choose &quot;DisCatSharp Issues&quot;).

When reporting an issue, make sure to include as much detail as possible. If at all possible, please include:

-   Steps to reproduce the issue
-   What were you trying to achieve
-   Expected/actual result
-   Stack traces, exception types, messages
-   Attempted solutions

## Contributing

Lastly, while we understand that not everyone is an expert programmer, we would appreciate it if you could fix any issues you
find and submit a Pull Request on GitHub. This would reduce the amount of work we would have to do.

When contributing, ensure your code matches the style of the rest of the library, and that you test the changes you make, and
catch any possible regressions.</file><file path="DisCatSharp.Docs/articles/misc/sentry.md">---
uid: misc_sentry
title: Sentry
author: DisCatSharp Team
---

# Sentry Integration in DisCatSharp

## Overview

Sentry is an error tracking tool that helps developers monitor and fix crashes in real-time. In DisCatSharp, Sentry is utilized to report and analyze errors and missing fields, ensuring a more robust and reliable library.

## How Sentry is Used in DisCatSharp

The Sentry integration in DisCatSharp is configured to capture and report exceptions, missing fields, and other critical information. This data helps developers identify and fix issues promptly. The integration is controlled by several configuration options within the `DiscordConfiguration` class.

## Configuration Options

The following configuration options are available for Sentry, and they are all **disabled** or set to **null** by default:

-   **ReportMissingFields**: Determines whether to report missing fields for Discord objects. This is useful for library development.

    ```csharp
    public bool ReportMissingFields { internal get; set; } = false;
    ```

-   **EnableSentry**: Enables the Sentry integration.

    ```csharp
    public bool EnableSentry { internal get; set; } = false;
    ```

-   **AttachRecentLogEntries**: If enabled, attaches the recent log entries.

    &gt; [!IMPORTANT]
    &gt; Please be mindful about how much information you log, if you enabled this. We might be able to see unwanted things.

    ```csharp
    public bool AttachRecentLogEntries { internal get; set; } = false;
    ```

-   **AttachUserInfo**: If enabled, attaches the bot&apos;s username and ID to Sentry reports to help pinpoint problems.

    ```csharp
    public bool AttachUserInfo { internal get; set; } = false;
    ```

-   **FeedbackEmail**: An email address that can be used to reach out when the bot encounters library bugs. It is only transmitted if `AttachUserInfo` is enabled.

    ```csharp
    public string? FeedbackEmail { internal get; set; } = null;
    ```

-   **DeveloperUserId**: The Discord user ID for contacting the developer when the bot encounters library bugs. It is only transmitted if `AttachUserInfo` is enabled.

    ```csharp
    public ulong? DeveloperUserId { internal get; set; } = null;
    ```

-   **EnableDiscordIdScrubber**: Optional, whether to additionally scrub discord-based ids from logs. Defaults to `false` since that isn&apos;t needed in most cases. Set it to `true` if you want additional filtering.
    ```csharp
    public bool EnableDiscordIdScrubber { internal get; set; } = false;
    ```

## Data Transmitted to Sentry

When an error or missing field is detected, the following data is transmitted to Sentry:

1. **Event Metadata**: Includes SDK information, event ID, and timestamps.

    ```json
    {
    	&quot;sdk&quot;: {
    		&quot;name&quot;: &quot;sentry.dotnet&quot;,
    		&quot;version&quot;: &quot;4.5.0&quot;
    	},
    	&quot;event_id&quot;: &quot;d9d303e3d75d400e992e1b1d7aef6641&quot;,
    	&quot;timestamp&quot;: &quot;2024-05-16T19:58:31.6006568+00:00&quot;
    }
    ```

2. **Exception Details**: Information about the exception, including the type, value, module, and stack trace.

    ```json
    {
    	&quot;exception&quot;: {
    		&quot;values&quot;: [
    			{
    				&quot;type&quot;: &quot;DisCatSharp.Exceptions.BadRequestException&quot;,
    				&quot;value&quot;: &quot;Bad request: BadRequest&quot;,
    				&quot;module&quot;: &quot;DisCatSharp, Version=10.6.3.0, Culture=neutral, PublicKeyToken=null&quot;,
    				&quot;stacktrace&quot;: {
    					&quot;frames&quot;: [
    						{
    							&quot;filename&quot;: &quot;Entities\\Command.cs&quot;,
    							&quot;function&quot;: &quot;async Task&lt;CommandResult&gt; Command.ExecuteAsync(CommandContext ctx)&quot;,
    							&quot;lineno&quot;: 100
    						}
    					]
    				}
    			}
    		]
    	}
    }
    ```

3. **Breadcrumbs**: Log entries leading up to the error, providing context for the issue.

    ```json
    {
    	&quot;breadcrumbs&quot;: [
    		{
    			&quot;timestamp&quot;: &quot;2024-05-16T19:58:09.814Z&quot;,
    			&quot;message&quot;: &quot;Release notes disabled by config&quot;,
    			&quot;category&quot;: &quot;DisCatSharp.BaseDiscordClient&quot;
    		}
    	]
    }
    ```

4. **User Information**: If `AttachUserInfo` is enabled, the bot&apos;s username, ID, and developer contact details.
    ```json
    {
    	&quot;user&quot;: {
    		&quot;id&quot;: &quot;822242444070092860&quot;,
    		&quot;username&quot;: &quot;nyuw#7780&quot;,
    		&quot;ip_address&quot;: &quot;{{auto}}&quot;,
    		&quot;other&quot;: {
    			&quot;developer&quot;: &quot;856780995629154305&quot;,
    			&quot;email&quot;: &quot;aiko@aitsys.dev&quot;
    		}
    	}
    }
    ```

## Ensuring User Privacy

No sensitive data, such as tokens or user messages, is logged or transmitted to Sentry. The only potentially sensitive data included are the bot&apos;s username and ID, which are only sent if explicitly enabled in the configuration. Additionally, steps have been taken to ensure that log lines sent with bad request reports do not contain sensitive information.

Furthermore, while the JSON payload includes the field `&quot;ip_address&quot;: &quot;{{auto}}&quot;`, no actual IP addresses are transmitted.

## Client-Side Filters

To enhance safety and ensure no sensitive information is leaked, various filters have been implemented on the client side:

1. **StripTokens Utility**: This utility function removes any Discord-based tokens from strings before they might be sent to Sentry.

    ```csharp
    public static string? StripTokens(string? str)
    {
       if (string.IsNullOrWhiteSpace(str))
          return str;

       str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
       str = Regex.Replace(str, @&quot;(mfa\\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);

       return str;
    }
    ```

2. **StripIds Utility**: This utility function removes any Discord-based tokens from strings before they might be sent to Sentry.

    ```csharp
    public static string? StripIds(string? str, bool strip)
    {
    	if (string.IsNullOrWhiteSpace(str) || !strip)
    		return str;

    	str = DiscordRegEx.IdRegex().Replace(str, &quot;{DISCORD_ID}&quot;);

    	return str;
    }
    ```

3. **Breadcrumb Filter**: Filters out sensitive information from breadcrumb logs before sending them to Sentry.

    ```csharp
    options.SetBeforeBreadcrumb(b
    =&gt; new(Utilities.StripIds(Utilities.StripTokens(b.Message), this.Configuration.EnableDiscordIdScrubber)!,
    	b.Type!,
    	b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripIds(Utilities.StripTokens(x.Value), this.Configuration.EnableDiscordIdScrubber)!))
          b.Category,
          b.Level));
    ```

4. **Transaction Filter**: Ensures that sensitive information is not included in transaction data sent to Sentry.

    ```csharp
    options.SetBeforeSendTransaction(tr =&gt;
    {
       if (tr.Request.Data is string str)
          tr.Request.Data = Utilities.StripIds(Utilities.StripTokens(str), this.Configuration.EnableDiscordIdScrubber);

       return tr;
    });
    ```

By maintaining these practices, DisCatSharp ensures user privacy while leveraging Sentry to improve the library&apos;s reliability and performance.

For more information on configuring and using Sentry in DisCatSharp, refer to the official [announcement](https://docs.dcs.aitsys.dev/changelogs/v10/10_6_0#sentry-integration).</file><file path="DisCatSharp.Docs/articles/misc/voice_activities.md">---
uid: misc_voice_activities
title: Voice Activities
author: DisCatSharp Team
---

# Voice Activities

&gt; [!WARNING]
&gt; This list is not maintained.
&gt; Please refer to https://github.com/Delitefully/DiscordLists/blob/master/activities.md instead.

Discord offers a variety of Voice activities. Here is a list of the applications that are currently usable in production.

| Application ID      | Application Name     | Boost level | Max participants |
| ------------------- | -------------------- | ----------- | ---------------- |
| 880218394199220334  | Watch Together       | 0           | Unlimited        |
| 755827207812677713  | Poker Night          | 1           | 25               |
| 773336526917861400  | Betrayal.io          | 0           | Unlimited        |
| 814288819477020702  | Fishington.io        | 0           | Unlimited        |
| 832012774040141894  | Chess In The Park    | 1           | Unlimited        |
| 902271654783242291  | Sketch Heads         | 0           | 16               |
| 879863686565621790  | Letter League        | 1           | 0                |
| 879863976006127627  | Word Snacks          | 0           | 8                |
| 852509694341283871  | SpellCast            | 1           | 100              |
| 832013003968348200  | Checkers In The Park | 1           | Unlimited        |
| 832025144389533716  | Blazing 8s           | 1           | 8                |
| 945737671223947305  | Putt Party           | 1           | Unlimited        |
| 903769130790969345  | Land-io              | 1           | 16               |
| 947957217959759964  | Bobble League        | 1           | 8                |
| 976052223358406656  | Ask Away             | 1           | 10               |
| 950505761862189096  | Know What I Meme     | 1           | 8                |
| 1006584476094177371 | Bash Out             | 1           | 16               |</file><file path="DisCatSharp.Docs/articles/modules/application_commands/cooldowns.md">---
uid: modules_application_commands_cooldowns
title: Cooldowns
author: DisCatSharp Team
hasDiscordComponents: true
---

## Cooldown Attribute

You can apply cooldowns to your application commands with the @DisCatSharp.ApplicationCommands.Attributes.SlashCommandCooldownAttribute &amp; @DisCatSharp.ApplicationCommands.Attributes.ContextMenuCooldownAttribute.

The cooldown attributes consists of three required parameters and one optional parameter.

- `int maxUses` - The number of times a command can be used during the definied time before being put on cooldown.
- `double resetAfter` - After how many seconds the cooldown resets.
- `CooldownBucketType bucketType` - The [type](xref:DisCatSharp.Enums.Core.CooldownBucketType) of bucket to use. Can be combined.

## Usage

```cs
// We create a slash command which sends a meow to the channel. This command can be executed twice every 40 seconds per channel.
[SlashCommand(&quot;meow&quot;, &quot;Meow at chat&quot;), SlashCommandCooldown(2, 40, CooldownBucketType.Channel)]
public async Task MeowAsync(InteractionContext ctx)
{
    await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Meow!&quot;));
}
```

### Visual Example

Please note that the timestamp would show the actual time of the cooldown reset.
We can&apos;t dynamically change the timestamp in the example, so we just use a static one.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; ephemeral&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Error: Ratelimit hit&lt;br/&gt;Try again &lt;discord-time timestamp=&quot;1894912612&quot; format=&quot;R&quot;&gt;&lt;/discord-time&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Customizing the cooldown hit response

You can customize the response that is sent when a user hits a cooldown by creating a custom class which inherits from [ICooldownResponder](xref:DisCatSharp.ApplicationCommands.Entities.ICooldownResponder).

```cs
public sealed class CooldownResponse : ICooldownResponder
{
    /// &lt;inheritdoc /&gt;
    public async Task Responder(BaseContext context)
    {
        await context.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;You hit a cooldown! Try again later.&quot;).AsEphemeral());
    }
}
```

You can then apply this to your command by using the `cooldownResponderType` property on the attribute.

```cs
[SlashCommand(&quot;meow&quot;, &quot;Meow at chat&quot;), SlashCommandCooldown(2, 40, CooldownBucketType.Channel, typeof(CooldownResponse))]
public async Task CooldownTestAsync(InteractionContext ctx)
{
    await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Meow!&quot;));
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; ephemeral&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        You hit a cooldown! Try again later.
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/application_commands/events.md">---
uid: modules_application_commands_events
title: Application Commands Events
---

# Application Commands events

Sometimes we need to add a variety of actions and checks before and after executing a command.
We can do this in the commands itself, or we can use special events for this.

## Before execution

The simplest example in this case: checking if the command was executed within the guild.
Suppose we have a certain class with commands that must be executed ONLY in the guilds:

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    [SlashCommand(&quot;mute&quot;, &quot;Mute user.&quot;)]
    public static async Task Mute(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;kick&quot;, &quot;Kick user.&quot;)]
    public static async Task Kick(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;ban&quot;, &quot;Ban user.&quot;)]
    public static async Task Ban(InteractionContext ctx)
    {

    }
}
```

In this case, the easiest way would be to override the method from [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    public override async Task&lt;bool&gt; BeforeSlashExecutionAsync(InteractionContext ctx)
    {
        if (ctx.Guild == null)
            return false;
    }

    [SlashCommand(&quot;mute&quot;, &quot;Mute user.&quot;)]
    public static async Task Mute(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;kick&quot;, &quot;Kick user.&quot;)]
    public static async Task Kick(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;ban&quot;, &quot;Ban user.&quot;)]
    public static async Task Ban(InteractionContext ctx)
    {

    }
}
```

Now, before executing any of these commands, the `BeforeSlashExecutionAsync` method will be executed. You can do anything in it, for example, special logging.
If you return `true`, then the command method will be executed after that, otherwise the execution will end there.

## After execution

If you want to create actions after executing the command, then you need to do the same, but override a different method:

```cs
public override async Task AfterSlashExecutionAsync(InteractionContext ctx)
{
    // some actions
}
```

## Context menus

You can also add similar actions for the context menus. But this time, you need to override the other methods:

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    public override async Task&lt;bool&gt; BeforeContextMenuExecutionAsync(ContextMenuContext ctx)
    {
        if (ctx.Guild == null)
            return false;
    }
    public override async Task AfterContextMenuExecutionAsync(ContextMenuContext ctx)
    {
        // some actions
    }
}
```

## Error handling

If you want to handle errors for slash commands, subscribe to the [SlashCommandErrored](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.SlashCommandErrored) event.

A separate event exists for context menus as [ContextMenuErrored](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.ContextMenuErrored) event.

It contains a castable field `Exception` with the exception that was thrown during the execution of the command.

As example it can be a type of [SlashExecutionChecksFailedException](xref:DisCatSharp.ApplicationCommands.Exceptions.SlashExecutionChecksFailedException) or [ContextMenuExecutionChecksFailedException](xref:DisCatSharp.ApplicationCommands.Exceptions.ContextMenuExecutionChecksFailedException) which contains a list of failed checks.</file><file path="DisCatSharp.Docs/articles/modules/application_commands/intro.md">---
uid: modules_application_commands_intro
title: Application Commands Introduction
---

&gt;[!NOTE]
&gt; This article assumes you&apos;ve recently read the article on *[writing your first bot](xref:getting_started_first_bot)*.

# Introduction to Application Commands
Discord provides built-in commands called: *Application Commands*.&lt;br/&gt;
Be sure to install the `DisCatSharp.ApplicationCommands` package from NuGet before continuing.

At the moment it is possible to create such commands:
- Slash commands
- User context menu commands
- Message context menu commands

## Writing an Application Commands

### Creation of the first commands

Each command is a method with the attribute [SlashCommand](xref:DisCatSharp.ApplicationCommands.Attributes.SlashCommandAttribute) or [ContextMenu](xref:DisCatSharp.ApplicationCommands.Attributes.ContextMenuAttribute). They must be in classes that inherit from [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).
Also, the first argument to the method must be [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext) or [ContextMenuContext](xref:DisCatSharp.ApplicationCommands.Context.ContextMenuContext).

Simple slash command:
```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public async Task MySlashCommand(InteractionContext ctx)
    {

    }
}
```

Simple context menu command:
```cs
public class MySecondCommand : ApplicationCommandsModule
{
    [ContextMenu(ApplicationCommandType.User, &quot;My Command&quot;)]
    public async Task MyContextMenuCommand(ContextMenuContext ctx)
    {

    }
}
```

Now let&apos;s add some actions to the commands, for example, send a reply:
```cs
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
{
    Content = &quot;Hello :3&quot;
});
```

If the command will be executed for more than 3 seconds, we must response at the beginning of execution and edit it at the end.
```cs
await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder());

await Task.Delay(5000); // Simulating a long command execution.

await ctx.EditResponseAsync(new DiscordWebhookBuilder()
{
    Content = &quot;Hello :3&quot;
});
```

&gt;[!NOTE]
&gt; Note that you can make your commands static, but then you cannot use [Dependency Injection](xref:modules_commandsnext_dependency_injection) in them.


### Registration of commands

After writing the commands, we must register them. For this we need a [DiscordClient](xref:DisCatSharp.DiscordClient).

```cs
var appCommands = client.UseApplicationCommands();

appCommands.RegisterGlobalCommands&lt;MyCommand&gt;();
appCommands.RegisterGlobalCommands&lt;MySecondCommand&gt;();
```
Simple, isn&apos;t it? You can register global and guild commands.
Global commands will be available on all guilds of which the bot is a member. Guild commands will only appear in a specific guild.

To register guild commands, it is enough to specify the Id of the guild as the first argument of the registration method.

```cs
var appCommands = client.UseApplicationCommands();

appCommands.RegisterGuildCommands&lt;MyCommand&gt;(&lt;guildId&gt;);
appCommands.RegisterGuildCommands&lt;MySecondCommand&gt;(&lt;guildId&gt;);
```

## Command Groups

Sometimes we may need to combine slash commands into groups.
In this case, we need to wrap our class with commands in another class and add the [SlashCommandGroup](xref:DisCatSharp.ApplicationCommands.Attributes.SlashCommandGroupAttribute) attribute.

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommandGroup(&quot;my_command&quot;, &quot;This is description of the command group.&quot;)]
    public class MyCommandGroup : ApplicationCommandsModule
    {
        [SlashCommand(&quot;first&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySlashCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is first subcommand.&quot;
            });
        }
        [SlashCommand(&quot;second&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySecondCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is second subcommand.&quot;
            });
        }
    }
}
```

Commands will now be available via `/my_command first` and `/my_command second`.
Also, note that both classes must inherit [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).</file><file path="DisCatSharp.Docs/articles/modules/application_commands/modals.md">---
uid: modules_application_commands_modals
title: Modals
---

# Modals

**The package `DisCatSharp.Interactivity` is required for this to work.**

You probably heard about the modal feature in Discord. It&apos;s a new feature that allows you to create a popup window that can be used to ask for information from the user. This is a great way to create a more interactive user experience.

The code below shows an example application command on how this could look.

```cs
using DisCatSharp.Interactivity;
using DisCatSharp.Interactivity.Enums;
using DisCatSharp.Interactivity.Extensions;
```

```cs
[SlashCommand(&quot;modals&quot;, &quot;A modal!&quot;)]
public async Task SendModalAsync(InteractionContext ctx)
{
	DiscordInteractionModalBuilder builder = new DiscordInteractionModalBuilder();
	builder.WithCustomId(&quot;modal_test&quot;);
	builder.WithTitle(&quot;Modal Test&quot;);
	builder.AddTextComponent(new DiscordTextComponent(TextComponentStyle.Paragraph, label: &quot;Some input&quot;, required: false));

    await ctx.CreateModalResponseAsync(builder);
	var res = await ctx.Client.GetInteractivity().WaitForModalAsync(builder.CustomId, TimeSpan.FromMinutes(1));

	if (res.TimedOut)
		return;

	await res.Result.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(res.Result.Interaction.Data.Components?.First()?.Value ?? &quot;Nothing was submitted.&quot;));
}
```</file><file path="DisCatSharp.Docs/articles/modules/application_commands/options.md">---
uid: modules_application_commands_options
title: Application Commands Options
---

# Slash Commands options
For slash commands, you can create options. They allow users to submit additional information to commands.

Command options can be of the following types:
- string
- int
- long
- double
- bool
- [DiscordUser](xref:DisCatSharp.Entities.DiscordUser)
- [DiscordRole](xref:DisCatSharp.Entities.DiscordRole)
- [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel)
- [DiscordAttachment](xref:DisCatSharp.Entities.DiscordAttachment)
- mentionable (ulong)
- Enum

## Basic usage

&gt;[!NOTE]
&gt;Options can only be added in the slash commands. Context menus do not support this!

All of options must contain the [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute) attribute.
They should be after [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext).

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;argument&quot;, &quot;This is description of the option.&quot;)] string firstParam)
    {
        await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
        {
            Content = firstParam
        });
    }
}
```

## Choices
Sometimes, we need to allow users to choose from several pre-created options.
We can of course add a string or long parameter and let users guess the options, but why when we can make things more convenient?

We have 3 ways to make choices:
- Enums
- [Choice Attribute](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute)
- [Choice Providers](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider)

### Enums

This is the easiest option. We just need to specify the required Enum as a command parameter.

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;enum_param&quot;, &quot;Description&quot;)] MyEnum enumParameter)
    {

    }
}

public enum MyEnum
{
    FirstOption,
    SecondOption
}
```

In this case, the user will be shown this as options: `FirstOption` and `SecondOption`.
Therefore, if you want to define different names for options without changing the Enum, you can add a special attribute:
```cs
public enum MyEnum
{
    [ChoiceName(&quot;First option&quot;)]
    FirstOption,
    [ChoiceName(&quot;Second option&quot;)]
    SecondOption
}
```

### Choice Attribute

With this way, you can get rid of unnecessary conversions within the command.
To do this, you need to add one or more [Choice Attributes](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute) before the [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute) attribute
```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Choice(&quot;First option&quot;, 1)] [Choice(&quot;Second option&quot;, 2)] [Option(&quot;option&quot;, &quot;Description&quot;)] long firstParam)
{

}
```

As the first parameter, [Choice](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute) takes a name that will be visible to the user, and the second - a value that will be passed to the command.
You can also use strings.

### Choice Provider

Perhaps the most difficult way. It consists in writing a method that will generate a list of options when registering commands.
This way we don&apos;t have to list all of them in the code when there are many of them.

To create your own provider, you need to create a class that inherits [IChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider) and contains the `Provider()` method.
```cs
public class MyChoiceProvider : IChoiceProvider
{
    public Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider()
    {

    }
}
```

As seen above, the method should return a list of [DiscordApplicationCommandOptionChoice](xref:DisCatSharp.Entities.DiscordApplicationCommandOptionChoice).

Now we need to create a list and add items to it:
```cs
var options = new List&lt;DiscordApplicationCommandOptionChoice&gt;
{
    new DiscordApplicationCommandOptionChoice(&quot;First option&quot;, 1),
    new DiscordApplicationCommandOptionChoice(&quot;Second option&quot;, 2)
};

return Task.FromResult(options.AsEnumerable());
```

Of course you can generate this list as you like. The main thing is that the method should return this list.

Now let&apos;s add our new provider to the command.


```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [ChoiceProvider(typeof(MyChoiceProvider))] [Option(&quot;option&quot;, &quot;Description&quot;)] long option)
{

}
```

All the code that we got:
```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [ChoiceProvider(typeof(MyChoiceProvider))] [Option(&quot;option&quot;, &quot;Description&quot;)] long option)
    {

    }
}

public class MyChoiceProvider : IChoiceProvider
{
    public Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider()
    {
        var options = new List&lt;DiscordApplicationCommandOptionChoice&gt;
        {
            new DiscordApplicationCommandOptionChoice(&quot;First option&quot;, 1),
            new DiscordApplicationCommandOptionChoice(&quot;Second option&quot;, 2)
        };

        return Task.FromResult(options.AsEnumerable());
    }
}
```

That&apos;s all, for a better example for [ChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider) refer to the examples.

## Autocomplete
Autocomplete works in the same way as ChoiceProvider, with one difference:
the method that creates the list of choices is triggered not once when the commands are registered, but whenever the user types a command.
It is advisable to use this method exactly when you have a list that will be updated while the bot is running.
In other cases, when the choices will not change, it is advisable to use the previous methods.

Creating an autocomplete is similar to creating a ChoiceProvider with a few changes:
```cs
public class MyAutocompleteProvider : IAutocompleteProvider
{
    public async Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext ctx)
    {
        var options = new List&lt;DiscordApplicationCommandAutocompleteChoice&gt;
        {
            new DiscordApplicationCommandAutocompleteChoice(&quot;First option&quot;, 1),
            new DiscordApplicationCommandAutocompleteChoice(&quot;Second option&quot;, 2)
        };

        return Task.FromResult(options.AsEnumerable());
    }
}
```

The changes are that instead of [IChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider), the class inherits [IAutocompleteProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IAutocompleteProvider), and the Provider method should return a list with [DiscordApplicationCommandAutocompleteChoice](xref:DisCatSharp.Entities.DiscordApplicationCommandAutocompleteChoice).

Now we add it to the command:
```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Autocomplete(typeof(MyAutocompleteProvider))] [Option(&quot;option&quot;, &quot;Description&quot;, true)] long option)
{

}
```

Note that we have not only replaced [ChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceProviderAttribute) with [Autocomplete](xref:DisCatSharp.ApplicationCommands.Attributes.AutocompleteAttribute), but also added `true` to [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute).

## Channel types

Sometimes we may need to give users the ability to select only a certain type of channels, for example, only text, or voice channels.

This can be done by adding the [ChannelTypes](xref:DisCatSharp.ApplicationCommands.Attributes.ChannelTypesAttribute) attribute to the option with the [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) type.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;You can select only text channels.&quot;), ChannelTypes(ChannelType.Text)] DiscordChannel channel)
{

}
```

This will make it possible to select only text channels.

## MinimumValue / MaximumValue Attribute

Sometimes we may need to give users the ability to select only a certain range of values.

This can be done by adding the [MinimumValue](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumValueAttribute) and [MaximumValue](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumValueAttribute) attribute to the option.
It can be used only for the types `double`, `int` and `long` tho.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;number&quot;, &quot;You can select only a certain range.&quot;), MinimumValue(50), MaximumValue(100)] int numbers)
{

}
```

## MinimumLength / MaximumLength Attribute

Sometimes we may need to limit the user to a certain string length.

This can be done by adding the [MinimumLength](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumLengthAttribute) and [MaximumLength](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumLengthAttribute) attribute to the option.
It can be used only for the type `string`.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;text&quot;, &quot;You can only send text with a length between 10 and 50 characters.&quot;), MinimumLength(10), MaximumLength(50)] string text)
{

}
```</file><file path="DisCatSharp.Docs/articles/modules/application_commands/paginated_modals.md">---
uid: modules_application_commands_paginated_modals
title: Paginated Modals
---

# Paginated Modals

**The package `DisCatSharp.Interactivity` is required for this to work.**

You may need multi-step modals to collect a variety of information from a user. We implemented an easy way of doing this with paginated modals.
You simply construct all your modals, call `DiscordInteraction.CreatePaginatedModalResponseAsync` and you&apos;re good to go. After the user submitted all modals, you&apos;ll get back a `PaginatedModalResponse` which has a `TimedOut` bool, the `DiscordInteraction` that was used to submit the last modal and a `IReadOnlyDictionary&lt;string, string&gt;` with the component custom ids as key.

The code below shows an example application command on how this could look.

```cs
using DisCatSharp.Interactivity;
using DisCatSharp.Interactivity.Enums;
using DisCatSharp.Interactivity.Extensions;
```

```cs
[SlashCommand(&quot;paginated-modals&quot;, &quot;Paginated modals!&quot;)]
public async Task PaginatedModals(InteractionContext ctx)
{
    _ = Task.Run(async () =&gt;
    {
        var responses = await ctx.Interaction.CreatePaginatedModalResponseAsync(
            new List&lt;ModalPage&gt;()
            {
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;First Title&quot;)
                    .AddModalComponents(new DiscordTextComponent(TextComponentStyle.Small, &quot;title&quot;, &quot;Title&quot;, &quot;Name&quot;, 0, 250, false))),
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;Second Title&quot;)
                    .AddModalComponents(new DiscordTextComponent(TextComponentStyle.Small, &quot;title1&quot;, &quot;Next Modal&quot;, &quot;Some value here&quot;))
                    .AddModalComponents(new DiscordTextComponent(TextComponentStyle.Paragraph, &quot;description1&quot;, &quot;Some bigger thing here&quot;, required: false))),
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;Third Title&quot;)
                    .AddModalComponents(new DiscordTextComponent(TextComponentStyle.Small, &quot;title2&quot;, &quot;Title2&quot;, &quot;Even more here&quot;, 0, 250, false))
                    .AddModalComponents(new DiscordTextComponent(TextComponentStyle.Paragraph, &quot;description2&quot;, &quot;and stuff here&quot;, required: false))),
            });

        // If the user didn&apos;t submit all modals, TimedOut will be true. We return the command as there is nothing to handle.
        if (responses.TimedOut)
            return;

        // We simply throw all response into the Console, you can do whatever with this.
        foreach (var b in responses.Responses)
            Console.WriteLine(b.ToString());

        // We use EditOriginalResponseAsync here because CreatePaginatedModalResponseAsync responds to the last modal with a thinking state.
        await responses.Interaction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Success&quot;));
    });
}
```</file><file path="DisCatSharp.Docs/articles/modules/application_commands/translations/reference.md">---
uid: modules_application_commands_translations_reference
title: Translation Reference
---

# Translation Reference

&gt; [!NOTE]
&gt; DisCatSharp uses [JSON](https://www.json.org) to inject the translations of [Application Commands](https://discord.com/developers/docs/interactions/application-commands).

## Command Object

| Key                       | Value                                         | Description                                                                                                 |
| ------------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| name                      | string                                        | name of the application command                                                                             |
| description?              | string                                        | description of the application command                                                                      |
| type                      | int                                           | [type](#application-command-type) of application command, used to map command types, not valid for options  |
| name_translations         | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command name                                       |
| description_translations? | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command description, only valid for slash commands |
| options                   | array of [Option Objects](#option-object)     | array of option objects containing translations                                                             |

### Application Command Type

| Type                         | Value |
| ---------------------------- | ----- |
| Slash Command                | 1     |
| User Context Menu Command    | 2     |
| Message Context Menu Command | 3     |

## Command Group Object

| Key                      | Value                                                           | Description                                                                                                |
| ------------------------ | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| name                     | string                                                          | name of the application command group                                                                      |
| description              | string                                                          | description of the application command group                                                               |
| type                     | int                                                             | [type](#application-command-type) of application command, used to map command types, not valid for options |
| name_translations        | array of [Translation KVPs](#translation-kvp)                   | array of translation key-value-pairs for the application command group name                                |
| description_translations | array of [Translation KVPs](#translation-kvp)                   | array of translation key-value-pairs for the application command group description                         |
| commands                 | array of [Command Objects](#command-object)                     | array of command objects containing translations                                                           |
| groups                   | array of [Sub Command Group Objects](#sub-command-group-object) | array of sub command group objects containing translations                                                 |

## Sub Command Group Object

| Key                      | Value                                         | Description                                                                            |
| ------------------------ | --------------------------------------------- | -------------------------------------------------------------------------------------- |
| name                     | string                                        | name of the application command sub group                                              |
| description              | string                                        | description of the application command sub group                                       |
| name_translations        | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command sub group name        |
| description_translations | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command sub group description |
| commands                 | array of [Command Objects](#command-object)   | array of command objects containing translations                                       |

## Option Object

| Key                      | Value                                                   | Description                                                                         |
| ------------------------ | ------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| name                     | string                                                  | name of the application command option                                              |
| description              | string                                                  | description of the application command group                                        |
| name_translations        | array of [Translation KVPs](#translation-kvp)           | array of translation key-value-pairs for the application command option name        |
| description_translations | array of [Translation KVPs](#translation-kvp)           | array of translation key-value-pairs for the application command option description |
| choices                  | array of [Option Choice Objects](#option-choice-object) | array of option choice objects containing translations                              |

## Option Choice Object

| Key               | Value                                         | Description                                                                         |
| ----------------- | --------------------------------------------- | ----------------------------------------------------------------------------------- |
| name              | string                                        | name of the application command option choice                                       |
| name_translations | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command option choice name |

## Translation KVP

A translation object is a key-value-pair of `&quot;locale&quot;: &quot;value&quot;`.

### Example Translation Array:

```json
{
	&quot;en-US&quot;: &quot;Hello&quot;,
	&quot;de&quot;: &quot;Hallo&quot;
}
```

## Valid Locales

| Locale | Language               |
| ------ | ---------------------- |
| id     | Indonesian             |
| da     | Danish                 |
| de     | German                 |
| en-GB  | English, UK            |
| en-US  | English, US            |
| es-ES  | Spanish                |
| es-419 | Spanish, Latin America |
| fr     | French                 |
| hr     | Croatian               |
| it     | Italian                |
| lt     | Lithuanian             |
| hu     | Hungarian              |
| nl     | Dutch                  |
| no     | Norwegian              |
| pl     | Polish                 |
| pt-BR  | Portuguese, Brazilian  |
| ro     | Romanian, Romania      |
| fi     | Finnish                |
| sv-SE  | Swedish                |
| vi     | Vietnamese             |
| tr     | Turkish                |
| cs     | Czech                  |
| el     | Greek                  |
| bg     | Bulgarian              |
| ru     | Russian                |
| uk     | Ukrainian              |
| hi     | Hindi                  |
| th     | Thai                   |
| zh-CN  | Chinese, China         |
| ja     | Japanese               |
| zh-TW  | Chinese, Taiwan        |
| ko     | Korean                 |</file><file path="DisCatSharp.Docs/articles/modules/application_commands/translations/using.md">---
uid: modules_application_commands_translations_using
title: Using Translations
---

# Using Translations

## Why Do We Outsource Translation In External JSON Files

Pretty simple: It&apos;s common to have translations external stored.
This makes it easier to modify them, while keeping the code itself clean.

## Adding Translations

Translations are added the same way like permissions are added to Application Commands:

```cs
const string TRANSLATION_PATH = &quot;translations/&quot;;

Client.GetApplicationCommands().RegisterGuildCommands&lt;MyCommand&gt;(1215484634894646844, translations =&gt;
{
    string json = File.ReadAllText(TRANSLATION_PATH + &quot;my_command.json&quot;);

    translations.AddGroupTranslation(json);
});

Client.GetApplicationCommands().RegisterGuildCommands&lt;MySimpleCommands&gt;(1215484634894646844, translations =&gt;
{
    string json = File.ReadAllText(TRANSLATION_PATH + &quot;my_simple_command.json&quot;);

    translations.AddSingleTranslation(json);
});
```

&gt; [!WARNING]
&gt; If you add a translation to a class, you have to supply translations for every command in this class. Otherwise it will fail.

## Creating The Translation JSON

We split the translation in two categories.
One for slash command groups and one for normal slash commands and context menu commands.
The `name` key in the JSON will be mapped to the command / option / choice names internally.

### Translation For Slash Command Groups

Imagine, your class look like the following example:

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommandGroup(&quot;my_command&quot;, &quot;This is description of the command group.&quot;)]
    public class MyCommandGroup : ApplicationCommandsModule
    {
        [SlashCommand(&quot;first&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySlashCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is first subcommand.&quot;
            });
        }
        [SlashCommand(&quot;second&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySecondCommand(InteractionContext ctx, [Option(&quot;value&quot;, &quot;Some string value.&quot;)] string value)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is second subcommand. The value was &quot; + value
            });
        }
    }
}
```

The translation json is a object of [Command Group Objects](xref:modules_application_commands_translations_reference#command-group-object)
A correct translation json for english and german would look like that:

```json
[
	{
		&quot;name&quot;: &quot;my_command&quot;,
		&quot;description&quot;: &quot;This is description of the command group.&quot;,
		&quot;type&quot;: 1,
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;my_command&quot;,
			&quot;de&quot;: &quot;mein_befehl&quot;
		},
		&quot;description_translations&quot;: {
			&quot;en-US&quot;: &quot;This is description of the command group.&quot;,
			&quot;de&quot;: &quot;Das ist die description der Befehl Gruppe.&quot;
		},
		&quot;groups&quot;: [],
		&quot;commands&quot;: [
			{
				&quot;name&quot;: &quot;first&quot;,
				&quot;description&quot;: &quot;First&quot;,
				&quot;name_translations&quot;: {
					&quot;en-US&quot;: &quot;first&quot;,
					&quot;de&quot;: &quot;erste&quot;
				},
				&quot;description_translations&quot;: {
					&quot;en-US&quot;: &quot;This is description of the command.&quot;,
					&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
				}
			},
			{
				&quot;name&quot;: &quot;second&quot;,
				&quot;description&quot;: &quot;Second&quot;,
				&quot;name_translations&quot;: {
					&quot;en-US&quot;: &quot;second&quot;,
					&quot;de&quot;: &quot;zweite&quot;
				},
				&quot;description_translations&quot;: {
					&quot;en-US&quot;: &quot;This is description of the command.&quot;,
					&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
				},
				&quot;options&quot;: [
					{
						&quot;name&quot;: &quot;value&quot;,
						&quot;description&quot;: &quot;Some string value.&quot;,
						&quot;type&quot;: 3,
						&quot;name_translations&quot;: {
							&quot;en-US&quot;: &quot;value&quot;,
							&quot;de&quot;: &quot;wert&quot;
						},
						&quot;description_translations&quot;: {
							&quot;en-US&quot;: &quot;Some string value.&quot;,
							&quot;de&quot;: &quot;Ein string Wert.&quot;
						}
					}
				]
			}
		]
	}
]
```

### Translation For Slash Commands &amp; Context Menu Commands

Now imagine, that your class look like this example:

```cs
public class MySimpleCommands : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public async Task MySlashCommand(InteractionContext ctx)
    {

    }

    [ContextMenu(ApplicationCommandType.User, &quot;My Command&quot;)]
    public async Task MyContextMenuCommand(ContextMenuContext ctx)
    {

    }
}
```

The slash command is a simple [Command Object](xref:modules_application_commands_translations_reference#command-object).
Same goes for the context menu command, but note that it can&apos;t have a description.

Slash Commands has the [type](xref:modules_application_commands_translations_reference#application-command-type) `1` and context menu commands the [type](xref:modules_application_commands_translations_reference#application-command-type) `2` or `3`.
We use this to determine, where the translation belongs to.

Please note that the description field is optional. We suggest setting it for slash commands if you want to use our translation generator, which we&apos;re building right now.
Context menu commands can&apos;t have a description, so omit it.

A correct json for this example would look like that:

```json
[
	{
		&quot;name&quot;: &quot;my_command&quot;,
		&quot;description&quot;: &quot;This is description of the command.&quot;,
		&quot;type&quot;: 1, // Type 1 for slash command
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;my_command&quot;,
			&quot;de&quot;: &quot;mein_befehl&quot;
		},
		&quot;description_translations&quot;: {
			&quot;en-US&quot;: &quot;This is description of the command.&quot;,
			&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
		}
	},
	{
		&quot;name&quot;: &quot;My Command&quot;,
		&quot;type&quot;: 2, // Type 2 for user context menu command
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;My Command&quot;,
			&quot;de&quot;: &quot;Mein Befehl&quot;
		}
	}
]
```

## Available Locales

Discord has a limited choice of locales, in particular, the ones you can select in the client.
To see the available locales, visit [this](xref:modules_application_commands_translations_reference#valid-locales) page.

## Can We Get The User And Guild Locale?

Yes, you can!
Discord sends the user on all [interaction types](xref:DisCatSharp.Enums.InteractionType), except `Ping`.

We introduced two new properties `Locale` and `GuildLocale` on [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext), [ContextMenuContext](xref:DisCatSharp.ApplicationCommands.Context.ContextMenuContext), [AutoCompleteContext](xref:DisCatSharp.ApplicationCommands.Context.AutocompleteContext) and [DiscordInteraction](xref:DisCatSharp.Entities.DiscordInteraction).
`Locale` is the locale of the user and always represented.
`GuildLocale` is only represented, when the interaction is **not** in a DM.

Furthermore we cache known user locales on the [DiscordUser](xref:DisCatSharp.Entities.DiscordUser.Locale) object.</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/advanced.md">---
uid: modules_audio_lavalink_v4_advanced
title: Lavalink V4 Advanced
author: DisCatSharp Team
---

# Advanced Lavalink Usage

Given the new possibilities to use Lavalink with Spotify, Apple Music, Deezer and Yandex Music, we go a bit deeper into this topic here.

## Preamble

For this to work, you need the following plugin installed in your Lavalink server: https://github.com/topi314/LavaSrc

## Setup

General config:

```yml
lavalink:
  plugins:
    - dependency: &quot;com.github.topi314.lavasrc:lavasrc-plugin:4.3.0&quot;
      repository: &quot;https://maven.lavalink.dev/releases&quot;
[..]
plugins:
  lavasrc:
    providers: # Custom providers for track loading. This is the default
      - &quot;ytsearch:\&quot;%ISRC%\&quot;&quot; # Will be ignored if track does not have an ISRC. See https://esearch.wikipedia.org/wiki/International_Standard_Recording_Code
      - &quot;ytsearch:%QUERY%&quot; # Will be used if track has no ISRC or no track could be found for the ISRC
      - &quot;scsearch:%QUERY%&quot; # Soundcloud search provider
      - &quot;spsearch:%QUERY%&quot; # Spotify search provider
      - &quot;sprec:%QUERY%&quot; # Spotify recommendation search provider
      - &quot;ymsearch:%QUERY%&quot; # YouTube Music search provider
      - &quot;amsearch:%QUERY%&quot; # Apple Music search provider
      - &quot;dzisrc:%ISRC%&quot; # Deezer ISRC provider
      - &quot;dzsearch:%QUERY%&quot; # Deezer search provider
      - &quot;ymsearch:%QUERY%&quot; # Yandex Music search provider

    sources:
      spotify: true # Enable Spotify source
      applemusic: true # Enable Apple Music source
      deezer: true # Enable Deezer source
      yandexmusic: true # Enable Yandex Music source
```

### Spotify Setup

```yml
plugins:
  lavasrc:
[..]
    spotify:
        clientId: &quot;your client id&quot;
        clientSecret: &quot;your client secret&quot;
        countryCode: &quot;US&quot; # the country code you want to use for filtering the artists top tracks. See https://esearch.wikipedia.org/wiki/ISO_3166-1_alpha-2
        playlistLoadLimit: 6 # The number of pages at 100 tracks each
        albumLoadLimit: 6 # The number of pages at 50 tracks each
```

### Apple Music Setup

```yml
plugins:
  lavasrc:
[..]
    applemusic:
        countryCode: &quot;US&quot; # the country code you want to use for filtering the artists top tracks and language. See https://esearch.wikipedia.org/wiki/ISO_3166-1_alpha-2
        playlistLoadLimit: 6 # The number of pages at 100 tracks each
        albumLoadLimit: 6 # The number of pages at 50 tracks each
```

### Deezer Setup

```yml
plugins:
  lavasrc:
[..]
    deezer:
      masterDecryptionKey: &quot;your master decryption key&quot; # the master key used for decrypting the deezer tracks. (yes this is not here you need to get it from somewhere else)
```

### Yandex Music Setup

```yml
plugins:
  lavasrc:
[..]
    yandexmusic:
      accessToken: &quot;your access token&quot; # the token used for accessing the yandex music api. See https://github.com/topi314/LavaSrc#yandex-music
```

## Usage

### Client Configuration

You don&apos;t have to configure anything directly in DisCatSharp.Lavalink.

### Code Snippets

```cs
// We got the search as string from xy already
string search = &quot;spsearch:Shooting Stars&quot;;
// Node connection is already defined.
LavalinkNodeConnection nodeConnection;

// We set YouTube as default search type because it&apos;s the most common one.
var type = LavalinkSearchType.Youtube;
if (search.StartsWith(&quot;ytsearch:&quot;))
{
	search = search.Replace(&quot;ytsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.Youtube;
}
else if (search.StartsWith(&quot;scsearch:&quot;))
{
	search = search.Replace(&quot;ytsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.SoundCloud;
}
else if (search.StartsWith(&quot;spsearch:&quot;))
{
	search = search.Replace(&quot;spsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.Spotify;
}
else if (search.StartsWith(&quot;amsearch:&quot;))
{
	search = search.Replace(&quot;amsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.AppleMusic;
}

// This function gives us a result from Lavalink.
LavalinkLoadResult result = await guildPlayer.LoadTracksAsync(type, query);

// Internally Lavalink searches the Spotify api, and then searches YouTube for the result.
// We can now use the result and play the song.
// Same for Apple Music.
```

## Conclusion

This is the most basic example of how to use the new Lavalink features. You can find more information in the Lavalink plugin docs: https://github.com/topi314/LavaSrc?tab=readme-ov-file#lavalink-usage</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/commands.md">---
uid: modules_audio_lavalink_v4_commands
title: Lavalink V4 Commands
author: DisCatSharp Team
hasDiscordComponents: true
---

# Adding Music Commands

This article assumes that you know how to use ApplicationCommands. If you do not, you should learn [here](xref:modules_application_commands_intro) before continuing with this guide.

## Prerequisites

Before we start we will need to make sure ApplicationCommands is configured. For this we can make a simple configuration and command class:

```cs
using DisCatSharp.ApplicationCommands;
namespace FirstLavalinkBot;

public class MyFirstLavalinkCommands : ApplicationCommandsModule
{ }
```

Next up you gotta register the ApplicationCommands module:

```cs
ApplicationCommands = Discord.UseApplicationCommands();
// Either as a global command
ApplicationCommands.RegisterGlobalCommands&lt;MyFirstLavalinkCommands&gt;();
// Or as a guild command
ulong myGuildId = 858089281214087179;
ApplicationCommands.RegisterGuildCommands&lt;MyFirstLavalinkCommands&gt;(myGuildId);
```

## Adding base commands

Your bot, and Lavalink, will need to connect to a voice channel to play music.

Let&apos;s create the base for these commands:

```cs
[SlashCommand(&quot;join&quot;, &quot;Join a voice channel&quot;)]
public async Task JoinAsync(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;Channel to join&quot;)] DiscordChannel channel)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}

[SlashCommand(&quot;leave&quot;, &quot;Leave the voice channel&quot;)]
public async Task LeaveAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}
```

To get the Lavalink node we will need to use the `GetLavalink()` extension method on the DiscordClient. This will return a [LavalinkExtension](xref:DisCatSharp.Lavalink.LavalinkExtension) object, which contains a collection of connected sessions. Since we only have one node, we can use linq&apos;s `.First()` method on the extensions connected nodes to get what we need.

If we have the session, we can use the `ConnectAsync()` method to connect to the voice channel. This method will return a [LavalinkGuildPlayer](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) object, which we can use to play music. We will also need to check if the channel is a voice channel. If the guild player is already connected, the function will return the existing player.

So far, your command class should look something like this:

```cs
using System.Threading.Tasks;
using DisCatSharp;
using DisCatSharp.Entities;
using DisCatSharp.ApplicationCommands;
using DisCatSharp.ApplicationCommands.Context;
using DisCatSharp.ApplicationCommands.Attributes;
using DisCatSharp.Lavalink;
using DisCatSharp.Lavalink.Entities;
using DisCatSharp.Lavalink.Enums;
namespace FirstLavalinkBot;

public class MyFirstLavalinkCommands : BaseCommandModule
{
	[SlashCommand(&quot;join&quot;, &quot;Join a voice channel&quot;)]
	public async Task JoinAsync(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;Channel to join&quot;)] DiscordChannel channel)
	{
		await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
		var lavalink = ctx.Client.GetLavalink();
		if (!lavalink.ConnectedSessions.Any())
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;The Lavalink connection is not established&quot;));
			return;
		}

		var session = lavalink.ConnectedSessions.Values.First();

		if (channel.Type != ChannelType.Voice || channel.Type != ChannelType.Stage)
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Not a valid voice channel.&quot;));
			return;
		}

		await session.ConnectAsync(channel);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Joined {channel.Mention}!&quot;));
	}

	[SlashCommand(&quot;leave&quot;, &quot;Leave the voice channel&quot;)]
	public async Task LeaveAsync(InteractionContext ctx)
	{
		await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
		var lavalink = ctx.Client.GetLavalink();
		var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);
		if (guildPlayer == null)
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink not connected.&quot;));
			return;
		}

		await guildPlayer.DisconnectAsync();
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Left {guildPlayer.channel.Mention}!&quot;));
	}
}
```

## Adding playback commands

Now that we have the base commands, we can add the playback commands. For this we will need to get the Lavalink session, the guild connection, and the track details. We will also need to check if Lavalink is connected.

```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}
```
One of Lavalink&apos;s best features is its ability to search for tracks from a variety of media sources, such as YouTube, SoundCloud, Twitch, and more. This is what makes bots like Rythm, Fredboat, and Groovy popular

Lavalink can also play tracks directly from a media url. This is useful for playing tracks from other sources, such as Bandcamp, Vimeo, and more.

Like before, we will need to get our node and guild connection and have the appropriate checks. Since it wouldn&apos;t make sense to have the channel as a parameter, we will instead get it from the member&apos;s voice state:

```cs
// Important to check the voice state itself first, as it may throw a NullReferenceException if they don&apos;t have a voice state.
if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
{
	await ctx.RespondAsync(&quot;You are not in a voice channel.&quot;);
	return;
}

var lavalink = ctx.Client.GetLavalink();
var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

if (guildPlayer == null)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
	return;
}
```

```cs
var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);
```

The load result will contain an enum called `LoadResultType`, which will inform us if Lavalink was able to retrieve the track data. We can use this as a check:

```cs
// If something went wrong on Lavalink&apos;s end or it just couldn&apos;t find anything.
if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
	return;
}
```

Lavalink will return a dynamic result object. This object will contain the track data, as well as the type of result.

We can use the `LoadResultType` to determine what type of result we got. If we now the result type we need to specify the objects type.

A shorthand method exists as `GetResultAs&lt;T&gt;`:

```cs
LavalinkTrack track = loadResult.LoadType switch {
    LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
    LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
    LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().First(),
    _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
};
```

And finally, we can play the track:

```cs
await guildPlayer.PlayAsync(track);

await ctx.RespondAsync($&quot;Now playing {track.Title}!&quot;);
```

Your play command should look like this:
```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);

	if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
		return;
	}

	LavalinkTrack track = loadResult.LoadType switch {
        LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
        LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
        LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().Tracks.First(),
        _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
    };

	await guildPlayer.PlayAsync(track);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Now playing {query}!&quot;));
}
```

Being able to pause and resume the player is also useful. For this we can use most of the base from the play command:

```cs
[SlashCommand(&quot;pause&quot;, &quot;Pause a track&quot;)]
public async Task PauseAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}
}
```

For this command we will also want to check the player state to determine if we should send a pause command. We can do so by checking `guildPlayer.CurrentTrack`:

```cs
if (guildPlayer.CurrentTrack == null)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
	return;
}
```

And finally, we can call pause:

```cs
await guildPlayer.PauseAsync();
```

The equivalent for resume:

```cs
await guildPlayer.ResumeAsync();
```

The finished commands should look like so:
```cs
[SlashCommand(&quot;pause&quot;, &quot;Pause a track&quot;)]
public async Task PauseAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	if (guildPlayer.CurrentTrack == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
		return;
	}

	await guildPlayer.PauseAsync();
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Playback paused!&quot;));
}

[SlashCommand(&quot;resume&quot;, &quot;Resume a track&quot;)]
public async Task ResumeAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	if (guildPlayer.CurrentTrack == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
		return;
	}

	await guildPlayer.ResumeAsync();
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Playback resumed!&quot;));
}
```

Now we can use these commands to listen to music!

## Visual Example

&lt;discord-messages&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/join&quot;&gt;&lt;/discord-command&gt;
		Joined &lt;discord-mention type=&quot;voice&quot;&gt;Music&lt;/discord-mention&gt;!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/play&quot;&gt;&lt;/discord-command&gt;
		Now playing &lt;a target=&quot;_blank&quot; class=&quot;discord-link external&quot; href=&quot;https://youtu.be/38-cJT320aw&quot;&gt;https://youtu.be/38-cJT320aw&lt;/a&gt;!
		&lt;discord-embed
			slot=&quot;embeds&quot;
			provider=&quot;YouTube&quot;
            provider-url=&quot;https://www.youtube.com&quot;
			author-name=&quot;Raon&quot;
			author-url=&quot;https://www.youtube.com/channel/UCQn1FqrR2OCjSe6Nl4GlVHw&quot;
			color=&quot;#FF0000&quot;
			embed-title=&quot;Raon 라온 | ‘クネクネ (Wiggle Wiggle)’ M/V&quot;
			video=&quot;38-cJT320aw&quot;
			url=&quot;https://www.youtube.com/watch?v=38-cJT320aw&quot;
			image=&quot;https://cdn.aitsys.dev/file/data/kcrwt6baxsmr32rjnrdg/PHID-FILE-2w72lbyg6lrbstqo3geh/38-cJT320aw.jpg&quot;
		&gt;&lt;/discord-embed&gt;
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/pause&quot;&gt;&lt;/discord-command&gt;
		Playback paused!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/resume&quot;&gt;&lt;/discord-command&gt;
		Playback resumed!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/leave&quot;&gt;&lt;/discord-command&gt;
		Left &lt;discord-mention type=&quot;voice&quot;&gt;Music&lt;/discord-mention&gt;!
	&lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/configuration.md">---
uid: modules_audio_lavalink_v4_configuration
title: Lavalink V4 Configuration
author: DisCatSharp Team
---

# Setting up DisCatSharp.Lavalink

## Configuring Your Client

To begin using DisCatSharp&apos;s Lavalink client, you will need to add the `DisCatSharp.Lavalink` nuget package. Once installed, simply add these namespaces at the top of your bot file:
```cs
using DisCatSharp.Net;
using DisCatSharp.Lavalink;
```

After that, we will need to create a configuration for our extension to use. This is where the special values from the server configuration are used.
```cs
var endpoint = new ConnectionEndpoint
{
    Hostname = &quot;127.0.0.1&quot;, // From your server configuration.
    Port = 2333 // From your server configuration
};

var lavalinkConfig = new LavalinkConfiguration
{
    Password = &quot;youshallnotpass&quot;, // From your server configuration.
    RestEndpoint = endpoint,
    SocketEndpoint = endpoint
};
```
Finally, initialize the extension.
```cs
var lavalink = Discord.UseLavalink();
```

## Connecting with Lavalink

We are now ready to connect to the server. Call the Lavalink extension&apos;s connect method and pass the configuration. Make sure to call this **after** your Discord client connects. This can be called either directly after your client&apos;s connect method or in your client&apos;s ready event.

```cs
LavalinkNode = await Lavalink.ConnectAsync(lavalinkConfig);
```

Your main bot file should now look like this:

```cs
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using DisCatSharp;
using DisCatSharp.Net;
using DisCatSharp.Lavalink;
namespace FirstLavalinkBot;

public class Program
{
	public static DiscordClient Discord { get; internal set; }

	public static void Main(string[] args = null)
	{
		MainAsync(args).ConfigureAwait(false).GetAwaiter().GetResult();
	}

	public static async Task MainAsync(string[] args)
	{
		Discord = new DiscordClient(new DiscordConfiguration
		{
			Token = &quot;&lt;token_here&gt;&quot;,
			TokenType = TokenType.Bot,
			MinimumLogLevel = LogLevel.Debug
		});

		var endpoint = new ConnectionEndpoint
		{
			Hostname = &quot;127.0.0.1&quot;, // From your server configuration.
			Port = 2333 // From your server configuration
		};

		var lavalinkConfig = new LavalinkConfiguration
		{
			Password = &quot;youshallnotpass&quot;, // From your server configuration.
			RestEndpoint = endpoint,
			SocketEndpoint = endpoint
		};

		var lavalink = Discord.UseLavalink();

		await Discord.ConnectAsync();
		await lavalink.ConnectAsync(lavalinkConfig); // Make sure this is after Discord.ConnectAsync().

		await Task.Delay(-1);
	}
}
```
We are now ready to start the bot. If everything is configured properly, you should see a Lavalink connection appear in your DisCatSharp console:

```yml
[2020-10-10 17:56:07 -04:00] [403 /LavalinkSessionConnected] [Debug] Connection to Lavalink established UwU
```

And a client connection appear in your Lavalink console:

```yml
INFO 4436 --- [  XNIO-1 task-1] io.undertow.servlet                      : Initializing Spring DispatcherServlet &apos;dispatcherServlet&apos;
INFO 4436 --- [  XNIO-1 task-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &apos;dispatcherServlet&apos;
INFO 4436 --- [  XNIO-1 task-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.RequestLoggingFilter  : GET /version?trace=false, client=127.0.0.1
INFO 4436 --- [  XNIO-1 task-1] l.server.io.HandshakeInterceptorImpl     : Incoming connection from /127.0.0.1:54649
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.RequestLoggingFilter  : GET /v4/websocket, client=127.0.0.1
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.SocketServer          : Connection successfully established from DisCatSharp.Lavalink/10.6.6+38c8062e7f88b2e9920a535637d4f3afccbbf205
```

We are now ready to set up some music commands!</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/docker.md">---
uid: modules_audio_lavalink_v4_docker
title: Lavalink V4 Docker
author: DisCatSharp Team
---

# Template for running Lavalink in Docker

- Create a folder where you&apos;d save the lavalink config and plugins. I.e. `mkdir /opt/lavalink`.
- Follow the [Setup](xref:modules_audio_lavalink_v4_setup) instructions to create your `application.yml`. Make sure to set `0.0.0.0` as `address`.
- Save the `application.yml` in the created folder.
- Create a `docker-compose.yml` file like this and save it in the created folder:
```yml
services:
  lavalink:
    image: ghcr.io/lavalink-devs/lavalink:latest
    container_name: lavalink
    restart: unless-stopped
    environment:
      - _JAVA_OPTIONS=-Xmx6G
      - SERVER_PORT=2333
    volumes:
      - ./application.yml:/opt/Lavalink/application.yml
      - ./plugins/:/opt/Lavalink/plugins/
    networks:
      - lavalink
    expose:
      - 2333
    ports:
      - &quot;2333:2333&quot;
    extra_hosts:
      - &quot;host.docker.internal:host-gateway&quot;
networks:
  lavalink:
    name: lavalink
```
- Create a folder called `plugins` in the created folder.
- Run `docker compose up -d` to start lavalink</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/intro.md">---
uid: modules_audio_lavalink_v4_intro
title: Lavalink V4 Introduction
author: DisCatSharp Team
---

# Lavalink V4

Calling all Discord bot maestros and audio enthusiasts! Get ready to unleash the true power of music in your DisCatSharp-powered bots with our lively and feature-packed C# client library for Lavalink – the ultimate DJ for Discord.

Picture this: seamless audio streaming, mind-blowing playlists, and custom audio sources at your fingertips, all thanks to our vibrant C# client library. We&apos;ve carefully crafted this gem to harmonize perfectly with DisCatSharp, elevating your bot&apos;s audio playback game to legendary status!

Lavalink, the rockstar audio player library, takes center stage as it effortlessly syncs with the Discord API ecosystem. And with our C# client library in your arsenal, you become the conductor, orchestrating an unforgettable audio experience for your bot users.

Tune into your favorite audio sources like YouTube, SoundCloud, and more, letting Lavalink&apos;s magic bring those beats to life. Whether it&apos;s a catchy track, a curated playlist, or even a unique custom audio source, our C# client library knows just how to keep the party going.

But that&apos;s not all! With our library, you&apos;ll have full control over the volume knobs, precise track seeking, and an intuitive queue management system. Your bot will groove to your commands as you fine-tune the audio experience, ensuring your users get the perfect vibe every time.

So, bot maestros, join the audio revolution! Integrate our C# client library seamlessly into DisCatSharp and let the music take over. Elevate your Discord bot to superstar status, delivering an audio experience that will make your users want to dance the night away.

Get ready to rock and roll with our playful C# client library for Lavalink and DisCatSharp – because every bot deserves to be the life of the party!</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/queue.md">---
uid: modules_audio_lavalink_v4_queue_system
title: Lavalink V4 Queue System
author: DisCatSharp Team
---

# Lavalink Guild Player Queue System

The Lavalink module provides a built-in queue system for managing audio tracks. The queue system allows you to add, remove, and manipulate tracks in a guild-specific queue.

## Enabling the Queue System
The queue system is disabled by default, To use the queue system, you must enable it in your [`LavalinkConfiguration`](xref:DisCatSharp.Lavalink.LavalinkConfiguration):

```cs
var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true
};
```
## Basic Queue Operations
### Adding Tracks
You can add individual tracks or entire playlists to the queue:

```cs
// Add a single track
guildPlayer.AddToQueue(track);

// Add all tracks from a playlist
    var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);
var playlist = loadResult.GetResultAs&lt;LavalinkPlaylist&gt;()
guildPlayer.AddToQueue(playlist);
```

### Playing the Queue
To start playing tracks from the queue:
```cs
guildPlayer.PlayQueue();
```

The finished commands should look like so:
```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
    await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
    if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
        return;
    }

    var lavalink = ctx.Client.GetLavalink();
    var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

    if (guildPlayer == null)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
        return;
    }

    var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);

    if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
        return;
    }

    LavalinkTrack track = loadResult.LoadType switch
    {
        LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
        LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
        LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().First(),
        _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
    };

    if (guildPlayer.CurrentTrack == null)
    {
        guildPlayer.AddToQueue(track);
        guildPlayer.PlayQueue();
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Now playing {query}!&quot;));
    }
    else
    {
        guildPlayer.AddToQueue(track);
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track added to queue {track.Info.Title}!&quot;));
    }
}
```
### Skipping the Current Track
To skip the currently playing track, you can use the [`SkipAsync`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.SkipAsync*) method of the [`LavalinkGuildPlayer`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) class. This method will skip the current track. If the queue system is enabled and there are more tracks in the queue, the next track will automatically start playing.
```cs
await guildPlayer.SkipAsync();
```

### Managing the Queue

The queue system provides several other methods for managing tracks:
```cs
// See list queue
guildPlayer.Queue;

// Remove a specific track
guildPlayer.RemoveQueue(track);

// Remove a track by its title/identifier
guildPlayer.RemoveQueue(&quot;song title&quot;);

// Clear all tracks from the queue
guildPlayer.ClearQueue();

// Shuffle the queue
guildPlayer.ShuffleQueue();

// Reverse the queue order
guildPlayer.ReverseQueue();

...
```
## Queue Entry Pipeline
The Lavalink queue system includes a powerful pipeline system that allows you to execute custom actions before and after track playback. This is implemented through the [`IQueueEntry`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry) interface.
### Queue Entry Lifecycle
Each track in the queue goes through the following pipeline stages:
1. **Before Playing**: Called right before a track starts playing
2. **Track Playback**: The actual track playback
3. **After Playing**: Called after track playback completes

### Creating Custom Queue Entries
To create a custom queue entry, implement the [`IQueueEntry`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry) interface:

```cs
public class CustomQueueEntry : IQueueEntry
{
    public LavalinkTrack Track { get; set; }

    public async Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
    {
        // Execute code before the track plays
        // Return false to skip this track
        return true;
    }

    public async Task AfterPlayingAsync(LavalinkGuildPlayer player)
    {
        // Execute code after the track finishes playing
    }
}
```

### Configuring Custom Queue Entries
To use custom queue entries, configure them in your [`LavalinkConfiguration`](xref:DisCatSharp.Lavalink.LavalinkConfiguration):
```cs
var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true,
    QueueEntryFactory = () =&gt; new CustomQueueEntry()
};
```
or
```cs
 services.AddTransient&lt;IQueueEntry, CustomQueueEntry&gt;();

var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true,
    QueueEntryFactory = () =&gt; scope.ServiceProvider.GetRequiredService&lt;IQueueEntry&gt;
};
```
In case you use dependency injection in `CustomQueueEntry`

### Pipeline Flow Control
- The [`BeforePlayingAsync`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry.BeforePlayingAsync*) method can control whether a track should be played by returning `true` or `false`
- The [`AfterPlayingAsync`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry.AfterPlayingAsync*) method is called after the track finishes, allowing for cleanup or next-track preparation
- Both methods have access to the [`LavalinkGuildPlayer`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) instance for advanced control

Example usage of flow control:
```cs
public async Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
{
    if (/* some condition */)
    {
        // Skip this track
        return false;
    }

    // Play this track
    await player.Channel.SendMessageAsync($&quot;Track Started: {Track.Info.Title}&quot;);
    return true;
}
```</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/setup.md">---
uid: modules_audio_lavalink_v4_setup
title: Lavalink V4 Setup
author: DisCatSharp Team
---

# Lavalink Setup

## Configuring Java

In order to run Lavalink, you must have Java 17 or greater installed. For more details check the [requirements](https://github.com/lavalink-devs/Lavalink/tree/master?tab=readme-ov-file#requirements) before downloading.
The latest v17 releases can be found [here](https://www.oracle.com/java/technologies/downloads/#java17).

Make sure the location of the newest JRE&apos;s bin folder is added to your system variable&apos;s path. This will make the `java` command run from the latest runtime. You can verify that you have the right version by entering `java -version` in your command prompt or terminal.

## Downloading Lavalink

Download the Lavalink V4 server from the [GitHub](https://github.com/lavalink-devs/Lavalink/releases).

To use the Lavalink server, you need to configure it first.

Create a new YAML file called `application.yml`, and use the [example file](https://github.com/lavalink-devs/Lavalink/blob/dev/LavalinkServer/application.yml.example), or copy this snippet:

&gt;[!NOTE]
&gt; For YouTube Support, see the sections `plugins -&gt; youtube` and `lavalink -&gt; plugins` in the config.

```yaml
server:
  port: 2333
  address: 127.0.0.1 # Set it to 0.0.0.0 if you run it in docker or if you want to share it
  http2:
    enabled: false # Personally we don&apos;t see any reason currently to enable it
plugins:
  youtube: # To read more about it&apos;s configuration visit https://github.com/lavalink-devs/youtube-source#plugin
    enabled: true
    allowSearch: true
    allowDirectVideoIds: true
    allowDirectPlaylistIds: true
    clients: # We suggest using it like this, since it switches through the clients to get streams and search running
      - M_WEB
      - WEB
      - MUSIC
      - WEBEMBEDDED
      - ANDROID_VR
      - TV
      - TVHTML5EMBEDDED
    oauth: # Read https://github.com/lavalink-devs/youtube-source?tab=readme-ov-file#using-oauth-tokens for more information
      enabled: true
      skipInitialization: false # Set to true if you got your refresh token
      # refreshToken: &quot;&quot; # Fill out after u got the refresh token
    pot: # Read https://github.com/lavalink-devs/youtube-source?tab=readme-ov-file#using-a-potoken for more information or use this one
      token: &quot;CgtLYnJKeDl1N0pJMCjW2cO8BjIKCgJERRIEEgAgKg==&quot;
      visitorData: &quot;MnRuJyEtJOv8LW4fImJbwY4qXcflEPdSWXwKWnQappnJt4Ee_3bFCJEUmiePXV3jvyjxMuT8pE3j-ZKoLtF-bIjo7-erKATkj38QRYgrGRsEHDC97Qk9a-tcYdXpmMQt2h6A1S325QgSsRfbfjBfBTeDq_oZBA==&quot;
  lavasrc: # To read more about it&apos;s configuration visit https://github.com/topi314/LavaSrc?tab=readme-ov-file
    providers:
      - &quot;ytsearch:\&quot;%ISRC%\&quot;&quot;
      - &quot;ytsearch:%QUERY%&quot;
      - &quot;scsearch:%QUERY%&quot;
      - &quot;spsearch:%QUERY%&quot;
      - &quot;sprec:%QUERY%&quot;
      - &quot;ymsearch:%QUERY%&quot;
      #- &quot;amsearch:%QUERY%&quot;
      #- &quot;dzisrc:%ISRC%&quot;
      #- &quot;dzsearch:%QUERY%&quot;
      - &quot;ymsearch:%QUERY%&quot;
    sources:
      spotify: true
      applemusic: false
      deezer: false
      yandexmusic: true
      flowerytts: true
      vkmusic: false
      youtube: true
    lyrics-sources:
      spotify: true
      deezer: false
      youtube: true
      yandexmusic: true
      vkmusic: false
    spotify:
        clientId: &quot;&quot; # Aquire it by visiting https://developer.spotify.com/dashboard/create
        clientSecret: &quot;&quot; # Aquire it by visiting https://developer.spotify.com/dashboard/create
        spDc: &quot;&quot; # Needed for lyrics, if used. Read https://github.com/topi314/LavaSrc?tab=readme-ov-file#spotify for more details.
        playlistLoadLimit: 6
        albumLoadLimit: 6
        resolveArtistsInSearch: false
        localFiles: true
    yandexmusic:
      accessToken: &quot;&quot; # Aquire it by visiting https://oauth.yandex.ru/authorize?response_type=token&amp;client_id=23cabbbdc6cd418abb4b39c32c41195d
      playlistLoadLimit: 1
      albumLoadLimit: 1
      artistLoadLimit: 1
    flowerytts:
      voice: &quot;default voice&quot;
      translate: false
      silence: 0
      speed: 1.0
      audioFormat: &quot;mp3&quot;
  lavalyrics: # To read more about it&apos;s configuration visit https://github.com/topi314/LavaLyrics?tab=readme-ov-file#lavalink-usage
    sources:
      - spotify
      - youtube
      #- deezer
      - yandexMusic
lavalink:
  plugins: # You can find more plugins on Lavalinks official site at https://lavalink.dev/plugins
    - dependency: &quot;dev.lavalink.youtube:youtube-plugin:1.11.4&quot; # Source: https://github.com/lavalink-devs/youtube-source
      snapshot: false
    - dependency: &quot;com.github.topi314.lavasearch:lavasearch-plugin:1.0.0&quot; # Source: https://github.com/topi314/LavaSearch
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
    - dependency: &quot;com.github.topi314.lavasrc:lavasrc-plugin:4.4.1&quot; # Source: https://github.com/topi314/LavaSrc
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
    - dependency: &quot;com.github.topi314.lavalyrics:lavalyrics-plugin&quot; # Source: https://github.com/topi314/LavaLyrics
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
  server:
    password: &quot;youshallnotpassMEOW&quot; # Set your lavalink password
    sources:
      youtube: false # Disabled youtube because it&apos;s not maintained anymore and got replaced by youtube-plugin
      bandcamp: true
      soundcloud: true
      twitch: true
      vimeo: true
      http: true
      local: true
      nico: true
    filters:
      volume: true
      equalizer: true
      karaoke: true
      timescale: true
      tremolo: true
      vibrato: true
      distortion: true
      rotation: true
      channelMix: true
      lowPass: true
    bufferDurationMs: 400
    frameBufferDurationMs: 5000
    opusEncodingQuality: 10
    resamplingQuality: MEDIUM
    trackStuckThresholdMs: 10000
    useSeekGhosting: true
    youtubePlaylistLoadLimit: 6
    playerUpdateInterval: 5
    youtubeSearchEnabled: true
    soundcloudSearchEnabled: true
    gc-warnings: true

metrics:
  prometheus:
    enabled: false
    endpoint: /metrics

sentry:
  dsn: &quot;&quot;
  environment: &quot;dev&quot;
logging:
  file:
    path: ./logs/

  level:
    root: INFO
    lavalink: INFO
    dev.lavalink.youtube.http.YoutubeOauth2Handler: INFO

  request:
    enabled: true
    includeClientInfo: true
    includeHeaders: false
    includeQueryString: true
    includePayload: true
    maxPayloadLength: 10000


  logback:
    rollingpolicy:
      max-file-size: 1GB
      max-history: 30
```
YAML is whitespace-sensitive. Make sure you are using a text editor which properly handles this.


There are a few values to keep in mind.

The `host` is the IP of the Lavalink host. This will be `0.0.0.0` by default, but it should be changed as it is a security risk. For this guide, set this to `127.0.0.1` as we will be running Lavalink locally.

`port` is the allowed port for the Lavalink connection. `2333` is the default port, and is what will be used for this guide.

The `password` is the password that you will need to specify when connecting. This can be anything as long as it is a valid YAML string. Keep it as `youshallnotpass` for this guide.

When you are finished configuring this, save the file in the same directory as your Lavalink executable.

Keep note of your `port`, `address`, and `password` values, as you will need them later for connecting.

## Starting Lavalink

Open your command prompt or terminal and navigate to the directory containing Lavalink.

Once there, type `java -jar Lavalink.jar`. You should start seeing log output from Lavalink.

If everything is configured properly, you should see this appear somewhere in the log output without any errors:
```yml
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Starting Launcher v4.0.8 using Java 18.0.2.1 with PID 1 (/opt/Lavalink/Lavalink.jar started by lavalink in /opt/Lavalink)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : No active profile set, falling back to 1 default profile: &quot;default&quot;
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;lavasearch-plugin&apos; version 1.0.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;lavasrc-plugin&apos; version 4.3.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;sponsorblock-plugin&apos; version 3.0.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;youtube-plugin&apos; version 1.11.3
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded lavasearch-plugin-1.0.0.jar (20 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded lavasrc-plugin-4.3.0.jar (168 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded sponsorblock-plugin-3.0.0.jar (90 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded youtube-plugin-1.11.3.jar (16 classes)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Started Launcher in 2.194 seconds (process running for 2.752)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 :

       .   _                  _ _       _    __ _ _
      /\\ | | __ ___   ____ _| (_)_ __ | | __\ \ \ \
     ( ( )| |/ _` \ \ / / _` | | | &apos;_ \| |/ / \ \ \ \
      \\/ | | (_| |\ V / (_| | | | | | |   &lt;   ) ) ) )
       &apos;  |_|\__,_| \_/ \__,_|_|_|_| |_|_|\_\ / / / /
    =========================================/_/_/_/

        Version:        4.0.8
        Build time:     20.09.2024 20:20:10 UTC
        Branch          HEAD
        Commit:         2946608
        Commit time:    20.09.2024 20:17:58 UTC
        JVM:            18.0.2.1
        Lavaplayer      2.2.2

INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : No active profile set, falling back to 1 default profile: &quot;default&quot;
WARN 1 --- [Lavalink] [           main] io.undertow.websockets.jsr               : UT026010: Buffer pool was not set on WebSocketDeploymentInfo, the default pool will be used
INFO 1 --- [Lavalink] [           main] io.undertow.servlet                      : Initializing Spring embedded WebApplicationContext
INFO 1 --- [Lavalink] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 712 ms
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Loading LavaSrc plugin...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Youtube Source audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Spotify search manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Youtube search manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Yandex Music search manager...
INFO 1 --- [Lavalink] [           main] c.s.d.l.tools.GarbageCollectionMonitor   : GC monitoring enabled, reporting results every 2 minutes.
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Spotify audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Yandex Music audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Flowery TTS audio source manager...
WARN 1 --- [Lavalink] [           main] d.l.youtube.plugin.ClientProvider        : Failed to resolve M_WEB into a Client
INFO 1 --- [Lavalink] [           main] d.l.youtube.plugin.YoutubePluginLoader   : YouTube source initialised with clients: WEB, WEB_REMIX, WEB_EMBEDDED_PLAYER, ANDROID_VR, TVHTML5, TVHTML5_SIMPLY_EMBEDDED_PLAYER
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : OAUTH INTEGRATION: To give youtube-source access to your account, go to https://www.google.com/device and enter code &lt;redacted&gt;
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] Picked up _JAVA_OPTIONS: -Xmx6G
INFO 1 --- [Lavalink] [           main] c.g.t.s.plugin.SponsorBlockPlugin        : Loading SponsorBlock Plugin...
INFO 1 --- [Lavalink] [           main] l.server.config.KoeConfiguration         : OS: LINUX, Arch: X86_64
INFO 1 --- [Lavalink] [           main] l.server.config.KoeConfiguration         : Enabling JDA-NAS
INFO 1 --- [Lavalink] [           main] c.s.l.c.natives.NativeLibraryLoader      : Native library udpqueue: loading with filter null
INFO 1 --- [Lavalink] [           main] c.s.l.c.natives.NativeLibraryLoader      : Native library udpqueue: successfully loaded.
WARN 1 --- [Lavalink] [           main] l.server.config.SentryConfiguration      : Turning off sentry
INFO 1 --- [Lavalink] [           main] io.undertow                              : starting server: Undertow - 2.3.13.Final
INFO 1 --- [Lavalink] [           main] org.xnio                                 : XNIO version 3.8.8.Final
INFO 1 --- [Lavalink] [           main] org.xnio.nio                             : XNIO NIO Implementation Version 3.8.8.Final
INFO 1 --- [Lavalink] [           main] org.jboss.threads                        : JBoss Threads version 3.5.0.Final
INFO 1 --- [Lavalink] [           main] o.s.b.w.e.undertow.UndertowWebServer     : Undertow started on port 2333 (http) with context path &apos;/&apos;
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Started Launcher in 3.43 seconds (process running for 6.19)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Lavalink is ready to accept connections.
```

If it does, congratulations. We are now ready to interact with it using DisCatSharp.

## YouTube OAuth Token

If you configured OAuth correctly, you should see the following in your logs:
```yml
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : OAUTH INTEGRATION: To give youtube-source access to your account, go to https://www.google.com/device and enter code XXX-XXX-XXX
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
```</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/prerequisites.md">---
uid: modules_audio_voicenext_prerequisites
title: VoiceNext Prerequisites
---

# VoiceNext Prerequisites

&gt; [!NOTE]
&gt; We highly suggest using the [DisCatSharp.Lavalink](xref:modules_audio_lavalink_v4_intro) package for audio playback. It is much easier to use and has a lot of features that VoiceNext does not have.

## Required Libraries

VoiceNext depends on the [libsodium](https://github.com/jedisct1/libsodium) and [Opus](https://opus-codec.org/) libraries to decrypt and process audio packets.&lt;br/&gt;
Both _must_ be available on your development and host machines otherwise VoiceNext will _not_ work.

### Windows

When installing VoiceNext though NuGet, an additional package containing the native Windows binaries will automatically be included with **no additional steps required**.

However, if you are using DisCatSharp from source or without a NuGet package manager, you must manually [download](xref:natives) the binaries and place them at the root of your working directory where your application is located.

If the package doesn&apos;t work, you might have to instruct msbuild to include it:

```xml
&lt;PackageReference Include=&quot;DisCatSharp.VoiceNext.Natives&quot; Version=&quot;10.6.0-nightly-001&quot;&gt;
	&lt;IncludeAssets&gt;runtime; native; contentfiles&lt;/IncludeAssets&gt;
&lt;/PackageReference&gt;
```


### MacOS

Native libraries for Apple&apos;s macOS can be installed using the [Homebrew](https://brew.sh) package manager:

```console
$ brew install opus libsodium
```

### Linux

#### Debian and Derivatives

Opus package naming is consistent across Debian, Ubuntu, and Linux Mint.

```bash
sudo apt-get install libopus0 libopus-dev
```

Package naming for _libsodium_ will vary depending on your distro and version:

|           Distributions            |                 Terminal Command                 |
| :--------------------------------: | :----------------------------------------------: |
|     Ubuntu 18.04+, Debian 10+      | `sudo apt-get install libsodium23 libsodium-dev` |
| Linux Mint, Ubuntu 16.04, Debian 9 | `sudo apt-get install libsodium18 libsodium-dev` |
|              Debian 8              | `sudo apt-get install libsodium13 libsodium-dev` |</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/receive.md">---
uid: modules_audio_voicenext_receive
title: Receiving
---

## Receiving with VoiceNext

### Enable Receiver

Receiving incoming audio is disabled by default to save on bandwidth, as most users will never make use of incoming data.
This can be changed by providing a configuration object to `DiscordClient#UseVoiceNext()`.

```cs
var discord = new DiscordClient();

discord.UseVoiceNext(new VoiceNextConfiguration()
{
    EnableIncoming = true
});
```

### Establish Connection

The voice channel join process is the exact same as when transmitting.

```cs
DiscordChannel channel;
VoiceNextConnection connection = await channel.ConnectAsync();
```

### Write Event Handler

We&apos;ll be able to receive incoming audio from the `VoiceReceived` event fired by `VoiceNextConnection`.

```cs
connection.VoiceReceived += ReceiveHandler;
```

Writing the logic for this event handler will depend on your overall goal.

The event arguments will contain a PCM audio packet for you to make use of.
You can convert each packet to another format, concatenate them all together, feed them into an external program, or process the packets any way that&apos;ll suit your needs.

When a user is speaking, `VoiceReceived` should fire once every twenty milliseconds and its packet will contain around twenty milliseconds worth of audio; this can vary due to differences in client settings.
To help keep track of the torrent of packets for each user, you can use user IDs in combination the synchronization value (SSRC) sent by Discord to determine the source of each packet.

This short-and-simple example will use [ffmpeg](https://ffmpeg.org/about.html) to convert each packet to a _wav_ file.

```cs
private async Task ReceiveHandler(VoiceNextConnection _, VoiceReceiveEventArgs args)
{
    var name = DateTimeOffset.Now.ToUnixTimeMilliseconds();
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 {name}.wav&quot;,
        RedirectStandardInput = true
    });

    await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData);
}
```

&lt;br/&gt;
That&apos;s really all there is to it. Connect to a voice channel, hook an event, process the data as you see fit.

![Wav Files](/images/voicenext_receive_01.png)

## Example Commands

```cs
[Command(&quot;start&quot;)]
public async Task StartCommand(CommandContext ctx, DiscordChannel channel = null)
{
    channel ??= ctx.Member.VoiceState?.Channel;
    var connection = await channel.ConnectAsync();

    Directory.CreateDirectory(&quot;Output&quot;);
    connection.VoiceReceived += VoiceReceiveHandler;
}


[Command(&quot;stop&quot;)]
public Task StopCommand(CommandContext ctx)
{
    var vnext = ctx.Client.GetVoiceNext();

    var connection = vnext.GetConnection(ctx.Guild);
    connection.VoiceReceived -= VoiceReceiveHandler;
    connection.Dispose();

    return Task.CompletedTask;
}

private async Task VoiceReceiveHandler(VoiceNextConnection connection, VoiceReceiveEventArgs args)
{
    var fileName = DateTimeOffset.Now.ToUnixTimeMilliseconds();
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 Output/{fileName}.wav&quot;,
        RedirectStandardInput = true
    });

    await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData);
    ffmpeg.Dispose();
}
```</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/transmit.md">---
uid: modules_audio_voicenext_transmit
title: Transmitting
---

## Transmitting with VoiceNext

### Enable VoiceNext
Install the `DisCatSharp.VoiceNext` package from NuGet.

![NuGet Package Manager](/images/voicenext_transmit_01.png)

Then use the `UseVoiceNext` extension method on your instance of `DiscordClient`.
```cs
var discord = new DiscordClient();
discord.UseVoiceNext();
```

### Connect
Joining a voice channel is *very* easy; simply use the `ConnectAsync` extension method on `DiscordChannel`.
```cs
DiscordChannel channel;
VoiceNextConnection connection = await channel.ConnectAsync();
```

### Transmit
Discord requires that we send Opus encoded stereo PCM audio data at a sample rate of 48,000 Hz.

You&apos;ll need to convert your audio source to PCM S16LE using your preferred program for media conversion, then read
that data into a `Stream` object or an array of `byte` to be used with VoiceNext. Opus encoding of the PCM data will
be done automatically by VoiceNext before sending it to Discord.

This example will use [ffmpeg](https://ffmpeg.org/about.html) to convert an MP3 file to a PCM stream.
```cs
var filePath = &quot;funiculi_funicula.mp3&quot;;
var ffmpeg = Process.Start(new ProcessStartInfo
{
    FileName = &quot;ffmpeg&quot;,
    Arguments = $@&quot;-i &quot;&quot;{filePath}&quot;&quot; -ac 2 -f s16le -ar 48000 pipe:1&quot;,
    RedirectStandardOutput = true,
    UseShellExecute = false
});

Stream pcm = ffmpeg.StandardOutput.BaseStream;
```

Now that our audio is the correct format, we&apos;ll need to get a *transmit sink* for the channel we&apos;re connected to.
You can think of the transmit stream as our direct interface with a voice channel; any data written to one will be
processed by VoiceNext, queued, and sent to Discord which will then be output to the connected voice channel.
```cs
VoiceTransmitSink transmit = connection.GetTransmitSink();
```

Once we have a transmit sink, we can &apos;play&apos; our audio by copying our PCM data to the transmit sink buffer.
```cs
await pcm.CopyToAsync(transmit);
```
`Stream#CopyToAsync()` will copy PCM data from the input stream to the output sink, up to the sink&apos;s configured
capacity, at which point it will wait until it can copy more. This means that the call will hold the task&apos;s execution,
until such time that the entire input stream has been consumed, and enqueued in the sink.

This operation cannot be cancelled. If you&apos;d like to have finer control of the playback, you should instead consider
using `Stream#ReadAsync()` and `VoiceTransmitSink#WriteAsync()` to manually copy small portions of PCM data to the
transmit sink.

### Disconnect
Similar to joining, leaving a voice channel is rather straightforward.
```cs
var vnext = discord.GetVoiceNext();
var connection = vnext.GetConnection();

connection.Disconnect();
```

## Example Commands
```cs
[Command(&quot;join&quot;)]
public async Task JoinCommand(CommandContext ctx, DiscordChannel channel = null)
{
    channel ??= ctx.Member.VoiceState?.Channel;
    await channel.ConnectAsync();
}

[Command(&quot;play&quot;)]
public async Task PlayCommand(CommandContext ctx, string path)
{
    var vnext = ctx.Client.GetVoiceNext();
    var connection = vnext.GetConnection(ctx.Guild);

    var transmit = connection.GetTransmitSink();

    var pcm = ConvertAudioToPcm(path);
    await pcm.CopyToAsync(transmit);
    await pcm.DisposeAsync();
}

[Command(&quot;leave&quot;)]
public async Task LeaveCommand(CommandContext ctx)
{
    var vnext = ctx.Client.GetVoiceNext();
    var connection = vnext.GetConnection(ctx.Guild);

    connection.Disconnect();
}

private Stream ConvertAudioToPcm(string filePath)
{
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-i &quot;&quot;{filePath}&quot;&quot; -ac 2 -f s16le -ar 48000 pipe:1&quot;,
        RedirectStandardOutput = true,
        UseShellExecute = false
    });

    return ffmpeg.StandardOutput.BaseStream;
}
```</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/command_attributes.md">---
uid: modules_commandsnext_command_attributes
title: Command Attributes
author: DisCatSharp Team
hasDiscordComponents: true
---

## Built-In Attributes

CommandsNext has a variety of built-in attributes to enhance your commands and provide some access control.
The majority of these attributes can be applied to your command methods and command groups.

-   @DisCatSharp.CommandsNext.Attributes.AliasesAttribute
-   @DisCatSharp.CommandsNext.Attributes.DescriptionAttribute
-   @DisCatSharp.CommandsNext.Attributes.DontInjectAttribute
-   @DisCatSharp.CommandsNext.Attributes.HiddenAttribute
-   @DisCatSharp.CommandsNext.Attributes.ModuleLifespanAttribute
-   @DisCatSharp.CommandsNext.Attributes.PriorityAttribute
-   @DisCatSharp.CommandsNext.Attributes.RemainingTextAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireBotPermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireCommunityAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireDirectMessageAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireGuildAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireGuildOwnerAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireMemberVerificationGateAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireNsfwAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireOwnerAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireOwnerOrIdAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequirePermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequirePrefixesAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireRolesAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireUserPermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireWelcomeScreenAttribute

## Custom Attributes

If the above attributes don&apos;t meet your needs, CommandsNext also gives you the option of writing your own!
Simply create a new class which inherits from `CheckBaseAttribute` and implement the required method.

Our example below will only allow a command to be ran during a specified year.

```cs
public class RequireYearAttribute : CheckBaseAttribute
{
    public int AllowedYear { get; private set; }

    public RequireYearAttribute(int year)
    {
        AllowedYear = year;
    }

    public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
    {
        return Task.FromResult(AllowedYear == DateTime.Now.Year);
    }
}
```

You&apos;ll also need to apply the `AttributeUsage` attribute to your attribute.
For our example attribute, we&apos;ll set it to only be usable once on methods.

```cs
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class RequireYearAttribute : CheckBaseAttribute
{
    // ...
}
```

You can provide feedback to the user using the `CommandsNextExtension#CommandErrored` event.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();
	var commands = discord.UseCommandsNext();

	commands.CommandErrored += CmdErroredHandler;
}

private async Task CmdErroredHandler(CommandsNextExtension _, CommandErrorEventArgs e)
{
    var failedChecks = ((ChecksFailedException)e.Exception).FailedChecks;
    foreach (var failedCheck in failedChecks)
    {
        if (failedCheck is RequireYearAttribute)
        {
            var yearAttribute = (RequireYearAttribute)failedCheck;
            await e.Context.RespondAsync($&quot;Only usable during year {yearAttribute.AllowedYear}.&quot;);
        }
    }
}
```

Once you&apos;ve got all of that completed, you&apos;ll be able to use it on a command!

```cs
[Command(&quot;generic&quot;), RequireYear(2030)]
public async Task GenericCommand(CommandContext ctx, string generic)
{
    await ctx.RespondAsync(&quot;Generic response.&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !generic
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Only usable during the year 2030!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/cooldowns.md">---
uid: modules_commandsnext_cooldowns
title: Cooldowns
author: DisCatSharp Team
hasDiscordComponents: true
---

## Cooldown Attribute

You can apply cooldowns to your text commands with the @DisCatSharp.CommandsNext.Attributes.CooldownAttribute.

The cooldown attribute consists of three required parameters and one optional parameter.

-   `int maxUses` - The number of times a command can be used during the definied time before being put on cooldown.
-   `double resetAfter` - After how many seconds the cooldown resets.
-   `CooldownBucketType bucketType` - The [type](xref:DisCatSharp.Enums.Core.CooldownBucketType) of bucket to use. Can be combined.

## Usage

```cs
// We create a text command which sends a meow to the channel. This command can be executed twice every 40 seconds per channel.
[Command(&quot;meow&quot;), Description(&quot;Meow at chat&quot;), Cooldown(2, 40, CooldownBucketType.Channel)]
public async Task MeowAsync(CommandContext ctx)
{
    await context.RespondAsync(&quot;Meow!&quot;);
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot;&gt;
        !meow
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;false&quot; name=&quot;:x:&quot; emoji=&quot;https://cdn.aitsys.dev/file/data/z5xj4bzraybavtu72in7/PHID-FILE-3rkjxmtwinuysdnwumm7/d22e8c77c1aa9e5a69a2.png&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Customizing the cooldown hit response

You can customize the response that is sent when a user hits a cooldown by creating a custom class which inherits from [ICooldownResponder](xref:DisCatSharp.CommandsNext.Entities.ICooldownResponder).

```cs
public sealed class CooldownResponse : ICooldownResponder
{
    /// &lt;inheritdoc /&gt;
    public async Task Responder(BaseContext context)
    {
        await context.Message.CreateReactionAsync(DiscordEmoji.FromGuildEmote(context.Client, 972904417005293609));
        // or send a message
        // await context.Member.SendMessageAsync(&quot;You hit a cooldown! Try again later.&quot;);

    }
}
```

You can then apply this to your command by using the `cooldownResponderType` property on the attribute.

```cs
[Command(&quot;meow&quot;), Description(&quot;Meow at chat&quot;), Cooldown(2, 40, CooldownBucketType.Channel, typeof(CooldownResponse)))]
public async Task MeowAsync(CommandContext ctx)
{
    await context.RespondAsync(&quot;Meow!&quot;);
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot;&gt;
        !meow
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;false&quot; name=&quot;:hasiscared:&quot; emoji=&quot;https://cdn.discordapp.com/emojis/972904417005293609.png&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/argument_converters.md">---
uid: modules_commandsnext_customization_argument_converters
title: Argument Converter
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Argument Converter

Writing your own argument converter will enable you to convert custom types and replace the functionality of existing converters.
Like many things in DisCatSharp, doing this is straightforward and simple.

First, create a new class which implements `IArgumentConverter&lt;T&gt;` and its method `ConvertAsync`.
Our example will be a boolean converter, so we&apos;ll also pass `bool` as the type parameter for `IArgumentConverter`.

```cs
public class CustomArgumentConverter : IArgumentConverter&lt;bool&gt;
{
    public Task&lt;Optional&lt;bool&gt;&gt; ConvertAsync(string value, CommandContext ctx)
    {
        if (bool.TryParse(value, out var boolean))
        {
            return Task.FromResult(Optional.Some&lt;bool&gt;(boolean));
        }

        switch (value.ToLower())
        {
            case &quot;yes&quot;:
            case &quot;y&quot;:
            case &quot;t&quot;:
                return Task.FromResult(Optional.Some&lt;bool&gt;(true));

            case &quot;no&quot;:
            case &quot;n&quot;:
            case &quot;f&quot;:
                return Task.FromResult(Optional.Some&lt;bool&gt;(false));

            default:
                return Task.FromResult(Optional.None);
        }
    }
}
```

Then register the argument converter with CommandContext.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.RegisterConverter(new CustomArgumentConverter());
```

Once the argument converter is written and registered, we&apos;ll be able to use it:

```cs
[Command(&quot;boolean&quot;)]
public async Task BooleanCommand(CommandContext ctx, bool boolean)
{
    await ctx.RespondAsync($&quot;Converted to {boolean} :3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !boolean yes
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Converted to True :3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/command_handler.md">---
uid: modules_commandsnext_customization_command_handler
title: Custom Command Handler
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Command Handler

&gt;[!IMPORTANT]
 &gt; Writing your own handler logic should only be done if *you know what you&apos;re doing*.
 &gt; You will be responsible for command execution and preventing deadlocks.

### Disable Default Handler

To begin, we&apos;ll need to disable the default command handler provided by CommandsNext.
This is done by setting the `UseDefaultCommandHandler` configuration property to `false`.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
{
    UseDefaultCommandHandler = false
});
```

### Create Event Handler

We&apos;ll then write a new handler for the `MessageCreated` event fired from `DiscordClient`.

```cs
discord.MessageCreated += CommandHandler;

// ...

private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e)
{
    // See below ...
}
```
This event handler will be our command handler, and you&apos;ll need to write the logic for it.

### Handle Commands

Start by parsing the message content for a prefix and command string

```cs
var cnext = client.GetCommandsNext();
var msg = e.Message;

// Check if message has valid prefix.
var cmdStart = msg.GetStringPrefixLength(&quot;!&quot;);
if (cmdStart == -1) return;

// Retrieve prefix.
var prefix = msg.Content.Substring(0, cmdStart);

// Retrieve full command string.
var cmdString = msg.Content.Substring(cmdStart);
```

Then provide the command string to `CommandsNextExtension#FindCommand`

```cs
var command = cnext.FindCommand(cmdString, out var args);
```

Create a command context using our message and prefix, along with the command and its arguments

```cs
var ctx = cnext.CreateContext(msg, prefix, command, args);
```

And pass the context to `CommandsNextExtension#ExecuteCommandAsync` to execute the command.

```cs
_ = Task.Run(async () =&gt; await cnext.ExecuteCommandAsync(ctx));
// Wrapped in Task.Run() to prevent deadlocks.
```


### Finished Product

Altogether, your implementation should function similarly to the following:

```cs
private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e)
{
    var cnext = client.GetCommandsNext();
    var msg = e.Message;

    var cmdStart = msg.GetStringPrefixLength(&quot;!&quot;);
    if (cmdStart == -1) return Task.CompletedTask;

    var prefix = msg.Content.Substring(0, cmdStart);
    var cmdString = msg.Content.Substring(cmdStart);

    var command = cnext.FindCommand(cmdString, out var args);
    if (command == null) return Task.CompletedTask;

    var ctx = cnext.CreateContext(msg, prefix, command, args);
    Task.Run(async () =&gt; await cnext.ExecuteCommandAsync(ctx));

    return Task.CompletedTask;
}
```</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/help_formatter.md">---
uid: modules_commandsnext_customization_help_formatter
title: Help Formatter
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Help Formatter

The built-in help command provided by CommandsNext is generated with a _help formatter_.
This simple mechanism is given a command and its subcommands then returns a formatted help message.
If you&apos;re not happy with the default help formatter, you&apos;re able to write your own and customize the output to your liking.

Simply inherit from `BaseHelpFormatter` and provide an implementation for each of the required methods.

```cs
public class CustomHelpFormatter : BaseHelpFormatter
{
	// protected DiscordEmbedBuilder _embed;
	// protected StringBuilder _strBuilder;

	public CustomHelpFormatter(CommandContext ctx) : base(ctx)
	{
		// _embed = new DiscordEmbedBuilder();
		// _strBuilder = new StringBuilder();

		// Help formatters do support dependency injection.
		// Any required services can be specified by declaring constructor parameters.

		// Other required initialization here ...
	}

	public override BaseHelpFormatter WithCommand(Command command)
	{
		// _embed.AddField(new DiscordEmbedField(command.Name, command.Description));
		// _strBuilder.AppendLine($&quot;{command.Name} - {command.Description}&quot;);

		return this;
	}

	public override BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; cmds)
	{
		foreach (var cmd in cmds)
		{
			// _embed.AddField(new DiscordEmbedField(cmd.Name, cmd.Description));
			// _strBuilder.AppendLine($&quot;{cmd.Name} - {cmd.Description}&quot;);
		}

		return this;
	}

	public override CommandHelpMessage Build()
	{
		// return new CommandHelpMessage(embed: _embed);
		// return new CommandHelpMessage(content: _strBuilder.ToString());
	}
}
```

Alternatively, if you&apos;re only wanting to make a few small tweaks to the default help, you can write a simple help formatter which inherits from `DefaultHelpFormatter` and modify the inherited `EmbedBuilder` property.

```cs
public class CustomHelpFormatter : DefaultHelpFormatter
{
	public CustomHelpFormatter(CommandContext ctx) : base(ctx) { }

	public override CommandHelpMessage Build()
	{
		EmbedBuilder.Color = DiscordColor.SpringGreen;
		return base.Build();
	}
}
```

Your final step is to register your help formatter with CommandsNext.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.SetHelpFormatter&lt;CustomHelpFormatter&gt;();
```

That&apos;s all there is to it.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-embed slot=&quot;embeds&quot; color=&quot;#00FF7F&quot; embed-title=&quot;Commands&quot;&gt;
            &lt;discord-embed-description slot=&quot;description&quot;&gt;All available commands will be listed below.&lt;/discord-embed-description&gt;
            &lt;discord-embed-fields slot=&quot;fields&quot;&gt;
                &lt;discord-embed-field field-title=&quot;!help&quot;&gt;Sends you a list of all available commands, their usage and their description.&lt;/discord-embed-field&gt;
                &lt;discord-embed-field field-title=&quot;!whois [@User]&quot;&gt;Displays information the bot knows about you or the mentioned user.&lt;/discord-embed-field&gt;
                &lt;discord-embed-field field-title=&quot;!avatar [@User]&quot;&gt;Displays your or the mentioned user&apos;s avatar as an embedded image.&lt;/discord-embed-field&gt;
            &lt;/discord-embed-fields&gt;
        &lt;/discord-embed&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/dependency_injection.md">---
uid: modules_commandsnext_dependency_injection
title: Dependency Injection
author: DisCatSharp Team
hasDiscordComponents: true
---

## Dependency Injection
As you begin to write more complex commands, you&apos;ll find that you need a way to get data in and out of them.
Although you *could* use `static` fields to accomplish this, the preferred solution would be *dependency injection*.

This would involve placing all required object instances and types (referred to as *services*) in a container, then providing that container to CommandsNext.
Each time a command module is instantiated, CommandsNext will then attempt to populate constructor parameters, `public` properties, and `public` fields exposed by the module with instances of objects from the service container.


We&apos;ll go through a simple example of this process to help you understand better.

### Create a Service Provider
To begin, we&apos;ll need to create a service provider; this will act as the container for the services you need for your commands.
Create a new variable just before you register CommandsNext with your `DiscordClient` and assign it a new instance of `ServiceCollection`.
```cs
var discord = new DiscordClient();
var services = new ServiceCollection();	// Right here!
var commands = discord.UseCommandsNext();
```

We&apos;ll use `.AddSingleton` to add type `Random` to the collection, then chain that call with the `.BuildServiceProvider()` extension method.
The resulting type will be `ServiceProvider`.
```cs
var services = new ServiceCollection()
    .AddSingleton&lt;Random&gt;()
	.BuildServiceProvider();
```

Then we&apos;ll need to provide CommandsNext with our services.
```cs
var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
{
    Services = services
});
```

### Using Your Services
Now that we have our services set up, we&apos;re able to use them in commands.&lt;br/&gt;
We&apos;ll be tweaking our [random number command](xref:modules_commandsnext_intro#argument-converters) to demonstrate.

Add a new property to the command module named *Rng*. Make sure it has a `public` setter.
```cs
public class MyFirstModule : BaseCommandModule
{
    public Random Rng { private get; set; } // Implied public setter.

    // ...
}
```

Modify the *random* command to use our property.
```cs
[Command(&quot;random&quot;)]
public async Task RandomCommand(CommandContext ctx, int min, int max)
{
    await ctx.RespondAsync($&quot;Your number is: {Rng.Next(min, max)}&quot;);
}
```

Then we can give it a try!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !random 1 500
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Your number is: 420
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;br/&gt;
CommandsNext has automatically injected our singleton `Random` instance into the `Rng` property when our command module was instantiated.
Now, for any command that needs `Random`, we can simply declare one as a property, field, or in the module constructor and CommandsNext will take care of the rest.
Ain&apos;t that neat?


## Lifespans

### Modules
By default, all command modules have a singleton lifespan; this means each command module is instantiated once for the lifetime of the CommandsNext instance.
However, if the reuse of a module instance is undesired, you also have the option to change the lifespan of a module to *transient* using the `ModulesLifespan` attribute.
```cs
[ModuleLifespan(ModuleLifespan.Transient)]
public class MyFirstModule : BaseCommandModule
{
    // ...
}
```
Transient command modules are instantiated each time one of its containing commands is executed.


### Services
In addition to the `.AddSingleton()` extension method, you&apos;re also able to use the `.AddScoped()` and `.AddTransient()` extension methods to add services to the collection.
The extension method chosen will affect when and how often the service is instantiated.
Scoped and transient services should only be used in transient command modules, as singleton modules will always have their services injected once.

Lifespan|Instantiated
:---:|:---
Singleton|One time when added to the collection.
Scoped|Once for each command module.
Transient|Each time its requested.</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/intro.md">---
uid: modules_commandsnext_intro
title: CommandsNext Introduction
author: DisCatSharp Team
hasDiscordComponents: true
---

&gt; [!NOTE]
&gt; This article assumes you&apos;ve recently read the article on _[writing your first bot](xref:getting_started_first_bot)_.

# Introduction to CommandsNext

This article will introduce you to some basic concepts of our native command framework: _CommandsNext_.&lt;br/&gt;
Be sure to install the `DisCatSharp.CommandsNext` package from NuGet before continuing.

![CommandsNext NuGet Package](/images/commands_intro_01.png)

## Writing a Basic Command

### Create a Command Module

A command module is simply a class which acts as a container for your command methods. Instead of registering individual commands,
you&apos;d register a single command module which contains multiple commands. There&apos;s no limit to the amount of modules you can have,
and no limit to the amount of commands each module can contain. For example: you could have a module for moderation commands and
a separate module for image commands. This will help you keep your commands organized and reduce the clutter in your project.

Our first demonstration will be simple, consisting of one command module with a simple command.&lt;br/&gt;
We&apos;ll start by creating a new folder named `Commands` which contains a new class named `MyFirstModule`.

![Solution Explorer](/images/commands_intro_02.png)

Give this new class `public` access and have it inherit from `BaseCommandModule`.

```cs
public class MyFirstModule : BaseCommandModule { }
```

### Create a Command Method

Within our new module, create a method named `GreetCommand` marked as `async` with a `Task` return type.
The first parameter of your method _must_ be of type `CommandContext`, as required by CommandsNext.

```cs
public async Task GreetCommand(CommandContext ctx) { }
```

In the body of our new method, we&apos;ll use `CommandContext#RespondAsync` to send a simple message.

```cs
await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
```

Finally, mark your command method with the `Command` attribute so CommandsNext will know to treat our method as a command method.
This attribute takes a single parameter: the name of the command.

We&apos;ll name our command _greet_ to match the name of the method.

```cs
[Command(&quot;greet&quot;)]
public async Task GreetCommand(CommandContext ctx)
{
    await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
}
```

Your command module should now resemble this:

```cs
using System.Threading.Tasks;
using DisCatSharp.CommandsNext;
using DisCatSharp.CommandsNext.Attributes;

public class MyFirstModule : BaseCommandModule
{
    [Command(&quot;greet&quot;)]
    public async Task GreetCommand(CommandContext ctx)
    {
        await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
    }
}
```

### Cleanup and Configuration

Before we can run our new command, we&apos;ll need modify our main method.&lt;br/&gt;
Start by removing the event handler we created [previously](xref:getting_started_first_bot#spicing-up-your-bot).

```cs
var discord = new DiscordClient();

discord.MessageCreated += async (s, e) =&gt;               // REMOVE
{                                                       // ALL
    if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;)) // OF
        await e.Message.RespondAsync(&quot;pong!&quot;);          // THESE
};                                                      // LINES

await discord.ConnectAsync();
```

Next, call the `UseCommandsNext` extension method on your `DiscordClient` instance and pass it a new `CommandsNextConfiguration` instance.
Assign the resulting `CommandsNextExtension` instance to a new variable named _commands_. This important step will enable CommandsNext for your Discord client.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext(new CommandsNextConfiguration());
```

Create an object initializer for `CommandsNextConfiguration` and assign the `StringPrefixes` property a new `string` array containing your desired prefixes.
Our example below will only define a single prefix: `!`.

```cs
new CommandsNextConfiguration()
{
    StringPrefixes = new List&lt;string&gt;() { &quot;!&quot; }
}
```

Now we&apos;ll register our command module.
Call the `RegisterCommands` method on our `CommandsNextExtension` instance and provide it with your command module.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.RegisterCommands&lt;MyFirstModule&gt;();

await discord.ConnectAsync();
```

Alternatively, you can pass in your assembly to register commands from all modules in your program.

```cs
commands.RegisterCommands(Assembly.GetExecutingAssembly());
```

Your main method should look similar to the following:

```cs
internal static async Task MainAsync()
{
    var discord = new DiscordClient(new DiscordConfiguration());
    var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
    {
        StringPrefixes = new List&lt;string&gt;() { &quot;!&quot; }
    });

    commands.RegisterCommands&lt;MyFirstModule&gt;();

    await discord.ConnectAsync();
    await Task.Delay(-1);
}
```

### Running Your Command

It&apos;s now the moment of truth; all your blood, sweat, and tears have lead to this moment.
Hit `F5` on your keyboard to compile and run your bot, then execute your command in any channel that your bot account has access to.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Greetings! UwU
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Taking User Input

### Command Arguments

Now that we have a basic command down, let&apos;s spice it up a bit by defining _arguments_ to accept user input.

Defining an argument is simple; just add additional parameters to your signature of your command method.
CommandsNext will automatically parse user input and populate the parameters of your command method with those arguments.
To demonstrate, we&apos;ll modify our _greet_ command to greet a user with a given name.

Head back to `MyFirstModule` and add a parameter of type `string` to the `GreetCommand` method.

```cs
[Command(&quot;greet&quot;)]
public async Task GreetCommand(CommandContext ctx, string name)
```

CommandsNext will now interpret this as a command named _greet_ that takes one argument.

Next, replace our original response message with an [interpolated string](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)
which uses our new parameter.

```cs
public async Task GreetCommand(CommandContext ctx, string name)
{
    await ctx.RespondAsync($&quot;Greetings, {name}! You&apos;re cute OwO!&quot;);
}
```

That&apos;s all there is to it. Smack `F5` and test it out in a channel your bot account has access to.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet Drac
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Greetings, Drac! You&apos;re cute OwO!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Now, you may have noticed that providing more than one word simply does not work.
For example, `!greet Luke Smith` will result in no response from your bot.

This fails because a valid [overload](#command-overloads) could not be found for your command.

CommandsNext will split arguments by whitespace. This means `Luke Smith` is counted as two separate arguments; `Luke` and `Smith`.
In addition to this, CommandsNext will attempt to find and execute an overload of your command that has the _same number_ of provided arguments.
Together, this means that any additional arguments will prevent CommandsNext from finding a valid overload to execute.

The simplest way to get around this would be to wrap your input with double quotes.
CommandsNext will parse this as one argument, allowing your command to be executed.

```
!greet &quot;Lala Sabathil&quot;
```

If you would prefer not to use quotes, you can use the `RemainingText` attribute on your parameter.
This attribute will instruct CommandsNext to parse all remaining arguments into that parameter.

```cs
public async Task GreetCommand(CommandContext ctx, [RemainingText] string name)
```

Alternatively, you can use the `params` keyword to have all remaining arguments parsed into an array.

```cs
public async Task GreetCommand(CommandContext ctx, params string[] names)
```

A more obvious solution is to add additional parameters to the method signature of your command method.&lt;br/&gt;

```cs
public async Task GreetCommand(CommandContext ctx, string firstName, string lastName)
```

Each of these has their own caveats; it&apos;ll be up to you to choose the best solution for your commands.

### Argument Converters

CommandsNext can convert arguments, which are natively `string`, to the type specified by a command method parameter.
This functionality is powered by _argument converters_, and it&apos;ll help to eliminate the boilerplate code needed to parse and convert `string` arguments.

CommandsNext has built-in argument converters for the following types:

|    Category    | Types                                                                                                                                 |
| :------------: | :------------------------------------------------------------------------------------------------------------------------------------ |
|    Discord     | `DiscordGuild`, `DiscordChannel`, `DiscordMember`, `DiscordUser`,&lt;br/&gt;`DiscordRole`, `DiscordMessage`, `DiscordEmoji`, `DiscordColor` |
|    Integral    | `byte`, `short`, `int`, `long`, `sbyte`, `ushort`, `uint`, `ulong`                                                                    |
| Floating-Point | `float`, `double`, `decimal`                                                                                                          |
|      Date      | `DateTime`, `DateTimeOffset`, `TimeSpan`                                                                                              |
|   Character    | `string`, `char`                                                                                                                      |
|    Boolean     | `bool`                                                                                                                                |

You&apos;re also able to create and provide your own [custom argument converters](xref:modules_commandsnext_customization_argument_converters), if desired.

Let&apos;s do a quick demonstration of the built-in converters.

Create a new command method above our `GreetCommand` method named `RandomCommand` and have it take two integer arguments.
As the method name suggests, this command will be named _random_.

```cs
[Command(&quot;random&quot;)]
public async Task RandomCommand(CommandContext ctx, int min, int max) { }
```

Make a variable with a new instance of `Random`.

```cs
var random = new Random();
```

Finally, we&apos;ll respond with a random number within the range provided by the user.

```cs
await ctx.RespondAsync($&quot;Your number is: {random.Next(min, max)}&quot;);
```

Run your bot once more with `F5` and give this a try in a text channel.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !random 1 100
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Your number is: 69
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

CommandsNext converted the two arguments from `string` into `int` and passed them to the parameters of our command,
removing the need to manually parse and convert the arguments yourself.

We&apos;ll do one more to drive the point home. Head back to our old `GreetCommand` method, remove our
`name` parameter, and replace it with a new parameter of type `DiscordMember` named `member`.

```cs
public async Task GreetCommand(CommandContext ctx, DiscordMember member)
```

Then modify the response to mention the provided member with the `Mention` property on `DiscordMember`.

```cs
public async Task GreetCommand(CommandContext ctx, DiscordMember member)
{
    await ctx.RespondAsync($&quot;Heywo, {member.Mention}! Enjoy the mention!&quot;);
}
```

Go ahead and give that a test run.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet &lt;discord-mention&gt;Discord User&lt;/discord-mention&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet Discord User
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet 666339628613107725
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

The argument converter for `DiscordMember` is able to parse mentions, usernames, nicknames, and user IDs then look for a matching member within the guild the command was executed from.
Ain&apos;t that neat?

## Command Overloads

Command method overloading allows you to create multiple argument configurations for a single command.

```cs
[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, string bar, int baz) { }

[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, DiscordUser bar) { }
```

Executing `!foo green 5` will run the first method, and `!foo @SecondUser` will run the second method.

Additionally, all check attributes are shared between overloads.&lt;br/&gt;

```cs
[Command(&quot;foo&quot;), Aliases(&quot;bar&quot;, &quot;baz&quot;)]
[RequireGuild, RequireBotPermissions(Permissions.AttachFiles)]
public Task FooCommand(CommandContext ctx, int bar, int baz, string qux = &quot;agony&quot;) { }

[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, DiscordChannel bar, TimeSpan baz) { }
```

The additional attributes and checks applied to the first method will also be applied to the second method.

## Further Reading

Now that you&apos;ve gotten an understanding of CommandsNext, it&apos;d be a good idea check out the following:

-   [Command Attributes](xref:modules_commandsnext_command_attributes)
-   [Help Formatter](xref:modules_commandsnext_customization_help_formatter)
-   [Dependency Injection](xref:modules_commandsnext_dependency_injection)</file><file path="DisCatSharp.Docs/articles/modules/interactivity/interactivity.md">---
uid: modules_interactivity_introduction
title: Interactivity Introduction
hasDiscordComponents: true
---

# Introduction to Interactivity

Interactivity will enable you to write commands which the user can interact with through reactions and messages.
The goal of this article is to introduce you to the general flow of this extension.

Make sure to install the `DisCatSharp.Interactivity` package from NuGet before continuing.

![Interactivity NuGet](/images/interactivity_01.png)

## Enabling Interactivity

Interactivity can be registered using the `DiscordClient#UseInteractivity()` extension method.&lt;br/&gt;
Optionally, you can also provide an instance of `InteractivityConfiguration` to modify default behaviors.

```cs
var discord = new DiscordClient();

discord.UseInteractivity(new InteractivityConfiguration()
{
    PollBehaviour = PollBehaviour.KeepEmojis,
    Timeout = TimeSpan.FromSeconds(30)
});
```

## Using Interactivity

There are two ways available to use interactivity:

-   Extension methods available for `DiscordChannel`, `DiscordMessage`, `DiscordClient` and `DiscordInteraction`.
-   [Instance methods](xref:DisCatSharp.Interactivity.InteractivityExtension#methods) available from `InteractivityExtension`.

We&apos;ll have a quick look at a few common interactivity methods along with an example of use for each.

The first (and arguably most useful) extension method is `SendPaginatedMessageAsync` for `DiscordChannel`.

This method displays a collection of _&apos;pages&apos;_ which are selected one-at-a-time by the user through reaction buttons.
Each button click will move the page view in one direction or the other until the timeout is reached.

You&apos;ll need to create a collection of pages before you can invoke this method.
This can be done easily using the `GeneratePagesInEmbed` and `GeneratePagesInContent` instance methods from `InteractivityExtension`.

Alternatively, for pre-generated content, you can create and add individual instances of `Page` to a collection.

This example will use the `GeneratePagesInEmbed` method to generate the pages.

```cs
public async Task PaginationCommand(CommandContext ctx)
{
    var reallyLongString = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing ...&quot;

    var interactivity = ctx.Client.GetInteractivity();
    var pages = interactivity.GeneratePagesInEmbed(reallyLongString);

    await ctx.Channel.SendPaginatedMessageAsync(ctx.Member, pages);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-embed slot=&quot;embeds&quot;&gt;
            &lt;discord-embed-description slot=&quot;description&quot;&gt;Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero&lt;/discord-embed-description&gt;
        &lt;/discord-embed&gt;
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏮️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;◀️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏹️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;▶️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏭️&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Next we&apos;ll look at the `WaitForReactionAsync` extension method for `DiscordMessage`.
This method waits for a reaction from a specific user and returns the emoji that was used.

An overload of this method also enables you to wait for a _specific_ reaction, as shown in the example below.

```cs
public async Task ReactionCommand(CommandContext ctx, DiscordMember member)
{
    var emoji = DiscordEmoji.FromName(ctx.Client, &quot;:ok_hand:&quot;);
    var message = await ctx.RespondAsync($&quot;Hey {member.Mention}, react with {emoji}!&quot;);

    var result = await message.WaitForReactionAsync(member, emoji);

    if (!result.TimedOut) await ctx.RespondAsync(&quot;Thanks :3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
         Hey &lt;discord-mention highlight profile=&quot;user&quot;&gt;Discord User&lt;/discord-mention&gt;, react with 👌!
         &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction name=&quot;👌&quot; emoji=&quot;/images/ok_hand.svg&quot; count=&quot;1&quot; reacted&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
         Thanks :3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Another reaction extension method for `DiscordMessage` is `CollectReactionsAsync`.
As the name implies, this method collects all reactions on a message until the timeout is reached.

```cs
public async Task CollectionCommand(CommandContext ctx)
{
    var message = await ctx.RespondAsync(&quot;React here!&quot;);
    var reactions = await message.CollectReactionsAsync();

    var stringBuilder = new StringBuilder();
    foreach (var reaction in reactions)
        stringBuilder.AppendLine($&quot;{reaction.Emoji}: {reaction.Total}&quot;);

    await ctx.RespondAsync(stringBuilder.ToString());
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        React here!
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction name=&quot;uwu&quot; emoji=&quot;https://cdn.discordapp.com/emojis/859022252372787241.png&quot; count=&quot;3&quot; reacted&gt;&lt;/discord-reaction&gt;
            &lt;discord-reaction name=&quot;👌&quot; emoji=&quot;/images/ok_hand.svg&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        👌: 1&lt;br/&gt;
        &lt;discord-custom-emoji name=&quot;uwu&quot; url=&quot;https://cdn.discordapp.com/emojis/859022252372787241.png&quot;&gt;&lt;/discord-custom-emoji&gt;: 3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

The final one we&apos;ll take a look at is the `GetNextMessageAsync` extension method for `DiscordMessage`.

This method will return the next message sent from the author of the original message.
Our example here will use its alternate overload which accepts an additional predicate.

```cs
public async Task ActionCommand(CommandContext ctx)
{
    await ctx.RespondAsync(&quot;Respond with `confirm` to continue.&quot;);
    var result = await ctx.Message.GetNextMessageAsync(m =&gt;
    {
        return m.Content.ToLower() == &quot;confirm&quot;;
    });

    if (!result.TimedOut)
        await ctx.RespondAsync(&quot;OwO, thanks for confirming &lt;3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;Respond with &lt;discord-inline-code&gt;confirm&lt;/discord-inline-code&gt; to continue.&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;confirm&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;OwO, thanks for confirming &lt;3&lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/oauth2/oauth2_client.md">---
uid: modules_oauth2_oauth2_client
title: Discord OAuth2 Client
author: DisCatSharp Team
---

# DiscordOAuth2Client

We support integrating discords OAuth2 directly into DisCatSharp bots.
For this we&apos;ve added the [DiscordOAuth2Client](xref:DisCatSharp.DiscordOAuth2Client).

Additionally, we provide a new extension called [OAuth2WebExtention](xref:DisCatSharp.Extensions.OAuth2Web.OAuth2WebExtension) in the package `DisCatSharp.Extensions.OAuth2Web`, which provides you with a web server implementation and certain events.

## Example

```cs
// Client registration
internal DiscordClient Client { get; private set; } // We assume you registered it somewhere
internal static DiscordOAuth2Client OAuth2Client { get; private set; }
internal static Uri RequestUri { get; set; }

// ...
OAuth2Client = new(3218382190382813, &quot;thisistotallylegitsecret&quot;, &quot;http://127.0.0.1:42069/oauth/&quot;);

// Event registration
OAuth2Client.OAuth2ClientErrored += (sender, args) =&gt;
{
	Client.Logger.LogError(args.Exception, &quot;OAuth2 Client error in {Event}. Exception: {Exception}&quot;, args.EventName, args.Exception.Message);
	return Task.CompletedTask;
};

// Some command class
[SlashCommand(&quot;test_oauth2&quot;, &quot;Tests OAuth2&quot;)]
public static async Task TestOAuth2Async(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Please wait..&quot;));

	var state = OAuth2Client.GenerateState();

    RequestUri = OAuth2Client.GenerateOAuth2Url(&quot;identify connections&quot;, state);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(RequestUri.AbsoluteUri));
}

// Somewhere were you handle web stuff
var uri; // we assume you got the uri in your http handler

if (!OAuth2Client.ValidateState(RequestUri, uri)) // Validate the state
	return;

var token = await OAuth2Client.ExchangeAccessTokenAsync(OAuth2Client.GetCodeFromUri(uri)); // Exchange the code for an access token
var user = await OAuth2Client.GetCurrentUserAsync(token); // Get the user

// Work with your token. I.e. get the users connections
var connections = await OAuth2Client.GetCurrentUserConnectionsAsync(token);

```

## Example with OAuth2Web Extension

```cs
// Client registration
internal DiscordClient Client { get; private set; } // We assume you registered it somewhere
internal OAuth2WebExtension OAuth2WebService { get; private set; }

// ...
this.OAuth2WebService = this.Client.UseOAuth2Web(new OAuth2WebConfiguration()
{
	ClientId = 3218382190382813, // Your client id
	ClientSecret = &quot;thisistotallylegitsecret&quot;, // Your client secret
	RedirectUri = &quot;http://127.0.0.1:42069/oauth/&quot;, // The redirect url, must be public accessible. Possible proxy it.
	ListenAll = true,
	SecureStates = true
});

// Event registration
var oauth2 = this.Client.GetOAuth2Web();
oauth2.AuthorizationCodeReceived += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Auth code received for {State}&quot;, args.ReceivedState);
	return Task.CompletedTask;
};
oauth2.AuthorizationCodeExchanged += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Auth code exchanged for {User} with state {State}&quot;, args.UserId, args.ReceivedState);
	return Task.CompletedTask;
};
oauth2.AccessTokenRefreshed += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Access token refresh for {User}&quot;, args.UserId);
	return Task.CompletedTask;
};
oauth2.AccessTokenRevoked += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Access token revoked for {User}&quot;, args.UserId);
	return Task.CompletedTask;
};
oauth2.OAuth2Client.OAuth2ClientErrored += (sender, args) =&gt;
{
	Client.Logger.LogError(args.Exception, &quot;OAuth2 Client error in {Event}. Exception: {Exception}&quot;, args.EventName, args.Exception.Message);
	return Task.CompletedTask;
};

// Client start
await this.Client.ConnectAsync();
this.Client.Logger.LogInformation(&quot;Starting OAuth2 Web&quot;);
this.OAuth2WebService.StartAsync();

// Some command class
[SlashCommand(&quot;test_oauth2&quot;, &quot;Tests OAuth2&quot;)]
public static async Task TestOAuth2Async(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Please wait..&quot;));

	var web = ctx.Client.GetOAuth2Web();

	var uri = web.OAuth2Client.GenerateOAuth2Url(&quot;identify connections&quot;, web.OAuth2Client.GenerateSecureState(ctx.User.Id));
	web.SubmitPendingOAuth2Url(uri);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(uri.AbsoluteUri));

	var res = await web.WaitForAccessTokenAsync(ctx.User, uri, TimeSpan.FromMinutes(1));
	if (!res.TimedOut)
	{
		var testData = await web.OAuth2Client.GetCurrentUserConnectionsAsync(res.Result.DiscordAccessToken);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;{testData.Count} total connections. First connection username: {testData.First().Name}&quot;));
		await web.RevokeAccessTokenAsync(ctx.User);
	}
	else
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Timed out :(&quot;));
}
```

## Limitations

We only implemented methods and routes which all users can use.
You can use the access token and build calls yourself if needed.</file><file path="DisCatSharp.Docs/articles/sec_comp/sentry.md">---
uid: sec_comp_sentry
title: Sentry Safety Report
author: DisCatSharp Team
---

# Recent Claims about the Sentry Integration and Measures Taken

## Overview

Recently, claims were made regarding the logging of tokens within our Sentry integration in the DisCatSharp library. These claims were taken seriously and thoroughly investigated. This document outlines our findings and the steps taken to further ensure the security and privacy of our users.

## Claims and Investigation

The claims suggested that our Sentry integration was logging sensitive information, including tokens. After a comprehensive review, including chasing the logs through a proxy, it was confirmed that no sensitive information such as tokens was being transmitted.

### Validation Process

1. **Proxy Analysis**: Logs sent to Sentry were inspected using a proxy to ensure no sensitive data was being transmitted.
2. **Code Review**: The relevant sections of the code were reviewed to verify that no tokens or sensitive information were included in the logs.

## Measures Taken

Despite the validation that no sensitive data was being logged, additional measures have been implemented to further enhance security:

1. **StripTokens Utility**: A utility function to remove any Discord-based tokens from strings before they are sent to Sentry.
   ```csharp
   public static string? StripTokens(string? str)
   {
      if (string.IsNullOrWhiteSpace(str))
         return str;

      str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
      str = Regex.Replace(str, @&quot;(mfa\\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);

      return str;
   }
   ```

2. **Breadcrumb Filter**: Filters out sensitive information from breadcrumb logs before sending them to Sentry.
   ```csharp
   options.SetBeforeBreadcrumb(b
      =&gt; new Breadcrumb(Utilities.StripTokens(b.Message),
         b.Type,
         b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripTokens(x.Value)))
         .ToDictionary(x =&gt; x.Key, x =&gt; x.Value),
         b.Category,
         b.Level));
   ```

3. **Transaction Filter**: Ensures that sensitive information is not included in transaction data sent to Sentry.
   ```csharp
   options.SetBeforeSendTransaction(tr =&gt;
   {
      if (tr.Request.Data is string str)
         tr.Request.Data = Utilities.StripTokens(str);

      return tr;
   });
   ```

## Conclusion

The initial claims were found to be unsubstantiated. However, we have taken this opportunity to enhance our security measures further to ensure the safety and privacy for our users. We appreciate the community&apos;s vigilance and remain committed to maintaining a secure and reliable library.

For more details on the specific pull requests and discussions related to these measures, please refer to the following links:
- [Pull Request 494](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/494)
- [Pull Request 493](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/493)
- [Pull Request 495](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/495)
- [Pull Request 501](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/501)

Thank you for your continued support and understanding.</file><file path="DisCatSharp.Docs/articles/topics/components/buttons.md">---
uid: topics_components_buttons
title: Buttons
author: DisCatSharp Team
hasDiscordComponents: true
---

# Introduction

Buttons are a feature in Discord based on the interaction framework appended to the bottom of a message which come in several colors.
You will want to familarize yourself with the [message builder](xref:topics_messagebuilder) as it and similar builder objects will be used throughout this article.

With buttons, you can have up to five buttons in a row, and up to five (5) rows of buttons, for a maximum for 25 buttons per message.
Furthermore, buttons come in two types: regular, and link. Link buttons contain a Url field, and are always grey.

# Buttons Continued

&gt; [!WARNING]
&gt; Component (Button) Ids on buttons should be unique, as this is what&apos;s sent back when a user presses a button.
&gt;
&gt; Link buttons do **not** have a custom id and do **not** send interactions when pressed.

Buttons consist of five parts:

-   Id
-   Style
-   Label
-   Emoji
-   Disabled

The id of the button is a settable string on buttons, and is specified by the developer. Discord sends this id back in the [interaction object](https://discord.dev/interactions/slash-commands#interaction).

Non-link buttons come in four colors, which are known as styles: Blurple, Grey, Green, and Red. Or as their styles are named: Primary, Secondary, Success, and Danger respectively.

How does one construct a button? It&apos;s simple, buttons support constructor and object initialization like so:

```cs
var myButton = new DiscordButtonComponent()
{
    CustomId = &quot;my_very_cool_button&quot;,
    Style = ButtonStyle.Primary,
    Label = &quot;Very cool button!&quot;,
    Emoji = new DiscordComponentEmoji(&quot;😀&quot;)
};
```

This will create a blurple button with the text that reads &quot;Very cool button!&quot;. When a user pushes it, `&quot;my_very_cool_button&quot;` will be sent back as the `Id` property on the event. This is expanded on in the [how to respond to buttons](#responding-to-button-presses).

The label of a button is optional _if_ an emoji is specified. The label can be up to 80 characters in length.
The emoji of a button is a [partial emoji object](https://discord.dev/interactions/message-components#component-object), which means that **any valid emoji is usable**, even if your bot does not have access to it&apos;s origin server.

The disabled field of a button is rather self explanatory. If this is set to true, the user will see a greyed out button which they cannot interact with.

## Adding buttons

&gt; [!NOTE]
&gt; This article will use underscores in button ids for consistency and styling, but spaces are also usable.

Adding buttons to a message is relatively simple. Simply make a builder, and sprinkle some content and the buttons you&apos;d like.

```cs
var builder = new DiscordMessageBuilder();
builder.WithContent(&quot;This message has buttons! Pretty neat innit?&quot;);
```

Well, there&apos;s a builder, but no buttons. What now? Simply make a new button object (`DiscordButtonComponent`) and call `.AddComponents()` on the MessageBuilder.

```cs
var myButton = new DiscordButtonComponent
{
    CustomId = &quot;my_custom_id&quot;,
    Label = &quot;This is a button!&quot;,
    Style = ButtonStyle.Primary,
};

var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has buttons! Pretty neat innit?&quot;)
    .AddComponents(myButton);
```

Now you have a message with a button. Congratulations! It&apos;s important to note that `.AddComponents()` will create a new row with each call, so **add everything you want on one row in one call!**

Buttons can be added in any order you fancy. Lets add 5 to demonstrate each color, and a link button for good measure.

```cs
var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has buttons! Pretty neat innit?&quot;)
    .AddComponents(new DiscordComponent[]
    {
        new DiscordButtonComponent(ButtonStyle.Primary, &quot;1_top&quot;, &quot;Primary&quot;),
        new DiscordButtonComponent(ButtonStyle.Secondary, &quot;2_top&quot;, &quot;Secondary&quot;),
        new DiscordButtonComponent(ButtonStyle.Success, &quot;3_top&quot;, &quot;Success&quot;),
        new DiscordButtonComponent(ButtonStyle.Danger, &quot;4_top&quot;, &quot;Danger&quot;),
        new DiscordLinkButtonComponent(&quot;https://some-super-cool.site&quot;, &quot;Link&quot;)
    });
```

As promised, not too complicated. Links however are `DiscordLinkButtonComponent`, which takes a URL as it&apos;s first parameter, and the label. Link buttons can also have an emoji, like regular buttons.

Lets also add a second row of buttons, but disable them, so the user can&apos;t push them all willy-nilly.

```cs
builder.AddComponents(new DiscordComponent[]
{
    new DiscordButtonComponent(ButtonStyle.Primary, &quot;1_top_d&quot;, &quot;Primary&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Secondary, &quot;2_top_d&quot;, &quot;Secondary&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Success, &quot;3_top_d&quot;, &quot;Success&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Danger, &quot;4_top_d&quot;, &quot;Danger&quot;, true),
    new DiscordLinkButtonComponent(&quot;https://some-super-cool.site&quot;, &quot;Link&quot;, true)
});
```

Practically identical, but now with `true` as an extra parameter. This is the `Disabled` property.

Produces a message like such:

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
    Omg buttons! Poggers :3
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot;&gt;Primary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;Secondary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;success&quot;&gt;Success&lt;/discord-button&gt;
                &lt;discord-button type=&quot;destructive&quot;&gt;Danger&lt;/discord-button&gt;
                &lt;discord-button url=&quot;https://discord.gg/RXA6u3jxdU&quot;&gt;Link&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot; disabled&gt;Primary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot; disabled&gt;Secondary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;success&quot; disabled&gt;Success&lt;/discord-button&gt;
                &lt;discord-button type=&quot;destructive&quot; disabled&gt;Danger&lt;/discord-button&gt;
                &lt;discord-button url=&quot;https://discord.gg/RXA6u3jxdU&quot; disabled&gt;Link&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Well, that&apos;s all neat, but lets say you want to add an emoji. Being able to use any emoji is pretty neat, after all. That&apos;s also very simple!

```cs
var myButton = new DiscordButtonComponent
(
    ButtonStyle.Primary,
    &quot;emoji_button&quot;,
    &quot;OwO&quot;,
    false,
    new DiscordComponentEmoji(922569846569455646)
);
```

And you&apos;re done! Simply add that to a builder, and when you send, you&apos;ll get a message that has a button with our cute logo!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
    What&apos;s this? Emojis in buttons??
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot; emoji=&quot;https://cdn.discordapp.com/emojis/922569846569455646.webp?size=96&amp;quality=lossless&quot; emoji-name=&quot;dcs&quot;&gt;OwO&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Responding to button presses

When any button is pressed, it will fire the [ComponentInteractionCreated](xref:DisCatSharp.DiscordClient.ComponentInteractionCreated) event.

In the event args, `Id` will be the id of the button you specified. There&apos;s also an `Interaction` property, which contains the interaction the event created. It&apos;s important to respond to an interaction within 3 seconds, or it will time out. Responding after this period will throw a `NotFoundException`.

With buttons, there are two new response types: `DeferredMessageUpdate` and `UpdateMessage`.
using `DeferredMessageUpdate` lets you create followup messages via the [followup message builder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder). The button will return to being in it&apos;s &apos;dormant&apos; state, or it&apos;s &apos;unpushed&apos; state, if you will.

You have 15 minutes from that point to make followup messages. Responding to that interaction looks like this:

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate);
    // Do things.. //
}
```

If you would like to update the message when a button is pressed, however, you&apos;d use `UpdateMessage` instead, and pass a `DiscordInteractionResponseBuilder` with the new content you&apos;d like.

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.UpdateMessage, new DiscordInteractionResponseBuilder().WithContent(&quot;No more buttons for you &gt;:)&quot;));
}
```

This will update the message, and without the infamous &lt;sub&gt;(edited)&lt;/sub&gt; next to it. Nice.

# Interactivity

Along with the typical `WaitForMessageAsync` and `WaitForReactionAsync` methods provided by interactivity, there are also button implementations as well.

More information about how interactivity works can be found in [the interactivity article](xref:modules_interactivity_introduction)

Since buttons create interactions, there are also two additional properties in the configuration:

-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior
-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseMessage

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior is what interactivity will do when handling something that isn&apos;t a valid valid button, in the context of waiting for a specific button. It defaults to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ignore, which will cause the interaction fail.

Alternatively, setting it to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ack will acknowledge the button, and continue waiting.

@DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Respond will reply with an ephemeral message with the aforementioned response message.

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior only applies to the overload accepting a string id of the button to wait for.</file><file path="DisCatSharp.Docs/articles/topics/components/select_menus.md">---
uid: topics_components_select_menus
title: Select Menus
author: DisCatSharp Team
---

# Introduction

The select menus, like the [buttons](xref:topics_components_buttons), are message components.
You will want to familarize yourself with the [message builder](xref:topics_messagebuilder) as it and similar builder objects will be used throughout this article.

A row can only have one select menu. An row containing a select menu cannot also contain buttons.
Since a message can have up to 5 rows, you can add up to 5 select menus to a message.

# Select Menus

&gt; [!WARNING]
&gt; Component Ids and option values should be unique, as this is what&apos;s sent back when a user selects one (or more) option.

Select menus consist of five parts:

-   Id
-   Placeholder
-   Options
-   MinOptions
-   MaxOptions
-   Disabled

The id of the select menu is a settable string, and is specified by the developer. Discord sends this id back in the [interaction object](https://discord.dev/interactions/slash-commands#interaction).

**Placeholder** is a settable string that appears in the select menu when nothing is selected.

**Options** is an array of options for the user to select. Their maximum number in one select menu is 25.
You can let users choose 1 or more options using **MinOptions** and **MaxOptions**.

Options consist of five parts:

-   Label
-   Value
-   Description
-   IsDefault
-   Emoji

Menu creation, for easier understanding, can be divided into two stages:

```cs
// First, create an array of options.
var options = new DiscordSelectComponentOption[]
{
    new DiscordSelectComponentOption(&quot;First option&quot;, &quot;first_option&quot;, &quot;This is the first option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😀&quot;)),
    new DiscordSelectComponentOption(&quot;Second option&quot;, &quot;second_option&quot;, &quot;This is the second option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😎&quot;))
};

// Now let&apos;s create a select menu with the options created above.
var selectMenu = new DiscordSelectComponent(&quot;my_select_menu&quot;, &quot;Please select one of the options&quot;, options);
```

This will create a select menu with two options and the text &quot;Please select one of the options&quot;.
When a user select **one** option, `&quot;my_select_menu&quot;` will be sent back as the `Id` property on the event.
This is expanded on in the [how to respond to select menus](#responding-to-select-menus).

You can increase the maximum/minimum number of selections in the select menu constructor. You can also block the select menu, or options.

Description and emoji of options are optional. The label, value and description can be up to 100 characters in length.
The emoji of a option is a [partial emoji object](https://discord.dev/interactions/message-components#component-object), which means that **any valid emoji is usable**, even if your bot does not have access to it&apos;s origin server.

## Adding Select Menu

Adding a select menu is no different than adding a button.
We have already created the select menu above, now we will just create a new message builder add the select menu to it.

```cs
var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has select menu! Pretty neat innit?&quot;)
    .AddComponents(selectMenu);
```

Now you have a message with a select menu. Congratulations! It&apos;s important to note that `.AddComponents()` will create a new row with each call, so **add everything you want on one row in one call!**

Lets also add a second row with select menu with the ability to choose any number of options.

```cs
var secondOptions = new DiscordSelectComponentOption[]
{
    new DiscordSelectComponentOption(&quot;First option&quot;, &quot;first_option&quot;, &quot;This is the first option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😀&quot;)),
    new DiscordSelectComponentOption(&quot;Second option&quot;, &quot;second_option&quot;, &quot;This is the second option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😎&quot;))
    new DiscordSelectComponentOption(&quot;Third option&quot;, &quot;third_option&quot;, &quot;This is the third option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😘&quot;))
};

var secondSelectMenu = new DiscordSelectComponent(&quot;my_second_select_menu&quot;, &quot;Please select up to 3 options&quot;, secondOptions, 1, 3);

builder.AddComponents(secondSelectMenu);
```

And you&apos;re done! The select menu will now be sent when the user closes the select menu with 1 to 3 options selected.

## Responding to select menus

When any select menu is pressed, it will fire the [ComponentInteractionCreated](xref:DisCatSharp.DiscordClient.ComponentInteractionCreated) event.

In the event args, `Id` will be the id of the select menu you specified. There&apos;s also an `Interaction` property, which contains the interaction the event created. It&apos;s important to respond to an interaction within 3 seconds, or it will time out. Responding after this period will throw a `NotFoundException`.

With select menus, there are two new response types: `DeferedMessageUpdate` and `UpdateMessage`.
using `DeferredMessageUpdate` lets you create followup messages via the [followup message builder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder).

You have 15 minutes from that point to make followup messages. Responding to that interaction looks like this:

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferedMessageUpdate);
    // Do things.. //
}
```

If you would like to update the message when an select menu option selected, however, you&apos;d use `UpdateMessage` instead, and pass a `DiscordInteractionResponseBuilder` with the new content you&apos;d like.

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.UpdateMessage, new DiscordInteractionResponseBuilder().WithContent(&quot;No more select menu for you &gt;:)&quot;));
}
```

This will update the message, and without the infamous &lt;sub&gt;(edited)&lt;/sub&gt; next to it. Nice.

# Interactivity

Along with the typical `WaitForMessageAsync` and `WaitForReactionAsync` methods provided by interactivity, there are also select menus implementations as well.

More information about how interactivity works can be found in [the interactivity article](xref:modules_interactivity_introduction)

Since select menus create interactions, there are also two additional properties in the configuration:

-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior
-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseMessage

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior is what interactivity will do when handling something that isn&apos;t a valid valid select menu, in the context of waiting for a specific select menu. It defaults to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ignore, which will cause the interaction fail.

Alternatively, setting it to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ack will acknowledge the select menu, and continue waiting.

@DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Respond will reply with an ephemeral message with the aforementioned response message.

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior only applies to the overload accepting a string id of the select menu to wait for.</file><file path="DisCatSharp.Docs/articles/topics/events.md">---
uid: topics_events
title: DisCatSharp Events
author: DisCatSharp Team
---

# Events In DisCatSharp

## Consuming Events

DisCatSharp makes use of _asynchronous events_ which will execute each handler asynchronously in sequential order.
This event system will require event handlers have a `Task` return type and take two parameters.

The first parameter will contain an instance of the object which fired the event.&lt;br/&gt;
The second parameter will contain an arguments object for the specific event you&apos;re handling.

Below is a snippet demonstrating this with a lambda expression.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += async (s, e) =&gt;
    {
        if (e.Message.Content.ToLower().Contains(&quot;spiderman&quot;))
            await e.Message.RespondAsync(&quot;I want pictures of Spiderman!&quot;);
    };

	discord.GuildMemberAdded += (s, e) =&gt;
    {
        // Non asynchronous code here.
        return Task.CompletedTask;
    };
}
```

Alternatively, you can create a new method to consume an event.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += MessageCreatedHandler;
	discord.GuildMemberAdded += MemberAddedHandler;
}

private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    if (e.Guild?.Id == 379378609942560770 &amp;&amp; e.Author.Id == 168548441939509248)
        await e.Message.DeleteAsync();
}

private Task MemberAddedHandler(DiscordClient s, GuildMemberAddEventArgs e)
{
    // Non asynchronous code here.
    return Task.CompletedTask;
}
```

## Using automatic event registration

Instead of having to manually register each event, the attributes `Event` and `EventHandler` can be utilized to semi-automatically register events in a multitude of ways.

By attributing all classes that constitute event handlers with `EventHandler` and all methods within those classes that are intended to handle events with `Event` you can register all of those events with a single call to `DiscordClient.RegisterEventHandlers(Assembly)`

```cs
[EventHandler]
public class MyEventHandler
{
    [Event]
    private async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }

    [Event(DiscordEvent.MessageCreated)] // You can specify the event name in the attribute, instead of via the method name!
    public static async Task MySecondaryHandler(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }
}
```

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();
    discord.RegisterEventHandlers(Assembly.GetExecutingAssembly());
}
```

If an event handler class is not `abstract` (which also means not `static`) it will be instantiated, optionally with the help of an `IServiceProvider`, if one has been provided to the `DiscordConfig`. The inability to instantiate an event handler type constitutes an error.

```cs
public class SomeClass { }

[EventHandler]
public class MyOtherEventHandler
{
    private SomeClass some;

    public MyOtherEventHandler(SomeClass some) { this.some = some; }

    [Event]
    public async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* do something with some */ }
}
```

In the above example an instance of `SomeClass` will need to be provided to the `DiscordContext`&apos;s `IServiceProvider`, read the next chapter to see how to accomplish that!

You can also register individual types, and even individual objects as event handlers using the overloaded method `DiscordClient.RegisterEventHandler`. In both of those cases the attribute `EventHandler` is not required.

When registering an object as a handler, by default the type&apos;s static methods will _not_ be considered as event handling methods.
This allows for registering multiple instances of the same type without registering their static event handling methods multiple times.
To register the static methods exclusively, use `DiscordClient.RegisterStaticEventHandler` with the type in question.

## Dependency Injection

Often, you need a way to get data in and out of your event handlers.
Although you _could_ use `static` fields to accomplish this, the preferred solution would be _dependency injection_.

First, you need to register the services that you can use in the event handlers in the future.

You can do this in DiscordConfiguration:

```cs
var config = new DiscordConfiguration()
{
    Token = &quot;Token here&quot;,
    TokenType = TokenType.Bot,
    ServiceProvider = new ServiceCollection()
        .AddScoped&lt;YourService&gt;()
        .AddSingleton&lt;YourSecondService&gt;()
        .BuildServiceProvider()
};
```

In this case, we have registered two services: `YourService` as Scoped and` YourSecondService` as Singleton.

Now you can use them in your event handlers.

```cs
private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    var service = e.ServiceProvider.GetRequiredService&lt;YourService&gt;();
    var secondService = e.ServiceProvider.GetRequiredService&lt;YourSecondService&gt;();
}
```

### Services

| Lifespan  | Instantiated                           |
| :-------: | :------------------------------------- |
| Singleton | One time when added to the collection. |
|  Scoped   | Once for each event handler.           |
| Transient | Every request to the ServiceProvider.  |

## Avoiding Deadlocks

Despite the fact that your event handlers are executed asynchronously, they are also executed one at a time on the gateway thread for consistency.
This means that each handler must complete its execution before others can be dispatched.

Because of this, executing code in your event handlers that runs for an extended period of time may inadvertently
create brief unresponsiveness or, even worse, cause a [deadlock](https://en.wikipedia.org/wiki/Deadlock).
To prevent such issues, any event handler that has the potential to take more than 2 seconds to execute should have its logic offloaded to a `Task.Run`.

```cs
discord.MessageCreated += (s, e) =&gt;
{
    _ = Task.Run(async () =&gt;
    {
        // Pretend this takes many, many seconds to execute.
        var response = await QuerySlowWebServiceAsync(e.Message.Content);

        if (response.Status == HttpStatusCode.OK)
        {
            await e.Guild?.BanMemberAsync((DiscordMember)e.Author);
        }
    });

	return Task.CompletedTask;
};
```

Doing this will allow the handler to complete its execution quicker, which will in turn allow other handlers to be executed and prevent the gateway thread from being blocked.</file><file path="DisCatSharp.Docs/articles/topics/intents.md">---
uid: topics_intents
title: Intents
author: DisCatSharp Team
---

# Intents

Intents were added to Discord to help the service not have to push so many events to the bots that were not using them. If you are going to be needing to subscribe to any type of event, they are going to have to be defined **BOTH** within the
[Discord Application under the Bot Page](https://discord.com/developers/applications) on Discords Site and also within the @DisCatSharp.DiscordConfiguration.

## Discord Application

On the [Discord Application under the Bot Page](https://discord.com/developers/applications) you will have to specify if your bot requires Privileged Intents. We recommend having these all enabled at first to ensure the most stability when building your first bot, otherwise you may run into issues when retrieving entities from the library&apos;s cache.

![Bot Page](/images/Intents.png)

&gt; [!WARNING]
&gt; These privileged intents may not be available for you to toggle on immediately.
&gt;
&gt; Due to their nature of sensitive data, Discord requires you to go through a verification process once your bot is in a certain amount of servers.
&gt; Please read this [blog post](https://support.discord.com/hc/en-us/articles/360040720412) for more information and how to apply.

## Discord Configuration

Within your `DiscordConfiguration` you will have to specify all the intents you will need. Here is a list of all the
[Intents](xref:DisCatSharp.Enums.DiscordIntents) DisCatSharp Supports. By default, the configuration will use `DiscordIntents.AllUnprivileged` as the default value. Like above however, we recommend having all intents enabled at first, so you should specify `DiscordIntents.All` in your configuration which will include the privileged intents you enabled in your application:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.All
};
```

When you become more advanced, you can try experimenting with turning off intents you do not need in order to save resources. In your `DiscordConfiguration` you can specify one or many.

Here is an example of just specifying one:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.GuildBans
};
```

Here is an example of specifying many:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.DirectMessageReactions
    | DiscordIntents.DirectMessages
    | DiscordIntents.GuildBans
    | DiscordIntents.GuildEmojis
    | DiscordIntents.GuildInvites
    | DiscordIntents.GuildMembers
    | DiscordIntents.GuildMessages
    | DiscordIntents.Guilds
    | DiscordIntents.GuildVoiceStates
    | DiscordIntents.GuildWebhooks,
};
```

Please Note, if you specify a privileged intent within your `DiscordConfiguration` that you have not signed up for on the Discord Application page, an error will be thrown on the connection.</file><file path="DisCatSharp.Docs/articles/topics/logging/default.md">---
uid: topics_logging_default
title: The Default Logger
author: DisCatSharp Team
---

# The Default Logger

DisCatSharp ships with a default logging implementation which is **enabled automatically** with **no setup required**.

![Info Level Logging](/images/topics_logging_default_01.png)

This is a basic implementation that only sends log messages to the console.

## Minimum Logging Level

You&apos;re able to adjust the verbosity of log messages via `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    MinimumLogLevel = LogLevel.Debug
};
```

The example above will display level log messages that are higher than or equal to `Debug`.

![Debug Level Logging](/images/topics_logging_default_02.png)

## Timestamp Format

You&apos;re also able to change the format of the log timestamp; this is also set through `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    LogTimestampFormat = &quot;MMM dd yyyy - hh:mm:ss tt&quot;
};
```

![The Real Timestamp Format](/images/topics_logging_default_03.png)

For a list of all available format specifiers, check out the MSDN page for [custom date and time format strings](https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings#day-d-format-specifier).

## Log Levels

Below is a table of all log levels and the kind of messages you can expect from each.
Name|Position|Description
:---:|:---:|:---
`Critical`|5|Fatal error which may require a restart.
`Error`|4| A failure of an operation or request.
`Warning`|3|Non-fatal errors and abnormalities.
`Information`|2|Session startup and resume messages.
`Debug`|1| Ratelimit buckets and related information.
`Trace`|0| Websocket &amp; REST traffic.

&gt; [!WARNING]
&gt; The `Trace` log level is _not_ recommended for use in production.
&gt;
&gt; It is intended for debugging DisCatSharp and may display tokens and other sensitive data.</file><file path="DisCatSharp.Docs/articles/topics/logging/di.md">---
uid: topics_logging_di
title: Dependency Injection Logging
author: DisCatSharp Team
---

# Default Logger

By default, when using DI, you will be using Microsoft&apos;s implementation of `ILogger` and `ILoggerFactory`. This requires no additional setup.

# Third Party Logger

If you wish to use a different logging service/implementation you simply install the appropriate nuget package, or create your own which have implementations for `ILoggerFactory` and `ILogger`.

You need to register either this third party implementation or your own via the `IServiceCollection` which becomes `IServiceProvider` at runtime.

If we are using the DisCatSharp ProjectTemplates there will be a project with a `.Web`. Inside is a `Program.cs` file.

###WebHost: Serilog

-   Serilog.AspNetCore
-   Serilog.Extensions.Hosting -- Gives us the `UseSerilog` extension
-   Serilog.Sinks.Console -- Sinks are used to direct where logs go. In this case we need it for outputting to console

```cs
using Serilog;

// unrelated code not shown for brevity
builder.Host.UseSerilog( (context, lc) =&gt; lc.WriteTo.Console()); // Our logs are directed to the console

var app = builder.Build();
app.Run();
```</file><file path="DisCatSharp.Docs/articles/topics/logging/third_party.md">---
uid: topics_logging_third_party
title: Third Party Logging
author: DisCatSharp Team
---

# Using a Third Party Logger

While the default logging implementation will meet the needs of most, some may desire to make use of a more robust implementation which provides more features.
Thankfully, DisCatSharp allows you to use any logging library which has an implementation for the [logging abstractions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging) provided by Microsoft.

[Serilog](https://serilog.net/), one of the more popular logging libraries, will be used to demonstrate.
This will simply be a brief demo, so we won&apos;t go into the configuration of Serilog.
You&apos;ll want to head on over to their [wiki page](https://github.com/serilog/serilog/wiki/Configuration-Basics) to learn about that!

We&apos;ll need to install both the `Serilog` and `Serilog.Extensions.Logging` packages from NuGet, along with at least one of the many available
[sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks). Our example here will only use the `Serilog.Sinks.Console` sink.

&lt;br/&gt;
Start off by creating a new `LoggerConfiguration` instance, slap `.WriteTo.Console().CreateLogger()` onto the end of it, then directly assign that to the static `Logger` property on the `Log` class.

```cs
Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .CreateLogger();
```

This will make a new Serilog logger instance which will write to the console sink.

&lt;br/&gt;
Next, create a new variable and assign it a new `LoggerFactory` instance which calls `AddSerilog()`.

```cs
var logFactory = new LoggerFactory().AddSerilog();
```

Then assign that variable to the `LoggerFactory` property of your of `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    LoggerFactory = logFactory
}
```

&lt;br/&gt;
Altogether, you&apos;ll have something similar to this:

```cs
using Microsoft.Extensions.Logging;
using Serilog;

public async Task MainAsync()
{
    Log.Logger = new LoggerConfiguration()
        .WriteTo.Console()
        .CreateLogger();

    var logFactory = new LoggerFactory().AddSerilog();
    var discord = new DiscordClient(new DiscordConfiguration()
    {
        LoggerFactory = logFactory
    });
}
```

And that&apos;s it! If you now run your bot, you&apos;ll see DisCatSharp log messages formatted and displayed by Serilog.

![Console](/images/topics_logging_third_party_01.png)</file><file path="DisCatSharp.Docs/articles/topics/messagebuilder.md">---
uid: topics_messagebuilder
title: Message Builder
author: DisCatSharp Team
hasDiscordComponents: true
---

# Message Builder

## Background

Before the message builder was put into place, we had one large method for sending messages along with 3 additional methods for sending files. This was becoming a major code smell and it was hard to maintain and add more parameters onto it. Now we support just sending a simple message, an embed, a simple message with an embed, or a message builder.

## Using the Message Builder

The API Documentation for the message builder can be found [there](xref:DisCatSharp.Entities.DiscordMessageBuilder),
but here we&apos;ll go over some of the concepts of using the message builder:

### Adding a File

For sending files, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
 using (var fs = new FileStream(&quot;global_name.cs&quot;, FileMode.Open, FileAccess.Read))
 {
    var msg = await new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s a code snippet for you!&quot;)
        .WithFiles(new Dictionary&lt;string, Stream&gt;() { { &quot;global_name.cs&quot;, fs } })
        .SendAsync(ctx.Channel);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Here&apos;s a code snippet for you!
        &lt;discord-attachments slot=&quot;attachments&quot;&gt;
            &lt;discord-attachment type=&quot;file&quot; alt=&quot;global_name.cs&quot; size=&quot;1.2 MB&quot;  url=&quot;/snippets/global_name.cs&quot;&gt;&lt;/discord-attachment&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

### Adding Mentions

For sending mentions, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;✔ UserMention(user): Hey, {user.Mention}! Listen!&quot;)
    .WithAllowedMentions(new IMention[] { new UserMention(user) })
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        ✔ UserMention(user): Hey, &lt;discord-mention highlight profile=&quot;user&quot;&gt;Discord User&lt;/discord-mention&gt;! Listen!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

### Sending TTS Messages

For sending a TTS message, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;This is a test message&quot;)
    .HasTTS(true)
    .SendAsync(ctx.Channel);
```

### Sending an Inline Reply

For sending an inline reply, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;I&apos;m talking to *you*!&quot;)
    .WithReply(ctx.Message.Id)
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Who you talking to?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Who you talking to?&lt;/discord-reply&gt;
        I&apos;m talking to &lt;discord-bold&gt;you&lt;/discord-bold&gt;!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;br/&gt;
By default, replies do not mention. To make a reply mention, simply pass true as the second parameter:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;I&apos;m talking to *you*!&quot;)
    .WithReply(ctx.Message.Id, true)
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Who you talking to?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Who you talking to?&lt;/discord-reply&gt;
        I&apos;m talking to &lt;discord-bold&gt;you&lt;/discord-bold&gt;!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/topics/sharding.md">---
uid: topics_sharding
title: Sharding
author: DisCatSharp Team
---

# Sharding

As your bot joins more guilds, your poor `DiscordClient` will be hit with an increasing number of events.
Thankfully, Discord allows you to establish multiple connections to split the event workload; this is called _sharding_ and each individual connection is referred to as a _shard_.
Each shard handles a separate set of servers and will _only_ receive events from those servers. However, all direct messages will be handled by your first shard.

Sharding is recommended once you reach 1,000 servers, and is a _requirement_ when you hit 2,500 servers.

## Automated Sharding

DisCatSharp provides a built-in sharding solution: `DiscordShardedClient`.
This client will _automatically_ spawn shards for you and manage their events.
Each DisCatSharp extension (e.g. CommandsNext, Interactivity) also supplies an extension method to register themselves automatically on each shard.

```cs
var discord = new DiscordShardedClient(new DiscordConfiguration
{
    Token = &quot;My First Token&quot;,
    TokenType = TokenType.Bot
});

await discord.UseCommandsNextAsync(new CommandsNextConfiguration()
{
    StringPrefixes = new[] { &quot;!&quot; }
});
```

## Manual Sharding

For most looking to shard, the built-in `DiscordShardedClient` will work well enough.
However, those looking for more control over the sharding process may want to handle it manually.

This would involve creating new `DiscordClient` instances, assigning each one an appropriate shard ID number, and handling the events from each instance.
Considering the potential complexity imposed by this process, you should only do this if you have a valid reason to do so and _know what you are doing_.</file><file path="DisCatSharp.Docs/articles/topics/workarounds.md">---
uid: topics_workarounds
title: Workarounds
author: DisCatSharp Team
---

# Workarounds

Here is a collection of common workarounds for minor problems.

## Thread warns with _.. take too long to execute_

This warning happens from time to time if you&apos;re doing big tasks on events.
A quick workaround for this warning is the following method:

```cs
discordClient.VoiceStateUpdated += (sender, args) =&gt;
{
    Task.Run(async () =&gt; await DiscordClientOnVoiceStateUpdated(sender, args));
    return Task.CompletedTask;
};
```

With this you start a new non-blocking thread.

Another alternative is:

```cs
new Thread(Method).Start()
```

## A messages components field type is changed suddenly

Let me quote something about that:

&gt; Going forward, you should be exceedingly prepared to handle new components not wrapped in action rows
&gt; - Discord Team

We&apos;ve had to introduce a breaking change due to this.
[DiscordMessage.Components](xref:DisCatSharp.Entities.DiscordMessage.Components) is now of the type `IReadOnlyList&lt;`[DiscordComponent](xref:DisCatSharp.Entities.DiscordComponent)`&gt;` instead of `IReadOnlyList&lt;`[DiscordActionRowComponent](xref:DisCatSharp.Entities.DiscordActionRowComponent)`&gt;`.

To get components in action rows (because bots can only create such component hierarchies) reliable, you&apos;d have to do [DiscordMessage.Components.OfType&lt;DiscordActionRowComponent&gt;](xref:System.Linq.Enumerable.OfType*) to get a `IReadOnlyList&lt;`[DiscordActionRowComponent](xref:DisCatSharp.Entities.DiscordActionRowComponent)`&gt;` again.</file><file path="DisCatSharp.Docs/changelogs/index.md">---
uid: changelogs
title: Changelogs
author: DisCatSharp Team
---

# Changelogs

Please select the changelog you want to view from the left side.

Current: [v10.6.6](xref:changelogs_v10_10_6_6)</file><file path="DisCatSharp.Docs/changelogs/v10/10_0_0.md">---
uid: changelogs_v10_10_0_0
title: Version 10.0.0
author: DisCatSharp Team
---

# Upgrade from **9.9.0** to **10.0.0**

## What is new in DisCatSharp?

-   Advanced dependency injection system
-   Support for API v10
-   Message content intent
-   Properly working application command localization
-   Optimized lib code
-   Pre-implementation of upcoming things
-   Support for [Channel Type](xref:DisCatSharp.Enums.ChannelType) `Forum` (WIP)

## What changed?

To get message content with API v10, you have to enable the message content intent in the developer portal AND specify the [DiscordIntent](xref:DisCatSharp.Enums.DiscordIntents) `MessageContent`.
Otherwise you won&apos;t receive message contents from guild messages where the bot isn&apos;t mentioned.

## Backwards Compatibility

You can always choose to use a previous API version.
I.e. if you want to use API V9, you can use `DiscordIntents.AllV9Less` to enable all intents that are valid for this version.</file><file path="DisCatSharp.Docs/changelogs/v10/10_1_0.md">---
uid: changelogs_v10_10_1_0
title: Version 10.1.0
author: DisCatSharp Team
---

# Upgrade from **10.0.0** to **10.1.0**

## What is new in DisCatSharp?

-   Rework of [ApplicationCommands](xref:api_discatsharp_applicationcommands_index)
-   Support for [DiscordGuild.DisableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableInvitesAsync*)
-   Full support for [Forum](xref:DisCatSharp.Enums.ChannelType) [Channels](xref:DisCatSharp.Entities.DiscordChannel)
-   Support for [Spotify](xref:DisCatSharp.Lavalink.Enums.LavalinkSearchType) and [Apple Music](xref:DisCatSharp.Lavalink.Enums.LavalinkSearchType) in [DisCatSharp.Lavalink](xref:api_discatsharp_lavalink_index). See [Lavalink Advanced Usage](xref:modules_audio_lavalink_v4_advanced) for more information.
-   Documentation has a bunch of new and reworked articles!

---

## What changed?

&gt; [!WARNING]
&gt; This release contains breaking changes. Please read the changelog carefully.
&gt; Some bug fixes aren&apos;t noted here.

### All packages

NuGet packages now support [Source Link](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) &amp; [Deterministic Builds](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation).

-   Updated the NuGet specs to be compatible with NuGet Gallery.
-   Changed PackageLicenseUrl to PackageLicenseFile and included the top-level [LICENSE.md](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/LICENSE.md)
-   Changed PackageIconUrl to PackageIcon and included [DisCatSharp.Logos/logobig.png](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/DisCatSharp.Logos/logobig.png)

&gt; [!CAUTION]
&gt; We&apos;ve fixed various namespaces. Please make sure to update your code accordingly.

### DisCatSharp

-   Implemented Forum Channels
    -   Added fields to [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel):
        -   [PostCreateUserRateLimit](xref:DisCatSharp.Entities.DiscordChannel.PostCreateUserRateLimit)
        -   [DefaultReactionEmoji](xref:DisCatSharp.Entities.DiscordChannel.DefaultReactionEmoji) with the type of [ForumReactionEmoji](xref:DisCatSharp.Entities.ForumReactionEmoji)
        -   [AvailableTags](xref:DisCatSharp.Entities.DiscordChannel.AvailableTags)
    -   Added fields to [DiscordThreadChannel](xref:DisCatSharp.Entities.DiscordThreadChannel):
        -   [TotalMessagesSent](xref:DisCatSharp.Entities.DiscordThreadChannel.TotalMessagesSent)
        -   [AppliedTags](xref:DisCatSharp.Entities.DiscordThreadChannel.AppliedTags)
    -   Added entity [ForumPostTag](xref:DisCatSharp.Entities.ForumPostTag)
    -   Added function to create a forum through the guild entity [CreateForumChannelAsync](xref:DisCatSharp.Entities.DiscordGuild.CreateForumChannelAsync*)
    -   Added functions to modify a forum channel [ModifyForumAsync](xref:DisCatSharp.Entities.DiscordChannel.ModifyForumAsync*)
    -   Added forum post tag operations on threads
-   Added disable invites for [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild)
    -   Added new function [EnableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.EnableInvitesAsync*)
    -   Added new function [DisableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableInvitesAsync*)
-   The ordered channel methods and fields in [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) now include Forum Channels
-   Added [DiscordMember.DisconnectFromVoiceAsync](xref:DisCatSharp.Entities.DiscordMember.DisconnectFromVoiceAsync*)
-   Added [Avatar Decorations](xref:DisCatSharp.Entities.DiscordUser.AvatarDecorationUrl)
-   Added [Theme Colors](xref:DisCatSharp.Entities.DiscordUser.ThemeColors)
-   Added support for the `X-Discord-Locale` Header in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration.Locale)
-   Added support for sending component-only messages
-   Implemented `ResumeGatewayUrl`
-   Added [GuildFeatures](xref:DisCatSharp.Entities.GuildFeatures):
    -   [GuildHomeTest](xref:DisCatSharp.Entities.GuildFeaturesEnum) (Experimental)
    -   [InvitesDisabled](xref:DisCatSharp.Entities.GuildFeaturesEnum)
-   Implemented DiscordWebhookBuilder.WithThreadName to create forum posts via a webhook
-   Added [ApplicationFlags.ApplicationCommandBadge](xref:DisCatSharp.Enums.ApplicationFlags)
-   Added a bypassCache option to [DiscordChannel.GetMessageAsync](xref:DisCatSharp.Entities.DiscordChannel.GetMessageAsync*)
-   Added the new field `AppPermissions` to the interaction entity and the context entities.
-   Added function [DiscordGuild.EnableMfaAsync](xref:DisCatSharp.Entities.DiscordGuild.EnableMfaAsync*)
-   Added function [DiscordGuild.DisableMfaAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableMfaAsync*)
-   Reworked component result for modal submits [\*DC1](xref:changelogs_v10_10_1_0#dc1)
-   Reworked [DiscordIntegration](xref:DisCatSharp.Entities.DiscordIntegration) to include the new fields
    -   Added [SubscriberCount](xref:DisCatSharp.Entities.DiscordIntegration.SubscriberCount)
    -   Added [Revoked](xref:DisCatSharp.Entities.DiscordIntegration.Revoked)
    -   Added [Application](xref:DisCatSharp.Entities.DiscordIntegration.Application)
    -   Added [Scopes](xref:DisCatSharp.Entities.DiscordIntegration.Scopes)
    -   Removed int ExpireBehavior
    -   Added [ExpireBehavior](xref:DisCatSharp.Entities.DiscordIntegration.ExpireBehavior) as new enum [IntegrationExpireBehavior](xref:DisCatSharp.Enums.IntegrationExpireBehavior)
-   Reworked [DiscordConnection](xref:DisCatSharp.Entities.DiscordConnection) to include the new fields
    -   Removed int Visibility
    -   Added [Visibility](xref:DisCatSharp.Entities.DiscordConnection.Visibility) as new enum [ConnectionVisibilityType](xref:DisCatSharp.Enums.ConnectionVisibilityType)
    -   Added [TwoWayLink](xref:DisCatSharp.Entities.DiscordConnection.TwoWayLink)
-   [DiscordClient.ReconnectAsync](xref:DisCatSharp.DiscordClient.ReconnectAsync*) param startNewSession now defaults to `true`
-   Moved guild related enums from the [DisCatSharp](xref:DisCatSharp) to the [DisCatSharp.Enums](xref:DisCatSharp.Enums) namespace
-   Fixed webhooks for threads
-   Dropped support for channel banners, it sadly never made its way into discord

### DisCatSharp.ApplicationCommands

-   Added support for slash commands in shards
-   Added Translation Generator &amp; Exporter (see [here](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsConfiguration.GenerateTranslationFilesOnly))
-   Added [DiscordClient.RemoveGlobalApplicationCommandsAsync](xref:DisCatSharp.DiscordClient.RemoveGlobalApplicationCommandsAsync*)
-   Implemented support for minimum_length and maximum_length for application command options
    -   Added [MinimumLengthAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumLengthAttribute). Minimum `int` if set: 0. Valid for: `string`
    -   Added [MaximumLengthAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumLengthAttribute). Minimum `int` if set: 1. Valid for: `string`
-   Changed namespaces
    -   [DisCatSharp.ApplicationCommands](xref:DisCatSharp.ApplicationCommands)
    -   [DisCatSharp.ApplicationCommands.Attributes](xref:DisCatSharp.ApplicationCommands.Attributes)
    -   [DisCatSharp.ApplicationCommands.Context](xref:DisCatSharp.ApplicationCommands.Context)
    -   [DisCatSharp.ApplicationCommands.Exceptions](xref:DisCatSharp.ApplicationCommands.Exceptions)
-   Renamed MinimumAttribute to [MinimumValueAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumValueAttribute). Valid for: `int`, `long` &amp; `double`
-   Renamed MaximumAttribute &amp; [MaximumValueAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumValueAttribute). Valid for: `int`, `long` &amp; `double`
-   Proper exception log when registering app commands fails
-   Reworked [translation](xref:modules_application_commands_translations_using) for application commands
-   Reworked application command registration
-   Fixed `DmPermissions` check for Application Commands on registration
-   Fixed double interaction bug
-   Fixed `int` &gt; `long` cast exception
-   Fixed a bug where the default help command would not work if auto defer was enabled
-   Various bug fixes
-   Removed `ApplicationCommandsExtension.CleanGuildCommandsAsync()`
-   Removed `ApplicationCommandsExtension.CleanGlobalCommandsAsync()`

### DisCatSharp.Lavalink

-   Added support for apple music &amp; spotify search

---

## Other changes

Please compare the commits on [GitHub](https://github.com/Aiko-IT-Systems/DisCatSharp/compare/10.0.0...v10.1.0)

## Information to other [Discord Features](https://discord.com/developers/docs/change-log)

-   We won&apos;t implement AutoMod for a while, as it takes a lot of time to implement and we don&apos;t have the time for it right now.
-   DiscordMember Timeout Events are still buggy, we have it on our list of bugs to fix, but it&apos;s not a priority right now.

## Diff Changes

### DC1

DiscordInteractionData:

Pulled up the component results from modal submits for easier access

```diff
- IEnumerable&lt;DiscordInteractionDataOption&gt; Options
+ IReadOnlyList&lt;DiscordInteractionDataOption&gt; Options
- IEnumerable&lt;DiscordActionRowComponentResult&gt; Components
+ IReadOnlyList&lt;DiscordComponentResult&gt; Components
```

DiscordActionRowComponentResult:

```diff
- List&lt;DiscordComponentResult&gt; Components
+ IReadOnlyList&lt;DiscordComponentResult&gt; Components
```</file><file path="DisCatSharp.Docs/changelogs/v10/10_2_0.md">---
uid: changelogs_v10_10_2_0
title: Version 10.2.0
author: DisCatSharp Team
---

# Upgrade from **10.1.0** to **10.2.0**

## What is new in DisCatSharp?

This release contains changes from Hacktoberfest tasks.

## What changed?

We worked hard during hacktober to make the lib better. Here&apos;s what we did:

---

### 10.2.0-hacktober-001

#### Changelog

```diff
+ Added stickers to guild preview (Task 3)
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/206

#### Contributors

-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-002

```diff
* Reworked activity invite creation
* Fixed forum channel creation, it now actually creates a forum (type 15) channel
+ Added article for available activities *1
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/208
-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/209

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)
-   [Lulalaby](https://github.com/Lulalaby)

#### New Articles

-   [Voice Activities](xref:misc_voice_activities)

---

### 10.2.0-hacktober-003

```diff
* Reworked various thinks like lists, arrays, namespaces
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/210

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)

---

### 10.2.0-hacktober-004

```diff
+ Added DiscordClient.GetGuildWidgetAsync
+ Added DiscordClient.TryGetGuildWidgetAsync
* Fixed a bug in guild widgets
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/211
-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/212

#### Contributors

-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-005

```diff
* Fixed the presence update event
- Removed PresenceUpdateEventArgs.UserBefore
- Removed PresenceUpdateEventArgs.UserAfter
```

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)

---

### 10.2.0-hacktober-006

```diff
* Fixed ModifyCommunitySettingsAsync (channels are now required to set when modifying the community state)
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/213

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)

---

### 10.2.0-hacktober-007

```diff
* Reworked guild features
* Changed the HasXy methods to flags (Enums)
+ Created a method for the enum named HasFeature(GuildFeatureFlag)
+ Created a method for the guild features to dynamically generate a string list of features
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/214

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)

---

### 10.2.0-hacktober-008

&gt; [!WARNING]
&gt; This version contains breaking changes

#### Note

This version adds support for user, role, channel &amp; mentionable selects in both the main lib as well in interactivity.

```diff
- DiscordSelectComponent was removed and replaced by
+ DiscordStringSelectComponent + DiscordStringSelectComponentOption
+ Select component types have the base class DiscordBaseSelect from now on
* Interactivity for selects where changed in the InteractivityExtension, as well in the MessageExtension to have an additional required parameter before the timeout override called selectType. You need to specify for which select type you&apos;re waiting for
```

#### Documentation

##### DisCatSharp Package

Entities:

-   [DiscordBaseSelectComponent](xref:DisCatSharp.Entities.DiscordBaseSelectComponent) &gt; and the sub classes
    [DiscordStringSelectComponentOption](xref:DisCatSharp.Entities.DiscordStringSelectComponentOption) (Replaces `DiscordSelectComponentOption`)

Enums

-   [ComponentType](xref:DisCatSharp.Enums.ComponentType)

##### DisCatSharp.Interactivity

InteractivityExtension:

-   [WaitForSelectAsync](xref:DisCatSharp.Interactivity.InteractivityExtension.WaitForSelectAsync*) and additional functions

Message Extension:

-   [WaitForSelectAsync](xref:DisCatSharp.Interactivity.Extensions.MessageExtensions.WaitForSelectAsync*) and additional functions

#### Example

```cs
[SlashCommand(name: &quot;test_select&quot;, description: &quot;Testing select&quot;)]
public static async Task TestSelectAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral());
	DiscordWebhookBuilder builder = new();
	builder.WithContent(content: &quot;Testing user select&quot;);
	builder.AddComponents(new DiscordUserSelectComponent(label: &quot;User to select&quot;, custom_id: &quot;select_test_001&quot;, min_options: 1, max_options: 2, disabled: false));
	var msg = await ctx.EditResponseAsync(builder);
	var inter = await ctx.Client.GetInteractivity().WaitForSelectAsync(message: msg, id: &quot;select_test_001&quot;, selectType: ComponentType.UserSelect, timespan: TimeSpan.FromSeconds(30));
	if (!inter.TimedOut)
	{
		await inter.Result.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(content: $&quot;Selected {string.Join(&quot; &amp; &quot;, inter.Result.Values)}&quot;));
		await ctx.Channel.SendMessageAsync(content: $&quot;Ping pong {string.Join(&quot; &amp; &quot;, inter.Result.Interaction.Data.Resolved.Users.Values.Select(x =&gt; x.Mention))}&quot;);
	}
}
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/218

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)
-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-010

```diff
+ Added method to look up additional infos about applications (rpc endpoint)
```

#### Documentation

-   [DiscordRpcApplication](xref:DisCatSharp.Entities.DiscordRpcApplication)
-   [DiscordClient.GetRpcApplicationAsync](xref:DisCatSharp.DiscordClient.GetRpcApplicationAsync*)
-   [DiscordUser.GetRpcInfoAsync](xref:DisCatSharp.Entities.DiscordUser.GetRpcInfoAsync*)

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)</file><file path="DisCatSharp.Docs/changelogs/v10/10_3_0.md">---
uid: changelogs_v10_10_3_0
title: Version 10.3.0
author: DisCatSharp Team
---

# Upgrade from **10.2.0** to **10.3.0**

## What is new in DisCatSharp?

Full support for [Auto Moderation](https://support.discord.com/hc/en-us/articles/4421269296535)

## What changed?

-   We fixed a bug with [DiscordChannelSelectComponent](xref:DisCatSharp.Entities.DiscordChannelSelectComponent) where the `channelTypes` property threw a null exception because incorrect array conversion.
-   Added support for new [UserFlags](xref:DisCatSharp.Enums.UserFlags) and [ApplicationFlags](xref:DisCatSharp.Enums.ApplicationFlags).
-   Application Commands support now the [`nsfw`](https://support.discord.com/hc/en-us/articles/10123937946007) parameter.

### Flags

#### Added user flags

-   `ActiveDeveloper`
-   `HighGlobalRateLimit`
-   `Deleted`
-   `DisabledSuspiciousActivity`
-   `SelfDeleted`

#### Renamed user flags

-   `PartnerOrVerificationApplication` was renamed to `InternalApplication`

#### Added application flags

-   `Active`

### Auto Moderation

-   The events for automoderation rules and executions are fully implemented.
-   Support for creating, updating and deleting rules.
-   Support for fetching rules.
-   Support for automod regex rules.
-   Intents for automod.

## Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/224

## Contributors

-   [Sh1be](https://github.com/xMaxximum)
-   [Lulalaby](https://github.com/Lulalaby)
-   [Mira](https://github.com/TheXorog)</file><file path="DisCatSharp.Docs/changelogs/v10/10_4_0.md">---
uid: changelogs_v10_10_4_0
title: Version 10.4.0
author: DisCatSharp Team
---

# Upgrade from **10.3.0** to **10.4.0**

&lt;br/&gt;

&gt; [!NOTE]
&gt; DisCatSharp is now compiled with .NET 7.0.

&gt; [!IMPORTANT]
&gt; The namespaces were adjusted to fit the actual location.

---

## What Is New In DisCatSharp?

&lt;br/&gt;

🆕 **Added [DisCatSharp Analyzer](xref:vs) to help you write better code**

🆕 Support for the new [Username System](https://dis.gd/usernames)

🆕 Support for [Linked Roles](https://discord.com/build/linked-roles)

🆕 Support for [Application Subscriptions](https://discord.com/build/apply-now) aka Premium Apps

🆕 Support for [Voice Messages](https://support.discord.com/hc/en-us/articles/13091096725527)

🆕 Support for sending [`@silent`](https://discord.com/blog/discord-update-february-20-2023-changelog#heading-1) messages

🧪 Partial support for role subscriptions

🧪 Partial support for burst reactions

🧪 Partial support for onboarding

🛠️ Fixed a bug where various flag enums were missing the `[Flags]` annotation.

---

## What Changed?

&lt;br/&gt;

### DisCatSharp

#### [DiscordClient](xref:DisCatSharp.DiscordClient)

➕ Added [GenerateInAppOauthFor](xref:DisCatSharp.DiscordClient.GenerateInAppOauthFor*) to generate an oauth link for other apps.

➕ Added [GetCurrentApplicationInfoAsync](xref:DisCatSharp.DiscordClient.GetCurrentApplicationInfoAsync*) to get the current application info.

➕ Added the [GuildAuditLogEntryCreated](xref:DisCatSharp.DiscordClient.GuildAuditLogEntryCreated) to the [DiscordClient](xref:DisCatSharp.DiscordClient). The implementation is currently unstable.

➕ Added `AutoModerationConfiguration` and `AutoModerationExecution` to [DiscordIntent](xref:DisCatSharp.Enums.DiscordIntents). This is included in `AllUnprivileged` and `All`.

➕ Added TryGetPublishedListings to get the published premium sku listings for an application.

⚠️ Removed `GuildBans` from [DiscordIntents](xref:DisCatSharp.Enums.DiscordIntents) and replaced it with `GuildModeration`.

#### [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration)

⚠️ Deprecated `UseCanary` &amp; `UsePtb`.

➕ Added [ApiChannel](xref:DisCatSharp.DiscordConfiguration.ApiChannel).

`UseCanary` &amp; `UsePtb` temporarily set `ApiChannel` internally:
[!code-csharp[](../../../DisCatSharp/DiscordConfiguration.cs#L220-L229)]

#### [DiscordApplication](xref:DisCatSharp.Entities.DiscordApplication)

➕ Added [ApproximateGuildCount](xref:DisCatSharp.Entities.DiscordApplication.ApproximateGuildCount) to get the approximate guild count.

➕ Added [InteractionsEndpointUrl](xref:DisCatSharp.Entities.DiscordApplication.InteractionsEndpointUrl) to get the interactions endpoint url set in the developer portal.

➕ Added [RedirectUris](xref:DisCatSharp.Entities.DiscordApplication.RedirectUris) to get the redirect uris set in the developer portal.

➕ Added [Guild](xref:DisCatSharp.Entities.DiscordApplication.Guild) to get the guild this application is linked to as support server.

➕ Added support for application subscriptions. See [this](#application-subscription) for more information.

➕ Added enum `DisCatSharp.Enums.ApplicationCommandContexts`. This field isn&apos;t added for now.

#### [DiscordInteraction](xref:DisCatSharp.Entities.DiscordInteraction)

➕ Added the options `AsSilentMessage` and `SuppressEmbeds` to [DiscordFollowupMessageBuilder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder), [DiscordInteractionResponseBuilder](xref:DisCatSharp.Entities.DiscordInteractionResponseBuilder) and [DiscordWebhookBuilder](xref:DisCatSharp.Entities.DiscordWebhookBuilder).

➕ Added [Entitlements](xref:DisCatSharp.Entities.DiscordInteraction.Entitlements) to get the entitlements for premium apps.

➕ Added [InteractionResponseType](xref:DisCatSharp.Enums.InteractionResponseType) `InteractionRequireEntitlement`.

#### [DiscordRole](xref:DisCatSharp.Entities.DiscordRole)

➕ Added `IsLinkedRole` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to check whether this role is a linked role.

➕ Added `SubscriptionListingId` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to get the subscription listing id.

➕ Added `AvailableForPurchase` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to check whether this role is available for purchase.

#### [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild)

➕ Added [SafetyAlertsChannel](xref:DisCatSharp.Entities.DiscordGuild.SafetyAltersChannel) to get the safety alerts channel and the corresponding function [ModifySafetyAlertsSettingsAsync](xref:DisCatSharp.Entities.DiscordGuild.ModifySafetyAlertsSettingsAsync*) to modify the safety alerts settings.

#### [AutomodRule](xref:DisCatSharp.Entities.AutomodRule)

➕ Added [MentionRaidProtectionEnabled](xref:DisCatSharp.Entities.AutomodTriggerMetadata.MentionRaidProtectionEnabled) to [AutomodTriggerMetadata](xref:DisCatSharp.Entities.AutomodTriggerMetadata).

➕ Added `TriggerType` `EnforceServerRules`. This is currently in alpha.

#### [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel)

➕ Added `scheduledEventId` to [DiscordChannel.OpenStageAsync](xref:DisCatSharp.Entities.DiscordChannel.OpenStageAsync*) to create a stage channel bound to a scheduled event.

➕ Added new [ChannelFlags](xref:DisCatSharp.Enums.ChannelFlags):

-   `IsBroadcasting`
-   `IsRoleSubscriptionTemplatePreviewChannel`
-   `ApplicationShelfConsent`
-   `SummariesDisabled`
-   `IsMediaChannel`
-   `IsScheduledForDeletion`
-   `ClydeAi`
-   `IsGuildResourceChannel`
-   `IsSpam`

⚠️ Removed `privacyLevel` from [DiscordChannel.OpenStageAsync](xref:DisCatSharp.Entities.DiscordChannel.OpenStageAsync*) as it&apos;s no longer supported by discord.

#### [DiscordThreadChannel](xref:DisCatSharp.Entities.DiscordThreadChannel)

➕ Added [LockAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.LockAsync*) to lock a thread.

➕ Added [UnlockAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.UnlockAsync*) to unlock a thread.

➕ You can now pin posts in forum channels.

❕ [Thread members](xref:DisCatSharp.Entities.DiscordThreadChannel.GetMembersAsync*) are now paginated.

⚠️ Deprecated parameter `locked` from [ArchiveAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.ArchiveAsync*) as it&apos;s no longer supported by discord.

#### [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage)

➕ Added support for voice messages. Flag `IsVoiceMessage` is set to represented if the message is a voice message.

➕ Added new [MessageTypes](xref:DisCatSharp.Enums.MessageType):

-   `PrivateChannelIntegrationAdded`
-   `PrivateChannelIntegrationRemoved`
-   `PremiumReferral`

#### [DiscordAttachment](xref:DisCatSharp.Entities.DiscordAttachment)

➕ Added [DurationSecs](xref:DisCatSharp.Entities.DiscordAttachment.DurationSecs) to get the duration of a voice message.

➕ Added [WaveForm](xref:DisCatSharp.Entities.DiscordAttachment.WaveForm) to get the waveform of a voice message. This is a base64 encoded byte-array representing a sampled waveform.

#### [DiscordReaction](xref:DisCatSharp.Entities.DiscordReaction)

&gt; [!WARNING]
&gt; Reactions are undergoing a rework which is not covered in this release.

🧪 Partial support for burst reactions.

#### [DiscordUser](xref:DisCatSharp.Entities.DiscordUser)

➕ Added [CreateDmChannelAsync](xref:DisCatSharp.Entities.DiscordUser.CreateDmChannelAsync*) to create a dm channel with this user.

➕ Added [SendMessageAsync](xref:DisCatSharp.Entities.DiscordUser.SendMessageAsync*) to send a message to this user.

➕ Added `Collaborator` and `RestrictedCollaborator` to [UserFlags](xref:DisCatSharp.Entities.DiscordUser.Flags) to check whether this user is a collaborator.

➕ Added support for the new [Username System](https://dis.gd/usernames). See [this](#username-system-change) for more information.

➕ Added [GlobalName](xref:DisCatSharp.Entities.DiscordUser.GlobalName) to get the global name of this user.

➕ Added [UsernameWithGlobalName](xref:DisCatSharp.Entities.DiscordUser.UsernameWithGlobalName) to get the username with the global name of this user.

➕ Added [IsMigrated](xref:DisCatSharp.Entities.DiscordUser.IsMigrated) to check whether this user is migrated to the new [Username System](https://dis.gd/usernames).

🛠️ Fixed a bug causing `Locale` to be null.

⚠️ Deprecated [UsernameWithDiscriminator](xref:DisCatSharp.Entities.DiscordUser.UsernameWithDiscriminator).

⚠️ Deprecated [Discriminator](xref:DisCatSharp.Entities.DiscordUser.Discriminator).

#### [DiscordMember](xref:DisCatSharp.Entities.DiscordMember)

➕ Added method [VerifyAsync](xref:DisCatSharp.Entities.DiscordMember.VerifyAsync*) to verify a member. This skips the verification requirements when onboarding is enabled.

➕ Added method [UnverifyAsync](xref:DisCatSharp.Entities.DiscordMember.UnverifyAsync*) to unverify a member.

➕ Added new [MemberFlags](xref:DisCatSharp.Enums.MemberFlags):

-   `BypassesVerification`
-   `StartedOnboarding`
-   `CompletedOnboarding`
-   `IsGuest`
-   `StartedHomeActions`
-   `CompletedHomeActions`
-   `AutomodQuarantinedUsernameOrGuildNickname`
-   `AutomodQuarantinedBio`

#### [DiscordInvite](xref:DisCatSharp.Entities.DiscordInvite)

➕ Added new [TargetType](xref:DisCatSharp.Enums.TargetType)s.

➕ Added new [InviteFlags](xref:DisCatSharp.Enums.InviteFlags).

#### [Permissions](xref:DisCatSharp.Enums.Permissions)

➕ Added `CreateGuildExpressions`

➕ Added `CreateEvents`

➕ Added `UseSoundboard`

➕ Added `UseExternalSounds`

➕ Added `SendVoiceMessages`

⚠️ Renamed `ManageExpressions` to `ManageGuildExpressions`

⚠️ Removed `ManageEmojisAndStickers`

#### [Formatter](xref:DisCatSharp.Formatter)

🛠️ All methods are now extension methods.

➕ Added support for extended markdown.

### DisCatSharp.ApplicationCommands

➕ You can now register guild commands via assembly. This doesn&apos;t support translations tho.

➕ Added [Entitlements](xref:DisCatSharp.ApplicationCommands.Context.BaseContext.Entitlements) to BaseContext.

➕ Added support for application subscriptions.

➕ Added ApplicationCommandRequireEntitlementAttribute to require an entitlement to execute a command.

🛠️ Fixed a bug preventing you to set `DmPermission` for ContextMenu commands.

### DisCatSharp.VoiceNext

🛠️ Fixed the ip discovery used to connect to discord voice servers.

Discord changed this suddenly without heads up.

Thanks to [disgo](https://github.com/disgoorg/disgo/) for helping out.

---

## Username System Change

&lt;br/&gt;

### [Preamble](#tab/username-sys-pre)

Official resources:

-   https://dis.gd/usernames
-   https://dis.gd/app-usernames
-   https://discord.com/blog/usernames

### [The Discord Announcement](#tab/username-sys-discord)

#### Impact of Unique Usernames on Apps and Bots

Discord announced that Discord’s username system is changing. Discriminators are being removed and new, unique usernames (`@name`) and display names are being introduced. These changes will make it easier for users to connect with their friends and give more control over identity on Discord. You can visit https://discord.com/blog/usernames to hear from one of their founders about why usernames are changing, or read more details about how changes to the username system affects non-bot users at https://dis.gd/usernames.

#### More details for developers (including an FAQ) are in the Help Center article:

-   https://dis.gd/app-usernames

Below is an overview of how apps and bots will be affected by the username change. More details for developers, including exact dates, will be communicated soon.

#### Changes to bot users on Discord

1. They recently made a change to add bot users to all newly-created apps. During the username migration, all apps without a bot user created before April 14 will have a bot user automatically added. If your app doesn’t require a bot user, you can skip adding the `bot` scope during installation.

2. After migration, developers will no longer be able to directly set bot usernames or bot icons. The bot user’s icon will _always_ be the same as the App Icon. Bot usernames will be determined differently for verified and unverified apps:

-   **Verified apps**: Bot usernames will be determined by the Application Name. When an unverified app goes through the verification process, a username created from the Application Name will be given to the bot user.
-   **Unverified apps**: Bot usernames will be randomized for new and existing unverified apps. This does not affect the Application Name.

3. Application Names (the `Name` field on the **General Overview** page within the app’s settings) will be used as the Display Name for an app’s bot user. This means developers cannot manually update the Display Name for a bot user without updating the Application Name. Server nicknames are unaffected by this change.

4. The Discord client will be updated to only display Application Names in most surfaces, including the bot profile and in the search interface. The client changes will allow all Discord apps, verified and unverified, to use their Application Name as the identity for their app (and bot) across Discord.

#### Migration of verified app usernames

Most verified apps with Application Names which can be automatically migrated to the new username system have been reserved. No user will be able to claim the reserved username, and during migration the reserved name will be automatically given to the app&apos;s bot user.

Verified apps that cannot be automatically migrated or wish to change their Application Name for another reason will be able to make a one-time change at the time of migration.

#### Identifying migrated users

To keep clients backwards-compatible, users that are migrated to the new username system will have a single zero (`#0`) discriminator. This will not appear in the client, but will be in payloads your app receives. After the migration to the new username system is complete, the `0` discriminator will be removed.

#### Preparing your app for username changes

-   Remove any logic that depends on discriminators for Discord users. Apps should continue using user IDs to uniquely identify Discord users in their code. Make sure to account for the temporary `#0` discriminator that updated users will have when updating your code.
-   Be prepared for your username change. That includes in code, or anywhere else you may reference your bot username.
-   If your app is verified, stay tuned for details about migration dates and how to perform a one-time update for your Application Name/bot username.

### [DisCatSharps Info](#tab/username-sys-discatsharp)

#### Developer take on the username change for bots

Bots having `Username#Discrim` is pretty useless imo.
`Username#Discrim`s only purpose is to add friends, but you can&apos;t add bots as friends.

A single `@username` makes more sense for bots because it acts as a vanity identifier.

Now you could argue about the fact that non-verified bots usernames are randomized.
That might be true, but users see the application name anyways in the UI, and this field is changeable.
Upon verification you can choose your custom `@username`.

I think this helps fighting scams and impersionations even more.

#### Transition to global name

We&apos;ve deprecated `Discriminator` &amp; `DiscriminatorInt` on the [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) &amp; [DiscordMember](xref:DisCatSharp.Entities.DiscordMember) entities.

Due to global name not being rolled out yet, `GlobalName` is marked as experimental for now.

During the rollout we&apos;ll remove the experimental mark from `GlobalName`.

You should update to this new field as soon as possible when the rollout begins.

As an example how to handle both cases:

[!code-csharp[](../../snippets/global_name.cs?highlight=13)]

#### New, changed and deprecated fields

These changes apply both for [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) &amp; [DiscordMember](xref:DisCatSharp.Entities.DiscordMember).

| Change Type | Field or Function         | Type            | Change Description                                                                     |
| ----------- | ------------------------- | --------------- | -------------------------------------------------------------------------------------- |
| Deprecated  | Discriminator             | @System.String  |                                                                                        |
| Deprecated  | DiscriminatorInt          | @System.Int32   |                                                                                        |
| Deprecated  | UsernameWithDiscriminator | @System.String  | This falls back to `UsernameWithGlobalName` for a while if a user is already migrated. |
| Added       | UsernameWithGlobalName    | @System.String  |                                                                                        |
| Added       | GlobalName                | @System.String  |                                                                                        |
| Added       | IsMigrated                | @System.Boolean | Helper function to detect whether a user has is enrolled in the new system.            |
| Changed     | ToString()\*              | @System.String  | Function was updated to return the correct info based on `IsMigrated`                  |

\*This was also changed for [DiscordTeamMember.ToString()](xref:DisCatSharp.Entities.DiscordTeamMember.ToString)

#### Automatic Mapping

To help you transition to this change, we automatically map the old username with discriminator to the new username with global name.

```mermaid
flowchart LR

A([UsernameWithDiscriminator]) --&gt; B{IsMigrated}
B --&gt;|True| C([Using UsernameWithGlobalName])
B --&gt;|False| D([Using Username#Discriminator])
```

---

---

## Application Subscription

&lt;br/&gt;

### [Preamble](#tab/appsub-pre)

We would like to announce that we have added partial support for Discord&apos;s Premium Apps feature. However, please note that this feature is currently in alpha and may not be fully supported by our library as library developers don&apos;t get access to the documentation for it.

Premium Apps allow developers to provide premium commands for which users can subscribe via in-app purchases. If a user is not subscribed, bots will respond with a message asking them to subscribe. If they are subscribed, the command payload from Discord to the bot will have a SKU ID set, indicating that the user or server is subscribed.

Although our library has implemented support for this feature, you might need to make adjustments to your code to fully utilize it. If you encounter any issues or require assistance, please inform us so that we can address the issue within the library.

### [Premium Apps](#tab/appsub-pa)

![premium_app_popout_profile](/images/premium_app_popout_profile.png)

![premium_app_popout_description](/images/premium_app_popout_description.png)

![premium_app_app_discovery](/images/premium_app_app_discovery.png)

### [Implementation](#tab/appsub-impl)

#### DisCatSharp

We&apos;ve added the field [Entitlements](xref:DisCatSharp.Entities.DiscordInteraction.Entitlements) to get the entitlements for premium apps.
It is a list of sku ids.

[InteractionResponseType](xref:DisCatSharp.Enums.InteractionResponseType) was extended by type `10` called `InteractionRequireEntitlement`. This is used to tell Discord that the user is not entitled to use the command and requests the user to buy the premium subscription.

Additionally we&apos;ve added the function TryGetPublishedListings to get the published premium sku listings for an application.
You can use it to check dynamically for your sku ids.

#### DisCatSharp.ApplicationCommands

Application commands got a new @System.Attribute called ApplicationCommandRequireEntitlementAttribute to require an entitlement to execute a command.

BaseContext now has the field [Entitlements](xref:DisCatSharp.ApplicationCommands.Context.BaseContext.Entitlements).

---

---

## Pull Requests

-   [feat: Paginated thread members](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/253)
-   [feat: Add guild audit log entry create event](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/256)
-   [fix: ip discovery](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/274)
-   [feat: Application rework](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/275)
-   [fix: speaking is flags not bool](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/276)
-   [fix(readme): minor grammar mistake](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/280)
-   [fix: DiscordEmoji operator == add compare name](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/284)
-   [DisCatSharp v10.4.0 Stable Release](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/295)

[Full Changes](https://github.com/Aiko-IT-Systems/DisCatSharp/compare/v10.3.2...v10.4.0)

---

## Contributors

-   [JustaSqu1d](https://github.com/JustaSqu1d)
-   [tonnac](https://github.com/tonnac)
-   [Lulalaby](https://github.com/Lulalaby)
-   [TheXorog](https://github.com/TheXorog)
-   [TopiSenpai](https://github.com/TopiSenpai)
-   [quinchs](https://github.com/quinchs)
-   [JuliaJJ](https://github.com/JuliaJJ/)

---

## Special Thanks

This release special thanks go to:

-   [snek](https://github.com/devsnek) for helping out with details about the premium apps implementation 😝
-   [TopiSenpai](https://github.com/TopiSenpai) for helping out with fixing the ip discovery
-   [quinchs](https://github.com/quinchs) for advising a good change I (Lala) totally forgot about
-   [JuliaJJ](https://github.com/JuliaJJ/) for helping out with design choice

---</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_0.md">---
uid: changelogs_v10_10_6_0
title: Version 10.6.0
author: DisCatSharp Team
---

# Upgrade from **10.4.0** to **10.6.0**

&gt; [!IMPORTANT]
&gt; We dropped support for .NET 5 in favor of newer features and major improvements in speed and stability.
&gt;
&gt; We removed previously deprecated fields and methods.
&gt;
&gt; We fixed a major bug with the gateway connection: Previously it wasn&apos;t actually applying the `version`, `encoding`, and `compress` fields, causing the gateway to use the default but deprecated version 6.

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

&gt; [!NOTE]
&gt; With this version, we are re-opening issues on GitHub. We hope that everything goes well and we can keep them open.
&gt; You can continue to use our [Discord server](https://discord.gg/RXA6u3jxdU) for support tho.

---

## Why weren&apos;t there any releases for a long time?

We&apos;ve been focusing on rewriting internals and improving the library.
Most of the changes were considered highly experimental and not ready for public use.

Other reasons were the lack of motivation to write changelogs 😅

---

## What changed?

&lt;br/&gt;

➕ Added [Members](xref:DisCatSharp.Entities.DiscordRole.Members) field to [DiscordRole](xref:DisCatSharp.Entities.DiscordRole).

➕ Added [EnableEmoticons](xref:DisCatSharp.Entities.DiscordIntegration.EnableEmoticons) and [GuildId](xref:DisCatSharp.Entities.DiscordIntegration.GuildId) to [DiscordIntegration](xref:DisCatSharp.Entities.DiscordIntegration).

➕ [Sentry](#sentry-integration) for automatic tracking of library errors and reporting new fields in API payloads.

➕ [Update check on startup](#update-check-on-startup) for new library versions, configurable in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ New configuration field [EnablePayloadReceivedEvent](xref:DisCatSharp.DiscordConfiguration.EnablePayloadReceivedEvent) to work with raw events.

⚠️ Added [ApiChannel](xref:DisCatSharp.DiscordConfiguration.ApiChannel) enum in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration); removed `UseCanary` &amp; `UsePtb`.

➕ [Locale](xref:DisCatSharp.DiscordConfiguration.Locale) and [Timezone](xref:DisCatSharp.DiscordConfiguration.Timezone) settings in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ New methods and constructors for building [DiscordOverwrite](xref:DisCatSharp.Entities.DiscordOverwrite) objects.

🛠️ Caching members now in [DiscordGuild.GetAllMembersAsync()](xref:DisCatSharp.Entities.DiscordGuild.GetAllMembersAsync).

➕ `SubCommandName` &amp; `FullCommandName` to [BaseContext](xref:DisCatSharp.ApplicationCommands.Context.BaseContext).

➕ [UnusualDmActivityUntil](xref:DisCatSharp.Entities.DiscordMember.UnusualDmActivityUntil) in [DiscordMember](xref:DisCatSharp.Entities.DiscordMember).

➕ Incident configs and events on [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild).

🛠️ Group, subgroup, and subcommand creation for application commands along side each other.

➕ Added support for custom status.

➕ [DiscordOAuth2Client](xref:DisCatSharp.DiscordOAuth2Client) for OAuth2 API interaction.

➕ Support for iframe modals (Currently only midjourney has access to this).

➕ Pagination buttons constants for custom ids.

⚠️ Removed `DiscordEmbedBuilder.AddField(string name, string value, bool inline)`; use [DiscordEmbedBuilder.AddField(DiscordEmbedField field)](xref:DisCatSharp.Entities.DiscordEmbedBuilder.AddField*) instead.

🛠️ [DiscordGuild.BanMemberAsync](xref:DisCatSharp.Entities.DiscordGuild.BanMemberAsync*) now supports [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) as [argument](xref:DisCatSharp.Entities.DiscordGuild.BanMemberAsync*#DisCatSharp_Entities_DiscordGuild_BanMemberAsync_DisCatSharp_Entities_DiscordUser_System_Int32_System_String_).

➕ New channel types and flags.

🛠️ Fixed standalone [DiscordWebhookClient](xref:DisCatSharp.DiscordWebhookClient) methods.

⚠️ [Target](xref:DisCatSharp.Entities.DiscordOverwriteBuilder.Target) of [DiscordOverwriteBuilder](xref:DisCatSharp.Entities.DiscordOverwriteBuilder) changed to `ulong`.

⚠️ Removed Lavalink v1 support; added support for [Lavalink v4](xref:modules_audio_lavalink_v4_intro).

➕ Support for premium apps in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ Various new permissions and options to generate [PermissionStrings](xref:DisCatSharp.Utilities.ToPermissionString*).

🛠️ Overhauled ApplicationCommands extension.

➕ Default values for select menus in interactions.

⚠️ Removed privacy level settings from stage and scheduled events.

➕ Added support for [team roles](xref:DisCatSharp.Entities.DiscordTeamMember.Role) from the developer portal.

⚠️ Removed `ApplicationCommandRequireOwnerAttribute`; added corresponding team role attributes like `ApplicationCommandRequireTeamAdminAttribute`. This adds support for the [team roles](xref:DisCatSharp.Entities.DiscordTeamMember.Role) in the developer portal.

🛠️ Opus encoder/decoder made public.

⚠️ Renamed `DiscordAttachment.FileName` to [Filename](xref:DisCatSharp.Entities.DiscordAttachment.Filename).

➕ Exposed regexes in `DisCatSharp.Common`.

🛠️ Fixed application commands registration issues.

➕ Added support for application command names in other languages than english.

➕ Added support for GCP attachments.

🛠️ Major overhaul of the DisCatSharp documentation.

---

## Why does this changelog look so small?

We&apos;ve been focusing on rewriting internals and improving the library.

Furthermore we might have added new features we haven&apos;t tracked on our changelog list, we&apos;re gonna add them when we find them again 😅

---

## Key Features

&lt;br/&gt;

### Sentry Integration

&lt;svg alt=&quot;Sentry Logo&quot; class=&quot;css-lfbo6j e10nushx4&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 222 66&quot; width=&quot;400&quot; height=&quot;119&quot; style=&quot;background-color: rgb(88, 70, 116);&quot;&gt;&lt;path d=&quot;M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z M124.32,28.28,109.56,9.22h-3.68V34.77h3.73V15.19l15.18,19.58h3.26V9.22h-3.73ZM87.15,23.54h13.23V20.22H87.14V12.53h14.93V9.21H83.34V34.77h18.92V31.45H87.14ZM71.59,20.3h0C66.44,19.06,65,18.08,65,15.7c0-2.14,1.89-3.59,4.71-3.59a12.06,12.06,0,0,1,7.07,2.55l2-2.83a14.1,14.1,0,0,0-9-3c-5.06,0-8.59,3-8.59,7.27,0,4.6,3,6.19,8.46,7.52C74.51,24.74,76,25.78,76,28.11s-2,3.77-5.09,3.77a12.34,12.34,0,0,1-8.3-3.26l-2.25,2.69a15.94,15.94,0,0,0,10.42,3.85c5.48,0,9-2.95,9-7.51C79.75,23.79,77.47,21.72,71.59,20.3ZM195.7,9.22l-7.69,12-7.64-12h-4.46L186,24.67V34.78h3.84V24.55L200,9.22Zm-64.63,3.46h8.37v22.1h3.84V12.68h8.37V9.22H131.08ZM169.41,24.8c3.86-1.07,6-3.77,6-7.63,0-4.91-3.59-8-9.38-8H154.67V34.76h3.8V25.58h6.45l6.48,9.2h4.44l-7-9.82Zm-10.95-2.5V12.6h7.17c3.74,0,5.88,1.77,5.88,4.84s-2.29,4.86-5.84,4.86Z&quot; fill=&quot;#ffffff&quot; transform=&quot;translate(11, 11)&quot;&gt;&lt;/path&gt;&lt;/svg&gt;

Every developer should at least have heard about [Sentry](https://sentry.io).

They were so kind to provide us with a free business plan 🙏💕

With the integration of Sentry, we&apos;re taking a significant leap forward in proactively managing library errors.

Sentry&apos;s real-time error tracking enables us to identify and rectify issues swiftly, often before they impact users.

This enhancement is not just about fixing bugs faster; it&apos;s about ensuring a seamless and stable experience for everyone using our library.

To enable this feature and help us to improve our library, you need to set up some things in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration):

```cs
DiscordConfiguration configuration = new()
{
    // other settings
    EnableSentry = true, // To generally enable sentry
    AttachUserInfo = true, // To attach the bot id and username to sentry reports
    DeveloperUserId = 32183902178903721, // Set your Discord id here so we can reach out to you if we have questions to a bug. Set null or leave it out to disable this feature.
    FeedbackEmail = &quot;your@email.com&quot;, // Set your email here so we can reach out to you if we have questions to a bug.
    ReportMissingFields = true // To let sentry report missing fields in API payloads
};
```

### Update check on startup

We&apos;ve added a new feature to check for new library versions on startup.

This feature is enabled by default and can be disabled in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

You can configure the update check with the following properties:

```cs
DiscordConfiguration configuration = new()
{
    // other settings
    DisableUpdateCheck = true, // To disable the update check on startup
    ShowReleaseNotesInUpdateCheck = false, // To disable the release notes in the update check on startup
    UpdateCheckMode = UpdateCheckMode.GitHub, // To check against GitHub instead of NuGet
    UpdateCheckGitHubToken = &quot;ghp_your_token&quot; // Set this to use a personal access token, in case you&apos;re getting rate limited or you have access to private extensions
};
```

Every official extension supports this too. You currently can&apos;t disable this feature seperatly for extensions.

---

## Future Roadmap

&lt;br/&gt;

### DisCatSharp.Voice (Planned)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Caching System Overhaul (Under Consideration)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved.
We are still in the cenceptual stage for this.

### Audit Log Functionality Enhancement (In Development)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

### Cooldowns for DisCatSharp.ApplicationCommands (Planned)

We are planning to add support for cooldowns in DisCatSharp.ApplicationCommands. This feature would allow developers to set cooldowns for commands, preventing users from spamming commands. While this feature is still in the planning phase, we will provide updates as development progresses.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Mira](https://github.com/TheXorog)
- [Sh1be](https://github.com/xMaxximum)
- [Fabi-Chan](https://github.com/FabiChan99)
- [Licho](https://github.com/Licho1)
- [Drac](https://github.com/DraconicDragon)

## Special Thanks

- [Dziurwa](https://github.com/Dziurwa14) for identifying a major bug in our gateway connection
- [Red Kalab](https://github.com/RedKinda) for being so awesome 💕💕

---</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_2.md">---
uid: changelogs_v10_10_6_2
title: Version 10.6.2
author: DisCatSharp Team
---

# Upgrade from **10.6.0** to **10.6.2**

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

&gt; [!WARNING]
&gt; The last versions including this one have under special circumstates a bug with reactions.
&gt; If you encounter any issues in this direction, disable the reaction intents.

---

## What changed?

&lt;br/&gt;

➕ Added Application Command [Cooldowns](xref:modules_application_commands_cooldowns).

➕ Added [DefaultForumLayout](xref:DisCatSharp.Entities.DiscordChannel.DefaultForumLayout) to [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) and it&apos;s methods.

➕ Implemented User Apps! You can now use apps anywhere :3 Articles will follow.

➕ [Nonce](xref:DisCatSharp.Entities.DiscordMessage.Nonce) &amp; [EnforceNonce](xref:DisCatSharp.Entities.DiscordMessage.EnforceNonce) for [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage) and the [DiscordMessageBuilder](xref:DisCatSharp.Entities.DiscordMessageBuilder.WithEnforceNonce*).

➕ Re-implemented the timeout events [GuildMemberTimeoutAdded](xref:DisCatSharp.DiscordClient.GuildMemberTimeoutAdded) &amp; [GuildMemberTimeoutRemoved](xref:DisCatSharp.DiscordClient.GuildMemberTimeoutRemoved). It won&apos;t show the broken audit log informations anymore.

➕ Added [InteractionMetadata](xref:DisCatSharp.Entities.DiscordMessage.InteractionMetadata) to [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage).

➕ Added [Polls](https://support.discord.com/hc/en-us/articles/22163184112407)! Apps can now send polls, request vote information and get the result. Additionally two gateway events exist which are fired on vote add and vote remove. Articles will follow.

➕ Added [OAuth2AddToGuildAsync](xref:DisCatSharp.Entities.DiscordUser.OAuth2AddToGuildAsync*) to [DiscordUser](xref:DisCatSharp.Entities.DiscordUser).

🛠️ Fixed a bug, causing apps to crash when trying to identify / resume. This was caused by both Discord and us. It seems to still bug out in special cases, we&apos;re on it!

🛠️ Fixed an NRE in GetMentions, which caused messages to throw on construct.

🛠️ Reworked ApplicationCommands &amp; CommandsNext Cooldowns, articles will be updated in near future.

🛠️ The translator entities used for application commands localization are now `public`.

⚠️ Removed `TokenType.User`.

---

## Completed Roadmap

&lt;br/&gt;

### Cooldowns for DisCatSharp.ApplicationCommands (Completed)

We were planning to add support for cooldowns in DisCatSharp.ApplicationCommands. This feature would allow developers to set cooldowns for commands, preventing users from spamming commands. This is now implemented. See [this article](xref:modules_application_commands_cooldowns) for details.

---

## Future Roadmap

&lt;br/&gt;

### Signed Attachment

We added signed attachments previously but it clashed with other attachment types and broke. We will re-introduce the entity at some point soon.

### DisCatSharp.Voice (Planned)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)
A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

### DisCatSharp.CommandNext Revamp (Proposed)

complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mira](https://github.com/TheXorog)
- [LaPepega](https://github.com/LaPepega)
- [Rand](https://github.com/byterand)</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_4.md">---
uid: changelogs_v10_10_6_4
title: Version 10.6.4
author: DisCatSharp Team
---

# Upgrade from **10.6.2** to **10.6.4**

&gt; [!NOTE]
&gt; This version improves the safety of data transmitted to sentry, if enabled.

---

## What changed?

&lt;br/&gt;

➕ Added clan badges

🛠️ Fixed OAuth2 NRE&apos;s

🛠️ Fixed caching issues

➕ Added `avatar_decoration_data` for guild members

➕ Added `dm_spam_detected_at` &amp; `raid_detected_at` in guild incident data

➕ Added bulk ban capabilities ([#482](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/482))

📚 Added Termux Hosting docs ([#490](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/490))

🛠️ Fixed a hosting configuration intent bug ([#498](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/498))

➕ Added additional client-side Sentry filtering ([#495](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/495))

📚 Added Sentry docs

---

## Other important info

&lt;br/&gt;

After we&apos;ve received concerns about the privacy for our users when using Sentry, by Quinch, we&apos;ve investigated possible issues together with the team at Discord.

While we did not find any privacy leaks, we did implemented additional client-side filters to further enhance user safety &amp; privacy.

For that we&apos;ve added a new [article](xref:misc_sentry) about our Sentry integration.

You can read the full report here: [Sentry Safety Report](xref:sec_comp_sentry).

&lt;br/&gt;

Additionally we&apos;ve made updates to our [Code of Conduct](https://github.com/Aiko-IT-Systems/.github/blob/main/CODE_OF_CONDUCT.md) and our [Security Policy](https://github.com/Aiko-IT-Systems/.github/blob/main/SECURITY.md).

We added the following new terms:

**Unacceptable Behavior:** Rude, offensive, or disrespectful behavior, including AI-generated content that does not adhere to our guidelines, will not be tolerated.
**Enforcement:** Violations of our guidelines may result in bans or other appropriate measures.

---

## Future Roadmap

&lt;br/&gt;

### Signed Attachment

We added signed attachments previously but it clashed with other attachment types and broke. We will re-introduce the entity at some point soon.

### DisCatSharp.Voice (Planned)

We&apos;re working on DisCatSharp.Voice which is set to replace the existing DisCatSharp.VoiceNext. It&apos;s planned to have better performance, stability and maintainability than its predecessor. Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use. The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved. We are still in the cenceptual stage for this.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of DisCatSharp.CommandsNext is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mira](https://github.com/TheXorog)
- [KristalliDev](https://github.com/KristalliDev)</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_6.md">---
uid: changelogs_v10_10_6_6
title: Version 10.6.6
author: DisCatSharp Team
---

# Upgrade from **10.6.4** to **10.6.6**

&gt; [!IMPORTANT]
&gt; This version introduces **breaking changes** and numerous enhancements. Please review the details carefully before upgrading.

&gt; [!IMPORTANT]
&gt; We dropped support for .NET 7 in favor of newer features and major improvements in speed and stability.

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

---

## What changed?

&lt;br/&gt;

### ❕ Breaking Changes

- **[DiscordRoleTags](xref:DisCatSharp.Entities.DiscordRoleTags)**: We removed the `IsPremiumSubscriber` and `IsLinkedRole` fields due to an overhaul of the tag system. You can now determine the actual type of role by referencing [DiscordRole.RoleType](xref:DisCatSharp.Entities.DiscordRole.Type). It&apos;s not officially returned by Discord, but instead calculated by analyzing the role tags combinations.
- **[DiscordEmoji.TryFromName](xref:DisCatSharp.Entities.DiscordEmoji.TryFromName*#DisCatSharp_Entities_DiscordEmoji_TryFromName_DisCatSharp_BaseDiscordClient_System_String_System_Boolean_System_Boolean_DisCatSharp_Entities_DiscordEmoji__)**: Additional required parameter `bool includeApplication` was added to match Discord&apos;s changes in handling emoji lookups. This was to account for different emoji types (Unicode, Guild, Application).
- **[TryGetMemberAsync](xref:DisCatSharp.Entities.DiscordGuild.TryGetMemberAsync*) method signature change**: The return type for [`TryGetMemberAsync`](xref:DisCatSharp.Entities.DiscordGuild.TryGetMemberAsync*) was changed from `bool` to `Task&lt;DiscordMember?&gt;` to align with asynchronous patterns and allow for better error handling and member retrieval.
- **ImageTool renamed to [MediaTool](xref:DisCatSharp.MediaTool)**: This was necessary due to the support of additional media types, like MP3 and OGG, for soundboard functionality.
- **ImageFormat renamed to [MediaFormat](xref:DisCatSharp.MediaFormat)**: This was also necessary for the support of additional media types.
- **[DiscordMessage.Components](xref:DisCatSharp.Entities.DiscordMessage.Components) type change**: `IReadOnlyCollection&lt;DiscordActionRowComponent&gt;` was changed to `IReadOnlyCollection&lt;DiscordComponent&gt;` due to Discord allowing new components not necessarily wrapped in action rows, breaking the previous assumption of a static structure.
- **DiscordAttachment flags renamed**: The flag values in [`AttachmentFlags`](xref:DisCatSharp.Enums.AttachmentFlags) were prefixed with `Is` to be consistent with other flag names across the codebase.
- **[DiscordFollowupMessageBuilder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder), [DiscordInteractionResponseBuilder](xref:DisCatSharp.Entities.DiscordInteractionResponseBuilder), [DiscordWebhookBuilder](xref:DisCatSharp.Entities.DiscordWebhookBuilder) method renaming**: The `AddMention` and `AddMentions` methods were renamed to `WithAllowedMention` and `WithAllowedMentions` for better clarity and consistency.

### ➕ Additions

#### Added Entities
- [`WaveformConverter`](xref:DisCatSharp.Common.Utilities.WaveformConverter)
- [`WaveformVisualizer`](xref:DisCatSharp.Common.Utilities.WaveformVisualizer)
- [`AudioHelper`](xref:DisCatSharp.Experimental.AudioHelper)
- [`DiscordGuildMemberSearchParams`](xref:DisCatSharp.Experimental.Entities.DiscordGuildMemberSearchParams)
- [`DiscordGuildMemberSearchValidator`](xref:DisCatSharp.Experimental.Entities.DiscordGuildMemberSearchValidator)
- [`DiscordMemberFilter`](xref:DisCatSharp.Experimental.Entities.DiscordMemberFilter)
- [`DiscordMemberPaginationFilter`](xref:DisCatSharp.Experimental.Entities.DiscordMemberPaginationFilter)
- [`DiscordQuery`](xref:DisCatSharp.Experimental.Entities.DiscordQuery)
- [`DiscordRangeQuery`](xref:DisCatSharp.Experimental.Entities.DiscordRangeQuery)
- [`DiscordSafetySignals`](xref:DisCatSharp.Experimental.Entities.DiscordSafetySignals)
- [`DiscordSearchGuildMembersResponse`](xref:DisCatSharp.Experimental.Entities.DiscordSearchGuildMembersResponse)
- [`DiscordSupplementalGuildMember`](xref:DisCatSharp.Experimental.Entities.DiscordSupplementalGuildMember)
- [`DefaultQueueEntry`](xref:DisCatSharp.Lavalink.Entities.DefaultQueueEntry)
- [`LavalinkQueue`](xref:DisCatSharp.Lavalink.LavalinkQueue`1)
- [`DiscordApplicationEmoji`](xref:DisCatSharp.Entities.DiscordApplicationEmoji)
- [`DiscordClanSettings`](xref:DisCatSharp.Entities.DiscordClanSettings) (Not release for bots)
- [`DiscordGuildJoinRequest`](xref:DisCatSharp.Entities.DiscordGuildJoinRequest)
- [`DiscordGuildJoinRequestSearchResult`](xref:DisCatSharp.Entities.DiscordGuildJoinRequestSearchResult) (Not release for bots)
- [`DiscordGuildMembershipScreeningFieldResponse`](xref:DisCatSharp.Entities.DiscordGuildMembershipScreeningFieldResponse)
- [`DiscordRecurrenceRuleNWeekday`](xref:DisCatSharp.Entities.DiscordRecurrenceRuleNWeekday)
- [`DiscordScheduledEventRecurrenceRule`](xref:DisCatSharp.Entities.DiscordScheduledEventRecurrenceRule)
- [`DiscordScheduledEventRecurrenceRuleValidator`](xref:DisCatSharp.Entities.DiscordScheduledEventRecurrenceRuleValidator)
- [`DiscordPremiumButtonComponent`](xref:DisCatSharp.Entities.DiscordPremiumButtonComponent)
- [`DiscordActivityInstance`](xref:DisCatSharp.Entities.DiscordActivityInstance)
- [`DiscordInteractionCallback`](xref:DisCatSharp.Entities.DiscordInteractionCallback)
- [`DiscordInteractionCallbackResponse`](xref:DisCatSharp.Entities.DiscordInteractionCallbackResponse)
- [`DiscordInteractionResource`](xref:DisCatSharp.Entities.DiscordInteractionResource)
- [`DiscordForwardedMessage`](xref:DisCatSharp.Entities.DiscordForwardedMessage)
- [`DiscordMessageSnapshot`](xref:DisCatSharp.Entities.DiscordMessageSnapshot)
- [`DiscordSubscription`](xref:DisCatSharp.Entities.DiscordSubscription)
- [`DiscordSoundboardSound`](xref:DisCatSharp.Entities.DiscordSoundboardSound)
- [`GuildJoinRequestCreateEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestCreateEventArgs)
- [`GuildJoinRequestDeleteEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestDeleteEventArgs)
- [`GuildJoinRequestUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestUpdateEventArgs)
- [`GuildSoundboardSoundCreateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundCreateEventArgs)
- [`GuildSoundboardSoundDeleteEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundDeleteEventArgs)
- [`GuildSoundboardSoundUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundUpdateEventArgs)
- [`GuildSoundboardSoundsUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundsUpdateEventArgs)
- [`SoundboardSoundsEventArgs`](xref:DisCatSharp.EventArgs.SoundboardSoundsEventArgs)
- [`SubscriptionCreateEventArgs`](xref:DisCatSharp.EventArgs.SubscriptionCreateEventArgs)
- [`SubscriptionUpdateEventArgs`](xref:DisCatSharp.EventArgs.SubscriptionUpdateEventArgs)
- [`VoiceChannelEffectSendEventArgs`](xref:DisCatSharp.EventArgs.VoiceChannelEffectSendEventArgs)
- [`DisCatSharpUserException`](xref:DisCatSharp.Exceptions.DisCatSharpUserException)
- [`DiscordJsonException`](xref:DisCatSharp.Exceptions.DiscordJsonException)

#### Added Events
- [`GuildSoundboardSoundCreated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundCreated)
- [`GuildSoundboardSoundUpdated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundUpdated)
- [`GuildSoundboardSoundDeleted`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundDeleted)
- [`GuildSoundboardSoundsUpdated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundsUpdated)
- [`SoundboardSounds`](xref:DisCatSharp.DiscordClient.SoundboardSounds)
- [`GuildJoinRequestCreated`](xref:DisCatSharp.DiscordClient.GuildJoinRequestCreated)
- [`GuildJoinRequestUpdated`](xref:DisCatSharp.DiscordClient.GuildJoinRequestUpdated)
- [`GuildJoinRequestDeleted`](xref:DisCatSharp.DiscordClient.GuildJoinRequestDeleted)
- [`VoiceChannelEffectSend`](xref:DisCatSharp.DiscordClient.VoiceChannelEffectSend)
- [`SubscriptionCreated`](xref:DisCatSharp.DiscordClient.SubscriptionCreated)
- [`SubscriptionUpdated`](xref:DisCatSharp.DiscordClient.SubscriptionUpdated)

#### Added Enums
- [`JoinSourceType`](xref:DisCatSharp.Experimental.Enums.JoinSourceType)
- [`MemberSortType`](xref:DisCatSharp.Experimental.Enums.MemberSortType)
- [`ApplicationCommandHandlerType`](xref:DisCatSharp.Enums.ApplicationCommandHandlerType)
- [`ApplicationExplicitContentFilter`](xref:DisCatSharp.Enums.ApplicationExplicitContentFilter)
- [`ApplicationVerificationEligibilityFlags`](xref:DisCatSharp.Enums.ApplicationVerificationEligibilityFlags)
- [`BadgeType`](xref:DisCatSharp.Enums.BadgeType)
- [`BannerType`](xref:DisCatSharp.Enums.BannerType)
- [`JoinRequestStatusType`](xref:DisCatSharp.Enums.JoinRequestStatusType)
- [`PlayStyle`](xref:DisCatSharp.Enums.PlayStyle)
- [`RoleType`](xref:DisCatSharp.Enums.RoleType)
- [`RecurrenceRuleFrequency`](xref:DisCatSharp.Enums.RecurrenceRuleFrequency)
- [`RecurrenceRuleWeekday`](xref:DisCatSharp.Enums.RecurrenceRuleWeekday)
- [`EmbedFlags`](xref:DisCatSharp.Enums.EmbedFlags)
- [`EmbedMediaFlags`](xref:DisCatSharp.Enums.EmbedMediaFlags)
- [`ReferenceType`](xref:DisCatSharp.Enums.ReferenceType)
- [`SubscriptionStatus`](xref:DisCatSharp.Enums.SubscriptionStatus)
- [`AnimationType`](xref:DisCatSharp.Enums.AnimationType)
- [`MediaFormat`](xref:DisCatSharp.MediaFormat)

#### Added Properties
- [`LavalinkTrack.UserData`](xref:DisCatSharp.Lavalink.Entities.LavalinkTrack.UserData)
- [`DiscordClient.RegisteredEventhandlers`](xref:DisCatSharp.DiscordClient.RegisteredEventhandlers)
- [`DiscordConfiguration.HasActivitiesEnabled`](xref:DisCatSharp.DiscordConfiguration.HasActivitiesEnabled)
- [`DiscordConfiguration.ActivityHandlerType`](xref:DisCatSharp.DiscordConfiguration.ActivityHandlerType)
- [`DiscordApplicationCommand.HandlerType`](xref:DisCatSharp.Entities.DiscordApplicationCommand.HandlerType)
- [`DiscordMember.PrimaryGuild`](xref:DisCatSharp.Entities.DiscordMember.PrimaryGuild)
- [`DiscordRoleTags.GuildConnections`](xref:DisCatSharp.Entities.DiscordRoleTags.GuildConnections)
- [`DiscordRoleTags.PremiumSubscriber`](xref:DisCatSharp.Entities.DiscordRoleTags.PremiumSubscriber)
- [`DiscordAttachment.ClipParticipants`](xref:DisCatSharp.Entities.DiscordAttachment.ClipParticipants)
- [`DiscordAttachment.ClipCreatedAt`](xref:DisCatSharp.Entities.DiscordAttachment.ClipCreatedAt)
- [`DiscordMessage.ChannelType`](xref:DisCatSharp.Entities.DiscordMessage.ChannelType)
- [`DiscordMessage.MessageSnapshots`](xref:DisCatSharp.Entities.DiscordMessage.MessageSnapshots)
- [`DiscordMessage.HasMessageReference`](xref:DisCatSharp.Entities.DiscordMessage.HasMessageReference)
- [`DiscordMessage.HasMessageSnapshots`](xref:DisCatSharp.Entities.DiscordMessage.HasMessageSnapshots)
- [`DiscordMessage.SoundboardSounds`](xref:DisCatSharp.Entities.DiscordMessage.SoundboardSounds)
- [`DiscordEntitlement.Branches`](xref:DisCatSharp.Entities.DiscordEntitlement.Branches)
- [`DiscordEntitlement.Consumed`](xref:DisCatSharp.Entities.DiscordEntitlement.Consumed)
- [`DiscordEntitlement.Deleted`](xref:DisCatSharp.Entities.DiscordEntitlement.Deleted)
- [`DiscordEntitlement.GiftCodeBatchId`](xref:DisCatSharp.Entities.DiscordEntitlement.GiftCodeBatchId)
- [`DiscordEntitlement.GiftCodeFlags`](xref:DisCatSharp.Entities.DiscordEntitlement.GiftCodeFlags)
- [`DiscordEntitlement.GifterUserId`](xref:DisCatSharp.Entities.DiscordEntitlement.GifterUserId)
- [`DiscordEntitlement.PromotionId`](xref:DisCatSharp.Entities.DiscordEntitlement.PromotionId)
- [`DiscordEntitlement.SubscriptionId`](xref:DisCatSharp.Entities.DiscordEntitlement.SubscriptionId)
- [`DiscordSubscription.RenewalSkuIds`](xref:DisCatSharp.Entities.DiscordSubscription.RenewalSkuIds)
- [`DiscordSubscription.EntitlementIds`](xref:DisCatSharp.Entities.DiscordSubscription.EntitlementIds)
- [`DiscordSubscription.CurrentPeriodStartsAt`](xref:DisCatSharp.Entities.DiscordSubscription.CurrentPeriodStartsAt)
- [`DiscordSubscription.CurrentPeriodEndsAt`](xref:DisCatSharp.Entities.DiscordSubscription.CurrentPeriodEndsAt)
- [`DiscordSubscription.CanceledAt`](xref:DisCatSharp.Entities.DiscordSubscription.CanceledAt)
- [`DiscordSubscription.Country`](xref:DisCatSharp.Entities.DiscordSubscription.Country)
- [`DiscordUser.PrimaryGuild`](xref:DisCatSharp.Entities.DiscordUser.PrimaryGuild)
- [`DiscordApplication`](xref:DisCatSharp.Entities.DiscordApplication) got extended with additional properties, which are too many to list

#### Added Enum Values
- [`ApplicationCommandType`](xref:DisCatSharp.Enums.ApplicationCommandType)
	- `PrimaryEntryPoint`
- [`ChannelType`](xref:DisCatSharp.Enums.ChannelType)
	- `Lobby`
- [`DiscordEvent`](xref:DisCatSharp.Enums.DiscordEvent)
    - `SubscriptionCreated`
    - `SubscriptionUpdated`
    - `VoiceChannelEffectSend`
    - `GuildSoundboardSoundCreated`
    - `GuildSoundboardSoundUpdated`
    - `GuildSoundboardSoundDeleted`
    - `GuildSoundboardSoundsUpdated`
    - `SoundboardSounds`
    - `GuildJoinRequestCreated`
    - `GuildJoinRequestUpdated`
    - `GuildJoinRequestDeleted`
- [`DiscordIntents`](xref:DisCatSharp.Enums.DiscordIntents)
	- `GuildExpressions`
- [`MemberFlags`](xref:DisCatSharp.Enums.MemberFlags)
    - `AutomodQuarantinedUsername`
    - `DmSettingsUpsellAcknowledged`
    - `AutomodQuarantinedClanTag`
- [`MembershipScreeningFieldType`](xref:DisCatSharp.Enums.MembershipScreeningFieldType)
    - `TextInput`
    - `Paragraph`
    - `MultipleChoice`
- [`Permissions`](xref:DisCatSharp.Enums.DiscordIntents)
	- `UseExternalApps`
- [`ComponentType`](xref:DisCatSharp.Enums.ComponentType)
	- `File`
- [`InteractionResponseType`](xref:DisCatSharp.Enums.DiscordIntents)
	- `LaunchActivity`
- [`AttachmentFlags`](xref:DisCatSharp.Enums.AttachmentFlags)
    - `IsClip`
    - `IsThumbnail`
    - `IsRemix`
    - `IsSpoiler`
    - `IsAnimated`
- [`MessageFlags`](xref:DisCatSharp.Enums.MessageFlags)
	- `HasSnapshots`
- [`MessageType`](xref:DisCatSharp.Enums.MessageType)
    - `PollResult`
    - `ChannelLinkedToLobby`
    - `GiftingPrompt`
    - `GuildJoinRequestAccepted`
    - `GuildJoinRequestRejected`

#### Added Methods
- [`DiscordClient.RequestAndWaitForSoundboardSoundsAsync`](xref:DisCatSharp.DiscordClient.RequestAndWaitForSoundboardSoundsAsync*)
- [`DiscordClient.GetEntitlementAsync`](xref:DisCatSharp.DiscordClient.GetEntitlementAsync*)
- [`DiscordClient.GetSkuSubscriptionsAsync`](xref:DisCatSharp.DiscordClient.GetSkuSubscriptionsAsync*)
- [`DiscordClient.GetSkuSubscriptionAsync`](xref:DisCatSharp.DiscordClient.GetSkuSubscriptionAsync*)
- [`DiscordClient.GetApplicationEmojisAsync`](xref:DisCatSharp.DiscordClient.GetApplicationEmojisAsync*)
- [`DiscordClient.GetApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.GetApplicationEmojiAsync*)
- [`DiscordClient.CreateApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.CreateApplicationEmojiAsync*)
- [`DiscordClient.ModifyApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.ModifyApplicationEmojiAsync*)
- [`DiscordClient.DeleteApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.DeleteApplicationEmojiAsync*)
- [`DiscordClient.GetStickerPackAsync`](xref:DisCatSharp.DiscordClient.GetStickerPackAsync*)
- [`DiscordClient.ListDefaultSoundboardSoundsAsync`](xref:DisCatSharp.DiscordClient.ListDefaultSoundboardSoundsAsync*)
- [`DiscordChannel.SendSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordChannel.SendSoundboardSoundAsync*)
- [`DiscordEmoji.FromApplicationEmote`](xref:DisCatSharp.Entities.DiscordEmoji.FromApplicationEmote*)
- [`DiscordGuild.GetCurrentMemberVoiceStateAsync`](xref:DisCatSharp.Entities.DiscordGuild.GetCurrentMemberVoiceStateAsync*)
- [`DiscordGuild.CreateSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.CreateSoundboardSoundAsync*)
- [`DiscordGuild.ModifySoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.ModifySoundboardSoundAsync*)
- [`DiscordGuild.DeleteSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.DeleteSoundboardSoundAsync*)
- [`DiscordGuild.GetSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.GetSoundboardSoundAsync*)
- [`DiscordGuild.ListSoundboardSoundsAsync`](xref:DisCatSharp.Entities.DiscordGuild.ListSoundboardSoundsAsync*)
- [`DiscordMember.GetVoiceStateAsync`](xref:DisCatSharp.Entities.DiscordMember.GetVoiceStateAsync*)
- [`DiscordRoleTags.DetermineRoleType`](xref:DisCatSharp.Entities.DiscordRoleTags.DetermineRoleType*)
- [`DiscordMessage.ForwardMessageAsync`](xref:DisCatSharp.Entities.DiscordMessage.ForwardMessageAsync*)
- [`DiscordUser.OAuth2UpdateApplicationRoleConnectionAsync`](xref:DisCatSharp.Entities.DiscordUser.OAuth2UpdateApplicationRoleConnectionAsync*)
- [`DiscordSoundboardSound.DeleteSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordSoundboardSound.DeleteSoundboardSoundAsync*)


### 🛠️ Fixes

- Fixed a rare case where embed fields throw an exception if old embeds are received from Discord
- Fixed an issue with banning members while providing `delete_message_days`/`delete_message_seconds`
- Fixed a possible parser error
- Fixed a rare case where paginations on interactions could fail with `Message not found`
- Fixed component pagination
- Fixed an NRE within events that broke bots: Ensured [`Interaction.Guild`](xref:DisCatSharp.Entities.DiscordInteraction.Guild) falls back to partial guild data when null.
- Fixed an issue where [`ApplicationRoleConnectionMetadata`](xref:DisCatSharp.Entities.OAuth2.ApplicationRoleConnectionMetadata) had only internal constructors
- Fixed invalid API routes for [`UpdateCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.UpdateCurrentUserApplicationRoleConnectionAsync*) and [`GetCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.GetCurrentUserApplicationRoleConnectionAsync*)
- Fixed max poll duration: Increased from `7` days to `32` days (`768` hours) to align with new limits.
- Fixed poll creation on [`EditOriginalResponseAsync`](xref:DisCatSharp.Entities.DiscordInteraction.EditOriginalResponseAsync*): Enabled creating polls when the original response is deferred.
- Fixed a critical NRE in interaction create dispatches
- Fixed a NRE in audit log processing

### ⚠️ Removals

- Removed `AutoCompleteRequest` and `ModalSubmit` from [`ApplicationCommandType`](xref:DisCatSharp.Enums.ApplicationCommandType) due to incorrect implementation.
- Removed `DiscordApplication.Owners`. Use [`DiscordApplication.Members`](xref:DisCatSharp.Entities.DiscordApplication.Members) instead.
- Removed the enum `ExplicitContentFilterLevel`
- Removed `ApplicationCommandRequireDisCatSharpDeveloperAttribute` and `RequireDisCatSharpDeveloperAttribute`

### 📚 Documentation

- New article about [GCP Attachments](xref:experimental_gcp_attachments)
- New article about [ElasticSearch-Based Member Search](xref:experimental_search_guild_members)
- Extended articles about [Lavalink](xref:modules_audio_lavalink_v4_intro), including the recent refactor of the [queue system](xref:modules_audio_lavalink_v4_queue_system)
- Documented more internal and private code to make library development easier.
- Added missing documentation for public code.

---

## Future Roadmap

&lt;br/&gt;

### DisCatSharp.Voice (On Hold)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved.
We are still in the cenceptual stage for this.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mark Cilia Vincenti](https://github.com/MarkCiliaVincenti)
- [Truong Hoang](https://github.com/hqtruong27)
- [Rand](https://github.com/byterand)
- [Mira](https://github.com/TheXorog)</file><file path="DisCatSharp.Docs/changelogs/v9/9_8_2.md">---
uid: changelogs_v9_9_8_2
title: Version 9.8.2
author: DisCatSharp Team
---

# What changed?

Discord [changed](https://discord.com/developers/docs/interactions/slash-commands) **SlashCommands** into **Application Commands** in favor of the new context menu stuff.
You can read about it [here](https://discord.com/developers/docs/interactions/application-commands).

## Upgrade from **DisCatSharp.SlashCommands** to **DisCatSharp.ApplicationCommands**

In **DisCatSharp.SlashCommands** you used Application Commands like this:

```cs
// Usage directives
using DisCatSharp.SlashCommands;
using DisCatSharp.SlashCommands.EventArgs;

// Extension
    public static SlashCommandsExtension Slash;

// Injecting SlashCommands
    Client.UseSlashCommands();
    Slash = Client.GetSlashCommands();

// Registration of commands and events
    Slash.SlashCommandErrored += Slash_SlashCommandErrored;
    Slash.SlashCommandExecuted += Slash_SlashCommandExecuted;

    Slash.RegisterCommands&lt;SlashCommands.Main&gt;();

// Events
    public static Task Slash_SlashCommandExecuted(SlashCommandsExtension sender, SlashCommandExecutedEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Info: {e.Context.CommandName}&quot;);
        return Task.CompletedTask;
    }

    public static Task Slash_SlashCommandErrored(SlashCommandsExtension sender, SlashCommandErrorEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Error: {e.Exception.Message} | CN: {e.Context.CommandName} | IID: {e.Context.InteractionId}&quot;);
        return Task.CompletedTask;
    }

// Commands
using DisCatSharp;
using DisCatSharp.Entities;
using DisCatSharp.SlashCommands;
using DisCatSharp.SlashCommands.Attributes;
namespace TestBot.SlashCommands
{
    internal class Main : SlashCommandModule
    {

        [SlashCommand(&quot;test&quot;, &quot;A slash command made to test the DisCatSharp library!&quot;)]
        public static async Task TestCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
            await Task.Delay(5000);
            await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;5 second delay complete!&quot;));
        }
    }
}
```

In **DisCatSharp.ApplicationCommands** you use them like this:

```cs
// Usage directives
using DisCatSharp.ApplicationCommands;
using DisCatSharp.ApplicationCommands.EventArgs;

// Extension
    public static ApplicationCommandsExtension ApplicationCommands;

// Injecting SlashCommands
    Client.UseApplicationCommands();
    ApplicationCommands = Client.GetApplicationCommands();

// Registration of commands and events
    ApplicationCommands.SlashCommandExecuted += Ac_SlashCommandExecuted;
    ApplicationCommands.SlashCommandErrored += Ac_SlashCommandErrored;
    /* New stuff - context menu */
    ApplicationCommands.ContextMenuExecuted += Ac_ContextMenuExecuted;
    ApplicationCommands.ContextMenuErrored += Ac_ContextMenuErrored;

    ApplicationCommands.RegisterCommands&lt;SlashCommands.Main&gt;();

// Events
    public static Task Ac_SlashCommandExecuted(ApplicationCommandsExtension sender, SlashCommandExecutedEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Info: {e.Context.CommandName}&quot;);
        return Task.CompletedTask;
    }

    public static Task Ac_SlashCommandErrored(ApplicationCommandsExtension sender, SlashCommandErrorEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Error: {e.Exception.Message} | CN: {e.Context.CommandName} | IID: {e.Context.InteractionId}&quot;);
        return Task.CompletedTask;
    }

    public static Task Ac_ContextMenuExecuted(ApplicationCommandsExtension sender, ContextMenuExecutedEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Info: {e.Context.CommandName}&quot;);
        return Task.CompletedTask;
    }

    public static Task Ac_ContextMenuErrored(ApplicationCommandsExtension sender, ContextMenuErrorEventArgs e)
    {
        Console.WriteLine($&quot;Slash/Error: {e.Exception.Message} | CN: {e.Context.CommandName} | IID: {e.Context.InteractionId}&quot;);
        return Task.CompletedTask;
    }

// Commands
using DisCatSharp;
using DisCatSharp.Entities;
using DisCatSharp.Enums;
using DisCatSharp.ApplicationCommands;
using DisCatSharp.ApplicationCommands.Attributes;
namespace TestBot.ApplicationCommands
{
    internal class Main : ApplicationCommandsModule
    {

        [SlashCommand(&quot;test&quot;, &quot;A slash command made to test the DisCatSharp library!&quot;)]
        public static async Task TestCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
            await Task.Delay(5000);
            await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;5 second delay complete!&quot;));
        }
    }
}
```</file><file path="DisCatSharp.Docs/changelogs/v9/9_8_3.md">---
uid: changelogs_v9_9_8_3
title: Version 9.8.3
author: DisCatSharp Team
---

# What changed?

We [changed](https://canary.discord.com/channels/858089281214087179/858099438580006913/890973133148926004) the option to restrict channel types in Slash Commands to an extra Attribute named `ChannelTypes` in favor of the application command autocompletion.
You can read about it [here](https://github.com/discord/discord-api-docs/pull/3849).

## Upgrade from **9.8.2** to **9.8.3**

In **DisCatSharp.ApplicationCommands** you restricted channel types like this:

```cs
[SlashCommand(&quot;openstage&quot;, &quot;Opens a stage&quot;)]
public static async Task OpenStageAsync(InteractionContext ctx,
    [Option(&quot;stage&quot;, &quot;Stage Channel&quot;, ChannelType.Stage)] DiscordChannel stage,
    [Option(&quot;topic&quot;, &quot;Topic of stage&quot;)] string topic,
    [Option(&quot;notify&quot;, &quot;Whether to notify people&quot;)] bool notify = false,
    [Option(&quot;make_public&quot;, &quot;Whether the stage channel will be public&quot;)] bool make_public = false)
{
    try
    {
        await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Opening stage&quot;).AsEphemeral(true));
        await stage.OpenStageAsync(topic, notify, make_public ? StagePrivacyLevel.PUBLIC : StagePrivacyLevel.GUILD_ONLY);
        await ctx.EditResponseAsync(new()
        {
            Content = &quot;Stage channel has been successfully opened.&quot;
        });
    }
    catch (Exception ex)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(ex.Message + &quot; &quot; + ex.StackTrace));
    }
}
```

In **DisCatSharp.ApplicationCommands** you restrict channel types now like this:

```cs
[SlashCommand(&quot;openstage&quot;, &quot;Opens a stage&quot;)]
public static async Task OpenStageAsync(InteractionContext ctx,
    [Option(&quot;stage&quot;, &quot;Stage Channel&quot;), ChannelTypes(ChannelType.Stage)] DiscordChannel stage,
    [Option(&quot;topic&quot;, &quot;Topic of stage&quot;)] string topic,
    [Option(&quot;notify&quot;, &quot;Whether to notify people&quot;)] bool notify = false,
    [Option(&quot;make_public&quot;, &quot;Whether the stage channel will be public&quot;)] bool make_public = false)
{
    try
    {
        await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Opening stage&quot;).AsEphemeral(true));
        await stage.OpenStageAsync(topic, notify, make_public ? StagePrivacyLevel.PUBLIC : StagePrivacyLevel.GUILD_ONLY);
        await ctx.EditResponseAsync(new()
        {
            Content = &quot;Stage channel has been successfully opened.&quot;
        });
    }
    catch (Exception ex)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(ex.Message + &quot; &quot; + ex.StackTrace));
    }
}
```

## New function: Application Command Autocompletion:

Examples:

&gt; Autocomplete Option: https://github.com/Aiko-IT-Systems/DisCatSharp.Examples/blob/main/ApplicationCommands/src/Commands/Tags.cs#L34

&gt; Autocomplete Provider: https://github.com/Aiko-IT-Systems/DisCatSharp.Examples/blob/main/ApplicationCommands/src/Commands/Tags.cs#L168

Docs:
https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.Attributes.AutocompleteAttribute.html
https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.Attributes.IAutocompleteProvider.html
https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordApplicationCommandAutocompleteChoice.html
https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.OptionAttribute.html#DisCatSharp_ApplicationCommands_OptionAttribute__ctor_System_String_System_String_System_Boolean_</file><file path="DisCatSharp.Docs/changelogs/v9/9_8_4.md">---
uid: changelogs_v9_9_8_4
title: Version 9.8.4
author: DisCatSharp Team
---

# Upgrade from **9.8.3** to **9.8.4**

## What is new in #discatsharp?

-   Components
-   Scheduled Events
-   New Application Fields
-   A ExecuteRawRequest Method
-   Threads
-   Hosting Packages
-   New Templates
-   Better Guild Channel Operations
-   New Permissions
-   New Application Command Permission (Not v2 yet)
-   A new Logo :3 :heart:

## What changed?

### Threads

We have fixed many bugs in threads over time, and they work completely now.

-   [DisCatSharp.Net.Models.ThreadEditModel](https://docs.dcs.aitsys.dev/api/DisCatSharp.Net.Models.ThreadEditModel.html) has a new field called [PerUserRateLimit](https://docs.dcs.aitsys.dev/api/DisCatSharp.Net.Models.ThreadEditModel.html#DisCatSharp_Net_Models_ThreadEditModel_PerUserRateLimit).
-   [DisCatSharp.Entities.DiscordThreadChannel](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordThreadChannel.html) now supports [DisCatSharp.Entities.DiscordThreadChannel#GetMemberAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordThreadChannel.html?q=DiscordThreadChannel#DisCatSharp_Entities_DiscordThreadChannel_GetMemberAsync_System_UInt64_)

### Components

We support every Component available on the API.

### Discord Application Object

[DiscordApplication](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordApplication.html) now includes the property fields:

-   [CustomInstallUrl](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordApplication.html#DisCatSharp_Entities_DiscordApplication_CustomInstallUrl)
-   [InstallParams](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordApplication.html#DisCatSharp_Entities_DiscordApplication_InstallParams)
-   [Tags](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordApplication.html#DisCatSharp_Entities_DiscordApplication_Tags)

You can find the settings for these fields in the [Discord Developer Portal](https://discord.com/developers/applications).

### Scheduled Events

The new scheduled events are already fully supported by us.

**Entities:**

-   [DisCatSharp.Entities.DiscordScheduledEvent](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordScheduledEvent.html)
-   [DisCatSharp.Entities.DiscordScheduledEventEntityMetadata](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordScheduledEventEntityMetadata.html)
-   [DisCatSharp.Entities.DiscordScheduledEventUser](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordScheduledEventUser.html)

**Emums:**

-   [DisCatSharp.ScheduledEventEntityType](https://docs.dcs.aitsys.dev/api/DisCatSharp.ScheduledEventEntityType.html)
-   [DisCatSharp.ScheduledEventStatus](https://docs.dcs.aitsys.dev/api/DisCatSharp.ScheduledEventStatus.html)

**Events:**

-   [DisCatSharp.EventArgs.GuildScheduledEventCreateEventArgs](https://docs.dcs.aitsys.dev/api/DisCatSharp.EventArgs.GuildScheduledEventCreateEventArgs.html)
-   [DisCatSharp.EventArgs.GuildScheduledEventUpdateEventArgs](https://docs.dcs.aitsys.dev/api/DisCatSharp.EventArgs.GuildScheduledEventUpdateEventArgs.html)
-   [DisCatSharp.EventArgs.GuildScheduledEventDeleteEventArgs](https://docs.dcs.aitsys.dev/api/DisCatSharp.EventArgs.GuildScheduledEventDeleteEventArgs.html)
-   [DisCatSharp.EventArgs.GuildScheduledEventUserAddEventArgs](https://docs.dcs.aitsys.dev/api/DisCatSharp.EventArgs.GuildScheduledEventUserAddEventArgs.html)
-   [DisCatSharp.EventArgs.GuildScheduledEventUserRemoveEventArgs](https://docs.dcs.aitsys.dev/api/DisCatSharp.EventArgs.GuildScheduledEventUserRemoveEventArgs.html)

**Models:**

-   [DisCatSharp.Net.Models.ScheduledEventEditModel](https://docs.dcs.aitsys.dev/events/api/DisCatSharp.Net.Models.ScheduledEventEditModel.html)

**Extra Properties:**

-   [DisCatSharp.Entities.DiscordGuild#ScheduledEvents](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_ScheduledEvents)

**Extra Methods:**

-   [DisCatSharp.Entities.DiscordGuild#CreateScheduledEventAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_CreateScheduledEventAsync_System_String_DateTimeOffset_System_Nullable_DateTimeOffset__DisCatSharp_Entities_DiscordChannel_DisCatSharp_Entities_DiscordScheduledEventEntityMetadata_System_String_DisCatSharp_ScheduledEventEntityType_System_String_)
-   [DisCatSharp.Entities.DiscordGuild#CreateExternalScheduledEventAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_CreateExternalScheduledEventAsync_System_String_DateTimeOffset_DateTimeOffset_System_String_System_String_System_String_)
-   [DisCatSharp.Entities.DiscordGuild#GetScheduledEventAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_GetScheduledEventAsync_DisCatSharp_Entities_DiscordScheduledEvent_System_Nullable_System_Boolean__)
-   [DisCatSharp.Entities.DiscordGuild#GetScheduledEventsAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_GetScheduledEventsAsync_System_Nullable_System_Boolean__)
-   [DisCatSharp.Entities.DiscordChannel#CreateScheduledEventAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_CreateScheduledEventAsync_System_String_DateTimeOffset_System_String_System_String_)

### Audit Log

-   [DisCatSharp.Entities.DiscordAuditLogGuildEntry](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordAuditLogGuildEntry.html) has the new field [PremiumProgressBarChange](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordAuditLogGuildEntry.html#DisCatSharp_Entities_DiscordAuditLogGuildEntry_PremiumProgressBarChange)
-   Added [DisCatSharp.Entities.DiscordAuditLogScheduledEventEntry](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordAuditLogScheduledEventEntry.html)

### Enums

We&apos;ve updated some enums to reflect the [API Documentation](https://discord.com/developers/docs/intro) of Discord:

-   [DisCatSharp.PremiumTier](https://docs.dcs.aitsys.dev/api/DisCatSharp.PremiumTier.html)
-   [DisCatSharp.StagePrivacyLevel](https://docs.dcs.aitsys.dev/api/DisCatSharp.StagePrivacyLevel.html)
-   [DisCatSharp.UserFlags](https://docs.dcs.aitsys.dev/api/DisCatSharp.UserFlags.html)

### DisCatSharp.CommandsNext

-   `RequireDiscordEmployeeAttribute` is now `RequireStaffAttribute`
-   `RequireDiscordCertifiedModeratorAttribute` is now `RequireCertifiedModeratorAttribute`

### ExecuteRawRequest

We added the [ExecuteRawRequestAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.DiscordClient.html#DisCatSharp_DiscordClient_ExecuteRawRequestAsync_RestRequestMethod_System_String_System_Object_System_String_Dictionary_System_String_System_String__System_Nullable_System_Double__) method.

### Better Guild Channel Operations

We did some engineering in the Discord API to create a method which gets an [ordered channel dictionary](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_OrderedChannels).

Furthermore, we added a few new functions to [DisCatSharp.Entities.DiscordGuild](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.):

-   [DisCatSharp.Entities.DiscordGuild#GetOrderedChannels](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_GetOrderedChannels)
-   [DisCatSharp.Entities.DiscordGuild#GetOrderedChannelsAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_GetOrderedChannelsAsync)

And a couple more methods to [DisCatSharp.Entities.DiscordChannel](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel):

-   [DisCatSharp.Entities.DiscordChannel#GetMinPosition](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_GetMinPosition)
-   [DisCatSharp.Entities.DiscordChannel#GetMaxPosition](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_GetMaxPosition)
-   [DisCatSharp.Entities.DiscordChannel#ModifyPositionAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_ModifyPositionAsync_System_Int32_System_String_)
-   [DisCatSharp.Entities.DiscordChannel#RefreshPositionsAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_RefreshPositionsAsync)
-   [DisCatSharp.Entities.DiscordChannel#ModifyPositionInCategorySmartAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_ModifyPositionInCategoryAsync_System_Int32_System_String_)
-   [DisCatSharp.Entities.DiscordChannel#ModifyParentAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_ModifyParentAsync_DisCatSharp_Entities_DiscordChannel_System_Nullable_System_Boolean__System_String_)
-   [DisCatSharp.Entities.DiscordChannel#RemoveParentAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordChannel.html#DisCatSharp_Entities_DiscordChannel_RemoveParentAsync_System_String_)

### New Permissions

-   SendMessagesInThreads
-   StartEmbeddedActivities
-   ManageEvents

### New Application Command Permission (Not v2 yet)

-   [DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext#AddUser](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext.html#DisCatSharp_ApplicationCommands_ApplicationCommandsPermissionContext_AddUser_System_UInt64_System_Boolean_)
-   [DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext#AddRole](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext.html#DisCatSharp_ApplicationCommands_ApplicationCommandsPermissionContext_AddRole_System_UInt64_System_Boolean_)
-   [DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext#AddChannel](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsPermissionContext.html#DisCatSharp_ApplicationCommands_ApplicationCommandsPermissionContext_AddChannel_System_UInt64_System_Boolean_)

### New Templates

We added a few templates for you:

-   [DisCatSharp.ProjectTemplates](https://github.com/Aiko-IT-Systems/DisCatSharp.ProjectTemplates)
-   [DisCatSharp.TemplateBot](https://github.com/Aiko-IT-Systems/DisCatSharp.TemplateBot)

### Hosting Packages

You can run your bot as a hosted service now!

If you&apos;re interested, check out this [article](https://docs.dcs.aitsys.dev/articles/getting_started/web_app.html).

You can also check out our new [templates](https://docs.dcs.aitsys.dev/articles/getting_started/templates.html)!</file><file path="DisCatSharp.Docs/changelogs/v9/9_8_5.md">---
uid: changelogs_v9_9_8_5
title: Version 9.8.5
author: DisCatSharp Team
---

# Upgrade from **9.8.4** to **9.8.5**

## What is new in DisCatSharp?

-   Enforced Naming Conventions
-   Reworked ApplicationCommands Module
-   Timeouts
-   RestClient
-   DisCatSharp.Common Extensions
-   Attachment manipulation and alt text
-   Modals
-   Slash Attachments

## What changed?

### ApplicationCommands Module

First of all, the complete module was rewritten to be significant faster.
We could decrease the application command startup to ~30 seconds.
Before it was like 5 minutes for big bots.

On startup, depending on the size, it can take a few minutes till application commands can be used.
The lib automatically catches this during the startup and warns the user.

We added `GuildCommands` &amp; `GlobalCommands` to the [Application​Commands​Extension](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.html#properties).

Every guild command will be added to [DiscordGuild.RegisteredApplicationCommands](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_RegisteredApplicationCommands) and the permissions to [DiscordGuild.GuildApplicationCommandPermissions](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_GuildApplicationCommandPermissions)

Furthermore:

-   Instead of registering commands when the client is ready, it waits for all guilds to be downloaded.
-   The module now checks for existing commands and only executes API calls when needed.

#### Default Help Module

You can add `EnableDefaultHelp = false` in the [ApplicationCommandsConfiguration](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsConfiguration.html#DisCatSharp_ApplicationCommands_ApplicationCommandsConfiguration_EnableDefaultHelp) to disable the module.

If not supplied, DisCatSharp automatically generates a global `/help` command.

Many thanks to Will for adding this to our lib ❤️

##### Example

```csharp
DiscordClient.UseApplicationCommands(new ApplicationCommandsConfiguration() {
    EnableDefaultHelp = true
});
```

#### Permissions

You can now set [global permissions](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsGlobalPermissionContext.html) ❤️

But we had to change the way the module works for it.

The new methods for adding commands are now:

-   Global Commands

```csharp
ApplicationCommandsExtension.RegisterGlobalCommands&lt;MyAwesomeGlobalCommandClass&gt;(perms =&gt; {
    perms.AddRole(some_cool_guild_id, some_cool_role_id, false);
});
```

-   Guild Commands

```csharp
ApplicationCommandsExtension.RegisterGuildCommands&lt;MyAwesomeGuildCommandClass&gt;(some_cool_guild_id, perms =&gt; {
    perms.AddRole(some_cool_role_id, true);
});
```

#### Options &amp; Attributes

Discord supports integers as input but we only added `long` for some unknown reason.
We added to the Option type [number](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommandOptionType.html) now `int`.

#### Events

We added the following events for you:

-   [ApplicationCommandsModuleReady](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.html#DisCatSharp_ApplicationCommands_ApplicationCommandsExtension_ApplicationCommandsModuleReady) Fired when the module finished the basic startup.
-   [ApplicationCommandsModuleStartupFinished](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.html#DisCatSharp_ApplicationCommands_ApplicationCommandsExtension_ApplicationCommandsModuleStartupFinished) Fired when all commands are registered.
-   [GuildApplicationCommandsRegistered](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.html#DisCatSharp_ApplicationCommands_ApplicationCommandsExtension_GuildApplicationCommandsRegistered) Fired when guild commands in a guild finished the registration.
-   [GlobalApplicationCommandsRegistered](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.html#DisCatSharp_ApplicationCommands_ApplicationCommandsExtension_GlobalApplicationCommandsRegistered) Fired when global commands finished the registration.

### Timeouts

#### Methods

You have the following methods to use timeouts:

-   [DiscordGuild.TimeoutAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_TimeoutAsync_System_UInt64_System_DateTime_System_String_) - has three overloads
-   [DiscordGuild.RemoveTimeoutAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordGuild.html#DisCatSharp_Entities_DiscordGuild_RemoveTimeoutAsync_System_UInt64_System_String_)
-   [DiscordMember.TimeoutAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordMember.html#DisCatSharp_Entities_DiscordMember_TimeoutAsync_System_DateTime_System_String_) - has three overloads
-   [DiscordMember.RemoveTimeoutAsync](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordMember.html#DisCatSharp_Entities_DiscordMember_RemoveTimeoutAsync_System_String_)

#### Properties

We added a property called [CommunicationDisabledUntil](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordMember.html#DisCatSharp_Entities_DiscordMember_CommunicationDisabledUntil) to [DiscordMember](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordMember.html)

#### Events (Unstable)

We added the following events for timeouts:

-   [GuildMemberTimeoutAdded](https://docs.dcs.aitsys.dev/api/DisCatSharp.DiscordClient.html#DisCatSharp_DiscordClient_GuildMemberTimeoutAdded) Fired when a timeout gets added.
-   [GuildMemberTimeoutChanged](https://docs.dcs.aitsys.dev/api/DisCatSharp.DiscordClient.html#DisCatSharp_DiscordClient_GuildMemberTimeoutChanged) Fired when a timeout gets updated.
-   [GuildMemberTimeoutRemoved](https://docs.dcs.aitsys.dev/api/DisCatSharp.DiscordClient.html#DisCatSharp_DiscordClient_GuildMemberTimeoutRemoved) Fired when a timeout gets removed.

#### Auditlogs

You can find the documentation for the timeout auditlog [here](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordAuditLogMemberUpdateEntry.html#DisCatSharp_Entities_DiscordAuditLogMemberUpdateEntry_AddedRoles).

### RestClient (Experimental)

We exposed our internal http client as the property [RestClient](https://docs.dcs.aitsys.dev/api/DisCatSharp.BaseDiscordClient.html#DisCatSharp_BaseDiscordClient_RestClient) on [DiscordBaseClient](https://docs.dcs.aitsys.dev/api/DisCatSharp.BaseDiscordClient.html)

### DisCatSharp.Common

We added the following RegEx to this extension:

-   [RegularExpressions.CommonRegEx](https://docs.dcs.aitsys.dev/api/DisCatSharp.Common.RegularExpressions.CommonRegEx.html)
-   [RegularExpressions.DiscordRegEx](https://docs.dcs.aitsys.dev/api/DisCatSharp.Common.RegularExpressions.DiscordRegEx.html)
    We use them mostly internally

### Attachments

You can now set the alt text on your attachments!

Visit the following docs for more infos:
[DiscordMessageFile.Description](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordMessageFile.html#DisCatSharp_Entities_DiscordMessageFile_Description)
[DiscordAttachment.Description](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordAttachment.html#DisCatSharp_Entities_DiscordAttachment_Description)

Our last changelogs for that:

```diff
+ Added support for file description (aka. Alt Text)
You can supply a description to {DiscordMessageBuilder|DiscordFollowupMessageBuilder|DiscordInteractionResponseBuilder|DiscordWebhookBuilder}.WithFile
You can view the description property of files with {DiscordMessageFile|DiscordAttachment}.Description
+ Added function DiscordWebhookBuilder.KeepAttachments
This allows you to add / modify &amp; replace / keep attachments on DiscordWebhookBuilders.
+ Full support for attachment operations on messages, webhooks &amp; interactions
Methods are now ModifyAttachments, KeepAttachments &amp; ClearAttachments
```

Snippet:

```csharp
[Command(&quot;ufwd&quot;), Description(Download a jpg file from an url and upload upload it to discord with a description (alt text).&quot;)]
public async Task UploadFileWithDescriptionAsync(CommandContext ctx, [Description(&quot;Url of file&quot;)] string url, [RemainingText, Description(&quot;Description of file&quot;)] string description)
{
    Uri uri = new(url);
    var stream = await ctx.Client.RestClient.GetStreamAsync(uri);
    DiscordMessageBuilder builder = new();
    builder.WithFile(&quot;test.jpg&quot;, stream, false, description);
    await ctx.RespondAsync(builder);
}
```

## Additional Notes

### Users

`DiscordClient.GetUserAsync` defaults now to `fetch=true`.

### Interaction Locales

We already support the newly introduced `locale` and `guild_locale` fields on interactions!

-   [ApplicationCommands.BaseContext.Locale](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.BaseContext.html#DisCatSharp_ApplicationCommands_BaseContext_Locale)
-   [ApplicationCommands.BaseContext.GuildLocale](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.BaseContext.html#DisCatSharp_ApplicationCommands_BaseContext_GuildLocale)
-   [ApplicationCommands.AutocompleteContext.Locale](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.BaseContext.html#DisCatSharp_ApplicationCommands_AutocompleteContext_Locale)
-   [ApplicationCommands.AutocompleteContext.GuildLocale](https://docs.dcs.aitsys.dev/api/DisCatSharp.ApplicationCommands.BaseContext.html#DisCatSharp_ApplicationCommands_AutocompleteContext_GuildLocale)
-   [DiscordInteraction.Locale](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordInteraction.html#DisCatSharp_Entities_DiscordInteraction_Locale)
-   [DiscordInteraction.GuildLocale](https://docs.dcs.aitsys.dev/api/DisCatSharp.Entities.DiscordInteraction.html#DisCatSharp_Entities_DiscordInteraction_GuildLocale)

### Modals &amp; Slash Attachments

These who things are still in private beta sadly, but we added it already.

Docs will be added on release from discord&apos;s side.

### Application Command Translations

Wait.. this is a thing?! YES!!!!

It&apos;s not yet released but I know that you love to see upcoming things.

So feel free to take a look into [Articles](https://docs.dcs.aitsys.dev/articles/application_commands/translations/using.html).</file><file path="DisCatSharp.Docs/changelogs/v9/9_9_0.md">---
uid: changelogs_v9_9_9_0
title: Version 9.9.0
author: DisCatSharp Team
---

# Upgrade from **9.8.6** to **9.9.0**

## What is new in DisCatSharp?

-   Slash Attachments
-   [DisCatSharp.Common.RegularExpressions](xref:DisCatSharp.Common.RegularExpressions)

## What changed?

This will be a quick one:

-   [DiscordInvite](xref:DisCatSharp.Entities.DiscordInvite) has the property `InviteTarget` to support user invites.
-   A few NRE&apos;s where fixed
-   Guild scheduled events support uploading a cover image
-   [DiscordThreadChannel](xref:DisCatSharp.Entities.DiscordThreadChannel) has the new property `CreateTimestamp`
-   The AsEphemeral functions defaulting to `true` now
-   Slash Attachments fully works
-   You can let the [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule) auto defer all responses</file><file path="DisCatSharp.Docs/images/ok_hand.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 36 36&quot;&gt;&lt;path fill=&quot;#EF9645&quot; d=&quot;M23.216 20.937l-1.721-6.86-3.947-8.816c-.502-1.297.143-2.756 1.44-3.257 1.296-.506 2.756.143 3.258 1.44l6.203 15.769-5.233 1.724z&quot;/&gt;&lt;path fill=&quot;#FFDC5D&quot; d=&quot;M31.565 18.449c-.488-2.581-1.988-6.523-1.988-6.523L23.79 1.437C23.164.195 21.648-.303 20.407.322c-1.242.626-1.742 2.141-1.115 3.383l5.33 9.547c.013.022 1.413 5.491 1.413 5.491-1.078-.995-2.607-2.359-4.015-3.618-3.098-2.772-4.936-3.811-4.936-3.811-.71-.443-1.179-.506-2.132-.059L9.08 13.823c-.157.078-.29.188-.395.329l-2.313 3.086c-.893 1.067-.752 2.655.315 3.547 1.066.893 2.653.75 3.548-.314.048-.058 1.78-2.56 1.936-2.64 1.037-.533 2.965-1.447 3.808-1.42.897.029 6.281 5.957 6.281 5.957.206.259.23.618.06.902l-2.915 5.228c-.079.131-.193.236-.33.303l-2.674 1.5c-.154.075-.328.099-.496.067l-5.27-2.272c-.262-.113-.48-.32-.592-.583-.787-1.85-.898-3.619-.899-3.639-.065-1.39-1.244-2.463-2.634-2.398-1.387.056-2.463 1.243-2.398 2.633.013.263.351 5.64 4.727 9.292 2.528 2.108 5.654 2.924 9.649 2.387 4.612-.619 7.469-1.233 11.506-9.558 1.117-2.305 1.903-6.024 1.571-7.781z&quot;/&gt;&lt;/svg&gt;</file><file path="DisCatSharp.Docs/index.md">---
uid: home
title: DisCatSharp
author: DisCatSharp Team
hasDiscordComponents: true
---

# DisCatSharp ![Stable](https://img.shields.io/nuget/v/DisCatSharp?color=1F8B4C&amp;label=Stable&amp;style=flat-square&amp;logo=Nuget) ![Nightly](https://img.shields.io/nuget/vpre/DisCatSharp?color=AD1457&amp;label=Nightly&amp;style=flat-square&amp;logo=Nuget)

&lt;br/&gt;

## Introduction

&lt;br/&gt;
&lt;discord-messages&gt;
   &lt;discord-message profile=&quot;user_dm&quot;&gt;Hey, I&apos;m searching for a C# library to code discord bots.&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user_dm&quot;&gt;How about DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user_dm&quot;&gt;What is that, do you have an invite?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user_dm&quot;&gt;
        Sure!&lt;br/&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; class=&quot;discord-link external&quot; href=&quot;https://discord.gg/RXA6u3jxdU&quot;&gt;https://discord.gg/RXA6u3jxdU&lt;/a&gt;
		&lt;discord-attachments slot=&quot;attachments&quot;&gt;&lt;discord-invite name=&quot;DisCatSharp&quot; icon=&quot;https://i.imgur.com/sHdXUPx.png&quot; url=&quot;https://discord.gg/RXA6u3jxdU&quot; online=&quot;69&quot; members=&quot;420&quot; verified=&quot;true&quot;&gt;&lt;/discord-invite&gt;&lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;
&lt;br/&gt;
&lt;discord-messages&gt;
    &lt;discord-header guild=&quot;DisCatSharp&quot; channel=&quot;general&quot; icon=&quot;https://i.imgur.com/sHdXUPx.png&quot;&gt;This is the main channel of DisCatSharp&lt;/discord-header&gt;
    &lt;discord-system-message type=&quot;join&quot;&gt;
        Welcome, &lt;i style=&quot;color: #00c0ff;&quot;&gt;Discord User&lt;/i&gt;. We hope you brought pizza.
         &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;true&quot; name=&quot;xcatclap&quot; emoji=&quot;https://cdn.discordapp.com/emojis/1059823127271575612.gif&quot; count=&quot;68&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-system-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Hey guys, I&apos;m new here!&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Hey guys, I&apos;m new here!&lt;/discord-reply&gt;Welcome to DisCatSharp! Nice that you made it here &lt;discord-custom-emoji name=&quot;xcatlove&quot; url=&quot;https://cdn.discordapp.com/emojis/1059820726426800158.png&quot;&gt;&lt;/discord-custom-emoji&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Hey guys, I&apos;m new here!&lt;/discord-reply&gt;Welcome! If you need help just ask &lt;discord-custom-emoji name=&quot;AGC_AnimeDance&quot; url=&quot;https://cdn.discordapp.com/emojis/1106244669974790154.gif&quot;&gt;&lt;/discord-custom-emoji&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;What is DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;What is DisCatSharp?&lt;/discord-reply&gt;
        &lt;discord-bold&gt;DisCatSharp&lt;/discord-bold&gt; or short &lt;discord-bold&gt;DCS&lt;/discord-bold&gt; is an .NET wrapper for the &lt;discord-bold&gt;Discord API&lt;/discord-bold&gt;, originally based off DSharpPlus.&lt;br /&gt;&lt;br /&gt;
        The library has been rewritten to fit quality and API standards.&lt;br /&gt;&lt;br /&gt;
    Furthermore this lib includes many new features of Discord and is pretty fast with keeping up with Discords API.
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Why should I use DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Why should I use DisCatSharp?&lt;/discord-reply&gt;
        If you:&lt;br /&gt;
        - want a library where you get kind and efficient help&lt;br /&gt;
        - would like to have and use the most recent features of the Discord API&lt;br /&gt;
        - are ready to build great things&lt;br /&gt;&lt;br /&gt;
    Then this is the right library for you!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;
&lt;br/&gt;

## Getting Started

New users probably want to take a look into the [articles](xref:preamble) for quick start guides, tutorials, and examples of use.&lt;br/&gt;
Once you&apos;ve gotten through the articles, head over to the [API Documentation](xref:api_index) for all classes and methods provided by this library.

## Source and Contributors

DisCatSharp is licensed under MIT License, as detailed in the [license](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/LICENSE.md) found in the repository.&lt;br/&gt;
The repository containing the source code for this library can be found [here](https://github.com/Aiko-IT-Systems/DisCatSharp). Contributions are welcomed.&lt;br/&gt;

### Sponsors

-   [Dei](https://github.com/DeividasKaza)
-   [Will](https://github.com/villChurch)
-   [SavageVictor](https://github.com/SavageVictor)
-   [Schattenclown](https://github.com/Schattenclown)
-   [FabiChan99](https://github.com/FabiChan99)

### Thanks

Big thanks goes to the following people who helped us without being part of the core team ♥️

-   [Auros Nexus](https://github.com/Auros)
-   [Lunar Starstrum](https://github.com/OoLunar)
-   [Geferon](https://github.com/geferon)
-   [Alice](https://github.com/QuantuChi)
-   [Will](https://github.com/villChurch)
-   [InFTord](https://github.com/InFTord)

### Special Thanks

The special thanks goes to Nagisa. Make sure to check out her [Instagram](https://www.instagram.com/nagisaarts_/) ♥️♥️

The second special thanks goes to [Sentry](https://sentry.io) ([GitHub](https://github.com/getsentry/)) for sponsering us a business account on sentry for error tracking.
You guys are the best 💕⭐

## Open Source License Status

[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=large)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_large)</file><file path="DisCatSharp.Docs/natives/index.md">---
uid: natives
title: Native Libraries
author: DisCatSharp Team
---

# Downloads

| Operating System   | Download                                           |
| ------------------ | -------------------------------------------------- |
| 64-bit Windows     | [Click Here](/natives/vnext_natives_win32_x64.zip) |
| 32-bit Windows     | [Click Here](/natives/vnext_natives_win32_x86.zip) |

# Licenses

| Library   | License                                                   |
| --------- | --------------------------------------------------------- |
| Opus      | https://opus-codec.org/license/                           |
| libsodium | https://github.com/jedisct1/libsodium/blob/master/LICENSE |</file><file path="DisCatSharp.Docs/snippets/global_name.cs">internal class SlashCommand : ApplicationCommandsModule
	internal static async Task ExecuteCommandAsync(InteractionContext ctx)
		await ctx.CreateResponseAsync(
			new DiscordInteractionResponseBuilder().WithContent($&quot;Your name: {name}&quot;)</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0001.md">---
uid: vs_analyzer_dcs_0001
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0001

You try to use an experimental field, function or similar.

This is mostly not stable and can change at any time.

It&apos;s recommended to not use this in production.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0002.md">---
uid: vs_analyzer_dcs_0002
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0002

You try to use an deprecated field, function or similar.

This will be removed in the next release(s).

It&apos;s recommended to update your code to use the new field, function or similar.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0101.md">---
uid: vs_analyzer_dcs_0101
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0101

You try to use an field, function or similar which is in experiment by discord.

Most experiments aren&apos;t stable and subject to change at any time.

Use carefully and at your own risk.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0102.md">---
uid: vs_analyzer_dcs_0102
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0102

You try to use an field, function or similar which is deprecated by discord.

Don&apos;t use this anymore. It will be removed in the future.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0103.md">---
uid: vs_analyzer_dcs_0103
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0103

You try to use an field, function or similar which isn&apos;t released yet by discord.

Use carefully and at your own risk.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0200.md">---
uid: vs_analyzer_dcs_0200
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0200

This needs special features to be enabled / set.</file><file path="DisCatSharp.Docs/vs/index.md">---
uid: vs
title: Visual Studio Tools
author: DisCatSharp Team
---

# Visual Studio Tools

This section contains information on how to use the Visual Studio tools for developing bots with DisCatSharp.

## Analyzers &amp; Code Fixes

DisCatSharp can be extended with a set of analyzers that can help you write better code. These analyzers will warn you about common mistakes and bad practices.

### DisCatSharp Analyzer

#### Installation

To use the DisCatSharp Analyzer, you need to install the [DisCatSharp.Analyzer.Roselyn](https://www.nuget.org/packages/DisCatSharp.Analyzer.Roselyn) NuGet package.

##### Visual Studio Code

Enable `omnisharp.enableRoslynAnalyzers` in your settings.

##### JetBrains Rider

See https://www.jetbrains.com/help/rider/Settings_Roslyn_Analyzers.html

#### Included Rules

| Rule ID                              | Category | Severity | Notes                                  |
| ------------------------------------ | -------- | -------- | -------------------------------------- |
| [DCS0001](xref:vs_analyzer_dcs_0001) | Usage    | Warning  | Experimental Attribute Analyzer        |
| [DCS0002](xref:vs_analyzer_dcs_0002) | Usage    | Warning  | Deprecated Attribute Analyzer          |
| [DCS0101](xref:vs_analyzer_dcs_0101) | Usage    | Warning  | DiscordInExperiment Attribute Analyzer |
| [DCS0102](xref:vs_analyzer_dcs_0102) | Usage    | Warning  | DiscordDeprecated Attribute Analyzer   |
| [DCS0103](xref:vs_analyzer_dcs_0103) | Usage    | Warning  | DiscordUnreleased Attribute Analyzer   |
| [DCS0200](xref:vs_analyzer_dcs_0200) | Usage    | Info     | RequiresFeature Attribute Analyzer     |</file><file path="DisCatSharp.Experimental/AudioHelper.cs">public static class AudioHelper
	public static (Stream Stream, float DurationSeconds) GetOpusAudioDurationInSeconds(this Stream opusStream)
		opusStream.Seek(0, SeekOrigin.Begin);
		using var decoder = OpusCodecFactory.CreateDecoder(48000, 1);
		var oggIn = new OpusOggReadStream(decoder, opusStream);
			var packet = oggIn.DecodeNextPacket();
			? throw new InvalidOperationException(&quot;Voice message duration exceeds the maximum allowed length of 20 minutes.&quot;)
	public static (Stream Stream, byte[] Waveform) GenerateWaveformBytes(this Stream opusStream, int maxWaveformSize = 200)
					: Math.Abs(t);
	public static (float DurationSeconds, byte[] Waveform) GetDurationAndWaveformBytes(this Stream opusStream)
	public static async Task&lt;Stream&gt; ConvertToOggOpusAsync(this Stream inputStream)
		inputStream.Seek(0, SeekOrigin.Begin);
		var outputStream = new MemoryStream();
		var tempFileName = Path.GetTempFileName();
		await using (var fileStream = new FileStream(tempFileName, FileMode.Create, FileAccess.Write))
			await inputStream.CopyToAsync(fileStream);
		var ffmpeg = new ProcessStartInfo
		Console.WriteLine(&quot;Starting FFmpeg process...&quot;);
		var process = Process.Start(ffmpeg) ?? throw new InvalidOperationException(&quot;Failed to start FFmpeg process&quot;);
				if (!string.IsNullOrWhiteSpace(e.Data))
					Console.WriteLine($&quot;FFmpeg error: {e.Data}&quot;);
			Console.WriteLine(&quot;Copying input stream to FFmpeg...&quot;);
			await inputStream.CopyToAsync(process.StandardInput.BaseStream);
			process.StandardInput.Close();
			Console.WriteLine(&quot;Reading output stream from FFmpeg...&quot;);
			await process.StandardOutput.BaseStream.CopyToAsync(outputStream);
			process.StandardOutput.Close();
			Console.WriteLine(&quot;Waiting for FFmpeg process to exit...&quot;);
			var processTask = process.WaitForExitAsync();
			if (await Task.WhenAny(processTask, Task.Delay(TimeSpan.FromMinutes(5))) == processTask)
				Console.WriteLine(&quot;FFmpeg process completed successfully.&quot;);
				process.Kill();
				throw new TimeoutException(&quot;FFmpeg process timed out.&quot;);
				throw new InvalidOperationException($&quot;FFmpeg process failed with exit code {process.ExitCode}.&quot;);
			Console.WriteLine($&quot;An error occurred during the FFmpeg process: {ex.Message}&quot;);
			outputStream.Seek(0, SeekOrigin.Begin);
			process.Dispose();
			await inputStream.DisposeAsync();
			File.Delete(tempFileName);</file><file path="DisCatSharp.Experimental/DisCatSharp.Experimental.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Experimental&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Experimental&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Experimental&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp.Experimental

			Experimental changes for DisCatSharp.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Experimental,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;Concentus&quot; Version=&quot;2.2.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Concentus.Oggfile&quot; Version=&quot;1.0.6&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;NAudio&quot; Version=&quot;2.2.1&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Experimental/DisCatSharpExtensions.cs">public static class DisCatSharpExtensions
	public static async Task&lt;string&gt; GetUsernameAsync(this DiscordClient client, ulong id)
		var user = await client.ApiClient.GetUserAsync(id);
	internal static async Task&lt;ClydeProfile&gt; GetClydeProfileAsync(this DiscordClient client, ulong profileId)
		DiscordApiClientHook hook = new(client.ApiClient);
		return await hook.GetClydeProfileAsync(profileId);
	internal static async Task&lt;ClydeSettings&gt; GetClydeSettingsAsync(this DiscordGuild guild)
		DiscordApiClientHook hook = new(guild.Discord.ApiClient);
		return await hook.GetClydeSettingsAsync(guild.Id);
	internal static async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(this DiscordGuild guild, ulong profileId)
		return await hook.ModifyClydeSettingsAsync(guild.Id, profileId);
	internal static async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(
		return await hook.ModifyClydeSettingsAsync(guild.Id, name, personality, MediaTool.Base64FromStream(avatar), MediaTool.Base64FromStream(banner),
				? themeColors.Value.Select(x =&gt; x.Value).ToList()
	internal static async Task&lt;string&gt; GenerateClydePersonalityAsync(this DiscordClient client, string? basePersonality = null)
		return await hook.GenerateClydePersonalityAsync(basePersonality);</file><file path="DisCatSharp.Experimental/DiscordApiClientHook.cs">internal sealed class DiscordApiClientHook
	internal async Task&lt;ClydeProfile&gt; GetClydeProfileAsync(ulong profileId)
		var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.GET, route, new
		var url = Utilities.GetApiUriFor(path, this.ApiClient.Discord.Configuration);
		var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.GET, route).ConfigureAwait(false);
	internal async Task&lt;ClydeSettings&gt; GetClydeSettingsAsync(ulong guildId)
	internal async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(ulong guildId, ulong profileId)
		ClydeSettingsProfileIdOnlyUpdatePayload pld = new()
		var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.PATCH, route, new
		var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
		var obj = JObject.Parse(res.Response);
		var settingsString = obj.GetValue(&quot;settings&quot;)!.ToString();
	internal async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(
		ClydeSettingsProfileUpdatePayload pld = new()
	internal async Task&lt;string&gt; GenerateClydePersonalityAsync(string? basePersonality = null)
		PersonalityGenerationPayload pld = new()
		var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.POST, route, new
		var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordSearchGuildMembersResponse&gt; SearchGuildMembersAsync(ulong guildId, DiscordGuildMemberSearchParams searchParams)
		var validationResult = searchParams.Validate();
			throw new ValidationException(
		var pld = DiscordJson.SerializeObject(searchParams);
		var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.POST, route, payload: pld).ConfigureAwait(false);
			throw new NotIndexedException(res);
				var usr = new DiscordUser(supplementalMember.TransportMember.User)
				this.ApiClient.Discord.UserCache.AddOrUpdate(supplementalMember.TransportMember.User.Id, usr, (id, old) =&gt;
	internal async Task&lt;GcpAttachmentsResponse&gt; RequestFileUploadAsync(ulong channelId, GcpAttachment attachment)
		var pld = new RestGcpAttachmentsPayload
	internal void UploadGcpFile(GcpAttachmentUploadInformation target, Stream file)
		HttpRequestMessage request = new(HttpMethod.Put, target.UploadUrl)
			Content = new StreamContent(file)
		this.ApiClient.Rest.HttpClient.Send(request);</file><file path="DisCatSharp.Experimental/Entities/Channel/DiscordChannelMethodHooks.cs">public static class DiscordChannelMethodHooks
	public static async Task&lt;GcpAttachmentUploadInformation&gt; UploadFileAsync(this DiscordChannel channel, string name, Stream stream, string? description = null)
		DiscordApiClientHook hook = new(channel.Discord.ApiClient);
		GcpAttachment attachment = new(name, stream);
		var response = await hook.RequestFileUploadAsync(channel.Id, attachment).ConfigureAwait(false);
		var target = response.Attachments.First();
		hook.UploadGcpFile(target, stream);</file><file path="DisCatSharp.Experimental/Entities/Clyde/ClydeProfile.cs">internal sealed class ClydeProfile : ObservableApiObject
			: this.ThemeColorsInternal.Select(x =&gt; new DiscordColor(x)).ToList();</file><file path="DisCatSharp.Experimental/Entities/Clyde/ClydeSettings.cs">internal sealed class ClydeSettings : ObservableApiObject</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchParams.cs">public sealed class DiscordGuildMemberSearchParams</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchValidator.cs">public static class DiscordGuildMemberSearchValidator
	public static (bool IsValid, string? ErrorMessage) Validate(this DiscordGuildMemberSearchParams searchParams)
			var orQueryCheck = searchParams.OrQuery.ValidateQuery(&quot;OR&quot;, true);
			var andQueryCheck = searchParams.AndQuery.ValidateQuery(&quot;AND&quot;, false);
	private static (bool IsValid, string? ErrorMessage) ValidateQuery(this DiscordMemberFilter filter, string queryType, bool validateOrQuery)
			var result = filter.UserId.ValidateQueryConditions(queryType, &quot;UserId&quot;, ValidateSnowflakeType, allowRange: true);
			var result = filter.Usernames.ValidateQueryConditions(queryType, &quot;Usernames&quot;, ValidateStringType, true);
			var result = filter.RoleIds.ValidateQueryConditions(queryType, &quot;RoleIds&quot;, ValidateSnowflakeType, true, true);
			var result = filter.GuildJoinedAt.ValidateQueryConditions(queryType, &quot;GuildJoinedAt&quot;, ValidateIntegerType, allowRange: true);
			var result = filter.JoinSourceType.ValidateQueryConditions(queryType, &quot;JoinSourceType&quot;, ValidateIntegerType, true);
			var result = filter.SourceInviteCode.ValidateQueryConditions(queryType, &quot;SourceInviteCode&quot;, ValidateStringType, true);
	private static (bool IsValid, string? ErrorMessage) ValidateQueryConditions(this DiscordQuery query, string queryType, string fieldName, Func&lt;string, bool&gt; validateType, bool allowOr = false, bool allowAnd = false, bool allowRange = false)
	private static (bool IsValid, string? ErrorMessage) ValidateSafetySignals(this DiscordSafetySignals safetySignals)
			var result = safetySignals.UnusualDmActivityUntil.ValidateQueryConditions(&quot;SafetySignals&quot;, &quot;UnusualDmActivityUntil&quot;, ValidateIntegerType, allowRange: true);
			var result = safetySignals.CommunicationDisabledUntil.ValidateQueryConditions(&quot;SafetySignals&quot;, &quot;CommunicationDisabledUntil&quot;, ValidateIntegerType, allowRange: true);
	private static bool ValidateSnowflakeType(this string query)
		=&gt; ulong.TryParse(query, out _);
	private static bool ValidateIntegerType(this string query)
		=&gt; int.TryParse(query, out _);
	private static bool ValidateStringType(this string query)
		=&gt; !string.IsNullOrWhiteSpace(query);</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMethodsHook.cs">public static class DiscordGuildMethodsHook
	public static async Task&lt;DiscordSearchGuildMembersResponse&gt; SearchMembersAsync(this DiscordGuild guild, DiscordGuildMemberSearchParams searchParams)
		DiscordApiClientHook hook = new(guild.Discord.ApiClient);
		return await hook.SearchGuildMembersAsync(guild.Id, searchParams);</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordMemberFilter.cs">public sealed class DiscordMemberFilter</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordMemberPaginationFilter.cs">public sealed class DiscordMemberPaginationFilter</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordQueries.cs">public sealed class DiscordQuery
public sealed class DiscordRangeQuery</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSafetySignals.cs">public sealed class DiscordSafetySignals</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSearchGuildMembersResponse.cs">public sealed class DiscordSearchGuildMembersResponse : ObservableApiObject</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSupplementalGuildMember.cs">public sealed class DiscordSupplementalGuildMember : ObservableApiObject</file><file path="DisCatSharp.Experimental/Entities/Message/DiscordMessageBuilderMethodHooks.cs">public static class DiscordMessageBuilderMethodHooks
	public static DiscordMessageBuilder AddGcpAttachment(this DiscordMessageBuilder builder, GcpAttachmentUploadInformation gcpAttachment, bool isVoice = false, Stream? originalStream = null)
			builder.AttachmentsInternal.Add(new()
			ArgumentNullException.ThrowIfNull(originalStream, nameof(originalStream));
			var (durationSeconds, waveform) = originalStream.GetDurationAndWaveformBytes();
			Console.WriteLine($&quot;Waveform length: {waveform.Length} bytes&quot;);
			builder.AsVoiceMessage();
	public static DiscordInteractionResponseBuilder AddGcpAttachment(this DiscordInteractionResponseBuilder builder, GcpAttachmentUploadInformation gcpAttachment)
	public static DiscordWebhookBuilder AddGcpAttachment(this DiscordWebhookBuilder builder, GcpAttachmentUploadInformation gcpAttachment)
	public static DiscordFollowupMessageBuilder AddGcpAttachment(this DiscordFollowupMessageBuilder builder, GcpAttachmentUploadInformation gcpAttachment)</file><file path="DisCatSharp.Experimental/Entities/Message/GcpAttachment.cs">public sealed class GcpAttachment : ObservableApiObject
		this.FileSize = int.TryParse(file.Length.ToString(), out var size)
			: throw new FileLoadException(&quot;File size too big&quot;, filename);</file><file path="DisCatSharp.Experimental/Entities/Message/GcpAttachmentsResponse.cs">public sealed class GcpAttachmentsResponse : ObservableApiObject</file><file path="DisCatSharp.Experimental/Entities/Message/GcpAttachmentUploadInformation.cs">public sealed class GcpAttachmentUploadInformation : NullableSnowflakeObject</file><file path="DisCatSharp.Experimental/Enums/Guild/JoinSourceType.cs"></file><file path="DisCatSharp.Experimental/Enums/Guild/MemberSortType.cs"></file><file path="DisCatSharp.Experimental/GlobalSuppressions.cs"></file><file path="DisCatSharp.Experimental/Payloads/ClydeSettingsPayloads.cs">internal sealed class ClydeSettingsProfileIdOnlyUpdatePayload : ObservableApiObject
internal sealed class ClydeSettingsProfileUpdatePayload : ObservableApiObject
internal sealed class PersonalityGenerationPayload : ObservableApiObject</file><file path="DisCatSharp.Experimental/Payloads/RestGcpAttachmentsPayload.cs">internal sealed class RestGcpAttachmentsPayload</file><file path="DisCatSharp.Hosting.DependencyInjection/DisCatSharp.Hosting.DependencyInjection.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Hosting.DependencyInjection&lt;/PackageId&gt;
		&lt;Description&gt;Dependency Injection for the DisCatSharp Hosting Extension.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Hosting,Web,Dependency Injection&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Hosting.DependencyInjection/ServiceCollectionExtensions.cs">public static class ServiceCollectionExtensions
	public static IServiceCollection AddDiscordHostedService&lt;TService&gt;(this IServiceCollection services)
		where TService : class, IDiscordHostedService
		services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;TService&gt;());
	public static IServiceCollection AddDiscordHostedShardService&lt;TService&gt;(this IServiceCollection services)
		where TService : class, IDiscordHostedShardService
	public static IServiceCollection AddDiscordHostedService&lt;TInterface, TService&gt;(this IServiceCollection services)
		where TInterface : class, IDiscordHostedService
		where TService : class, TInterface, IDiscordHostedService
		services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;TInterface&gt;());
	public static IServiceCollection AddDiscordHostedShardService&lt;TInterface, TService&gt;(
		where TInterface : class, IDiscordHostedShardService
		where TService : class, TInterface, IDiscordHostedShardService</file><file path="DisCatSharp.Hosting/BaseHostedService.cs">public abstract class BaseHostedService : BackgroundService
	protected readonly IHostApplicationLifetime ApplicationLifetime;
	protected readonly IConfiguration Configuration;
	protected readonly IServiceProvider ServiceProvider;
	protected virtual void OnInitializationError(Exception ex) =&gt; this.ApplicationLifetime.StopApplication();
	protected abstract Task ConnectAsync();
	protected Task InitializeExtensions(DiscordClient client)
		var typeMap = this.Configuration.FindImplementedExtensions(this.BotSection);
		this.Logger.LogDebug($&quot;Found the following config types: {string.Join(&quot;\n\t&quot;, typeMap.Keys)}&quot;);
					? typePair.Value.Section.Value.ExtractConfig(() =&gt;
						ActivatorUtilities.CreateInstance(this.ServiceProvider, typePair.Value.ConfigType))
					: ActivatorUtilities.CreateInstance(this.ServiceProvider, typePair.Value.ConfigType);
				var ctors = typePair.Value.ImplementationType.GetConstructors(flags);
				var instance = ctors.Any(x =&gt; x.GetParameters().Length == 1 &amp;&amp; x.GetParameters().First().ParameterType == typePair.Value.ConfigType)
					? Activator.CreateInstance(typePair.Value.ImplementationType, flags, null,
					: Activator.CreateInstance(typePair.Value.ImplementationType, true);
					this.Logger.LogError($&quot;Unable to instantiate &apos;{typePair.Value.ImplementationType.Name}&apos;&quot;);
				client.AddExtension((BaseExtension)instance);
				this.Logger.LogError($&quot;Unable to register &apos;{typePair.Value.ImplementationType.Name}&apos;: \n\t{ex.Message}&quot;);
				this.OnInitializationError(ex);
	protected abstract Task ConfigureAsync();
	protected abstract Task ConfigureExtensionsAsync();
	protected virtual Task PreConnectAsync() =&gt; Task.CompletedTask;
	protected virtual Task PostConnectAsync() =&gt; Task.CompletedTask;
	protected override async Task ExecuteAsync(CancellationToken stoppingToken)
			await this.ConfigureAsync();
			await this.PreConnectAsync();
			await this.ConnectAsync();
			await this.ConfigureExtensionsAsync();
			await this.PostConnectAsync();
			this.Logger.LogError($&quot;Was unable to start {this.GetType().Name} Bot as a Hosted Service&quot;);
		await Task.Delay(-1, stoppingToken);</file><file path="DisCatSharp.Hosting/ConfigurationExtensions.cs">internal static class ConfigurationExtensions
	public static List&lt;Assembly&gt; FindAssemblies(IEnumerable&lt;string&gt;? names)
		var queue = names.ToList();
		foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
			var loadedAssemblyName = assembly.GetName().Name;
			if (queue.Remove(loadedAssemblyName))
				results.Add(assembly);
			foreach (var referencedAssembly in assembly.GetReferencedAssemblies()
				.Where(x =&gt; x.Name != null &amp;&amp; queue.Contains(x.Name)))
					results.Add(Assembly.Load(referencedAssembly));
					queue.Remove(referencedAssembly.Name);
					Console.Error.WriteLine($&quot;Unable to load referenced assembly: &apos;{referencedAssembly.Name}&apos; \n\t{ex.Message}&quot;);
	public static Dictionary&lt;string, ExtensionConfigResult&gt; FindImplementedExtensions(
		if (string.IsNullOrEmpty(rootName))
			throw new ArgumentNullException(nameof(rootName), &quot;Root name must be provided&quot;);
		if (!configuration.HasSection(rootName, &quot;Using&quot;))
		assemblyNames = string.IsNullOrEmpty(configuration[configuration.ConfigPath(rootName, &quot;Using&quot;)])
			? configuration.GetSection(configuration.ConfigPath(rootName, &quot;Using&quot;)).Get&lt;string[]&gt;()
				configuration[configuration.ConfigPath(rootName, &quot;Using&quot;)]);
		foreach (var assembly in FindAssemblies(assemblyNames.Select(x =&gt; x.StartsWith(Constants.LibName, StringComparison.Ordinal) ? x : $&quot;{Constants.LibName}.{x}&quot;)))
			ExtensionConfigResult result = new();
				.Where(x =&gt; x.Name.EndsWith(Constants.ConfigSuffix, StringComparison.Ordinal) &amp;&amp; x is { IsAbstract: false, IsInterface: false }))
				var prefix = type.Name.Replace(Constants.ConfigSuffix, &quot;&quot;);
				if (configuration.HasSection(rootName, sectionName))
					result.Section = new ConfigSection(ref configuration, type.Name, rootName);
				else if (configuration.HasSection(rootName, prefix))
					result.Section = new ConfigSection(ref configuration, prefix, rootName);
				var implementationType = assembly.ExportedTypes.FirstOrDefault(x =&gt;
					x is { IsAbstract: false, IsInterface: false } &amp;&amp; x.Name.StartsWith(prefix, StringComparison.Ordinal) &amp;&amp;
					x.Name.EndsWith(Constants.ExtensionSuffix, StringComparison.Ordinal) &amp;&amp; x.IsAssignableTo(typeof(BaseExtension)));
					results.Add(implementationType.Name, result);</file><file path="DisCatSharp.Hosting/Constants.cs">internal static class Constants</file><file path="DisCatSharp.Hosting/DisCatSharp.Hosting.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Hosting&lt;/PackageId&gt;
		&lt;Description&gt;Hosting Extension for DisCatSharp.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Hosting,Web&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Hosting/DiscordHostedService.cs">public abstract class DiscordHostedService : BaseHostedService, IDiscordHostedService
	protected override Task ConfigureAsync()
			this.Client = this.Configuration.BuildClient(this.ServiceProvider, this.BotSection);
			this.Logger.LogError($&quot;Was unable to build {nameof(DiscordClient)} for {this.GetType().Name}&quot;);
			this.OnInitializationError(ex);
	protected sealed override async Task ConnectAsync() =&gt; await this.Client.ConnectAsync();
	protected override Task ConfigureExtensionsAsync()
		this.InitializeExtensions(this.Client);</file><file path="DisCatSharp.Hosting/DiscordSharedHostedService.cs">public abstract class DiscordShardedHostedService : BaseHostedService, IDiscordHostedShardService
	protected override Task ConfigureAsync()
			this.Logger.LogError($&quot;Was unable to build {nameof(DiscordShardedClient)} for {this.GetType().Name}&quot;);
			this.OnInitializationError(ex);
	protected sealed override async Task ConnectAsync() =&gt; await this.ShardedClient.StartAsync();
	protected override Task ConfigureExtensionsAsync()
			this.InitializeExtensions(client);</file><file path="DisCatSharp.Hosting/GlobalSuppressions.cs"></file><file path="DisCatSharp.Hosting/IDiscordHostedService.cs">public interface IDiscordHostedService : IHostedService
public interface IDiscordHostedShardService : IHostedService</file><file path="DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Interactivity&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Interactivity&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Interactivity&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Interactivity Extension

			Unleash the full power of discord commands.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/interactivity.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Pagination,Reactions,Buttons,Interactive Commands,Interactivity,Message Components&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;ConcurrentHashSet&quot; Version=&quot;1.3.0&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Interactivity/Entities/Page.cs">public class Page
		if (string.IsNullOrEmpty(content) &amp;&amp; embed is null)
			throw new ArgumentException(&quot;You need to specify at least content or embed or both.&quot;);</file><file path="DisCatSharp.Interactivity/Entities/PaginationEmojis.cs">public sealed class PaginationEmojis
		this.Left = DiscordEmoji.FromUnicode(&quot;◀&quot;);
		this.Right = DiscordEmoji.FromUnicode(&quot;▶&quot;);
		this.SkipLeft = DiscordEmoji.FromUnicode(&quot;⏮&quot;);
		this.SkipRight = DiscordEmoji.FromUnicode(&quot;⏭&quot;);
		this.Stop = DiscordEmoji.FromUnicode(&quot;⏹&quot;);</file><file path="DisCatSharp.Interactivity/Enums/ButtonPaginationBehavior.cs"></file><file path="DisCatSharp.Interactivity/Enums/InteractionResponseBehavior.cs"></file><file path="DisCatSharp.Interactivity/Enums/Modal/ModalPage.cs">public class ModalPage
		this.OpenButton = openButton ?? new DiscordButtonComponent(ButtonStyle.Primary, null, &quot;Open next page&quot;, false, new(DiscordEmoji.FromUnicode(&quot;📄&quot;)));
		this.OpenMessage = new DiscordInteractionResponseBuilder().WithContent(openText ?? &quot;`Click the button below to continue to the next page.`&quot;).AsEphemeral();</file><file path="DisCatSharp.Interactivity/Enums/Modal/PaginatedModalResponse.cs">public class PaginatedModalResponse</file><file path="DisCatSharp.Interactivity/Enums/PaginationBehaviour.cs"></file><file path="DisCatSharp.Interactivity/Enums/PaginationDeletion.cs"></file><file path="DisCatSharp.Interactivity/Enums/PollBehaviour.cs"></file><file path="DisCatSharp.Interactivity/Enums/SplitType.cs"></file><file path="DisCatSharp.Interactivity/EventHandling/Components/ComponentEventWaiter.cs">internal class ComponentEventWaiter : IDisposable
	private readonly DiscordClient _client;
	private readonly InteractivityConfiguration _config;
	private readonly DiscordFollowupMessageBuilder _message;
	public void Dispose()
		this._matchRequests.Clear();
		this._collectRequests.Clear();
	public async Task&lt;ComponentInteractionCreateEventArgs?&gt; WaitForMatchAsync(ComponentMatchRequest request)
		this._matchRequests.Add(request);
			return await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, e, &quot;An exception was thrown while waiting for components.&quot;);
			this._matchRequests.TryRemove(request);
	public async Task&lt;IReadOnlyList&lt;ComponentInteractionCreateEventArgs&gt;&gt; CollectMatchesAsync(ComponentCollectRequest request)
		this._collectRequests.Add(request);
			await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityCollectorError, e, &quot;There was an error while collecting component event args.&quot;);
			this._collectRequests.TryRemove(request);
		return request.Collected.ToArray();
	private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs args)
			if (mreq.Message == args.Message &amp;&amp; mreq.IsMatch(args))
				mreq.Tcs.TrySetResult(args);
				await args.Interaction.CreateFollowupMessageAsync(this._message).ConfigureAwait(false);
		foreach (var creq in this._collectRequests.Where(creq =&gt; creq.Message == args.Message &amp;&amp; creq.IsMatch(args)))
			await args.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate).ConfigureAwait(false);
			if (creq.IsMatch(args))
				creq.Collected.Add(args);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/ComponentPaginator.cs">internal class ComponentPaginator : IPaginator
	private readonly DiscordMessageBuilder _builder = new();
	private readonly DiscordClient _client;
	private readonly InteractivityConfiguration _config;
	public async Task DoPaginationAsync(IPaginationRequest request)
		var id = (await request.GetMessageAsync().ConfigureAwait(false)).Id;
		this._requests.Add(id, request);
			var tcs = await request.GetTaskCompletionSourceAsync().ConfigureAwait(false);
			await tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;There was an exception while paginating.&quot;);
			this._requests.Remove(id);
				await request.DoCleanupAsync().ConfigureAwait(false);
				this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;There was an exception while cleaning up pagination.&quot;);
	public void Dispose() =&gt; this._client.ComponentInteractionCreated -= this.Handle;
	private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs e)
		if (!this._requests.TryGetValue(e.Message.Id, out var req))
		if (!this._config.PaginationButtons.ButtonArray.Select(x =&gt; x.CustomId).Contains(e.Id))
			await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate).ConfigureAwait(false);
		if (await req.GetUserAsync().ConfigureAwait(false) != e.User)
				await e.Interaction.CreateFollowupMessageAsync(new()
				}).ConfigureAwait(false);
			ipr.RegenerateCts(e.Interaction); // Necessary to ensure we don&apos;t prematurely yeet the CTS //
		await this.HandlePaginationAsync(req, e).ConfigureAwait(false);
	private async Task HandlePaginationAsync(IPaginationRequest request, ComponentInteractionCreateEventArgs args)
		var msg = await request.GetMessageAsync().ConfigureAwait(false);
			_ when id == buttons.SkipLeft.CustomId =&gt; request.SkipLeftAsync(),
			_ when id == buttons.SkipRight.CustomId =&gt; request.SkipRightAsync(),
			_ when id == buttons.Stop.CustomId =&gt; Task.FromResult(tcs.TrySetResult(true)),
			_ when id == buttons.Left.CustomId =&gt; request.PreviousPageAsync(),
			_ when id == buttons.Right.CustomId =&gt; request.NextPageAsync(),
			_ =&gt; throw new ArgumentOutOfRangeException(nameof(args), &quot;Id was out of range&quot;)
		await paginationTask.ConfigureAwait(false);
		var page = await request.GetPageAsync().ConfigureAwait(false);
		var bts = await request.GetButtonsAsync().ConfigureAwait(false);
			var builder = new DiscordWebhookBuilder();
				builder.WithContent(page.Content);
				builder.AddEmbed(page.Embed);
			builder.AddComponents(bts);
			await (await ipr.GetLastInteractionAsync()).EditOriginalResponseAsync(builder).ConfigureAwait(false);
		this._builder.Clear();
			this._builder.WithContent(page.Content);
			this._builder.AddEmbed(page.Embed);
		this._builder.AddComponents(bts);
		await this._builder.ModifyAsync(msg).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/ModalEventWaiter.cs">internal class ModalEventWaiter : IDisposable
	private readonly DiscordClient _client;
	private readonly InteractivityConfiguration _config;
	private readonly DiscordFollowupMessageBuilder _message;
	public void Dispose()
		this._modalMatchRequests.Clear();
	public async Task&lt;ComponentInteractionCreateEventArgs?&gt; WaitForModalMatchAsync(ModalMatchRequest request)
		this._modalMatchRequests.Add(request);
			return await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, e, &quot;An exception was thrown while waiting for modals.&quot;);
			this._modalMatchRequests.TryRemove(request);
	private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs args)
			if (mreq.CustomId == args.Interaction.Data.CustomId &amp;&amp; mreq.IsMatch(args))
				mreq.Tcs.TrySetResult(args);
				await args.Interaction.CreateFollowupMessageAsync(this._message).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/PaginationButtons.cs">public class PaginationButtons
		this.SkipLeft = new(ButtonStyle.Secondary, &quot;leftskip&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏮&quot;)));
		this.Left = new(ButtonStyle.Secondary, &quot;left&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;◀&quot;)));
		this.Stop = new(ButtonStyle.Secondary, &quot;stop&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏹&quot;)));
		this.Right = new(ButtonStyle.Secondary, &quot;right&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;▶&quot;)));
		this.SkipRight = new(ButtonStyle.Secondary, &quot;rightskip&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏭&quot;)));</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ButtonPaginationRequest.cs">internal class ButtonPaginationRequest : IPaginationRequest
	private readonly ButtonPaginationBehavior _behaviorBehavior;
	private readonly PaginationButtons _buttons;
	private readonly DiscordMessage _message;
	private readonly CancellationToken _token;
	private readonly DiscordUser _user;
	private readonly PaginationBehaviour _wrapBehavior;
		this._pages.AddRange(pages);
		this._token.Register(() =&gt; this._tcs.TrySetResult(false));
	public Task&lt;Page&gt; GetPageAsync()
		var page = Task.FromResult(this._pages[this._index]);
			this._buttons.SkipLeft.Disable();
			this._buttons.Left.Disable();
			this._buttons.Right.Disable();
			this._buttons.SkipRight.Disable();
			this._buttons.Stop.Enable();
	public Task SkipLeftAsync()
	public Task SkipRightAsync()
	public Task NextPageAsync()
		this._index = Math.Min(this._index, this.PageCount - 1);
	public Task PreviousPageAsync()
		this._index = Math.Max(this._index, 0);
	public Task&lt;PaginationEmojis&gt; GetEmojisAsync()
		=&gt; Task.FromException&lt;PaginationEmojis&gt;(new NotSupportedException(&quot;Emojis aren&apos;t supported for this request.&quot;));
	public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
	public Task&lt;DiscordMessage&gt; GetMessageAsync()
		=&gt; Task.FromResult(this._message);
	public Task&lt;DiscordUser&gt; GetUserAsync()
		=&gt; Task.FromResult(this._user);
	public Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
		=&gt; Task.FromResult(this._tcs);
	public async Task DoCleanupAsync()
		var builder = new DiscordMessageBuilder();
				var buttons = this._buttons.ButtonArray.Select(b =&gt; b.Disable());
					builder.WithContent(page.Content);
					builder.AddEmbed(page.Embed);
				builder.AddComponents(buttons);
				await builder.ModifyAsync(this._message).ConfigureAwait(false);
				await this._message.DeleteAsync().ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentCollectRequest.cs">internal sealed class ComponentCollectRequest : ComponentMatchRequest</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentMatchRequest.cs">internal class ComponentMatchRequest
	protected readonly CancellationToken Cancellation;
		this.Cancellation.Register(() =&gt; this.Tcs.TrySetResult(null)); // TrySetCancelled would probably be better but I digress ~Velvet //
	public bool IsMatch(ComponentInteractionCreateEventArgs args) =&gt; this.Predicate(args);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/InteractionPaginationRequest.cs">internal class InteractionPaginationRequest : IPaginationRequest
	private readonly ButtonPaginationBehavior _behaviorBehavior;
	private readonly PaginationButtons _buttons;
	private readonly DiscordMessage _message;
	private readonly CancellationToken _token;
	private readonly DiscordUser _user;
	private readonly PaginationBehaviour _wrapBehavior;
	private CancellationTokenSource _interactionCts;
	private DiscordInteraction _lastInteraction;
		this._pages.AddRange(pages);
		this.RegenerateCts(interaction);
		this._token.Register(() =&gt; this._tcs.TrySetResult(false));
	public Task&lt;Page&gt; GetPageAsync()
		var page = Task.FromResult(this._pages[this._index]);
			_ = this._buttons.ButtonArray.Select(b =&gt; b.Disable());
			this._buttons.Stop.Enable();
	public Task SkipLeftAsync()
	public Task SkipRightAsync()
	public Task NextPageAsync()
		this._index = Math.Min(this._index, this.PageCount - 1);
	public Task PreviousPageAsync()
		this._index = Math.Max(this._index, 0);
	public Task&lt;PaginationEmojis&gt; GetEmojisAsync()
		=&gt; Task.FromException&lt;PaginationEmojis&gt;(new NotSupportedException(&quot;Emojis aren&apos;t supported for this request.&quot;));
	public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
	public Task&lt;DiscordMessage&gt; GetMessageAsync()
		=&gt; Task.FromResult(this._message);
	public Task&lt;DiscordUser&gt; GetUserAsync()
		=&gt; Task.FromResult(this._user);
	public Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
		=&gt; Task.FromResult(this._tcs);
	public async Task DoCleanupAsync()
		var builder = new DiscordWebhookBuilder();
					.Select(b =&gt; new DiscordButtonComponent(b))
					.Select(b =&gt; b.Disable());
					builder.WithContent(page.Content);
					builder.AddEmbed(page.Embed);
				builder.AddComponents(buttons);
				await this._lastInteraction.EditOriginalResponseAsync(builder).ConfigureAwait(false);
				await this._lastInteraction.DeleteOriginalResponseAsync().ConfigureAwait(false);
	internal void RegenerateCts(DiscordInteraction interaction)
		this._interactionCts = new(TimeSpan.FromSeconds((60 * 15) - 5));
		this._interactionCts.Token.Register(() =&gt; this._tcs.TrySetResult(false));
	public Task&lt;DiscordInteraction&gt; GetLastInteractionAsync() =&gt; Task.FromResult(this._lastInteraction);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ModalMatchRequest.cs">internal class ModalMatchRequest
	protected readonly CancellationToken Cancellation;
		this.Cancellation.Register(() =&gt; this.Tcs.TrySetResult(null)); // TrySetCancelled would probably be better but I digress ~Velvet //
	public bool IsMatch(ComponentInteractionCreateEventArgs args) =&gt; this.Predicate(args);</file><file path="DisCatSharp.Interactivity/EventHandling/EventWaiter.cs">internal class EventWaiter&lt;T&gt; : IDisposable where T : AsyncEventArgs
	private DiscordClient _client;
		var tinfo = this._client.GetType().GetTypeInfo();
		var handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, T&gt;));
		this._event = (AsyncEvent&lt;DiscordClient, T&gt;)handler.GetValue(this._client);
		this._event.Register(this._handler);
	public void Dispose()
		GC.SuppressFinalize(this);
	public async Task&lt;T?&gt; WaitForMatchAsync(MatchRequest&lt;T&gt; request)
		this._matchRequests.Add(request);
			result = await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, ex, &quot;An exception occurred while waiting for {0}&quot;, typeof(T).Name);
			request.Dispose();
			this._matchRequests.TryRemove(request);
	public async Task&lt;ReadOnlyCollection&lt;T&gt;&gt; CollectMatchesAsync(CollectRequest&lt;T&gt; request)
		this._collectRequests.Add(request);
			await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, ex, &quot;An exception occurred while collecting from {0}&quot;, typeof(T).Name);
			result = new(new HashSet&lt;T&gt;(request.Collected).ToList());
			this._collectRequests.TryRemove(request);
	private Task HandleEvent(DiscordClient client, T eventArgs)
				if (req.Predicate(eventArgs))
					req.Tcs.TrySetResult(eventArgs);
					req.Collected.Add(eventArgs);
		this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/IPaginator.cs">internal interface IPaginator
	Task DoPaginationAsync(IPaginationRequest request);
	void Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Paginator.cs">internal class Paginator : IPaginator
	private DiscordClient _client;
	public async Task DoPaginationAsync(IPaginationRequest request)
		await this.ResetReactionsAsync(request).ConfigureAwait(false);
		this._requests.Add(request);
			var tcs = await request.GetTaskCompletionSourceAsync().ConfigureAwait(false);
			await tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;Exception occurred while paginating&quot;);
			this._requests.TryRemove(request);
				await request.DoCleanupAsync().ConfigureAwait(false);
	public void Dispose()
		this._requests.Clear();
	private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
		_ = Task.Run(async () =&gt;
				var emojis = await req.GetEmojisAsync().ConfigureAwait(false);
				var msg = await req.GetMessageAsync().ConfigureAwait(false);
				var usr = await req.GetUserAsync().ConfigureAwait(false);
							await this.PaginateAsync(req, eventArgs.Emoji).ConfigureAwait(false);
							await msg.DeleteReactionAsync(eventArgs.Emoji, eventArgs.User).ConfigureAwait(false);
	private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
	private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
					await this.ResetReactionsAsync(req).ConfigureAwait(false);
	private async Task ResetReactionsAsync(IPaginationRequest p)
		var msg = await p.GetMessageAsync().ConfigureAwait(false);
		var emojis = await p.GetEmojisAsync().ConfigureAwait(false);
		if (mbr is not null &amp;&amp; (chn.PermissionsFor(mbr) &amp; Permissions.ManageMessages) != 0)
			await msg.DeleteAllReactionsAsync(&quot;Pagination&quot;).ConfigureAwait(false);
				await msg.CreateReactionAsync(emojis.SkipLeft).ConfigureAwait(false);
				await msg.CreateReactionAsync(emojis.Left).ConfigureAwait(false);
				await msg.CreateReactionAsync(emojis.Right).ConfigureAwait(false);
				await msg.CreateReactionAsync(emojis.SkipRight).ConfigureAwait(false);
				await msg.CreateReactionAsync(emojis.Stop).ConfigureAwait(false);
	private async Task PaginateAsync(IPaginationRequest p, DiscordEmoji emoji)
			await p.SkipLeftAsync().ConfigureAwait(false);
			await p.PreviousPageAsync().ConfigureAwait(false);
			await p.NextPageAsync().ConfigureAwait(false);
			await p.SkipRightAsync().ConfigureAwait(false);
			var tcs = await p.GetTaskCompletionSourceAsync().ConfigureAwait(false);
			tcs.TrySetResult(true);
		var page = await p.GetPageAsync().ConfigureAwait(false);
		var builder = new DiscordMessageBuilder();
			builder.WithContent(page.Content);
			builder.AddEmbed(page.Embed);
		await builder.ModifyAsync(msg).ConfigureAwait(false);
		this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Poller.cs">internal class Poller
	private DiscordClient _client;
	public async Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(PollRequest request)
		this._requests.Add(request);
			await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityPollError, ex, &quot;Exception occurred while polling&quot;);
			result = new(new HashSet&lt;PollEmoji&gt;(request.Collected).ToList());
			request.Dispose();
			this._requests.TryRemove(request);
	private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
		_ = Task.Run(async () =&gt;
					if (req.Emojis.Contains(eventArgs.Emoji) &amp;&amp; !req.Collected.Any(x =&gt; x.Voted.Contains(eventArgs.User)))
							req.AddReaction(eventArgs.Emoji, eventArgs.User);
						var member = await eventArgs.Channel.Guild.GetMemberAsync(client.CurrentUser.Id).ConfigureAwait(false);
						if (eventArgs.Channel.PermissionsFor(member).HasPermission(Permissions.ManageMessages))
							await eventArgs.Message.DeleteReactionAsync(eventArgs.Emoji, eventArgs.User).ConfigureAwait(false);
	private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
					req.RemoveReaction(eventArgs.Emoji, eventArgs.User);
	private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
				req.ClearCollected();
		this.Dispose();
	public void Dispose()
		this._requests.Clear();</file><file path="DisCatSharp.Interactivity/EventHandling/ReactionCollector.cs">internal class ReactionCollector : IDisposable
	private DiscordClient _client;
		var tinfo = this._client.GetType().GetTypeInfo();
		var handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionAddEventArgs&gt;));
		this._reactionAddEvent = (AsyncEvent&lt;DiscordClient, MessageReactionAddEventArgs&gt;)handler.GetValue(this._client);
		this._reactionAddEvent.Register(this._reactionAddHandler);
		handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionRemoveEventArgs&gt;));
		this._reactionRemoveEvent = (AsyncEvent&lt;DiscordClient, MessageReactionRemoveEventArgs&gt;)handler.GetValue(this._client);
		this._reactionRemoveEvent.Register(this._reactionRemoveHandler);
		handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionsClearEventArgs&gt;));
		this._reactionClearEvent = (AsyncEvent&lt;DiscordClient, MessageReactionsClearEventArgs&gt;)handler.GetValue(this._client);
		this._reactionClearEvent.Register(this._reactionClearHandler);
	public void Dispose()
		this._reactionAddEvent.Unregister(this._reactionAddHandler);
		this._reactionRemoveEvent.Unregister(this._reactionRemoveHandler);
		this._reactionClearEvent.Unregister(this._reactionClearHandler);
		this._requests.Clear();
		GC.SuppressFinalize(this);
	public async Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectAsync(ReactionCollectRequest request)
		this._requests.Add(request);
			await request.Tcs.Task.ConfigureAwait(false);
			this._client.Logger.LogError(InteractivityEvents.InteractivityCollectorError, ex, &quot;Exception occurred while collecting reactions&quot;);
			result = new(new HashSet&lt;Reaction&gt;(request.Collected).ToList());
			request.Dispose();
			this._requests.TryRemove(request);
	private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
				if (req.Collected.Any(x =&gt; x.Emoji == eventArgs.Emoji &amp;&amp; x.Users.Any(y =&gt; y.Id == eventArgs.User.Id)))
					var reaction = req.Collected.First(x =&gt; x.Emoji == eventArgs.Emoji &amp;&amp; x.Users.Any(y =&gt; y.Id == eventArgs.User.Id));
					req.Collected.TryRemove(reaction);
					reaction.Users.Add(eventArgs.User);
					req.Collected.Add(reaction);
					req.Collected.Add(new()
	private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
					reaction.Users.TryRemove(eventArgs.User);
	private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
				req.Collected.Clear();
		this.Dispose();
public class ReactionCollectRequest : IDisposable
	internal CancellationTokenSource Ct;
	internal DiscordMessage Message;
	internal TimeSpan Timeout;
		this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(null));
		this.Ct.Dispose();
public class Reaction</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/CollectRequest.cs">internal class CollectRequest&lt;T&gt; : IDisposable where T : AsyncEventArgs
	internal CancellationTokenSource Ct;
	internal TimeSpan Timeout;
		this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(true));
	public void Dispose()
		this.Ct.Dispose();
			this.Collected.Clear();
		GC.SuppressFinalize(this);
		this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/IPaginationRequest.cs">public interface IPaginationRequest
	Task&lt;Page&gt; GetPageAsync();
	Task SkipLeftAsync();
	Task SkipRightAsync();
	Task NextPageAsync();
	Task PreviousPageAsync();
	Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync();
	Task&lt;PaginationEmojis&gt; GetEmojisAsync();
	Task&lt;DiscordMessage&gt; GetMessageAsync();
	Task&lt;DiscordUser&gt; GetUserAsync();
	Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync();
	Task DoCleanupAsync();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/MatchRequest.cs">internal class MatchRequest&lt;T&gt; : IDisposable where T : AsyncEventArgs
	internal CancellationTokenSource Ct;
	internal TimeSpan Timeout;
		this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(null));
	public void Dispose()
		this.Ct.Dispose();
		GC.SuppressFinalize(this);
		this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/PaginationRequest.cs">internal class PaginationRequest : IPaginationRequest
	private readonly PaginationBehaviour _behaviour;
	private readonly CancellationTokenSource _ct;
	private readonly PaginationEmojis _emojis;
	private readonly DiscordMessage _message;
	private readonly TimeSpan _timeout;
	private readonly DiscordUser _user;
		this._ct.Token.Register(() =&gt; this._tcs.TrySetResult(true));
	public async Task&lt;Page&gt; GetPageAsync()
		await Task.Yield();
	public async Task SkipLeftAsync()
	public async Task SkipRightAsync()
	public async Task NextPageAsync()
	public async Task PreviousPageAsync()
	public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
		=&gt; throw new NotSupportedException(&quot;This request does not support buttons.&quot;);
	public async Task&lt;PaginationEmojis&gt; GetEmojisAsync()
	public async Task&lt;DiscordMessage&gt; GetMessageAsync()
	public async Task&lt;DiscordUser&gt; GetUserAsync()
	public async Task DoCleanupAsync()
				await this._message.DeleteAllReactionsAsync().ConfigureAwait(false);
				await this._message.DeleteAsync().ConfigureAwait(false);
	public async Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
		this.Dispose();
	public void Dispose()
		this._ct.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/PollRequest.cs">public class PollRequest
	internal CancellationTokenSource Ct;
	internal DiscordMessage Message;
	internal TimeSpan Timeout;
		this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(true));
		this.Emojis = emojis.ToList();
			this.Collected.Add(new(e));
	internal void ClearCollected()
		this.Collected.Clear();
	internal void RemoveReaction(DiscordEmoji emoji, DiscordUser member)
		if (this.Collected.Any(x =&gt; x.Emoji == emoji))
			if (this.Collected.Any(x =&gt; x.Voted.Contains(member)))
				var e = this.Collected.First(x =&gt; x.Emoji == emoji);
				this.Collected.TryRemove(e);
				e.Voted.TryRemove(member);
				this.Collected.Add(e);
	internal void AddReaction(DiscordEmoji emoji, DiscordUser member)
			if (!this.Collected.Any(x =&gt; x.Voted.Contains(member)))
				e.Voted.Add(member);
		this.Dispose();
	public void Dispose()
		this.Ct.Dispose();
public class PollEmoji
	public DiscordEmoji Emoji;</file><file path="DisCatSharp.Interactivity/Extensions/ChannelExtensions.cs">public static class ChannelExtensions
	public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, Func&lt;DiscordMessage, bool&gt; predicate, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(channel).WaitForMessageAsync(msg =&gt; msg.ChannelId == channel.Id &amp;&amp; predicate(msg), timeoutOverride);
	public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, TimeSpan? timeoutOverride = null)
		=&gt; channel.GetNextMessageAsync(msg =&gt; true, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, DiscordUser user, TimeSpan? timeoutOverride = null)
		=&gt; channel.GetNextMessageAsync(msg =&gt; msg.Author.Id == user.Id, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(this DiscordChannel channel, DiscordUser user, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(channel).WaitForUserTypingAsync(user, channel, timeoutOverride);
	public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationEmojis emojis, PaginationBehaviour? behaviour = default, PaginationDeletion? deletion = default, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, emojis, behaviour, deletion, timeoutOverride);
	public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
		=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, buttons, behaviour, deletion, token);
	public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
		=&gt; channel.SendPaginatedMessageAsync(user, pages, default, behaviour, deletion, token);
	public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
		=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, buttons, timeoutOverride, behaviour, deletion);
	public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
		=&gt; channel.SendPaginatedMessageAsync(user, pages, default, timeoutOverride, behaviour, deletion);
	internal static InteractivityExtension GetInteractivity(DiscordChannel channel)
		var interactivity = client.GetInteractivity();
		return interactivity ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);</file><file path="DisCatSharp.Interactivity/Extensions/ClientExtensions.cs">public static class ClientExtensions
	public static InteractivityExtension UseInteractivity(this DiscordClient client, InteractivityConfiguration configuration = null)
		if (client.GetExtension&lt;InteractivityExtension&gt;() != null) throw new InvalidOperationException($&quot;Interactivity is already enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);
		var extension = new InteractivityExtension(configuration);
		client.AddExtension(extension);
	public static async Task&lt;IReadOnlyDictionary&lt;int, InteractivityExtension&gt;&gt; UseInteractivityAsync(this DiscordShardedClient client, InteractivityConfiguration configuration = null)
		await client.InitializeShardsAsync().ConfigureAwait(false);
		foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
			var extension = shard.GetExtension&lt;InteractivityExtension&gt;() ?? shard.UseInteractivity(configuration);
			extensions.Add(shard.ShardId, extension);
	public static InteractivityExtension GetInteractivity(this DiscordClient client)
	public static async Task&lt;ReadOnlyDictionary&lt;int, InteractivityExtension&gt;&gt; GetInteractivityAsync(this DiscordShardedClient client)
			extensions.Add(shard.ShardId, shard.GetExtension&lt;InteractivityExtension&gt;());</file><file path="DisCatSharp.Interactivity/Extensions/InteractionExtensions.cs">public static class InteractionExtensions
	public static Task SendPaginatedResponseAsync(this DiscordInteraction interaction, bool deferred, bool ephemeral, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons = null, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
	public static async Task&lt;PaginatedModalResponse&gt; CreatePaginatedModalResponseAsync(this DiscordInteraction interaction, IReadOnlyList&lt;ModalPage&gt; modals, TimeSpan? timeOutOverride = null)
			throw new ArgumentException(&quot;You have to set at least one page&quot;);
		var interactivity = client.GetInteractivity() ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);
		timeOutOverride ??= TimeSpan.FromMinutes(15);
			var modal = b.Modal.WithCustomId(Guid.NewGuid().ToString());
				var originalResponse = (await previousInteraction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, b.OpenMessage.AddComponents(b.OpenButton)).ConfigureAwait(false)).Message;
				var modalOpen = await interactivity.WaitForButtonAsync(originalResponse, new List&lt;DiscordButtonComponent&gt;
				}, timeOutOverride).ConfigureAwait(false);
					_ = previousInteraction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(b.OpenMessage.Content).AddComponents(b.OpenButton.Disable()));
				await modalOpen.Result.Interaction.CreateInteractionModalResponseAsync(modal).ConfigureAwait(false);
				await previousInteraction.CreateInteractionModalResponseAsync(modal).ConfigureAwait(false);
			var modalResult = await interactivity.WaitForModalAsync(modal.CustomId, timeOutOverride).ConfigureAwait(false);
				caughtResponses.Add(submissions.CustomId, submissions.Value);
		await previousInteraction.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral()).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/Extensions/MessageExtensions.cs">public static class MessageExtensions
	public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
		=&gt; message.Channel.GetNextMessageAsync(message.Author, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordMessage message, Func&lt;DiscordMessage, bool&gt; predicate, TimeSpan? timeoutOverride = null)
		=&gt; message.Channel.GetNextMessageAsync(msg =&gt; msg.Author.Id == message.Author.Id &amp;&amp; message.ChannelId == msg.ChannelId &amp;&amp; predicate(msg), timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, string id, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, id, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, string id, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, id, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, user, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, DiscordUser user, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, user, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, predicate, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForButtonAsync(message, predicate, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, predicate, selectType, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, predicate, selectType, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, id, selectType, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, string id, ComponentType selectType, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, id, selectType, token);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, DiscordUser user, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, user, id, selectType, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, DiscordUser user, string id, ComponentType selectType, CancellationToken token)
		=&gt; GetInteractivity(message).WaitForSelectAsync(message, user, id, selectType, token);
	public static Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(this DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForReactionAsync(message, user, timeoutOverride);
	public static Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(this DiscordMessage message, DiscordUser user, DiscordEmoji emoji, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).WaitForReactionAsync(e =&gt; e.Emoji == emoji, message, user, timeoutOverride);
	public static Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectReactionsAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).CollectReactionsAsync(message, timeoutOverride);
	public static Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(this DiscordMessage message, IEnumerable&lt;DiscordEmoji&gt; emojis, PollBehaviour? behaviorOverride = null, TimeSpan? timeoutOverride = null)
		=&gt; GetInteractivity(message).DoPollAsync(message, emojis, behaviorOverride, timeoutOverride);
	internal static InteractivityExtension GetInteractivity(DiscordMessage message)
		var interactivity = client.GetInteractivity();
		return interactivity ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);</file><file path="DisCatSharp.Interactivity/GlobalSuppressions.cs"></file><file path="DisCatSharp.Interactivity/Helpers/InteractivityHelpers.cs">public static class InteractivityHelpers
	public static List&lt;Page&gt; Recalculate(this List&lt;Page&gt; pages)
		foreach (var page in pages.Where(p =&gt; p.Embed is not null))
			ArgumentNullException.ThrowIfNull(page.Embed);
			var replaceEmbed = new DiscordEmbedBuilder(page.Embed).WithFooter($&quot;Page {pageCount}/{pages.Count}&quot;);
			recalulatedPages.Add(new(embed: replaceEmbed));</file><file path="DisCatSharp.Interactivity/InteractivityConfiguration.cs">public sealed class InteractivityConfiguration
		if (this.ResponseBehavior is InteractionResponseBehavior.Respond &amp;&amp; string.IsNullOrWhiteSpace(this.ResponseMessage))
			throw new ArgumentException($&quot;{nameof(this.ResponseMessage)} cannot be null, empty, or whitespace when {nameof(this.ResponseBehavior)} is set to respond.&quot;);
	public TimeSpan Timeout { internal get; set; } = TimeSpan.FromMinutes(1);</file><file path="DisCatSharp.Interactivity/InteractivityEvents.cs">public static class InteractivityEvents</file><file path="DisCatSharp.Interactivity/InteractivityExtension.cs">public class InteractivityExtension : BaseExtension
	private ComponentEventWaiter _componentEventWaiter;
	private ComponentPaginator _compPaginator;
	private ModalEventWaiter _modalEventWaiter;
	private Paginator _paginator;
	private Poller _poller;
	private ReactionCollector _reactionCollector;
	protected internal override void Setup(DiscordClient client)
	public async Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(DiscordMessage m, IEnumerable&lt;DiscordEmoji&gt; emojis, PollBehaviour? behaviour = default, TimeSpan? timeout = null)
		if (!Utilities.HasReactionIntents(this.Client.Configuration.Intents))
			throw new InvalidOperationException(&quot;No reaction intents are enabled.&quot;);
		if (!emojis.Any())
			throw new ArgumentException(&quot;You need to provide at least one emoji for a poll!&quot;);
			await m.CreateReactionAsync(em).ConfigureAwait(false);
		var res = await this._poller.DoPollAsync(new(m, timeout ?? this.Config.Timeout, emojis)).ConfigureAwait(false);
		var thisMember = await m.Channel.Guild.GetMemberAsync(this.Client.CurrentUser.Id).ConfigureAwait(false);
		if (pollBehaviour == PollBehaviour.DeleteEmojis &amp;&amp; m.Channel.PermissionsFor(thisMember).HasPermission(Permissions.ManageMessages))
			await m.DeleteAllReactionsAsync().ConfigureAwait(false);
		return new(res.ToList());
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, IEnumerable&lt;DiscordButtonComponent&gt; buttons, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForButtonAsync(message, buttons, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, IEnumerable&lt;DiscordButtonComponent&gt; buttons, CancellationToken token)
			throw new InvalidOperationException(&quot;Interaction events are only sent to the application that created them.&quot;);
		if (!buttons.Any())
			throw new ArgumentException(&quot;You must specify at least one button to listen for.&quot;);
			throw new ArgumentException(&quot;Provided message does not contain any components.&quot;);
		if (!message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).Any(c =&gt; c.Type is ComponentType.Button))
			throw new ArgumentException(&quot;Provided Message does not contain any button components.&quot;);
			.WaitForMatchAsync(new(message,
					buttons.Any(b =&gt; b.CustomId == c.Id), token)).ConfigureAwait(false);
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForModalAsync(string customId, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForModalAsync(customId, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForModalAsync(string customId, CancellationToken token)
				.WaitForModalMatchAsync(new(customId, c =&gt; c.Interaction.Type is InteractionType.ModalSubmit, token))
				.ConfigureAwait(false);
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForButtonAsync(message, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, CancellationToken token)
			throw new ArgumentException(&quot;Message does not contain any button components.&quot;);
		var ids = message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).Select(c =&gt; c.CustomId);
				.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; ids.Contains(c.Id), token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForButtonAsync(message, user, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, DiscordUser user, CancellationToken token)
			.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; c.User == user, token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, string id, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForButtonAsync(message, id, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, string id, CancellationToken token)
		if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).OfType&lt;DiscordButtonComponent&gt;().All(c =&gt; c.CustomId != id))
			throw new ArgumentException($&quot;Message does not contain button with Id of &apos;{id}&apos;.&quot;);
			.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; c.Id == id, token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForButtonAsync(message, predicate, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, CancellationToken token)
			.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; predicate(c), token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForSelectAsync(message, predicate, selectType, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, CancellationToken token)
		if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).All(c =&gt; c.Type != selectType))
			throw new ArgumentException(&quot;Message does not contain any select components.&quot;);
			.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType == selectType &amp;&amp; predicate(c), token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForSelectAsync(message, id, selectType, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, string id, ComponentType selectType, CancellationToken token)
		if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).OfType&lt;DiscordBaseSelectComponent&gt;().All(c =&gt; c.CustomId != id))
			throw new ArgumentException($&quot;Message does not contain select component with Id of &apos;{id}&apos;.&quot;);
			.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType == selectType &amp;&amp; c.Id == id, token))
	public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, DiscordUser user, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
		=&gt; this.WaitForSelectAsync(message, user, id, selectType, this.GetCancellationToken(timeoutOverride));
	public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, DiscordUser user, string id, ComponentType selectType, CancellationToken token)
			throw new ArgumentException($&quot;Message does not contain select with Id of &apos;{id}&apos;.&quot;);
			.WaitForMatchAsync(new(message, c =&gt; c.Id == id &amp;&amp; c.User == user, token)).ConfigureAwait(false);
	public async Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; WaitForMessageAsync(
		if (!Utilities.HasMessageIntents(this.Client.Configuration.Intents))
			throw new InvalidOperationException(&quot;No message intents are enabled.&quot;);
		var returns = await this._messageCreatedWaiter.WaitForMatchAsync(new(x =&gt; predicate(x.Message), timeout)).ConfigureAwait(false);
	public async Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(
		var returns = await this._messageReactionAddWaiter.WaitForMatchAsync(new(predicate, timeout)).ConfigureAwait(false);
		=&gt; await this.WaitForReactionAsync(x =&gt; x.User.Id == user.Id &amp;&amp; x.Message.Id == message.Id, timeoutOverride).ConfigureAwait(false);
		=&gt; await this.WaitForReactionAsync(x =&gt; predicate(x) &amp;&amp; x.User.Id == user.Id &amp;&amp; x.Message.Id == message.Id, timeoutOverride).ConfigureAwait(false);
		=&gt; await this.WaitForReactionAsync(x =&gt; predicate(x) &amp;&amp; x.User.Id == user.Id, timeoutOverride).ConfigureAwait(false);
	public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(
		if (!Utilities.HasTypingIntents(this.Client.Configuration.Intents))
			throw new InvalidOperationException(&quot;No typing intents are enabled.&quot;);
		var returns = await this._typingStartWaiter.WaitForMatchAsync(
	public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(DiscordUser user, TimeSpan? timeoutOverride = null)
	public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForTypingAsync(DiscordChannel channel, TimeSpan? timeoutOverride = null)
	public async Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectReactionsAsync(DiscordMessage m, TimeSpan? timeoutOverride = null)
		var collection = await this._reactionCollector.CollectAsync(new(m, timeout)).ConfigureAwait(false);
	public async Task&lt;InteractivityResult&lt;T&gt;&gt; WaitForEventArgsAsync&lt;T&gt;(Func&lt;T, bool&gt; predicate, TimeSpan? timeoutOverride = null) where T : AsyncEventArgs
		var res = await waiter.WaitForMatchAsync(new(predicate, timeout)).ConfigureAwait(false);
	public async Task&lt;ReadOnlyCollection&lt;T&gt;&gt; CollectEventArgsAsync&lt;T&gt;(Func&lt;T, bool&gt; predicate, TimeSpan? timeoutOverride = null) where T : AsyncEventArgs
		var res = await waiter.CollectMatchesAsync(new(predicate, timeout)).ConfigureAwait(false);
	public async Task SendPaginatedMessageAsync(
			bts.SkipLeft.Disable();
			bts.Left.Disable();
		var page = pages.First();
		var builder = new DiscordMessageBuilder();
			builder.WithContent(page.Content);
			builder.AddEmbed(page.Embed);
		builder.AddComponents(bts.ButtonArray.ToList());
		var message = await builder.SendAsync(channel).ConfigureAwait(false);
		var req = new ButtonPaginationRequest(message, user, bhv, del, bts, pages, token == default ? this.GetCancellationToken() : token);
		await this._compPaginator.DoPaginationAsync(req).ConfigureAwait(false);
	public Task SendPaginatedMessageAsync(
		=&gt; this.SendPaginatedMessageAsync(channel, user, pages, buttons, behaviour, deletion, this.GetCancellationToken(timeoutOverride));
	public Task SendPaginatedMessageAsync(DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
		=&gt; this.SendPaginatedMessageAsync(channel, user, pages, default, behaviour, deletion, token);
	public Task SendPaginatedMessageAsync(DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
		=&gt; this.SendPaginatedMessageAsync(channel, user, pages, default, timeoutOverride, behaviour, deletion);
		var m = await builder.SendAsync(channel).ConfigureAwait(false);
		var pRequest = new PaginationRequest(m, user, bhv, del, ems, timeout, pages);
		await this._paginator.DoPaginationAsync(pRequest).ConfigureAwait(false);
	public async Task SendPaginatedResponseAsync(DiscordInteraction interaction, bool deferred, bool ephemeral, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons? buttons = null, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
		if (pages.Count() is 1)
			bts.SkipRight.Disable();
			bts.Stop.Disable();
			bts.Right.Disable();
		DiscordMessage message;
			var builder = new DiscordWebhookBuilder();
			message = await interaction.EditOriginalResponseAsync(builder).ConfigureAwait(false);
			var builder = new DiscordInteractionResponseBuilder();
				builder = builder.AsEphemeral();
			message = (await interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, builder).ConfigureAwait(false)).Message!;
		var req = new InteractionPaginationRequest(interaction, message, user, bhv, del, bts, pages, token);
	public async Task WaitForCustomPaginationAsync(IPaginationRequest request)
		=&gt; await this._paginator.DoPaginationAsync(request).ConfigureAwait(false);
	public async Task WaitForCustomComponentPaginationAsync(IPaginationRequest request)
		=&gt; await this._compPaginator.DoPaginationAsync(request).ConfigureAwait(false);
	public IEnumerable&lt;Page&gt; GeneratePagesInContent(string input, SplitType splitType = SplitType.Character)
		if (string.IsNullOrEmpty(input))
			throw new ArgumentException(&quot;You must provide a string that is not null or empty!&quot;);
				split = [.. this.SplitString(input, 500)];
				var subsplit = input.Split(&apos;\n&apos;);
					split.Add(s);
				if (split.All(x =&gt; x != s))
			result.Add(new($&quot;Page {page}:\n{s}&quot;));
	public IEnumerable&lt;Page&gt; GeneratePagesInEmbed(string input, SplitType splitType = SplitType.Character, DiscordEmbedBuilder? embedBase = null)
		var embed = embedBase ?? new DiscordEmbedBuilder();
			result.Add(new(null, new DiscordEmbedBuilder(embed).WithDescription(s).WithFooter($&quot;Page {page}/{split.Count}&quot;)));
	private List&lt;string&gt; SplitString(string str, int chunkSize)
			var size = Math.Min(len - i, chunkSize);
			res.Add(str.Substring(i, size));
	private CancellationToken GetCancellationToken(TimeSpan? timeout = null) =&gt; new CancellationTokenSource(timeout ?? this.Config.Timeout).Token;
	private async Task HandleInvalidInteraction(DiscordInteraction interaction)
			InteractionResponseBehavior.Ack =&gt; interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate),
			InteractionResponseBehavior.Respond =&gt; interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new()
			_ =&gt; throw new ArgumentException(&quot;Unknown enum value.&quot;)
		await at.ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/InteractivityResult.cs"></file><file path="DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Lavalink&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Lavalink&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Lavalink&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Lavalink V4 Extension

			Extend your bot with the full power of lavalink.
			Play your favorite music in discord!

			Requires Lavalink Server v4

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/audio/lavalink_v4/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Voice,Lavalink,Lavalink V4,Audio Player,Music,YouTube,Spotify,SoundCloud,Twitch,Vimeo,BandCamp,Apple Music,Yandex Music,Spotify,Spotify Recommendations,Deezer,Deezer ISRC,Local Music,Direct Url Music&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Lavalink/Entities/DefaultQueueEntry.cs">public sealed class DefaultQueueEntry : IQueueEntry
	public Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
		=&gt; Task.FromResult(true);
	public Task AfterPlayingAsync(LavalinkGuildPlayer player)</file><file path="DisCatSharp.Lavalink/Entities/Filters/IPluginFilter.cs">public interface IPluginFilter</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkChannelMix.cs">public sealed class LavalinkChannelMix</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkDisortion.cs">public sealed class LavalinkDisortion</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkEqualizer.cs">public sealed class LavalinkEqualizer</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkFilters.cs">public sealed class LavalinkFilters</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkKaraoke.cs">public sealed class LavalinkKaraoke</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkLowPass.cs">public sealed class LavalinkLowPass</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkRotation.cs">public sealed class LavalinkRotation</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkTimescale.cs">public sealed class LavalinkTimescale</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkTremolo.cs">public sealed class LavalinkTremolo</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkVibrato.cs">public sealed class LavalinkVibrato</file><file path="DisCatSharp.Lavalink/Entities/IQueueEntry.cs">public interface IQueueEntry
	public IQueueEntry AddTrack(LavalinkTrack track)
	Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player);
	Task AfterPlayingAsync(LavalinkGuildPlayer player);</file><file path="DisCatSharp.Lavalink/Entities/LavalinkException.cs">public sealed class LavalinkException</file><file path="DisCatSharp.Lavalink/Entities/LavalinkInfo.cs">public sealed class LavalinkInfo
	public DateTimeOffset BuildTime =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._buildTime);
public sealed class Git
	public DateTimeOffset CommitTime =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._commitTime);
public sealed class Plugin
public sealed class Version</file><file path="DisCatSharp.Lavalink/Entities/LavalinkLyricsResult.cs">public sealed class LavalinkLyricsResult</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlayer.cs">public sealed class LavalinkPlayer</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlayerState.cs">public sealed class LavalinkPlayerState
	public DateTimeOffset Time =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._time);
	public TimeSpan Position =&gt; TimeSpan.FromMilliseconds(this._position);</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlaylist.cs">public sealed class LavalinkPlaylist</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlaylistInfo.cs">public sealed class LavalinkPlaylistInfo</file><file path="DisCatSharp.Lavalink/Entities/LavalinkRestResponse.cs">internal sealed class LavalinkRestResponse</file><file path="DisCatSharp.Lavalink/Entities/LavalinkSessionConfiguration.cs">public sealed class LavalinkSessionConfiguration</file><file path="DisCatSharp.Lavalink/Entities/LavalinkStats.cs">public sealed class LavalinkStats
	public TimeSpan Uptime =&gt; TimeSpan.FromMilliseconds(this._uptime);
public sealed class MemoryStats
public sealed class CpuStats
public sealed class FrameStats</file><file path="DisCatSharp.Lavalink/Entities/LavalinkTrack.cs">public sealed class LavalinkTrack
public sealed class LavalinkPluginInfo
public sealed class LavalinkTrackInfo
	public TimeSpan Length =&gt; !this.IsStream ? TimeSpan.FromMilliseconds(this.LengthInternal) : TimeSpan.Zero;
	public TimeSpan Position =&gt; TimeSpan.FromMilliseconds(this.PositionInternal);</file><file path="DisCatSharp.Lavalink/Entities/LavalinkTrackLoadingResult.cs">public sealed class LavalinkTrackLoadingResult
	public T GetResultAs&lt;T&gt;()</file><file path="DisCatSharp.Lavalink/Entities/LavalinkVoiceState.cs">public sealed class LavalinkVoiceState</file><file path="DisCatSharp.Lavalink/Entities/LyricsLine.cs">public sealed class LyricsLine</file><file path="DisCatSharp.Lavalink/Entities/Websocket/EventOP.cs">internal class EventOp : LavalinkOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/LavalinkOp.cs">internal class LavalinkOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/PlayerUpdateOp.cs">internal sealed class PlayerUpdateOp : LavalinkOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/ReadyOp.cs">internal sealed class ReadyOp : LavalinkOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/StatsOp.cs">internal sealed class StatsOp : LavalinkOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackEndEvent.cs">internal sealed class TrackEndEvent : EventOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackException.cs">internal sealed class TrackException</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackExceptionEvent.cs">internal sealed class TrackExceptionEvent : EventOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackStartEvent.cs">internal sealed class TrackStartEvent : EventOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackStuckEvent.cs">internal sealed class TrackStuckEvent : EventOp</file><file path="DisCatSharp.Lavalink/Entities/Websocket/WebSocketClosedEvent.cs">internal sealed class WebSocketClosedEvent : EventOp</file><file path="DisCatSharp.Lavalink/Enums/Filters/LavalinkFilterBand.cs"></file><file path="DisCatSharp.Lavalink/Enums/LavalinkEvents.cs">public static class LavalinkEvents</file><file path="DisCatSharp.Lavalink/Enums/LavalinkLoadResultType.cs"></file><file path="DisCatSharp.Lavalink/Enums/LavalinkRestEndpoints.cs">internal static class Endpoints</file><file path="DisCatSharp.Lavalink/Enums/LavalinkSearchType.cs"></file><file path="DisCatSharp.Lavalink/Enums/LavalinkTrackEndReason.cs"></file><file path="DisCatSharp.Lavalink/Enums/RepeatMode.cs"></file><file path="DisCatSharp.Lavalink/Enums/Severity.cs"></file><file path="DisCatSharp.Lavalink/Enums/Websocket/EventOpType.cs"></file><file path="DisCatSharp.Lavalink/Enums/Websocket/OpType.cs"></file><file path="DisCatSharp.Lavalink/EventArgs/GuildPlayerDestroyedEventArgs.cs">public sealed class GuildPlayerDestroyedEventArgs : DiscordEventArgs
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.Player.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkPlayerStateUpdateEventArgs.cs">public sealed class LavalinkPlayerStateUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkSessionConnectedEventArgs.cs">public sealed class LavalinkSessionConnectedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkSessionDisconnectedEventArgs.cs">public sealed class LavalinkSessionDisconnectedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkStatsReceivedEventArgs.cs">public sealed class LavalinkStatsReceivedEventArgs : DiscordEventArgs</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackEndedEventArgs.cs">public sealed class LavalinkTrackEndedEventArgs : DiscordEventArgs
		this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackExceptionEventArgs.cs">public sealed class LavalinkTrackExceptionEventArgs : DiscordEventArgs
		this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackStartedEventArgs.cs">public sealed class LavalinkTrackStartedEventArgs : DiscordEventArgs
		this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackStuckEventArgs.cs">public sealed class LavalinkTrackStuckEventArgs : DiscordEventArgs
		this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
	public TimeSpan ThresholdMs =&gt; TimeSpan.FromMilliseconds(this.ThresholdMilliseconds);
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkWebsocketClosedEventArgs.cs">public sealed class LavalinkWebsocketClosedEventArgs : SocketCloseEventArgs
		this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
		=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/Exceptions/LavalinkRestException.cs">public sealed class LavalinkRestException : Exception
	public DateTimeOffset Timestamp =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._timestamp);</file><file path="DisCatSharp.Lavalink/ExtensionMethods.cs">public static class ExtensionMethods
	public static LavalinkExtension UseLavalink(this DiscordClient client)
			throw new InvalidOperationException(&quot;Lavalink is already enabled for that client.&quot;);
		if (!client.Configuration.Intents.HasIntent(DiscordIntents.GuildVoiceStates))
			client.Logger.LogCritical(LavalinkEvents.Intents, &quot;The Lavalink extension is registered but the guild voice states intent is not enabled. It is highly recommended to enable it.&quot;);
		var lava = new LavalinkExtension();
		client.AddExtension(lava);
	public static async Task&lt;IReadOnlyDictionary&lt;int, LavalinkExtension&gt;&gt; UseLavalinkAsync(this DiscordShardedClient client)
		await client.InitializeShardsAsync().ConfigureAwait(false);
		foreach (var shard in client.ShardClients.Select(shardClient =&gt; shardClient.Value))
			lava ??= shard.UseLavalink();
	public static LavalinkExtension GetLavalink(this DiscordClient client)
	public static async Task&lt;IReadOnlyDictionary&lt;int, LavalinkExtension&gt;&gt; GetLavalinkAsync(this DiscordShardedClient client)
			extensions.Add(shard.ShardId, shard.GetExtension&lt;LavalinkExtension&gt;());
	public static Task ConnectAsync(this DiscordChannel channel, LavalinkSession session)
			throw new NullReferenceException();
			throw new InvalidOperationException(&quot;Lavalink can only be used with guild channels.&quot;);
			throw new InvalidOperationException(&quot;You can only connect to voice and stage channels.&quot;);
		var lava = discord.GetLavalink();
			? throw new InvalidOperationException(&quot;Lavalink is not initialized for this Discord client.&quot;)
			: session.ConnectAsync(channel);</file><file path="DisCatSharp.Lavalink/GlobalSuppressions.cs"></file><file path="DisCatSharp.Lavalink/LavalinkConfiguration.cs">public sealed class LavalinkConfiguration
	public TimeSpan HttpTimeout { internal get; set; } = TimeSpan.FromMinutes(2);
		=&gt; (this.QueueEntryFactory ?? (() =&gt; new DefaultQueueEntry()))();</file><file path="DisCatSharp.Lavalink/LavalinkExtension.cs">public sealed class LavalinkExtension : BaseExtension
		add =&gt; this._sessionDisconnected.Register(value);
		remove =&gt; this._sessionDisconnected.Unregister(value);
		add =&gt; this._sessionConnected.Register(value);
		remove =&gt; this._sessionConnected.Unregister(value);
	protected internal override void Setup(DiscordClient client)
			throw new InvalidOperationException(&quot;What did I tell you?&quot;);
	public async Task&lt;LavalinkSession&gt; ConnectAsync(LavalinkConfiguration config)
		if (this._connectedSessions.TryGetValue(config.SocketEndpoint, out var session))
			var versionInfo = await this.REST.GetVersionAsync().ConfigureAwait(false);
			if (!versionInfo.Headers.Contains(&quot;Lavalink-Api-Version&quot;))
			if (versionInfo.Headers.TryGetValues(&quot;Lavalink-Api-Version&quot;, out var headerValues))
				if (headerValues.First() != &quot;4&quot;)
		var con = new LavalinkSession(this.Client, this, config);
			await con.EstablishConnectionAsync().ConfigureAwait(false);
			this.LavalinkSessionDisconnect(con);
	public LavalinkSession? GetSession(ConnectionEndpoint endpoint)
		=&gt; this._connectedSessions.GetValueOrDefault(endpoint);
	public LavalinkSession? GetIdealSession(DiscordVoiceRegion? region = null)
			return this._connectedSessions.Values.FirstOrDefault()!;
		var nodes = this._connectedSessions.Values.ToArray();
			return this.FilterByLoad(nodes);
		if (nodes.Any(regionPredicate))
			nodes = [.. nodes.Where(regionPredicate)];
		return nodes.Length &lt;= 1 ? nodes.FirstOrDefault()! : this.FilterByLoad(nodes);
	public LavalinkGuildPlayer? GetGuildPlayer(DiscordGuild guild)
		var node = nodes.FirstOrDefault(x =&gt; x.ConnectedPlayersInternal.ContainsKey(guild.Id));
	private LavalinkSession FilterByLoad(LavalinkSession[] sessions)
		Array.Sort(sessions, (a, b) =&gt;
			aPenaltyCount += (int)Math.Pow(1.05d, (100 * (a.Statistics.Cpu.SystemLoad / a.Statistics.Cpu.Cores) * 10) - 10);
			bPenaltyCount += (int)Math.Pow(1.05d, (100 * (b.Statistics.Cpu.SystemLoad / a.Statistics.Cpu.Cores) * 10) - 10);
				aPenaltyCount += (int)((Math.Pow(1.03d, 500f * (a.Statistics.Frames.Deficit / 3000f)) * 600) - 600);
				aPenaltyCount += (int)((Math.Pow(1.03d, 500f * (a.Statistics.Frames.Deficit / 3000f)) * 300) - 300);
				bPenaltyCount += (int)((Math.Pow(1.03d, 500f * (b.Statistics.Frames.Deficit / 3000f)) * 600) - 600);
				bPenaltyCount += (int)((Math.Pow(1.03d, 500f * (b.Statistics.Frames.Deficit / 3000f)) * 300) - 300);
	private async void LavalinkSessionConnect(LavalinkSession session)
		if (this._connectedSessions.TryAdd(session.NodeEndpoint, session))
			await session.EstablishConnectionAsync().ConfigureAwait(false);
	private void LavalinkSessionDisconnect(LavalinkSession session)
		=&gt; this._connectedSessions.TryRemove(session.NodeEndpoint, out _);
	private Task LavalinkSessionDisconnected(LavalinkSession session, LavalinkSessionDisconnectedEventArgs args)
		=&gt; this._sessionDisconnected.InvokeAsync(this, args);
	private Task LavalinkSessionConnected(LavalinkSession session, LavalinkSessionConnectedEventArgs args)
		=&gt; this._sessionConnected.InvokeAsync(this, args);</file><file path="DisCatSharp.Lavalink/LavalinkGuildPlayer.cs">public sealed class LavalinkGuildPlayer
	private RepeatMode _repeatMode = RepeatMode.None;
		this.Discord.VoiceStateUpdated += async (sender, args) =&gt; await this._voiceStateUpdated.InvokeAsync(sender, args).ConfigureAwait(false);
		this.CurrentUsersInternal.Add(this.Discord.CurrentUser.Id, this.Discord.CurrentUser);
			QueueInternal.TryAdd(guildId, new());
	public IReadOnlyList&lt;LavalinkTrack&gt; Queue =&gt; [.. QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;())];
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild)
	public bool IsConnected =&gt; !Volatile.Read(ref this._isDisposed) &amp;&amp; this.Channel != null!;
		add =&gt; this._voiceStateUpdated.Register(value);
		remove =&gt; this._voiceStateUpdated.Unregister(value);
		add =&gt; this.TrackStartedEvent.Register(value);
		remove =&gt; this.TrackStartedEvent.Unregister(value);
		add =&gt; this.TrackEndedEvent.Register(value);
		remove =&gt; this.TrackEndedEvent.Unregister(value);
		add =&gt; this.TrackExceptionEvent.Register(value);
		remove =&gt; this.TrackExceptionEvent.Unregister(value);
		add =&gt; this.TrackStuckEvent.Register(value);
		remove =&gt; this.TrackStuckEvent.Unregister(value);
		add =&gt; this.StateUpdatedEvent.Register(value);
		remove =&gt; this.StateUpdatedEvent.Unregister(value);
	private Task OnTrackEnded(LavalinkGuildPlayer sender, LavalinkTrackEndedEventArgs args)
			this.PlayNextInQueue();
	public async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; tracks)
		=&gt; await this.Session.DecodeTracksAsync(tracks).ConfigureAwait(false);
	public async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string track)
		=&gt; await this.Session.DecodeTrackAsync(track).ConfigureAwait(false);
	public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
		=&gt; await this.Session.LoadTracksAsync(identifier).ConfigureAwait(false);
	public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(LavalinkSearchType searchType, string identifier)
		=&gt; await this.Session.LoadTracksAsync(searchType, identifier).ConfigureAwait(false);
	public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(bool skipTrackSource = false)
		=&gt; await this.Session.Rest.GetLyricsForCurrentTrackAsync(this.Session.Config.SessionId!, this.GuildId, skipTrackSource).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; UpdateAsync(Action&lt;LavalinkPlayerUpdateModel&gt; action)
		var mdl = new LavalinkPlayerUpdateModel();
		if (mdl.EncodedTrack.HasValue &amp;&amp; !string.IsNullOrEmpty(mdl.EncodedTrack.Value) &amp;&amp; mdl.Identifier.HasValue)
			throw new InvalidOperationException($&quot;Cannot set both {nameof(mdl.EncodedTrack)} &amp; {mdl.Identifier}. Only one at a time.&quot;);
		this.Player = await this.Session.Rest.UpdatePlayerAsync(
		).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialAsync(string identifier, TimeSpan startTime, TimeSpan endTime)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: identifier, position: (int)startTime.TotalMilliseconds,
			endTime: (int)endTime.TotalMilliseconds).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialAsync(LavalinkTrack track, TimeSpan startTime, TimeSpan endTime)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: track.Info.Uri.ToString(),
			position: (int)startTime.TotalMilliseconds, endTime: (int)endTime.TotalMilliseconds).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialEncodedAsync(string encodedTrack, TimeSpan startTime, TimeSpan endTime)
			.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, encodedTrack, position: (int)startTime.TotalMilliseconds, endTime: (int)endTime.TotalMilliseconds)
			.ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayAsync(string identifier)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: identifier).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayAsync(LavalinkTrack track)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: track.Info.Uri.ToString()).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PlayEncodedAsync(string encodedTrack)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, encodedTrack).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; SeekAsync(int seconds)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, position: seconds * 1000).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; SeekAsync(TimeSpan position)
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, position: (int)position.TotalMilliseconds).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; SetVolumeAsync(int volume)
			throw new ArgumentException(&quot;Volume can only be between 0 and 1000&quot;, nameof(volume));
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, volume: volume).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; PauseAsync()
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, paused: true).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; ResumeAsync()
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, paused: false).ConfigureAwait(false);
	public async Task&lt;LavalinkGuildPlayer&gt; StopAsync()
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, null).ConfigureAwait(false);
	public Task&lt;LavalinkGuildPlayer&gt; SkipAsync()
		=&gt; this.StopAsync();
	public async Task&lt;LavalinkGuildPlayer&gt; PlayDirectUrlAsync(string url)
		if (CommonRegEx.AdvancedYoutubeRegex().IsMatch(url))
			if (url.Contains(&quot;playlist&quot;))
				throw new NotSupportedException(&quot;Lavalink is unable to play a playlist directly.&quot;);
			var match = CommonRegEx.AdvancedYoutubeRegex().Match(url);
			if (match.Groups[&quot;list&quot;] != null! &amp;&amp; !string.IsNullOrEmpty(match.Groups[&quot;list&quot;].Value))
				this.Session.Discord.Logger.LogTrace(LavalinkEvents.Misc, null, &quot;Removed list from playlist url. Not supported&quot;);
				url = url.Replace($&quot;list={match.Groups[&quot;list&quot;].Value}&quot;, null);
			if (match.Groups[&quot;index&quot;] != null! &amp;&amp; !string.IsNullOrEmpty(match.Groups[&quot;index&quot;].Value))
				this.Session.Discord.Logger.LogTrace(LavalinkEvents.Misc, null, &quot;Removed index from playlist url. Not supported&quot;);
				url = url.Replace($&quot;index={match.Groups[&quot;index&quot;].Value}&quot;, null);
		this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: url).ConfigureAwait(false);
	public async Task SwitchChannelAsync(DiscordChannel channel, bool deafened = true)
			throw new ArgumentException(&quot;Cannot switch to a non-voice channel&quot;, nameof(channel));
		var vsd = new DiscordDispatchPayload
			Payload = new VoiceStateUpdatePayload
		await this.Session.Discord.WsSendAsync(LavalinkJson.SerializeObject(vsd)).ConfigureAwait(false);
	internal void UpdatePlayerState(LavalinkPlayerState state)
	internal void UpdateVoiceState(LavalinkVoiceState voiceState)
	public async Task DisconnectAsync()
		await this.Session.Rest.DestroyPlayerAsync(this.Session.Config.SessionId!, this.GuildId).ConfigureAwait(false);
		await this.DisconnectVoiceAsync().ConfigureAwait(false);
		this.CurrentUsersInternal.Clear();
		Volatile.Write(ref this._isDisposed, true);
		await this.Session.GuildPlayerDestroyedEvent.InvokeAsync(this.Session, new(this)).ConfigureAwait(false);
	internal async Task DisconnectVoiceAsync()
	private Task OnVoiceStateUpdated(DiscordClient sender, VoiceStateUpdateEventArgs args)
			this.CurrentUsersInternal.TryAdd(args.User.Id, args.User);
		this.CurrentUsersInternal.Remove(args.User.Id);
	public void AddToQueue(LavalinkTrack track)
		QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;()).Enqueue(track);
	public void AddToQueue(LavalinkPlaylist playlist)
			this.AddToQueue(track);
	public void AddToQueueAt(int index, LavalinkTrack track)
		if (QueueInternal.TryGetValue(this.GuildId, out var queue))
			queue.InsertAt(index, track);
	public void AddToQueueAt(int index, IEnumerable&lt;LavalinkTrack&gt; tracks)
			queue.InsertRange(index, tracks);
	public bool TryPeekQueue([NotNullWhen(true)] out LavalinkTrack? track)
		if (QueueInternal.TryGetValue(this.GuildId, out var queue) &amp;&amp; queue.TryPeek(out var result))
	public void ShuffleQueue()
			queue.Shuffle();
	public void ReverseQueue()
			queue.Reverse();
	public void RemoveFromQueue(LavalinkTrack track)
			queue.Remove(track);
	public void RemoveFromQueue(string identifier)
		if (!this.QUEUE_SYSTEM_ENABLED || !QueueInternal.TryGetValue(this.GuildId, out var queue))
		var trackToRemove = queue.FirstOrDefault(x =&gt; x.Info.Title == identifier);
			queue.Remove(trackToRemove);
	public void RemoveFromQueueAt(int index)
			queue.RemoveAt(index);
	public void RemoveFromQueueAtRange(int index, int count)
			queue.RemoveRange(index, count);
	public void ClearQueue()
			queue.Clear();
	public void SetRepeatMode(RepeatMode mode)
	public void PlayQueue()
	private async void PlayNextInQueue()
			await Task.Delay(TimeSpan.FromSeconds(1));
		var queue = QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;());
		else if (queue.TryDequeue(out nextTrack))
				queue.Enqueue(track);
			this._playedTracks.Clear();
			if (queue.TryDequeue(out nextTrack))
			var queueEntry = this.Session.Config.QueueEntry.AddTrack(nextTrack);
			if (await queueEntry.BeforePlayingAsync(this).ConfigureAwait(false))
				await this.PlayAsync(queueEntry.Track).ConfigureAwait(false);
				await this._queueTsc.Task.ConfigureAwait(false);
				await queueEntry.AfterPlayingAsync(this).ConfigureAwait(false);
				this._playedTracks.Add(nextTrack);</file><file path="DisCatSharp.Lavalink/LavalinkJson.cs">internal static class LavalinkJson
	private static readonly JsonSerializerSettings s_setting = new()
		ContractResolver = new OptionalJsonContractResolver()
	public static T? DeserializeObject&lt;T&gt;(string value)
	public static string SerializeObject(object? value, Formatting formatting = Formatting.None)
		=&gt; JsonConvert.SerializeObject(value, formatting, s_setting);</file><file path="DisCatSharp.Lavalink/LavalinkQueue.cs">public class LavalinkQueue&lt;T&gt; : IEnumerable&lt;T&gt;
	public IEnumerator&lt;T&gt; GetEnumerator()
	IEnumerator IEnumerable.GetEnumerator()
		=&gt; this.GetEnumerator();
	public void Enqueue(T value)
		ArgumentNullException.ThrowIfNull(value);
			this._list.AddLast(value);
	public bool TryDequeue(out T value)
			this._list.RemoveFirst();
	public bool TryPeek([NotNullWhen(true)] out T? value)
	public void Remove(T value)
			this._list.Remove(value);
	public void Clear()
			this._list.Clear();
	public void Shuffle()
				var j = Random.Shared.Next(i + 1);
	public T RemoveAt(int index)
				this._list.Remove(currentNode);
	public void Reverse()
				reversedList.AddLast(node.Value);
	public ICollection&lt;T&gt; RemoveRange(int index, int count)
		ArgumentOutOfRangeException.ThrowIfNegative(index);
		ArgumentOutOfRangeException.ThrowIfNegative(count);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(count, this.Count - index);
	public void InsertAt(int index, T value)
		ArgumentOutOfRangeException.ThrowIfGreaterThan(index, this.Count);
				throw new ArgumentOutOfRangeException(nameof(index), &quot;Index was out of range.&quot;);
			this._list.AddBefore(currentNode, value);
	public void InsertRange(int index, IEnumerable&lt;T&gt; values)
		ArgumentNullException.ThrowIfNull(values);</file><file path="DisCatSharp.Lavalink/LavalinkRestClient.cs">internal sealed class LavalinkRestClient
		var httpHandler = new HttpClientHandler
			BaseAddress = new($&quot;{configuration.RestEndpoint.ToHttpString()}&quot;),
		this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;User-Agent&quot;, $&quot;DisCatSharp.Lavalink/{this.Discord.VersionString}&quot;);
		this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;Authorization&quot;, configuration.Password);
			this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;User-Id&quot;, this.Discord.CurrentUser.Id.ToString(CultureInfo.InvariantCulture));
	private static string BuildQueryString(IDictionary&lt;string, string&gt; values, bool post = false)
		var valuesCollection = values.Select(xkvp =&gt;
			$&quot;{WebUtility.UrlEncode(xkvp.Key)}={WebUtility.UrlEncode(xkvp.Value)}&quot;);
		var valuesString = string.Join(&quot;&amp;&quot;, valuesCollection);
	private static string GetPath(string route, object routeParams)
		var routeParamsProperties = routeParams.GetType()
			.GetTypeInfo()
			var val = xp.GetValue(routeParams);
					? dt.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture)
						? dto.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture)
							? xf.ToString(null, CultureInfo.InvariantCulture)
							: val.ToString();
		return CommonRegEx.HttpRouteRegex().Replace(route, xm =&gt; extractedRouteParams[xm.Groups[1].Value]);
	private Dictionary&lt;string, string&gt; GetDefaultParams()
			[&quot;trace&quot;] = this.TRACE_ENABLED.ToString().ToLower()
	private async Task&lt;LavalinkRestResponse&gt; DoRequestAsync(HttpMethod method, string path, IReadOnlyDictionary&lt;string, string&gt;? headers = null, string? payload = null)
		HttpRequestMessage request = new();
				request.Headers.TryAddWithoutValidation(header.Key, header.Value);
			request.Content = new StringContent(payload);
		var response = await this.HttpClient.SendAsync(request, HttpCompletionOption.ResponseContentRead).ConfigureAwait(false);
			var data = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
			var ex = LavalinkJson.DeserializeObject&lt;LavalinkRestException?&gt;(data) ?? new LavalinkRestException();
			this.Discord.Logger.LogError(LavalinkEvents.LavalinkRestError, ex, &quot;Lavalink rest encountered an exception: {data}&quot;, data);
		var res = new LavalinkRestResponse
			Response = response.StatusCode != HttpStatusCode.NoContent ? await response.Content.ReadAsStringAsync().ConfigureAwait(false) : null,
	internal async Task&lt;LavalinkRestResponse&gt; GetVersionAsync()
		var queryDict = this.GetDefaultParams();
		return await this.DoRequestAsync(HttpMethod.Get, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
	internal async Task&lt;LavalinkInfo&gt; GetInfoAsync()
		var res = await this.DoRequestAsync(HttpMethod.Get, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
	internal async Task&lt;LavalinkStats&gt; GetStatsAsync()
	internal async Task&lt;LavalinkSessionConfiguration&gt; UpdateSessionAsync(string sessionId, LavalinkSessionConfiguration config)
		var res = await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(config)).ConfigureAwait(false);
	internal async Task&lt;IReadOnlyList&lt;LavalinkPlayer&gt;&gt; GetPlayersAsync(string sessionId)
	internal async Task CreatePlayerAsync(string sessionId, ulong guildId, int defaultVolume)
		queryDict.Add(&quot;noReplace&quot;, &quot;false&quot;);
		var pld = new LavalinkRestPlayerCreatePayload(guildId.ToString(), defaultVolume);
		await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;LavalinkPlayer&gt; GetPlayerAsync(string sessionId, ulong guildId)
	internal async Task&lt;LavalinkPlayer&gt; UpdatePlayerAsync(
		queryDict.Add(&quot;noReplace&quot;, noReplace.ToString().ToLower());
		var pld = new LavalinkRestPlayerUpdatePayload(guildId.ToString())
				? new PlayerWithEncoded
					? new PlayerWithIdentifier
		var res = await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task UpdatePlayerVoiceStateAsync(string sessionId, ulong guildId, LavalinkVoiceState state)
		queryDict.Add(&quot;noReplace&quot;, &quot;true&quot;);
		var pld = new LavalinkRestVoiceStateUpdatePayload(state, guildId.ToString());
	internal async Task DestroyPlayerAsync(string sessionId, ulong guildId)
		await this.DoRequestAsync(HttpMethod.Delete, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
	internal async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
		queryDict.Add(&quot;identifier&quot;, identifier);
		var obj = JObject.Parse(res.Response!);
			LoadType = obj.GetValue(&quot;loadType&quot;)!.ToObject&lt;LavalinkLoadResultType&gt;(),
			RawResult = LavalinkJson.SerializeObject(obj.GetValue(&quot;data&quot;))
	internal async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(string encodedTrack, bool skipTrackSource, string? sessionId = null, ulong? guildId = null)
		queryDict.Add(&quot;track&quot;, encodedTrack);
		queryDict.Add(&quot;skipTrackSource&quot;, skipTrackSource.ToString().ToLowerInvariant());
	internal async Task&lt;LavalinkLyricsResult?&gt; GetLyricsForCurrentTrackAsync(string sessionId, ulong guildId, bool skipTrackSource)
	internal async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string base64Track)
		queryDict.Add(&quot;encodedTrack&quot;, base64Track);
	internal async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; base64Tracks)
		var res = await this.DoRequestAsync(HttpMethod.Post, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(base64Tracks)).ConfigureAwait(false);</file><file path="DisCatSharp.Lavalink/LavalinkSession.cs">public sealed class LavalinkSession
	private IWebSocketClient _webSocket;
		if (config.Region != null! &amp;&amp; this.Discord.VoiceRegions.Values.Contains(config.Region))
		Volatile.Write(ref this._isDisposed, false);
	public bool IsConnected =&gt; !Volatile.Read(ref this._isDisposed);
		add =&gt; this._lavalinkSocketError.Register(value);
		remove =&gt; this._lavalinkSocketError.Unregister(value);
		add =&gt; this._lavalinkSessionDisconnected.Register(value);
		remove =&gt; this._lavalinkSessionDisconnected.Unregister(value);
		add =&gt; this._lavalinkSessionConnected.Register(value);
		remove =&gt; this._lavalinkSessionConnected.Unregister(value);
		add =&gt; this._statsReceived.Register(value);
		remove =&gt; this._statsReceived.Unregister(value);
		add =&gt; this.GuildPlayerDestroyedEvent.Register(value);
		remove =&gt; this.GuildPlayerDestroyedEvent.Unregister(value);
		add =&gt; this._websocketClosed.Register(value);
		remove =&gt; this._websocketClosed.Unregister(value);
	internal event SessionDisconnectedEventHandler SessionDisconnected;
	internal event SessionConnectedEventHandler SessionConnected;
	public async Task&lt;LavalinkInfo&gt; GetLavalinkInfoAsync()
		=&gt; await this.Rest.GetInfoAsync().ConfigureAwait(false);
	public async Task&lt;string&gt; GetLavalinkVersionAsync()
		var versionInfo = await this.Rest.GetVersionAsync().ConfigureAwait(false);
		return versionInfo.Headers.TryGetValues(&quot;Lavalink-Api-Version&quot;, out var headerValues)
			? headerValues.First()
	public async Task&lt;LavalinkStats&gt; GetLavalinkStatsAsync()
		var stats = await this.Rest.GetStatsAsync().ConfigureAwait(false);
	public async Task DestroyAsync()
		await this.DestroyGuildPlayersAsync().ConfigureAwait(false);
		Volatile.Write(ref this._isDisposed, true);
		await this._webSocket.DisconnectAsync(1000, &quot;Shutting down Lavalink Session&quot;).ConfigureAwait(false);
	public async Task DestroyGuildPlayersAsync()
				await player.DisconnectAsync().ConfigureAwait(false);
		this.ConnectedPlayersInternal.Clear();
	private Task LavalinkGuildPlayerDestroyed(LavalinkSession sender, GuildPlayerDestroyedEventArgs args)
		this.ConnectedPlayersInternal.Remove(args.Player.GuildId, out _);
	public async Task&lt;LavalinkGuildPlayer&gt; ConnectAsync(DiscordChannel channel, bool deafened = true)
		if (this.ConnectedPlayersInternal.TryGetValue(channel.Guild.Id, out var connectedGuild))
			throw new ArgumentException(&quot;Invalid channel specified.&quot;, nameof(channel));
		var vsd = new DiscordDispatchPayload
			Payload = new VoiceStateUpdatePayload
		await this.Rest.CreatePlayerAsync(this.Config.SessionId!, channel.Guild.Id, this.Config.DefaultVolume).ConfigureAwait(false);
		await this.Discord.WsSendAsync(LavalinkJson.SerializeObject(vsd)).ConfigureAwait(false); // Send voice dispatch to trigger voice state &amp; voice server update
		var vst = await vstut.Task.ConfigureAwait(false); // Wait for voice state update to get session_id
		var vsr = await vsrut.Task.ConfigureAwait(false); // Wait for voice server update to get token, guild_id &amp; endpoint
		await this.Rest.UpdatePlayerVoiceStateAsync(this.Config.SessionId!, channel.Guild.Id, new()
			.ConfigureAwait(false);
		var player = await this.Rest.GetPlayerAsync(this.Config.SessionId!, channel.Guild.Id).ConfigureAwait(false);
		var con = new LavalinkGuildPlayer(this, channel.Guild.Id, player)
	public async Task&lt;LavalinkSession&gt; ConfigureAsync(LavalinkSessionConfiguration config)
		var newConfig = await this.Rest.UpdateSessionAsync(this.Config.SessionId!, config).ConfigureAwait(false);
	public LavalinkGuildPlayer? GetGuildPlayer(DiscordGuild guild)
		=&gt; this.ConnectedPlayersInternal.TryGetValue(guild.Id, out var lgp) &amp;&amp; lgp.IsConnected
	public IReadOnlyList&lt;LavalinkGuildPlayer&gt;? GetGuildPlayersAsync()
			? this.ConnectedPlayersInternal.Values.ToList()
	public async Task&lt;LavalinkPlayer&gt; GetPlayerAsync(DiscordGuild guild)
		=&gt; await this.Rest.GetPlayerAsync(this.Config.SessionId!, guild.Id).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;LavalinkPlayer&gt;&gt; GetPlayersAsync()
		=&gt; await this.Rest.GetPlayersAsync(this.Config.SessionId!).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; tracks)
		=&gt; await this.Rest.DecodeTracksAsync(tracks).ConfigureAwait(false);
	public async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string track)
		=&gt; await this.Rest.DecodeTrackAsync(track).ConfigureAwait(false);
	public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
		=&gt; await this.Rest.LoadTracksAsync(identifier).ConfigureAwait(false);
	public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(LavalinkTrack track, bool skipTrackSource = false)
		=&gt; await this.Rest.GetLyricsAsync(track.Encoded, skipTrackSource).ConfigureAwait(false);
	public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsForCurrentTrackAsync(string sessionId, ulong guildId, bool skipTrackSource)
		=&gt; await this.Rest.GetLyricsForCurrentTrackAsync(sessionId, guildId, skipTrackSource).ConfigureAwait(false);
	public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(LavalinkSearchType searchType, string identifier)
			_ =&gt; throw new ArgumentOutOfRangeException(nameof(searchType), searchType, &quot;Invalid search type.&quot;)
		return await this.LoadTracksAsync($&quot;{type}{identifier}&quot;).ConfigureAwait(false);
	internal async Task EstablishConnectionAsync()
			throw new InvalidOperationException(&quot;This operation requires the Discord client to be fully initialized.&quot;);
		this._webSocket = this.Discord.Configuration.WebSocketClientFactory(this.Discord.Configuration.Proxy, this.Discord.ServiceProvider);
		this._webSocket.AddDefaultHeader(CommonHeaders.AUTHORIZATION, this.Config.Password);
		this._webSocket.AddDefaultHeader(&quot;Num-Shards&quot;, this.Discord.ShardCount.ToString(CultureInfo.InvariantCulture));
		this._webSocket.AddDefaultHeader(&quot;User-Id&quot;, this.Discord.CurrentUser.Id.ToString(CultureInfo.InvariantCulture));
		this._webSocket.AddDefaultHeader(&quot;Client-Name&quot;, $&quot;DisCatSharp.Lavalink/{this.Discord.VersionString}&quot;);
			if (this.Config.SessionId != null &amp;&amp; !this._webSocket.DefaultHeaders.ContainsKey(&quot;Session-Id&quot;))
				this._webSocket.AddDefaultHeader(&quot;Session-Id&quot;, this.Config.SessionId);
				this._webSocket.RemoveDefaultHeader(&quot;Session-Id&quot;);
					await Task.Delay(this._backoff).ConfigureAwait(false);
					this._backoff = Math.Min(this._backoff * 2, MAXIMUM_BACKOFF);
				await this._webSocket.ConnectAsync(new($&quot;{this.Config.SocketEndpoint.ToWebSocketString()}{Endpoints.V4}{Endpoints.WEBSOCKET}&quot;)).ConfigureAwait(false);
				var sessionId = await this._sessionIdReceived.Task.ConfigureAwait(false);
					this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, ex, &quot;Failed to connect to Lavalink .-.&quot;);
				this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, ex, &quot;Failed to connect to Lavalink, retrying in {count} ms.&quot;, this._backoff);
	private Task Lavalink_WebSocket_MessageReceived(IWebSocketClient client, SocketMessageEventArgs args)
			this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, &quot;Lavalink sent binary data O.o - unable to process&quot;);
		_ = Task.Run(async () =&gt;
				var jsonData = JObject.Parse(json);
						this.Discord.Logger.LogTrace(LavalinkEvents.LavalinkWsRx, null,
							this._sessionIdReceived.SetResult(ready.SessionId);
							this.Discord.Logger.LogInformation(LavalinkEvents.LavalinkSessionConnected, null,
						if (this.ConnectedPlayersInternal.TryGetValue(playerUpdate.GuildId, out var value))
							await value.StateUpdatedEvent.InvokeAsync(value, new(this.Discord, playerUpdate.State)).ConfigureAwait(false);
						await this._statsReceived.InvokeAsync(this, new(this.Discord, this.Statistics)).ConfigureAwait(false);
						if (!string.IsNullOrEmpty(eventOp.GuildId) &amp;&amp;
						    this.ConnectedPlayersInternal.TryGetValue(Convert.ToUInt64(eventOp.GuildId),
									await player.TrackStartedEvent.InvokeAsync(player, new(this.Discord, startEvent)).ConfigureAwait(false);
									await player.TrackEndedEvent.InvokeAsync(player, new(this.Discord, endEvent)).ConfigureAwait(false);
									await player.TrackStuckEvent.InvokeAsync(player, new(this.Discord, stuckEvent)).ConfigureAwait(false);
									await player.TrackExceptionEvent.InvokeAsync(player,
										new(this.Discord, exceptionEvent)).ConfigureAwait(false);
								await this._websocketClosed.InvokeAsync(this, new(this.Discord, websocketClosedEvent)).ConfigureAwait(false);
								var ex = new InvalidDataException(&quot;Lavalink send an unknown up&quot;);
								this.Discord.Logger.LogTrace(LavalinkEvents.LavalinkWsException, ex,
				this.Discord.Logger.LogDebug(&quot;{message}&quot;, ex.Message);
				this.Discord.Logger.LogDebug(&quot;{stacktrace}&quot;, ex.StackTrace);
	private Task Lavalink_WebSocket_ExceptionThrown(IWebSocketClient client, SocketErrorEventArgs args)
		=&gt; this._lavalinkSocketError.InvokeAsync(this, new(client.ServiceProvider)
	private async Task Lavalink_WebSocket_Disconnected(IWebSocketClient client, SocketCloseEventArgs args)
			this.Discord.Logger.LogWarning(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Connection broken :/ ({code}, &apos;{message}&apos;), reconnecting&quot;, args.CloseCode, args.CloseMessage);
			await this._lavalinkSessionDisconnected.InvokeAsync(this, new(this, false)).ConfigureAwait(false);
				_ = Task.Run(this.EstablishConnectionAsync);
			this.Discord.Logger.LogInformation(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Connection closed ({code}, &apos;{message}&apos;)&quot;, args.CloseCode, args.CloseMessage);
			await this._lavalinkSessionDisconnected.InvokeAsync(this, new(this, true)).ConfigureAwait(false);
			this.Discord.Logger.LogWarning(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Lavalink died QwQ&quot;);
				await kvp.Value.DisconnectVoiceAsync().ConfigureAwait(false);
				_ = Task.Run(async () =&gt; await this.GuildPlayerDestroyedEvent.InvokeAsync(this, new(kvp.Value)).ConfigureAwait(false));
				_ = this.ConnectedPlayersInternal.TryRemove(kvp.Key, out _);
				await this.EstablishConnectionAsync().ConfigureAwait(false);
	private async Task Lavalink_WebSocket_Connected(IWebSocketClient client, SocketEventArgs args)
		this.Discord.Logger.LogDebug(LavalinkEvents.LavalinkSessionConnected, &quot;Connection to Lavalink established UwU&quot;);
		await this._lavalinkSessionConnected.InvokeAsync(this, new(this)).ConfigureAwait(false);
	private Task Discord_VoiceStateUpdated(DiscordClient client, VoiceStateUpdateEventArgs args)
		if (args.After.Channel == null! &amp;&amp; this.IsConnected &amp;&amp; this.ConnectedPlayersInternal.TryGetValue(gld.Id, out var dGuildPlayer))
				await Task.Delay(this.Config.WebSocketCloseTimeout).ConfigureAwait(false);
				await this.Rest.DestroyPlayerAsync(this.Config.SessionId!, dGuildPlayer.GuildId).ConfigureAwait(false);
					if (this.ConnectedPlayersInternal.TryRemove(gld.Id, out _))
						await this.GuildPlayerDestroyedEvent.InvokeAsync(this, new(dGuildPlayer)).ConfigureAwait(false);
		else if (!string.IsNullOrWhiteSpace(args.SessionId) &amp;&amp; this.ConnectedPlayersInternal.TryGetValue(gld.Id, out var guildPlayer))
				var state = new LavalinkVoiceState
				guildPlayer.UpdateVoiceState(state);
				await this.Rest.UpdatePlayerVoiceStateAsync(this.Config.SessionId!, guildPlayer.GuildId, state).ConfigureAwait(false);
		if (!string.IsNullOrWhiteSpace(args.SessionId) &amp;&amp; args.Channel != null! &amp;&amp; this._voiceStateUpdates.TryRemove(gld.Id, out var xe))
			xe.SetResult(args);
	private Task Discord_VoiceServerUpdated(DiscordClient client, VoiceServerUpdateEventArgs args)
		if (this.ConnectedPlayersInternal.TryGetValue(args.Guild.Id, out var guildPlayer))
		if (this._voiceServerUpdates.TryRemove(gld.Id, out var xe))</file><file path="DisCatSharp.Lavalink/Models/LavalinkPlayerUpdateModel.cs">public sealed class LavalinkPlayerUpdateModel</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerCreatePayload.cs">internal sealed class LavalinkRestPlayerCreatePayload</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerUpdatePayload.cs">internal sealed class LavalinkRestPlayerUpdatePayload
internal class PlayerBase
internal sealed class PlayerWithIdentifier : PlayerBase
internal sealed class PlayerWithEncoded : PlayerBase</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestVoiceStateUpdatePayload.cs">internal sealed class LavalinkRestVoiceStateUpdatePayload</file><file path="DisCatSharp.Logos/browserconfig.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;browserconfig&gt;&lt;msapplication&gt;&lt;tile&gt;&lt;square70x70logo src=&quot;/ms-icon-70x70.png&quot;/&gt;&lt;square150x150logo src=&quot;/ms-icon-150x150.png&quot;/&gt;&lt;square310x310logo src=&quot;/ms-icon-310x310.png&quot;/&gt;&lt;TileColor&gt;#ffffff&lt;/TileColor&gt;&lt;/tile&gt;&lt;/msapplication&gt;&lt;/browserconfig&gt;</file><file path="DisCatSharp.Logos/logo.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;svg viewBox=&quot;0 0 512 512&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;path opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M248.000000,0.999998 C336.314087,1.000000 424.628174,1.000000 512.971130,1.000000 C512.971130,171.610199 512.971130,342.220428 512.971130,512.915283 C342.427032,512.915283 171.854004,512.915283 1.140484,512.915283 C1.140484,342.333405 1.140484,171.666718 1.140484,1.000000 C58.428204,1.000000 115.749092,1.000000 173.593658,1.375180 C166.967422,4.764884 159.749908,7.630210 152.683960,10.830196 C142.984833,15.222683 133.974747,20.851778 127.332787,29.276129 C121.217926,37.031937 116.073006,45.544956 110.156647,53.467400 C106.127518,58.862720 101.696945,63.995472 97.079407,68.900658 C94.152626,72.009781 90.410057,74.334061 87.288055,77.280235 C82.535744,81.764900 81.622635,87.409836 84.060806,93.235405 C86.441933,98.924660 91.402382,101.437607 97.396065,101.997246 C112.561432,103.413254 123.549248,96.113777 132.028610,84.587418 C136.994980,77.836395 140.609970,70.098427 145.490997,63.275219 C149.673447,57.428547 154.016235,51.222664 159.646484,46.976952 C174.817581,35.536556 192.706894,32.373730 211.318161,33.076878 C221.653458,33.467350 228.558685,43.518589 226.741882,53.742512 C223.961914,69.386330 213.470352,79.639297 202.579559,89.657448 C196.429123,95.315086 191.339127,101.652908 188.034042,109.353592 C183.908798,118.965309 184.024139,128.754654 187.359848,138.649841 C176.060013,136.805725 165.625381,139.385117 155.134048,141.390778 C153.383484,141.725433 151.477356,142.250992 149.815216,141.891846 C127.533882,137.077255 105.502335,131.533905 85.152878,120.708405 C78.824730,117.341972 72.122330,116.707375 65.132195,119.861526 C56.960594,123.548790 56.040653,131.561844 53.052204,138.398270 C52.873985,138.805969 52.973713,139.419937 53.128391,139.875320 C54.673756,144.425018 55.953007,149.158997 60.860611,151.478317 C67.666855,154.694931 74.287643,158.401581 81.310837,161.037964 C91.102737,164.713669 101.193161,167.594116 111.344528,170.875885 C108.934456,173.513397 105.863029,175.841370 104.176743,178.926468 C100.163528,186.268707 96.929237,194.031738 93.143570,201.504868 C90.056671,207.598587 89.491295,213.676651 91.991776,220.317017 C86.251831,229.885773 86.251831,229.885773 93.960678,234.422943 C95.083824,236.989273 95.899811,239.365921 97.254112,241.380722 C102.375465,248.999954 107.671494,256.501770 112.786072,264.375244 C111.736000,266.151550 110.802010,267.600098 109.808479,269.140961 C100.604515,264.064026 91.702415,259.051147 82.693390,254.238373 C79.425453,252.492569 75.640022,251.263229 73.061440,255.140762 C70.050858,259.667908 67.481255,264.504272 64.935455,269.320221 C62.128433,274.630371 62.406216,275.165131 67.846298,277.954407 C77.786652,283.051147 87.720253,288.161041 97.852615,293.366089 C94.762871,298.484863 91.893005,303.286865 88.976418,308.060303 C84.503304,315.381195 80.141846,322.776886 75.435204,329.945282 C73.567719,332.789551 73.460655,334.420410 76.562424,336.341644 C85.272842,341.736908 93.797653,347.430786 102.457489,352.909180 C106.240791,355.302551 109.621635,354.313812 111.862808,350.410126 C113.012489,348.407623 114.093300,346.364532 115.278320,344.383514 C120.667725,335.373932 126.083122,326.379913 131.614532,317.171600 C136.926239,320.474060 141.942917,323.593079 147.286819,326.915527 C146.587128,328.437042 146.040878,329.780243 145.370468,331.058350 C139.579147,342.098236 133.760864,353.123993 127.962685,364.160309 C126.899147,366.184631 126.084244,368.106476 128.981476,369.493652 C139.411667,374.487518 149.725906,379.733490 160.260635,384.493164 C163.514603,385.963348 166.313812,384.823608 168.197800,380.997070 C172.844940,371.558319 177.997543,362.368378 183.105743,353.379211 C185.136444,356.782715 186.918655,359.944458 188.910110,362.968445 C190.366287,365.179657 191.719193,367.745575 193.787170,369.205994 C197.772461,372.020447 202.265228,374.107849 206.467117,376.630707 C207.377716,377.177429 208.592163,378.305359 208.571426,379.138275 C208.443878,384.259369 209.262787,389.905914 207.376129,394.366455 C204.367477,401.479614 205.950912,408.303589 206.391541,415.200256 C206.609421,418.610840 208.255386,422.077789 209.853668,425.214294 C211.740341,428.916656 214.274078,432.289307 216.815277,436.254272 C214.473709,437.108276 213.260910,437.567841 212.036621,437.994385 C204.502960,440.618958 196.642365,442.566040 189.510010,446.018341 C179.703323,450.765137 178.438141,461.411469 186.412628,467.740662 C188.391525,469.311279 191.081497,470.313416 193.597412,470.824036 C205.287064,473.196594 216.565582,471.115570 227.539673,466.977966 C242.032288,461.513794 251.659485,451.921478 254.096115,435.975372 C255.164627,428.982697 256.750305,422.046906 258.521790,415.194000 C259.288330,412.228699 260.452515,410.100800 265.154755,411.272461 C274.122192,413.506927 283.475067,414.194550 292.469940,415.495728 C299.089264,429.862000 306.376678,444.285980 312.377899,459.226562 C315.963257,468.152618 318.246704,477.773834 319.774139,487.297699 C320.916870,494.422638 321.120697,500.410400 329.758636,503.218170 C338.694580,506.122833 346.320496,504.836975 353.464752,499.738617 C355.635193,498.189728 357.506531,494.889740 357.737671,492.236908 C358.198090,486.953339 357.956238,481.466522 357.010864,476.243561 C356.115082,471.294769 354.239197,466.454620 352.287781,461.778046 C345.309631,445.054596 344.717590,427.746155 347.353424,410.287506 C353.076843,420.889191 358.513153,431.312561 363.937561,441.742157 C372.063660,457.366394 387.420013,464.970520 404.583160,461.465759 C407.486359,460.872925 408.832520,461.695953 410.307129,463.778961 C415.139008,470.604523 422.252380,473.191833 429.866028,471.268036 C443.526764,467.816254 456.520325,463.362762 467.459106,452.987976 C474.687592,446.132233 476.382782,439.654449 475.065491,430.833130 C474.712555,428.469513 475.313995,425.670898 476.317413,423.451965 C479.338654,416.771362 481.401794,409.679749 479.520020,402.695496 C474.205627,382.970764 464.050537,365.254852 455.520081,347.038757 C457.905273,346.825714 460.028961,347.042542 461.798859,346.352173 C465.220215,345.017670 470.232269,343.963806 469.585022,339.501007 C469.182953,336.728668 465.685822,333.588562 462.809784,332.161865 C456.838959,329.199982 450.356659,327.269165 444.002258,324.561768 C439.707489,316.343933 435.491577,308.480682 431.283661,300.613220 C427.122528,292.833252 420.577118,288.305786 412.196808,285.814789 C410.017426,285.166962 408.281433,282.797607 406.513184,281.045959 C403.173798,277.737946 400.500824,273.361908 396.584686,271.109772 C387.018616,265.608398 376.937012,267.950867 367.318695,271.549072 C361.296112,273.802094 355.399994,276.589508 349.834015,279.806549 C345.112854,282.535278 339.302704,284.512512 337.629395,290.996948 C334.144012,288.157440 331.452911,283.873230 327.813782,282.798126 C319.960297,280.478058 320.719543,275.026337 321.025116,269.300629 C321.130066,267.333710 321.804718,265.358246 321.668274,263.425598 C321.394501,259.547516 321.741119,255.123123 319.951782,252.001984 C318.305542,249.130569 318.797394,247.318527 319.583282,244.820557 C321.798309,237.779877 324.755371,230.825562 325.819061,223.601501 C327.798950,210.155457 328.700409,196.547348 329.892700,182.992783 C330.043182,181.282181 329.295654,179.474503 328.867676,177.735535 C328.294037,175.404465 327.575836,173.108826 327.008545,170.776337 C325.261505,163.593430 325.988617,155.570526 318.978424,150.283325 C315.745514,147.845001 311.949127,144.967941 310.622925,141.453964 C308.407928,135.585022 304.751587,131.245392 300.634277,126.906914 C299.967987,126.204803 300.170288,123.719635 300.903778,122.814293 C304.028625,118.957207 307.404083,115.286926 310.869446,111.724907 C322.894989,99.363876 333.743134,86.059273 341.455292,70.596329 C343.320984,66.855652 343.517853,61.551403 342.579559,57.395714 C341.933716,54.535286 337.952484,52.467705 335.557556,49.954697 C329.266754,43.353870 315.740875,42.665466 309.473450,49.238098 C306.129181,52.745277 303.743225,57.207275 301.139984,61.372841 C290.837250,77.858597 277.908844,92.133469 264.604523,106.205696 C259.425995,111.683090 252.445801,110.823425 246.747040,113.930061 C244.539108,115.133690 241.944473,115.627899 239.376831,116.313461 C239.227676,116.181625 238.916260,115.933563 238.944702,115.544991 C240.502899,111.751694 241.516159,107.970558 243.667389,105.018753 C248.501282,98.385986 254.472076,92.536781 258.927338,85.684174 C264.822021,76.617584 267.416870,66.410522 268.319794,55.414665 C269.525269,40.734692 267.448761,27.143637 259.330322,14.843633 C256.062744,9.893007 251.806366,5.595012 248.000000,0.999998 z&quot; style=&quot;fill: none; fill-rule: nonzero;&quot;/&gt;
  &lt;path fill=&quot;#525252&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M347.061005,410.112000 C344.717590,427.746155 345.309631,445.054596 352.287781,461.778046 C354.239197,466.454620 356.115082,471.294769 357.010864,476.243561 C357.956238,481.466522 358.198090,486.953339 357.737671,492.236908 C357.506531,494.889740 355.635193,498.189728 353.464752,499.738617 C346.320496,504.836975 338.694580,506.122833 329.758636,503.218170 C321.120697,500.410400 320.916870,494.422638 319.774139,487.297699 C318.246704,477.773834 315.963257,468.152618 312.377899,459.226562 C306.376678,444.285980 299.089264,429.862000 292.469940,415.495728 C283.475067,414.194550 274.122192,413.506927 265.154755,411.272461 C260.452515,410.100800 259.288330,412.228699 258.521790,415.194000 C256.750305,422.046906 255.164627,428.982697 254.096115,435.975372 C251.659485,451.921478 242.032288,461.513794 227.539673,466.977966 C216.565582,471.115570 205.287064,473.196594 193.597412,470.824036 C191.081497,470.313416 188.391525,469.311279 186.412628,467.740662 C178.438141,461.411469 179.703323,450.765137 189.510010,446.018341 C196.642365,442.566040 204.502960,440.618958 212.036621,437.994385 C213.260910,437.567841 214.473709,437.108276 216.815277,436.254272 C214.274078,432.289307 211.740341,428.916656 209.853668,425.214294 C208.255386,422.077789 206.609421,418.610840 206.391541,415.200256 C205.950912,408.303589 204.367477,401.479614 207.376129,394.366455 C209.262787,389.905914 208.443878,384.259369 208.571426,379.138275 C208.592163,378.305359 207.377716,377.177429 206.467117,376.630707 C202.265228,374.107849 197.772461,372.020447 193.787170,369.205994 C191.719193,367.745575 190.366287,365.179657 188.910110,362.968445 C186.918655,359.944458 185.136444,356.782715 183.075012,353.040558 C183.243362,350.593964 183.601257,348.786865 184.243073,347.161469 C184.968582,347.839539 185.424698,348.323700 185.849487,348.834015 C192.456024,356.770416 196.176834,367.304230 206.915451,371.535675 C210.254822,372.851501 213.446136,374.889740 216.245087,377.163666 C223.778320,383.283783 231.037506,389.740082 238.455063,396.004211 C244.402420,401.026855 250.492523,405.742249 259.112457,403.355194 C259.704620,403.191193 260.686768,403.170746 261.019836,403.524261 C266.897614,409.761993 274.558655,407.790131 281.720917,408.156799 C282.997986,408.222198 284.913361,408.205994 285.408905,408.963501 C287.347656,411.927094 289.804016,410.765411 291.350403,409.408813 C292.447937,408.445984 292.872772,405.869476 292.526581,404.240997 C289.588440,390.419861 289.600311,376.455109 290.186310,362.460052 C290.249084,360.960480 291.192108,359.497772 291.726807,358.017944 C292.269226,358.108032 292.811676,358.198120 293.354126,358.288208 C293.457733,360.123901 293.826019,361.989227 293.624298,363.790741 C291.432892,383.361664 293.789001,402.450806 300.965149,420.679596 C307.057404,436.155121 314.254761,451.196198 321.021240,466.403595 C321.307098,467.046051 322.180481,467.427063 322.836975,468.291260 C324.106750,477.485718 325.143463,486.348541 326.626221,495.136108 C327.161011,498.305481 330.445526,498.672729 331.891998,496.620331 C333.804169,493.907104 334.455750,490.270142 335.453278,486.971008 C335.721252,486.084717 335.278351,484.983429 335.161774,483.980835 C335.561584,483.810822 335.961395,483.640808 336.361206,483.470795 C337.161591,484.688995 338.803192,486.058716 338.615784,487.098999 C337.830811,491.456573 336.497681,495.715454 335.208008,500.607330 C336.565552,500.386200 338.741425,500.481262 340.494049,499.666168 C347.042603,496.620575 343.940369,489.876831 345.343201,484.534607 C348.381653,487.638458 348.381653,487.638458 347.317200,498.209991 C352.160919,495.137939 352.834473,490.574280 352.801849,485.938934 C352.710449,472.942291 345.950562,461.892181 342.047974,449.582642 C342.069214,448.315186 342.057037,447.483002 342.028625,446.651367 C341.666565,436.067688 341.033661,425.484863 341.005310,414.900330 C340.968781,401.258423 342.142914,387.523590 335.560730,374.777405 C335.241272,374.158875 335.718170,373.129089 335.824249,372.290802 C337.981628,373.643005 339.579468,375.229156 340.019867,377.089294 C341.581329,383.684479 342.715057,390.379974 344.086548,397.021820 C344.429932,398.684723 344.819305,401.532288 345.598511,401.680939 C347.700928,402.081970 351.146301,402.130280 352.052673,400.872711 C354.881805,396.947357 357.271912,392.519409 358.823181,387.944214 C359.514404,385.905457 357.793732,383.048920 357.061371,380.141327 C359.098572,380.571442 360.615265,380.891663 362.131927,381.211884 C362.584595,384.354340 363.400085,387.275391 365.323761,388.773224 C374.727661,396.095398 385.409058,400.975372 397.217041,404.291382 C401.535767,405.043549 406.086914,406.964233 408.304718,400.951294 C411.701294,395.074738 414.713654,389.257294 417.803925,383.481537 C418.713898,381.780731 419.709198,380.091309 420.900452,378.582214 C423.738586,374.986908 426.954041,371.668945 429.580444,367.932037 C433.083191,362.948273 433.452881,357.131439 434.226959,351.164246 C435.070984,344.658173 435.087952,338.720062 431.307281,333.535339 C426.986542,327.609955 421.892029,322.248779 416.635925,316.055908 C415.347473,321.288330 413.901794,325.263824 413.496460,329.342743 C413.097382,333.358429 412.944183,337.742126 414.161407,341.483337 C415.520355,345.660065 414.459045,346.907715 410.294678,347.502930 C410.286163,343.166687 407.530731,342.076874 404.052094,341.364471 C401.418335,340.825134 398.998535,339.298309 396.376770,338.629242 C392.823090,337.722351 389.056885,336.380188 385.595276,336.838104 C383.385284,337.130432 382.037445,337.890289 380.855103,335.620270 C379.545227,333.105408 380.445129,331.611908 382.546082,329.723419 C388.043396,324.782166 393.127258,319.380920 399.493774,313.051727 C395.169006,311.853302 391.778870,309.702423 389.775208,310.610565 C385.587402,312.508667 382.741638,310.554688 379.457672,309.182678 C376.256073,307.845062 372.865692,305.038147 369.890350,305.425720 C359.213013,306.816711 350.452576,302.224976 341.364899,298.132568 C338.573364,296.875488 335.487030,296.273224 332.535675,295.371094 C332.265717,295.911591 331.995728,296.452087 331.725739,296.992554 C329.555267,290.271057 325.800232,285.416046 318.531586,283.934875 C317.388336,283.701935 316.590271,280.964111 315.949829,279.264862 C314.990753,276.720306 314.312775,274.069855 313.811310,271.222076 C316.418304,264.542633 318.646393,258.183502 313.130737,252.037155 C312.335693,251.151230 312.336487,248.895645 312.833740,247.607758 C317.456940,235.633499 320.502075,223.501312 321.937714,210.552826 C323.845154,193.349380 324.510468,176.572983 318.974152,160.057846 C316.828552,153.657455 311.980194,149.140823 305.943665,145.611908 C305.078918,143.075928 304.303802,140.885651 303.433136,138.734055 C300.869965,132.399857 296.225128,129.264313 288.858978,129.413300 C289.920471,127.732216 290.578766,126.279984 291.595459,125.150291 C296.046295,120.204803 300.847015,115.555153 305.067230,110.425056 C314.036285,99.522308 322.918976,88.534981 331.412476,77.262428 C334.153778,73.624207 335.903748,69.107376 337.474243,64.763626 C338.575928,61.716568 338.676819,58.256886 335.023163,56.361439 C333.139526,59.400372 331.406036,62.197090 329.672516,64.993805 C329.038635,64.681725 328.404724,64.369637 327.770813,64.057556 C328.716553,61.624676 329.814087,59.237907 330.570587,56.747555 C331.574280,53.443512 329.945404,51.536083 326.922333,50.209820 C323.740997,63.368996 322.348236,65.550529 317.317627,65.059311 C318.937103,62.657543 321.035736,60.544582 321.865692,58.015320 C322.602081,55.771255 321.929565,53.064880 321.878998,50.562576 C319.314514,51.081493 316.133636,50.837986 314.329102,52.296886 C311.579102,54.520149 309.653442,57.834496 307.609222,60.842831 C304.433136,65.516922 301.617493,70.440514 298.357758,75.052422 C286.694366,91.553886 272.707184,105.976387 257.957947,119.696182 C257.784515,119.857521 257.329620,119.716270 256.884705,119.716270 C256.246918,118.598724 255.583008,117.435417 254.129700,114.888916 C252.864487,117.264091 251.994080,118.898109 251.123657,120.532135 C250.830658,119.967506 250.537659,119.402870 250.244675,118.838242 C248.188782,119.192619 246.007614,119.232384 244.111298,119.987503 C242.108719,120.784912 240.377731,122.264282 238.528107,123.445732 C238.317810,123.123070 238.107513,122.800415 237.897217,122.477753 C237.458649,123.593628 237.020081,124.709503 236.581512,125.825371 C233.004898,124.212967 230.436005,126.623550 227.394897,127.804382 C221.514969,130.087463 215.150681,131.207840 209.442245,133.808884 C206.932510,134.952469 205.153870,136.380020 202.257782,135.321136 C201.594360,135.078583 199.860992,136.342682 199.362671,137.299957 C196.237701,143.302963 190.305359,143.927750 185.052277,143.392136 C180.637344,142.941986 176.121796,147.928726 171.959045,143.117615 C171.883698,143.030533 171.378082,143.357025 171.059509,143.432663 C167.815414,144.202774 164.568466,144.960892 161.322327,145.722351 C159.701477,146.022842 157.925919,147.706680 156.447678,147.476990 C148.901443,146.304398 141.231903,145.278976 133.975876,143.014954 C117.021355,137.724869 100.278282,131.757050 83.239807,125.747116 C78.810524,124.455833 74.594337,122.746292 70.370506,122.727242 C66.653648,122.710472 65.655678,126.065842 68.171989,128.743332 C70.209511,130.911377 73.165619,132.358978 75.936943,133.647049 C77.968208,134.591141 80.192909,134.886398 78.825462,137.609467 C71.965973,136.383530 66.354942,133.970612 63.358841,126.165688 C62.299351,128.575821 60.875519,130.492630 61.296627,131.074722 C63.747288,134.462234 66.631279,137.536255 70.162758,141.638458 C67.686989,140.839066 65.942268,140.454376 64.362137,139.716980 C62.666286,138.925583 61.125149,137.802673 59.393806,136.749817 C57.861053,143.258286 62.668064,149.018768 68.947617,149.217041 C72.071899,151.377594 74.964462,153.832642 78.297226,154.860870 C96.374390,160.438126 114.565086,165.646805 132.701401,171.033905 C134.512436,171.571823 136.220551,172.456329 137.976425,173.179977 C137.755188,173.865295 137.533951,174.550598 137.312698,175.235901 C133.268509,174.313965 129.261307,173.104141 125.166260,172.577850 C122.702904,172.261246 119.539818,172.185837 117.683601,173.454315 C114.052979,175.935379 110.190598,178.910233 108.093620,182.623459 C104.129211,189.643417 101.053764,197.220367 98.208328,204.791153 C97.014153,207.968445 97.344971,211.718903 96.926010,215.547211 C95.300674,217.257721 93.731819,218.629822 92.162971,220.001923 C89.491295,213.676651 90.056671,207.598587 93.143570,201.504868 C96.929237,194.031738 100.163528,186.268707 104.176743,178.926468 C105.863029,175.841370 108.934456,173.513397 111.344528,170.875885 C101.193161,167.594116 91.102737,164.713669 81.310837,161.037964 C74.287643,158.401581 67.666855,154.694931 60.860611,151.478317 C55.953007,149.158997 54.673756,144.425018 53.128391,139.875320 C52.973713,139.419937 52.873985,138.805969 53.052204,138.398270 C56.040653,131.561844 56.960594,123.548790 65.132195,119.861526 C72.122330,116.707375 78.824730,117.341972 85.152878,120.708405 C105.502335,131.533905 127.533882,137.077255 149.815216,141.891846 C151.477356,142.250992 153.383484,141.725433 155.134048,141.390778 C165.625381,139.385117 176.060013,136.805725 187.359848,138.649841 C184.024139,128.754654 183.908798,118.965309 188.034042,109.353592 C191.339127,101.652908 196.429123,95.315086 202.579559,89.657448 C213.470352,79.639297 223.961914,69.386330 226.741882,53.742512 C228.558685,43.518589 221.653458,33.467350 211.318161,33.076878 C192.706894,32.373730 174.817581,35.536556 159.646484,46.976952 C154.016235,51.222664 149.673447,57.428547 145.490997,63.275219 C140.609970,70.098427 136.994980,77.836395 132.028610,84.587418 C123.549248,96.113777 112.561432,103.413254 97.396065,101.997246 C91.402382,101.437607 86.441933,98.924660 84.060806,93.235405 C81.622635,87.409836 82.535744,81.764900 87.288055,77.280235 C90.410057,74.334061 94.152626,72.009781 97.079407,68.900658 C101.696945,63.995472 106.127518,58.862720 110.156647,53.467400 C116.073006,45.544956 121.217926,37.031937 127.332787,29.276129 C133.974747,20.851778 142.984833,15.222683 152.683960,10.830196 C159.749908,7.630210 166.967422,4.764884 174.058685,1.375180 C180.021149,1.000000 186.042297,1.000000 192.269714,1.241520 C183.356186,4.580804 174.189453,7.547984 165.126358,10.803661 C146.562332,17.472303 131.347488,28.206182 121.697777,46.052849 C118.642570,51.703308 114.320892,56.670525 110.561272,61.937916 C108.747971,64.478439 106.894051,66.989960 104.701996,69.612061 C99.868446,73.362732 94.999443,76.637459 91.013672,80.765076 C86.039185,85.916595 87.565285,92.797951 93.775238,96.195976 C101.600632,100.477966 117.973839,95.447136 121.971733,87.497452 C122.166519,87.110107 121.961716,86.521805 122.300674,86.024429 C126.700806,80.883827 131.471313,76.155937 134.641724,70.526825 C142.444153,56.673489 150.942520,43.848087 166.148148,36.931557 C179.784256,30.728939 194.208694,28.450108 208.908096,28.315237 C226.868103,28.150448 233.934204,40.879841 231.988937,54.460793 C230.627945,63.962681 226.626709,72.316505 220.071655,79.292160 C214.367905,85.361900 208.186035,90.983315 202.502213,97.070595 C192.811478,107.449242 188.389175,119.505890 191.902039,133.748795 C192.260193,135.200943 193.103775,136.533386 194.166290,138.918472 C197.205307,133.961319 199.618744,129.596909 205.526138,131.922485 C205.943069,132.086624 206.675629,131.355255 207.292084,131.120987 C212.283020,129.224365 217.368576,127.546585 222.253830,125.410080 C227.584671,123.078712 234.173782,121.919914 233.588760,113.514297 C233.432983,111.276169 234.898178,108.632355 236.285309,106.638168 C239.600861,101.871552 243.014771,97.108864 246.918564,92.827477 C261.117798,77.254822 265.246277,58.728550 262.577179,38.521381 C260.341217,21.593275 251.487259,8.812224 236.000000,1.000000 C239.692902,1.000000 243.385818,1.000000 247.539368,0.999998 C251.806366,5.595012 256.062744,9.893007 259.330322,14.843633 C267.448761,27.143637 269.525269,40.734692 268.319794,55.414665 C267.416870,66.410522 264.822021,76.617584 258.927338,85.684174 C254.472076,92.536781 248.501282,98.385986 243.667389,105.018753 C241.516159,107.970558 240.502899,111.751694 238.727585,115.677353 C238.500809,116.626381 238.519608,117.054474 238.538406,117.482567 C238.867599,117.136810 239.196808,116.791046 239.526001,116.445297 C241.944473,115.627899 244.539108,115.133690 246.747040,113.930061 C252.445801,110.823425 259.425995,111.683090 264.604523,106.205696 C277.908844,92.133469 290.837250,77.858597 301.139984,61.372841 C303.743225,57.207275 306.129181,52.745277 309.473450,49.238098 C315.740875,42.665466 329.266754,43.353870 335.557556,49.954697 C337.952484,52.467705 341.933716,54.535286 342.579559,57.395714 C343.517853,61.551403 343.320984,66.855652 341.455292,70.596329 C333.743134,86.059273 322.894989,99.363876 310.869446,111.724907 C307.404083,115.286926 304.028625,118.957207 300.903778,122.814293 C300.170288,123.719635 299.967987,126.204803 300.634277,126.906914 C304.751587,131.245392 308.407928,135.585022 310.622925,141.453964 C311.949127,144.967941 315.745514,147.845001 318.978424,150.283325 C325.988617,155.570526 325.261505,163.593430 327.008545,170.776337 C327.575836,173.108826 328.294037,175.404465 328.867676,177.735535 C329.295654,179.474503 330.043182,181.282181 329.892700,182.992783 C328.700409,196.547348 327.798950,210.155457 325.819061,223.601501 C324.755371,230.825562 321.798309,237.779877 319.583282,244.820557 C318.797394,247.318527 318.305542,249.130569 319.951782,252.001984 C321.741119,255.123123 321.394501,259.547516 321.668274,263.425598 C321.804718,265.358246 321.130066,267.333710 321.025116,269.300629 C320.719543,275.026337 319.960297,280.478058 327.813782,282.798126 C331.452911,283.873230 334.144012,288.157440 337.773071,291.276733 C339.439545,292.370728 340.597931,293.174774 341.950928,294.278748 C344.774689,295.759644 347.403839,296.940643 350.271057,298.324402 C351.316040,298.689209 352.123016,298.851227 353.169342,299.271057 C355.891815,300.253326 358.374939,300.977844 361.117676,301.975677 C363.809753,302.179230 366.242188,302.109436 369.091370,302.017395 C373.188904,303.399567 376.864319,304.818359 380.552795,306.202332 C382.391418,306.892212 384.919098,308.623169 385.988708,307.979126 C390.266907,305.403259 393.699310,307.610596 397.151794,309.237549 C400.179108,310.664154 402.243439,310.495026 405.166870,308.459686 C407.485992,306.845032 411.664551,305.914307 414.064789,306.930420 C416.766541,308.074219 418.909576,311.477631 420.401855,314.360718 C424.735168,322.732513 429.481628,325.741150 438.833405,325.183777 C440.767822,325.205475 442.426208,325.059967 444.084595,324.914490 C450.356659,327.269165 456.838959,329.199982 462.809784,332.161865 C465.685822,333.588562 469.182953,336.728668 469.585022,339.501007 C470.232269,343.963806 465.220215,345.017670 461.798859,346.352173 C460.028961,347.042542 457.905273,346.825714 455.078583,347.016418 C452.745667,347.030182 451.275543,347.046295 449.410370,347.052551 C445.931213,347.665466 442.756836,348.026520 439.808716,349.043457 C438.673126,349.435211 437.212830,351.405670 437.327484,352.508514 C438.370117,362.538513 433.330475,370.617737 427.212311,376.981476 C422.195831,382.199310 419.646393,388.334259 415.796448,394.235657 C415.066681,395.999969 414.568817,397.608429 413.835510,399.514465 C411.117462,405.205750 407.087585,408.260101 400.974213,408.190369 C399.023285,408.168121 397.071808,408.190521 394.926453,407.935791 C390.373474,406.148132 386.014587,404.617157 381.417542,402.860840 C375.131989,399.070435 369.084686,395.505371 363.064819,391.963593 C363.092285,391.986847 363.059296,392.050812 362.986023,391.893677 C362.639893,391.811737 362.367096,391.886932 361.835632,392.252808 C361.373566,394.374237 361.170135,396.205017 360.590881,397.986969 C357.413666,400.634888 354.612274,403.331604 351.432892,406.036987 C348.195801,405.900513 346.800964,407.193542 347.061005,410.112000 M412.004120,317.998474 C412.004120,317.998474 412.056885,318.040588 412.590210,317.548370 C412.575531,314.911407 412.560822,312.274475 412.546112,309.637512 C410.866333,309.845062 408.616394,309.431183 407.600922,310.362793 C401.782837,315.700714 396.257935,321.358246 390.164886,327.220184 C389.417023,328.056274 388.669189,328.892365 387.618683,330.060333 C387.757416,330.401031 387.896149,330.741699 388.722900,331.174805 C395.154724,332.761841 401.586578,334.348877 408.634460,335.529022 C409.779236,329.692139 410.923981,323.855225 412.004120,317.998474 M451.758881,332.678558 C446.074280,329.321777 439.835541,328.717194 433.202301,328.293457 C435.328766,334.482544 437.220245,339.987793 439.294769,346.025696 C443.220917,344.911560 447.281830,343.759155 452.127869,342.929199 C456.609467,343.373627 460.767090,342.796539 465.452393,338.337158 C460.397003,336.405426 456.311005,334.844086 451.758881,332.678558 M209.696823,443.326965 C206.200363,444.836273 202.703903,446.345612 198.410248,447.825470 C197.883850,447.892792 197.357452,447.960144 196.116547,447.997406 C194.106674,449.647369 192.096802,451.297302 189.344177,453.093719 C185.975632,456.945251 186.018143,461.463684 189.981155,464.111694 C192.235489,465.617981 195.235260,467.038116 197.793137,466.870972 C206.020905,466.333557 214.494156,466.056641 222.323364,463.785492 C232.496567,460.834320 242.172745,455.660889 245.559677,444.489349 C249.201508,432.477051 251.788864,420.145020 254.950027,407.497589 C242.303345,406.287354 235.046295,396.761780 226.223953,389.688843 C222.566193,386.756439 218.978317,383.736847 214.563980,380.102692 C213.852234,383.334839 213.151138,385.211975 213.074646,387.114197 C212.857056,392.525696 213.285751,397.987030 212.743103,403.356262 C211.834610,412.345367 213.475754,420.494293 218.762756,427.909821 C219.796112,429.359222 219.935074,431.448486 220.974823,432.890564 C222.150803,434.521576 223.857330,435.777588 225.372726,437.153107 C226.110184,437.822479 226.937592,438.392731 227.870789,439.122406 C221.658325,440.559998 216.016983,441.865448 209.696823,443.326965 z&quot;/&gt;
  &lt;path fill=&quot;#1C1C1C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M105.058517,69.514618 C106.894051,66.989960 108.747971,64.478439 110.561272,61.937916 C114.320892,56.670525 118.642570,51.703308 121.697777,46.052849 C131.347488,28.206182 146.562332,17.472303 165.126358,10.803661 C174.189453,7.547984 183.356186,4.580804 192.738007,1.241520 C207.020889,1.000000 221.041794,1.000000 235.531342,1.000000 C251.487259,8.812224 260.341217,21.593275 262.577179,38.521381 C265.246277,58.728550 261.117798,77.254822 246.918564,92.827477 C243.014771,97.108864 239.600861,101.871552 236.285309,106.638168 C234.898178,108.632355 233.432983,111.276169 233.588760,113.514297 C234.173782,121.919914 227.584671,123.078712 222.253830,125.410080 C217.368576,127.546585 212.283020,129.224365 207.292084,131.120987 C206.675629,131.355255 205.943069,132.086624 205.526138,131.922485 C199.618744,129.596909 197.205307,133.961319 194.166290,138.918472 C193.103775,136.533386 192.260193,135.200943 191.902039,133.748795 C188.389175,119.505890 192.811478,107.449242 202.502213,97.070595 C208.186035,90.983315 214.367905,85.361900 220.071655,79.292160 C226.626709,72.316505 230.627945,63.962681 231.988937,54.460793 C233.934204,40.879841 226.868103,28.150448 208.908096,28.315237 C194.208694,28.450108 179.784256,30.728939 166.148148,36.931557 C150.942520,43.848087 142.444153,56.673489 134.641724,70.526825 C131.471313,76.155937 126.700806,80.883827 122.094452,85.752724 C117.759338,78.387024 112.856094,72.458076 105.058517,69.514618 z&quot;/&gt;
  &lt;path fill=&quot;#4A7146&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M91.991776,220.317017 C93.731819,218.629822 95.300674,217.257721 97.189423,215.315369 C102.208206,207.751602 102.195442,207.778091 109.683250,211.386627 C116.432884,214.639374 123.224426,217.805084 129.979355,221.046967 C136.314774,224.087524 136.269760,224.088242 140.008865,217.943604 C147.191284,206.140488 154.573593,194.455017 161.532425,182.522171 C163.704651,178.797272 165.707809,178.705750 169.118561,180.528168 C176.604355,184.527954 184.162201,188.418640 191.865112,191.976044 C196.070877,193.918381 196.717987,196.080505 194.524673,200.110184 C187.361359,213.271164 180.538315,226.617081 173.412628,239.799011 C171.771622,242.834747 172.184402,244.570236 175.232880,246.153015 C179.069519,248.144989 182.797928,250.365555 186.459824,252.667587 C189.412918,254.524048 191.291428,254.412674 193.228165,251.023468 C200.412766,238.450607 207.973358,226.092957 215.202347,213.544800 C216.982758,210.454330 218.596603,209.465073 221.852875,211.568115 C229.542679,216.534454 237.322189,221.368469 245.176437,226.070587 C248.610001,228.126175 249.093414,230.217667 247.145065,233.793686 C240.215347,246.512497 233.718491,259.467590 226.756668,272.168182 C224.719849,275.884033 225.566406,277.579254 228.953537,279.632660 C236.210449,284.032043 243.140060,288.967682 250.315720,293.506622 C252.841873,295.104553 253.268051,296.763885 251.840881,299.278625 C249.458176,303.477020 247.235489,307.765869 244.879868,311.980011 C241.533508,317.966522 241.046951,318.044495 235.004730,314.310028 C228.066345,310.021759 221.171219,305.654449 214.089981,301.614746 C212.851013,300.907898 209.738708,301.024902 209.269135,301.816254 C205.300751,308.503815 201.745392,315.436462 197.995590,322.426666 C198.947998,323.190033 199.523056,323.792419 200.216766,324.185333 C208.037018,328.614716 215.817886,333.119324 223.737488,337.364685 C226.886459,339.052673 227.866302,340.914062 225.961716,344.109161 C224.258057,346.967224 222.758194,349.945892 221.118790,352.843262 C216.347961,361.274841 216.263016,361.408997 207.615326,356.755127 C201.318848,353.366516 195.289078,349.485535 189.063721,345.959442 C187.268158,344.942505 185.012573,343.454285 183.959137,346.979736 C183.601257,348.786865 183.243362,350.593964 182.916199,352.739746 C177.997543,362.368378 172.844940,371.558319 168.197800,380.997070 C166.313812,384.823608 163.514603,385.963348 160.260635,384.493164 C149.725906,379.733490 139.411667,374.487518 128.981476,369.493652 C126.084244,368.106476 126.899147,366.184631 127.962685,364.160309 C133.760864,353.123993 139.579147,342.098236 145.370468,331.058350 C146.040878,329.780243 146.587128,328.437042 147.286819,326.915527 C141.942917,323.593079 136.926239,320.474060 131.614532,317.171600 C126.083122,326.379913 120.667725,335.373932 115.278320,344.383514 C114.093300,346.364532 113.012489,348.407623 111.862808,350.410126 C109.621635,354.313812 106.240791,355.302551 102.457489,352.909180 C93.797653,347.430786 85.272842,341.736908 76.562424,336.341644 C73.460655,334.420410 73.567719,332.789551 75.435204,329.945282 C80.141846,322.776886 84.503304,315.381195 88.976418,308.060303 C91.893005,303.286865 94.762871,298.484863 97.852615,293.366089 C87.720253,288.161041 77.786652,283.051147 67.846298,277.954407 C62.406216,275.165131 62.128433,274.630371 64.935455,269.320221 C67.481255,264.504272 70.050858,259.667908 73.061440,255.140762 C75.640022,251.263229 79.425453,252.492569 82.693390,254.238373 C91.702415,259.051147 100.604515,264.064026 109.808479,269.140961 C110.802010,267.600098 111.736000,266.151550 113.146210,264.350586 C114.758957,262.799042 115.895477,261.599945 117.303848,260.154602 C119.178612,257.034546 121.053123,254.267960 122.250832,251.234222 C122.730446,250.019379 122.213928,247.326965 121.308289,246.823914 C114.994347,243.316696 108.459267,240.207596 101.989388,236.992004 C101.983742,237.013031 102.027161,237.016525 101.917236,236.780518 C101.529770,236.338593 101.252228,236.132690 100.717010,235.670517 C98.273132,234.965195 96.086922,234.516159 93.900703,234.067123 C86.251831,229.885773 86.251831,229.885773 91.991776,220.317017 M117.505318,268.042877 C112.728134,276.713715 114.948433,278.491150 103.970207,272.070618 C96.929665,267.953033 89.750458,264.053131 82.466766,260.386658 C80.973221,259.634827 77.721184,259.597565 77.024773,260.531769 C74.304901,264.180481 72.285530,268.351349 69.801292,272.684723 C80.540154,278.313324 90.622238,283.780243 100.884659,288.884583 C104.858902,290.861328 105.463982,292.713440 103.020317,296.522308 C96.368263,306.890503 89.993454,317.440857 83.733673,328.051727 C82.826042,329.590210 82.281357,333.019165 83.051537,333.597015 C87.784637,337.148163 92.944000,340.131165 98.160400,343.428986 C99.313835,341.739227 100.091774,340.689514 100.776634,339.582214 C106.995422,329.527283 113.297363,319.521606 119.351547,309.368317 C121.479744,305.799225 123.552597,305.420624 126.971970,307.658600 C134.633072,312.672791 142.397232,317.545349 150.298019,322.170502 C154.017502,324.347900 154.431854,326.469208 152.407654,330.206360 C146.776443,340.602966 141.427475,351.156616 136.204163,361.765015 C135.515305,363.164124 135.555023,366.348511 136.365982,366.826996 C141.451065,369.827362 146.850525,372.294952 152.428360,375.079834 C158.855240,362.634552 164.978943,350.820740 171.059372,338.984680 C174.481262,332.323669 174.419083,332.356781 180.804184,336.213745 C190.175858,341.874634 199.595490,347.456116 209.418228,353.324432 C211.552200,349.603790 213.267365,346.216461 215.357361,343.078796 C217.531647,339.814575 216.988647,337.993164 213.451965,336.080200 C204.668655,331.329315 196.123962,326.138763 187.449326,321.184448 C185.001526,319.786499 183.443222,318.497009 185.399384,315.355835 C189.886887,308.149811 194.217102,300.838165 198.363403,293.430695 C200.308899,289.955017 202.298615,289.685669 205.515427,291.763397 C211.246994,295.465424 217.094406,299.008423 223.047119,302.343506 C236.343140,309.792755 233.304123,312.091309 241.732666,296.778168 C243.032944,294.415802 242.809601,293.014465 240.426651,291.491821 C232.427261,286.380402 224.761383,280.716217 216.567001,275.953278 C212.197189,273.413330 212.221985,271.243744 214.363708,267.294556 C221.190979,254.705597 227.625977,241.904388 234.388123,229.279236 C236.027405,226.218658 236.204544,224.320038 232.655899,222.591339 C229.232651,220.923752 226.044006,218.721542 222.909943,216.528854 C219.987122,214.483963 218.486801,215.183121 216.740646,218.231659 C209.458832,230.944626 201.816528,243.450790 194.496582,256.142456 C192.712234,259.236267 191.024124,259.497803 188.103607,257.759094 C179.949585,252.904724 171.640961,248.310913 163.446030,243.524124 C158.050171,240.372284 158.114395,239.848236 161.212631,234.142120 C168.126205,221.409195 174.934769,208.617767 181.595642,195.751572 C182.205063,194.574402 182.005936,191.750275 181.226837,191.282593 C176.281433,188.314011 171.067230,185.793274 165.860352,183.082581 C164.800537,184.532166 163.941406,185.547684 163.255936,186.669327 C155.615234,199.171982 147.894073,211.627747 140.450180,224.246902 C138.403122,227.717133 136.511002,228.457733 132.873138,226.533081 C126.696274,223.265167 120.245529,220.519028 113.954170,217.462479 C103.496536,212.381836 103.512459,212.352127 97.794807,222.207291 C97.460670,222.783218 97.125885,223.367142 96.718994,223.891098 C94.437386,226.829254 94.996040,228.620193 98.453140,230.361511 C107.522537,234.929749 116.375854,239.924942 125.373940,244.637985 C128.014404,246.021011 128.589127,247.647079 127.133514,250.260483 C123.973701,255.933594 120.934349,261.673798 117.505318,268.042877 M164.839401,374.343658 C169.762848,365.099579 174.597748,355.806854 179.644043,346.630341 C182.520767,341.399109 182.509872,341.022003 175.859833,338.094025 C169.294571,350.731659 162.701248,363.423370 156.160706,376.013428 C159.886215,379.219635 162.728546,380.053314 164.839401,374.343658 M170.496597,237.044098 C177.649124,223.765060 184.801651,210.486023 192.101334,196.933762 C189.204758,194.934570 187.112976,193.961777 185.242432,197.452621 C178.492340,210.049820 171.610916,222.578003 165.031357,235.263092 C164.396591,236.486908 165.510971,238.617981 165.813385,240.327896 C167.261993,239.452759 168.710587,238.577637 170.496597,237.044098 M217.609238,269.878387 C218.451080,271.283112 219.292938,272.687836 220.572784,274.823395 C222.290802,272.337830 223.370193,271.072662 224.125427,269.637024 C230.483215,257.551453 236.771530,245.429337 243.103851,233.330322 C245.130966,229.457199 242.531738,228.488541 239.394424,227.264175 C232.154236,241.394470 225.023849,255.310455 217.609238,269.878387 M113.154411,326.642944 C110.114601,331.577972 107.102531,336.530426 104.021645,341.439697 C102.750824,343.464691 101.018806,345.768921 104.165192,347.124908 C105.128807,347.540161 107.831734,345.675659 108.717583,344.229828 C114.425919,334.913086 119.907852,325.454956 125.295738,315.947876 C125.951881,314.790070 125.602699,313.062561 125.719421,311.599060 C124.259392,312.173737 122.207642,312.326965 121.444595,313.398132 C118.568161,317.436340 116.110909,321.773163 113.154411,326.642944 M189.406204,316.597443 C192.286041,320.789368 194.165619,321.070618 196.485718,317.094299 C200.149033,310.815887 203.398346,304.295929 206.848251,297.830658 C204.340424,294.930267 202.171890,294.318878 200.103241,297.867188 C196.596054,303.883026 193.098648,309.904602 189.406204,316.597443 M239.607834,308.038300 C239.244537,309.195496 238.881256,310.352722 238.517960,311.509918 C239.057800,311.686981 239.597641,311.864044 240.137497,312.041107 C243.394745,307.434723 246.289841,302.648895 247.948700,297.250641 C247.404861,296.964996 246.861023,296.679382 246.317184,296.393768 C244.219971,300.082245 242.122742,303.770691 239.607834,308.038300 M216.495193,348.023132 C215.407867,350.441254 214.320557,352.859344 213.233231,355.277466 C213.825272,355.565491 214.417328,355.853516 215.009369,356.141541 C217.675049,351.423370 220.340714,346.705200 223.006393,341.987030 C222.413849,341.606018 221.821320,341.225006 221.228790,340.843994 C219.764374,343.019196 218.299942,345.194397 216.495193,348.023132 z&quot;/&gt;
  &lt;path fill=&quot;#38374F&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M449.805450,347.062408 C451.275543,347.046295 452.745667,347.030182 454.657288,347.036407 C464.050537,365.254852 474.205627,382.970764 479.520020,402.695496 C481.401794,409.679749 479.338654,416.771362 476.317413,423.451965 C475.313995,425.670898 474.712555,428.469513 475.065491,430.833130 C476.382782,439.654449 474.687592,446.132233 467.459106,452.987976 C456.520325,463.362762 443.526764,467.816254 429.866028,471.268036 C422.252380,473.191833 415.139008,470.604523 410.307129,463.778961 C408.832520,461.695953 407.486359,460.872925 404.583160,461.465759 C387.420013,464.970520 372.063660,457.366394 363.937561,441.742157 C358.513153,431.312561 353.076843,420.889191 347.353424,410.287506 C346.800964,407.193542 348.195801,405.900513 351.568573,406.368774 C352.648590,407.896637 353.172699,409.123474 353.787842,410.302826 C359.707581,421.652405 364.942078,433.436707 371.757233,444.221710 C379.626953,456.675537 391.812958,460.808624 405.588440,456.247345 C420.412201,451.339050 435.074219,445.825104 449.446808,439.727020 C455.426544,437.189850 461.035095,433.057495 465.822845,428.589996 C474.292755,420.686646 477.059448,410.712982 473.197235,399.430389 C471.636292,394.870453 470.037476,390.295044 468.032013,385.921051 C462.069397,372.916412 455.896271,360.008270 449.805450,347.062408 M470.183319,435.648163 C469.944031,434.087036 469.704773,432.525879 469.465485,430.964752 C468.978241,430.766602 468.491028,430.568451 468.003815,430.370300 C466.213684,432.921906 463.364136,435.283447 462.864838,438.066650 C461.961761,443.100922 459.845123,447.106537 455.630035,449.425446 C449.248749,452.936035 442.668182,456.291931 435.802032,458.622833 C432.556274,459.724670 427.474426,459.608276 424.951172,457.727417 C420.466064,454.384186 417.235809,455.713043 413.333374,457.633972 C416.685059,465.300629 422.638275,468.990082 430.155457,466.801514 C441.671234,463.448822 452.866180,459.074829 462.430603,451.466400 C467.232025,447.646881 470.228546,442.860901 470.183319,435.648163 M455.482574,445.951172 C456.864716,443.913269 458.246857,441.875336 459.628998,439.837402 C459.317719,439.635468 459.006470,439.433502 458.695190,439.231567 C447.532135,444.037262 436.369049,448.842957 425.205963,453.648682 C425.196960,454.250671 425.187958,454.852692 425.178955,455.454712 C428.201630,455.699005 431.611908,456.964325 434.172821,455.992188 C441.273132,453.296967 448.019684,449.669861 455.482574,445.951172 z&quot;/&gt;
  &lt;path fill=&quot;#393850&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M368.674622,302.039673 C366.242188,302.109436 363.809753,302.179230 361.377319,301.753601 C371.040924,297.032684 380.704529,292.807129 391.687225,288.004791 C389.048309,285.575958 387.414154,283.113159 385.145020,282.156372 C377.113770,278.770050 355.580048,289.659546 353.105865,298.035797 C353.012665,298.351410 352.987061,298.686981 352.929962,299.013275 C352.123016,298.851227 351.316040,298.689209 350.305481,297.954041 C351.471069,294.973358 352.310181,291.927612 354.303711,290.271790 C361.832336,284.018555 370.578217,279.975677 380.281525,278.445953 C384.599792,277.765167 388.495422,279.219513 391.341003,282.819122 C395.307037,287.836060 395.312592,287.831665 401.954102,285.098999 C397.873505,275.235596 390.525208,270.885315 380.397614,272.611755 C367.838531,274.752594 357.013580,280.964691 346.549347,287.770935 C344.480835,289.116364 343.330200,291.872986 341.756287,293.978821 C340.597931,293.174774 339.439545,292.370728 338.137512,291.286896 C339.302704,284.512512 345.112854,282.535278 349.834015,279.806549 C355.399994,276.589508 361.296112,273.802094 367.318695,271.549072 C376.937012,267.950867 387.018616,265.608398 396.584686,271.109772 C400.500824,273.361908 403.173798,277.737946 406.513184,281.045959 C408.281433,282.797607 410.017426,285.166962 412.196808,285.814789 C420.577118,288.305786 427.122528,292.833252 431.283661,300.613220 C435.491577,308.480682 439.707489,316.343933 444.002258,324.561768 C442.426208,325.059967 440.767822,325.205475 438.730652,324.811859 C433.530334,315.755096 429.322479,306.805420 423.715759,298.840424 C418.032928,290.767242 409.034607,286.921844 399.524719,289.638824 C388.925537,292.667053 378.931885,297.814636 368.674622,302.039673 z&quot;/&gt;
  &lt;path fill=&quot;#515151&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M93.960678,234.422943 C96.086922,234.516159 98.273132,234.965195 100.835419,235.905228 C101.483383,236.602982 101.755272,236.809753 102.027161,237.016525 C102.027161,237.016525 101.983742,237.013031 101.950478,237.367157 C105.596695,246.186691 109.947037,254.205017 117.031998,260.400848 C115.895477,261.599945 114.758957,262.799042 113.262299,264.022827 C107.671494,256.501770 102.375465,248.999954 97.254112,241.380722 C95.899811,239.365921 95.083824,236.989273 93.960678,234.422943 z&quot;/&gt;
  &lt;path fill=&quot;#1C1C1C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M184.243088,347.161469 C185.012573,343.454285 187.268158,344.942505 189.063721,345.959442 C195.289078,349.485535 201.318848,353.366516 207.615326,356.755127 C216.263016,361.408997 216.347961,361.274841 221.118790,352.843262 C222.758194,349.945892 224.258057,346.967224 225.961716,344.109161 C227.866302,340.914062 226.886459,339.052673 223.737488,337.364685 C215.817886,333.119324 208.037018,328.614716 200.216766,324.185333 C199.523056,323.792419 198.947998,323.190033 197.995590,322.426666 C201.745392,315.436462 205.300751,308.503815 209.269135,301.816254 C209.738708,301.024902 212.851013,300.907898 214.089981,301.614746 C221.171219,305.654449 228.066345,310.021759 235.004730,314.310028 C241.046951,318.044495 241.533508,317.966522 244.879868,311.980011 C247.235489,307.765869 249.458176,303.477020 251.840881,299.278625 C253.268051,296.763885 252.841873,295.104553 250.315720,293.506622 C243.140060,288.967682 236.210449,284.032043 228.953537,279.632660 C225.566406,277.579254 224.719849,275.884033 226.756668,272.168182 C233.718491,259.467590 240.215347,246.512497 247.145065,233.793686 C249.093414,230.217667 248.610001,228.126175 245.176437,226.070587 C237.322189,221.368469 229.542679,216.534454 221.852875,211.568115 C218.596603,209.465073 216.982758,210.454330 215.202347,213.544800 C207.973358,226.092957 200.412766,238.450607 193.228165,251.023468 C191.291428,254.412674 189.412918,254.524048 186.459824,252.667587 C182.797928,250.365555 179.069519,248.144989 175.232880,246.153015 C172.184402,244.570236 171.771622,242.834747 173.412628,239.799011 C180.538315,226.617081 187.361359,213.271164 194.524673,200.110184 C196.717987,196.080505 196.070877,193.918381 191.865112,191.976044 C184.162201,188.418640 176.604355,184.527954 169.118561,180.528168 C165.707809,178.705750 163.704651,178.797272 161.532425,182.522171 C154.573593,194.455017 147.191284,206.140488 140.008865,217.943604 C136.269760,224.088242 136.314774,224.087524 129.979355,221.046967 C123.224426,217.805084 116.432884,214.639374 109.683250,211.386627 C102.195442,207.778091 102.208206,207.751602 97.245903,214.976959 C97.344971,211.718903 97.014153,207.968445 98.208328,204.791153 C101.053764,197.220367 104.129211,189.643417 108.093620,182.623459 C110.190598,178.910233 114.052979,175.935379 117.683601,173.454315 C119.539818,172.185837 122.702904,172.261246 125.166260,172.577850 C129.261307,173.104141 133.268509,174.313965 137.312698,175.235901 C137.533951,174.550598 137.755188,173.865295 137.976425,173.179977 C136.220551,172.456329 134.512436,171.571823 132.701401,171.033905 C114.565086,165.646805 96.374390,160.438126 78.297226,154.860870 C74.964462,153.832642 72.071899,151.377594 69.189857,148.989655 C72.626862,144.870605 75.850166,141.343002 79.142609,137.473953 C80.624367,133.442917 82.036972,129.753311 83.449577,126.063713 C100.278282,131.757050 117.021355,137.724869 133.975876,143.014954 C141.231903,145.278976 148.901443,146.304398 156.447678,147.476990 C157.925919,147.706680 159.701477,146.022842 161.322327,145.722351 C164.568466,144.960892 167.815414,144.202774 171.059509,143.432663 C171.378082,143.357025 171.883698,143.030533 171.959045,143.117615 C176.121796,147.928726 180.637344,142.941986 185.052277,143.392136 C190.305359,143.927750 196.237701,143.302963 199.362671,137.299957 C199.860992,136.342682 201.594360,135.078583 202.257782,135.321136 C205.153870,136.380020 206.932510,134.952469 209.442245,133.808884 C215.150681,131.207840 221.514969,130.087463 227.394897,127.804382 C230.436005,126.623550 233.004898,124.212967 236.581512,125.825371 C237.020081,124.709503 237.458649,123.593628 237.897217,122.477753 C238.107513,122.800415 238.317810,123.123070 238.528107,123.445732 C240.377731,122.264282 242.108719,120.784912 244.111298,119.987503 C246.007614,119.232384 248.188782,119.192619 250.244675,118.838242 C250.537659,119.402870 250.830658,119.967506 251.123657,120.532135 C251.994080,118.898109 252.864487,117.264091 254.129700,114.888916 C255.583008,117.435417 256.246918,118.598724 256.884705,119.716270 C257.329620,119.716270 257.784515,119.857521 257.957947,119.696182 C272.707184,105.976387 286.694366,91.553886 298.357758,75.052422 C301.617493,70.440514 304.433136,65.516922 307.609222,60.842831 C309.653442,57.834496 311.579102,54.520149 314.329102,52.296886 C316.133636,50.837986 319.314514,51.081493 321.878998,50.562576 C321.929565,53.064880 322.602081,55.771255 321.865692,58.015320 C321.035736,60.544582 318.937103,62.657543 317.317627,65.059311 C322.348236,65.550529 323.740997,63.368996 326.922333,50.209820 C329.945404,51.536083 331.574280,53.443512 330.570587,56.747555 C329.814087,59.237907 328.716553,61.624676 327.770813,64.057556 C328.404724,64.369637 329.038635,64.681725 329.672516,64.993805 C331.406036,62.197090 333.139526,59.400372 335.023163,56.361439 C338.676819,58.256886 338.575928,61.716568 337.474243,64.763626 C335.903748,69.107376 334.153778,73.624207 331.412476,77.262428 C322.918976,88.534981 314.036285,99.522308 305.067230,110.425056 C300.847015,115.555153 296.046295,120.204803 291.595459,125.150291 C290.578766,126.279984 289.920471,127.732216 288.858978,129.413300 C296.225128,129.264313 300.869965,132.399857 303.433136,138.734055 C304.303802,140.885651 305.078918,143.075928 305.715759,145.855591 C295.876190,153.664444 293.338318,163.921631 295.046906,174.899307 C297.681854,191.829147 296.898987,207.898895 290.722015,224.231415 C286.526337,235.325211 287.361755,247.573425 292.081085,258.891846 C295.956329,268.185791 303.970154,272.642181 313.515228,271.464417 C314.312775,274.069855 314.990753,276.720306 315.949829,279.264862 C316.590271,280.964111 317.388336,283.701935 318.531586,283.934875 C325.800232,285.416046 329.555267,290.271057 331.725739,296.992554 C331.995728,296.452087 332.265717,295.911591 332.535675,295.371094 C335.487030,296.273224 338.573364,296.875488 341.364899,298.132568 C350.452576,302.224976 359.213013,306.816711 369.890350,305.425720 C372.865692,305.038147 376.256073,307.845062 379.457672,309.182678 C382.741638,310.554688 385.587402,312.508667 389.775208,310.610565 C391.778870,309.702423 395.169006,311.853302 399.493774,313.051727 C393.127258,319.380920 388.043396,324.782166 382.546082,329.723419 C380.445129,331.611908 379.545227,333.105408 380.855103,335.620270 C382.037445,337.890289 383.385284,337.130432 385.595276,336.838104 C389.056885,336.380188 392.823090,337.722351 396.376770,338.629242 C398.998535,339.298309 401.418335,340.825134 404.052094,341.364471 C407.530731,342.076874 410.286163,343.166687 410.294678,347.502930 C414.459045,346.907715 415.520355,345.660065 414.161407,341.483337 C412.944183,337.742126 413.097382,333.358429 413.496460,329.342743 C413.901794,325.263824 415.347473,321.288330 416.635925,316.055908 C421.892029,322.248779 426.986542,327.609955 431.307281,333.535339 C435.087952,338.720062 435.070984,344.658173 434.226959,351.164246 C433.452881,357.131439 433.083191,362.948273 429.580444,367.932037 C426.954041,371.668945 423.738586,374.986908 420.900452,378.582214 C419.709198,380.091309 418.713898,381.780731 417.803925,383.481537 C414.713654,389.257294 411.701294,395.074738 408.028473,400.753662 C404.664551,399.541809 401.931305,398.452576 399.198090,397.363342 C398.446411,399.568665 397.694733,401.773987 396.943054,403.979309 C385.409058,400.975372 374.727661,396.095398 365.323761,388.773224 C363.400085,387.275391 362.584595,384.354340 362.131927,381.211884 C360.615265,380.891663 359.098572,380.571442 357.061371,380.141327 C357.793732,383.048920 359.514404,385.905457 358.823181,387.944214 C357.271912,392.519409 354.881805,396.947357 352.052673,400.872711 C351.146301,402.130280 347.700928,402.081970 345.598511,401.680939 C344.819305,401.532288 344.429932,398.684723 344.086548,397.021820 C342.715057,390.379974 341.581329,383.684479 340.019867,377.089294 C339.579468,375.229156 337.981628,373.643005 335.824249,372.290802 C335.718170,373.129089 335.241272,374.158875 335.560730,374.777405 C342.142914,387.523590 340.968781,401.258423 341.005310,414.900330 C341.033661,425.484863 341.666565,436.067688 342.028625,446.651367 C342.057037,447.483002 342.069214,448.315186 341.654907,449.626099 C335.485291,450.281830 331.955383,452.951660 331.006592,458.827454 C330.872040,459.660645 329.829010,460.793274 329.011841,460.993652 C325.272766,461.910583 323.608368,464.499664 322.780151,467.929871 C322.180481,467.427063 321.307098,467.046051 321.021240,466.403595 C314.254761,451.196198 307.057404,436.155121 300.965149,420.679596 C293.789001,402.450806 291.432892,383.361664 293.624298,363.790741 C293.826019,361.989227 293.457733,360.123901 293.354126,358.288208 C292.811676,358.198120 292.269226,358.108032 291.726807,358.017944 C291.192108,359.497772 290.249084,360.960480 290.186310,362.460052 C289.600311,376.455109 289.588440,390.419861 292.526581,404.240997 C292.872772,405.869476 292.447937,408.445984 291.350403,409.408813 C289.804016,410.765411 287.347656,411.927094 285.408905,408.963501 C284.913361,408.205994 282.997986,408.222198 281.720917,408.156799 C274.558655,407.790131 266.897614,409.761993 261.019836,403.524261 C260.686768,403.170746 259.704620,403.191193 259.112457,403.355194 C250.492523,405.742249 244.402420,401.026855 238.455063,396.004211 C231.037506,389.740082 223.778320,383.283783 216.245087,377.163666 C213.446136,374.889740 210.254822,372.851501 206.915451,371.535675 C196.176834,367.304230 192.456024,356.770416 185.849487,348.834015 C185.424698,348.323700 184.968582,347.839539 184.243088,347.161469 M388.873566,377.360229 C390.621796,379.942688 392.352600,382.537170 394.123901,385.103699 C395.479126,387.067261 397.200714,388.038574 398.726776,385.516815 C400.760406,382.156433 397.213531,373.626068 393.472473,372.336334 C389.918060,371.110962 388.359344,372.476624 388.873566,377.360229 M377.578278,378.733246 C374.826019,371.969757 368.092834,370.440704 362.421936,367.514862 C367.267578,371.146637 372.113251,374.778412 377.578278,378.733246 M379.460144,379.493713 C379.460144,379.493713 379.494598,379.536987 379.460144,379.493713 z&quot;/&gt;
  &lt;path fill=&quot;#A9B8EF&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M449.410370,347.052551 C455.896271,360.008270 462.069397,372.916412 468.032013,385.921051 C470.037476,390.295044 471.636292,394.870453 473.197235,399.430389 C477.059448,410.712982 474.292755,420.686646 465.822845,428.589996 C461.035095,433.057495 455.426544,437.189850 449.446808,439.727020 C435.074219,445.825104 420.412201,451.339050 405.588440,456.247345 C391.812958,460.808624 379.626953,456.675537 371.757233,444.221710 C364.942078,433.436707 359.707581,421.652405 353.787842,410.302826 C353.172699,409.123474 352.648590,407.896637 351.946533,406.360107 C354.612274,403.331604 357.413666,400.634888 360.700745,398.321350 C364.891663,403.997681 368.188934,409.647614 372.417633,414.483032 C376.596100,419.260986 382.428009,421.984436 388.919403,421.503540 C398.106567,420.822968 406.459656,417.408722 413.430206,411.345886 C419.543854,406.028381 420.030212,401.304047 416.028320,394.079773 C419.646393,388.334259 422.195831,382.199310 427.212311,376.981476 C433.330475,370.617737 438.370117,362.538513 437.327484,352.508514 C437.212830,351.405670 438.673126,349.435211 439.808716,349.043457 C442.756836,348.026520 445.931213,347.665466 449.410370,347.052551 M429.224457,417.723480 C433.964935,418.812408 437.851715,417.525970 440.200195,413.173126 C442.195465,409.474884 442.064758,405.245667 438.767365,402.753998 C436.322876,400.906799 432.168335,399.501801 429.489655,400.299072 C426.830078,401.090729 424.059845,404.560455 423.138763,407.433044 C421.732727,411.818085 424.270203,415.371765 429.224457,417.723480 z&quot;/&gt;
  &lt;path fill=&quot;#ECE6E6&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M313.811310,271.222076 C303.970154,272.642181 295.956329,268.185791 292.081085,258.891846 C287.361755,247.573425 286.526337,235.325211 290.722015,224.231415 C296.898987,207.898895 297.681854,191.829147 295.046906,174.899307 C293.338318,163.921631 295.876190,153.664444 305.761719,146.218994 C311.980194,149.140823 316.828552,153.657455 318.974152,160.057846 C324.510468,176.572983 323.845154,193.349380 321.937714,210.552826 C320.502075,223.501312 317.456940,235.633499 312.833740,247.607758 C312.336487,248.895645 312.335693,251.151230 313.130737,252.037155 C318.646393,258.183502 316.418304,264.542633 313.811310,271.222076 z&quot;/&gt;
  &lt;path fill=&quot;#1C1C1C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M196.831055,448.027496 C197.357452,447.960144 197.883850,447.892792 199.065796,448.021118 C200.809982,449.130280 201.898621,450.043762 202.894989,451.365967 C201.691925,451.912537 200.239807,451.664246 199.547852,452.275909 C198.423233,453.270142 197.623108,454.760101 197.069366,456.189392 C196.912781,456.593536 198.346558,458.187622 198.612991,458.086151 C200.050247,457.538727 201.615936,456.871124 202.614655,455.770630 C203.452682,454.847198 203.574188,453.273499 204.177811,451.589355 C210.961456,451.164215 211.825653,450.015381 210.375656,443.170898 C216.016983,441.865448 221.658325,440.559998 227.870789,439.122406 C226.937592,438.392731 226.110184,437.822479 225.372726,437.153107 C223.857330,435.777588 222.150803,434.521576 220.974823,432.890564 C219.935074,431.448486 219.796112,429.359222 218.762756,427.909821 C213.475754,420.494293 211.834610,412.345367 212.743103,403.356262 C213.285751,397.987030 212.857056,392.525696 213.074646,387.114197 C213.151138,385.211975 213.852234,383.334839 214.563980,380.102692 C218.978317,383.736847 222.566193,386.756439 226.223953,389.688843 C235.046295,396.761780 242.303345,406.287354 254.950027,407.497589 C251.788864,420.145020 249.201508,432.477051 245.559677,444.489349 C242.172745,455.660889 232.496567,460.834320 222.323364,463.785492 C214.494156,466.056641 206.020905,466.333557 197.793137,466.870972 C195.235260,467.038116 192.235489,465.617981 189.981155,464.111694 C186.018143,461.463684 185.975632,456.945251 190.005737,453.171265 C194.622650,453.752228 196.801086,452.157990 196.831055,448.027496 z&quot;/&gt;
  &lt;path fill=&quot;#E9E2E2&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M322.836975,468.291260 C323.608368,464.499664 325.272766,461.910583 329.011841,460.993652 C329.829010,460.793274 330.872040,459.660645 331.006592,458.827454 C331.955383,452.951660 335.485291,450.281830 341.613983,450.061584 C345.950562,461.892181 352.710449,472.942291 352.801849,485.938934 C352.834473,490.574280 352.160919,495.137939 347.317200,498.209991 C348.381653,487.638458 348.381653,487.638458 345.343201,484.534607 C343.940369,489.876831 347.042603,496.620575 340.494049,499.666168 C338.741425,500.481262 336.565552,500.386200 335.208008,500.607330 C336.497681,495.715454 337.830811,491.456573 338.615784,487.098999 C338.803192,486.058716 337.161591,484.688995 336.361206,483.470795 C335.961395,483.640808 335.561584,483.810822 335.161774,483.980835 C335.278351,484.983429 335.721252,486.084717 335.453278,486.971008 C334.455750,490.270142 333.804169,493.907104 331.891998,496.620331 C330.445526,498.672729 327.161011,498.305481 326.626221,495.136108 C325.143463,486.348541 324.106750,477.485718 322.836975,468.291260 z&quot;/&gt;
  &lt;path fill=&quot;#A8B6EC&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M369.091370,302.017426 C378.931885,297.814636 388.925537,292.667053 399.524719,289.638824 C409.034607,286.921844 418.032928,290.767242 423.715759,298.840424 C429.322479,306.805420 433.530334,315.755096 438.454651,324.644653 C429.481628,325.741150 424.735168,322.732513 420.401855,314.360718 C418.909576,311.477631 416.766541,308.074219 414.064789,306.930420 C411.664551,305.914307 407.485992,306.845032 405.166870,308.459686 C402.243439,310.495026 400.179108,310.664154 397.151794,309.237549 C393.699310,307.610596 390.266907,305.403259 385.988708,307.979126 C384.919098,308.623169 382.391418,306.892212 380.552795,306.202332 C376.864319,304.818359 373.188904,303.399567 369.091370,302.017426 z&quot;/&gt;
  &lt;path fill=&quot;#EBE4E4&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M104.701996,69.612061 C112.856094,72.458076 117.759338,78.387024 121.736771,85.755379 C121.961716,86.521805 122.166519,87.110107 121.971733,87.497452 C117.973839,95.447136 101.600632,100.477966 93.775238,96.195976 C87.565285,92.797951 86.039185,85.916595 91.013672,80.765076 C94.999443,76.637459 99.868446,73.362732 104.701996,69.612061 z&quot;/&gt;
  &lt;path fill=&quot;#A4B2E7&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M341.950928,294.278748 C343.330200,291.872986 344.480835,289.116364 346.549347,287.770935 C357.013580,280.964691 367.838531,274.752594 380.397614,272.611755 C390.525208,270.885315 397.873505,275.235596 401.954102,285.098999 C395.312592,287.831665 395.307037,287.836060 391.341003,282.819122 C388.495422,279.219513 384.599792,277.765167 380.281525,278.445953 C370.578217,279.975677 361.832336,284.018555 354.303711,290.271790 C352.310181,291.927612 351.471069,294.973358 350.067444,297.751282 C347.403839,296.940643 344.774689,295.759644 341.950928,294.278748 z&quot;/&gt;
  &lt;path fill=&quot;#8D9DE2&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M353.169342,299.271057 C352.987061,298.686981 353.012665,298.351410 353.105865,298.035797 C355.580048,289.659546 377.113770,278.770050 385.145020,282.156372 C387.414154,283.113159 389.048309,285.575958 391.687225,288.004791 C380.704529,292.807129 371.040924,297.032684 361.117676,301.480286 C358.374939,300.977844 355.891815,300.253326 353.169342,299.271057 z&quot;/&gt;
  &lt;path fill=&quot;#C3CFEA&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M395.120605,408.192474 C397.071808,408.190521 399.023285,408.168121 400.974213,408.190369 C407.087585,408.260101 411.117462,405.205750 413.953461,399.863342 C412.751007,402.838531 411.920593,406.890228 409.489777,408.453644 C404.274780,411.807892 398.363922,414.236420 392.492157,416.366364 C387.348572,418.232178 382.199890,416.899689 377.812073,413.719025 C370.297119,408.271515 365.632324,400.781281 363.037354,391.940338 C369.084686,395.505371 375.131989,399.070435 381.507324,403.211121 C386.118195,411.733398 389.006531,412.691254 395.120605,408.192474 z&quot;/&gt;
  &lt;path fill=&quot;#3D3C54&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M363.064819,391.963593 C365.632324,400.781281 370.297119,408.271515 377.812073,413.719025 C382.199890,416.899689 387.348572,418.232178 392.492157,416.366364 C398.363922,414.236420 404.274780,411.807892 409.489777,408.453644 C411.920593,406.890228 412.751007,402.838531 414.188904,399.565765 C414.568817,397.608429 415.066681,395.999969 415.796448,394.235657 C420.030212,401.304047 419.543854,406.028381 413.430206,411.345886 C406.459656,417.408722 398.106567,420.822968 388.919403,421.503540 C382.428009,421.984436 376.596100,419.260986 372.417633,414.483032 C368.188934,409.647614 364.891663,403.997681 361.076569,398.370148 C361.170135,396.205017 361.373566,394.374237 362.073578,392.311096 C362.570160,392.078705 363.059296,392.050812 363.059296,392.050812 C363.059296,392.050812 363.092285,391.986847 363.064819,391.963593 z&quot;/&gt;
  &lt;path fill=&quot;#282828&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M408.018402,335.935913 C401.586578,334.348877 395.154724,332.761841 388.352325,330.789612 C387.961609,330.179108 387.941467,329.953766 387.921326,329.728455 C388.669189,328.892365 389.417023,328.056274 390.789001,327.050110 C395.715454,323.416229 399.951691,319.865112 404.353119,316.532135 C406.085968,315.219910 408.187683,314.394745 410.121429,313.347748 C410.766571,314.912018 411.411713,316.476318 412.056885,318.040588 C412.056885,318.040588 412.004120,317.998474 411.776306,318.264221 C410.371796,324.331970 409.195099,330.133942 408.018402,335.935913 z&quot;/&gt;
  &lt;path fill=&quot;#1E1E1E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M451.342712,342.606750 C447.281830,343.759155 443.220917,344.911560 439.294769,346.025696 C437.220245,339.987793 435.328766,334.482544 433.202301,328.293457 C439.835541,328.717194 446.074280,329.321777 451.897583,333.355530 C451.805115,336.890564 451.573914,339.748657 451.342712,342.606750 z&quot;/&gt;
  &lt;path fill=&quot;#E5DEDE&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M79.073463,137.815399 C75.850166,141.343002 72.626862,144.870605 69.161316,148.625595 C62.668064,149.018768 57.861053,143.258286 59.393806,136.749817 C61.125149,137.802673 62.666286,138.925583 64.362137,139.716980 C65.942268,140.454376 67.686989,140.839066 70.162758,141.638458 C66.631279,137.536255 63.747288,134.462234 61.296627,131.074722 C60.875519,130.492630 62.299351,128.575821 63.358841,126.165688 C66.354942,133.970612 71.965973,136.383530 78.824631,137.575424 C79.098244,137.865311 79.073463,137.815399 79.073463,137.815399 z&quot;/&gt;
  &lt;path fill=&quot;#E5DFDF&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M79.142609,137.473953 C79.073463,137.815399 79.098244,137.865311 79.099075,137.899353 C80.192909,134.886398 77.968208,134.591141 75.936943,133.647049 C73.165619,132.358978 70.209511,130.911377 68.171989,128.743332 C65.655678,126.065842 66.653648,122.710472 70.370506,122.727242 C74.594337,122.746292 78.810524,124.455833 83.239807,125.747116 C82.036972,129.753311 80.624367,133.442917 79.142609,137.473953 z&quot;/&gt;
  &lt;path fill=&quot;#E4DDDD&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M451.735291,342.767975 C451.573914,339.748657 451.805115,336.890564 452.130646,333.657593 C456.311005,334.844086 460.397003,336.405426 465.452393,338.337158 C460.767090,342.796539 456.609467,343.373627 451.735291,342.767975 z&quot;/&gt;
  &lt;path fill=&quot;#202020&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M412.323547,317.794495 C411.411713,316.476318 410.766571,314.912018 410.121429,313.347748 C408.187683,314.394745 406.085968,315.219910 404.353119,316.532135 C399.951691,319.865112 395.715454,323.416229 391.023315,326.893677 C396.257935,321.358246 401.782837,315.700714 407.600922,310.362793 C408.616394,309.431183 410.866333,309.845062 412.546143,309.637512 C412.560822,312.274475 412.575531,314.911407 412.323547,317.794495 z&quot;/&gt;
  &lt;path fill=&quot;#E9CFE1&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M210.036240,443.248932 C211.825653,450.015381 210.961456,451.164215 204.171417,451.615570 C204.000168,452.040192 204.053406,452.024445 204.237030,451.673889 C203.936066,451.189819 203.451492,451.056335 202.955353,450.946106 C202.943802,450.969360 202.987259,450.957275 202.987259,450.957275 C201.898621,450.043762 200.809982,449.130280 199.464386,448.035828 C202.703903,446.345612 206.200363,444.836273 210.036240,443.248932 z&quot;/&gt;
  &lt;path fill=&quot;#EAD0E2&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M397.217041,404.291382 C397.694733,401.773987 398.446411,399.568665 399.198090,397.363342 C401.931305,398.452576 404.664551,399.541809 407.674011,400.828674 C406.086914,406.964233 401.535767,405.043549 397.217041,404.291382 z&quot;/&gt;
  &lt;path fill=&quot;#403F56&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M394.926453,407.935791 C389.006531,412.691254 386.118195,411.733398 381.745544,403.436462 C386.014587,404.617157 390.373474,406.148132 394.926453,407.935791 z&quot;/&gt;
  &lt;path fill=&quot;#202020&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M408.326416,335.732483 C409.195099,330.133942 410.371796,324.331970 411.808624,318.274170 C410.923981,323.855225 409.779236,329.692139 408.326416,335.732483 z&quot;/&gt;
  &lt;path fill=&quot;#D3BDCD&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M196.473801,448.012451 C196.801086,452.157990 194.622650,453.752228 190.377121,453.098022 C192.096802,451.297302 194.106674,449.647369 196.473801,448.012451 z&quot;/&gt;
  &lt;path fill=&quot;#000000&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M239.376831,116.313461 C239.196808,116.791046 238.867599,117.136810 238.538406,117.482567 C238.519608,117.054474 238.500809,116.626381 238.699142,116.065926 C238.916260,115.933563 239.227676,116.181625 239.376831,116.313461 z&quot;/&gt;
  &lt;path fill=&quot;#C3CFEA&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M362.986023,391.893677 C363.059296,392.050812 362.570160,392.078705 362.332214,392.020386 C362.367096,391.886932 362.639893,391.811737 362.986023,391.893677 z&quot;/&gt;
  &lt;path fill=&quot;#202020&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M387.770020,329.894409 C387.941467,329.953766 387.961609,330.179108 388.008301,330.743408 C387.896149,330.741699 387.757416,330.401031 387.770020,329.894409 z&quot;/&gt;
  &lt;path fill=&quot;#74AE81&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M117.675537,267.714722 C120.934349,261.673798 123.973701,255.933594 127.133514,250.260483 C128.589127,247.647079 128.014404,246.021011 125.373940,244.637985 C116.375854,239.924942 107.522537,234.929749 98.453140,230.361511 C94.996040,228.620193 94.437386,226.829254 96.718994,223.891098 C97.125885,223.367142 97.460670,222.783218 97.794807,222.207291 C103.512459,212.352127 103.496536,212.381836 113.954170,217.462479 C120.245529,220.519028 126.696274,223.265167 132.873138,226.533081 C136.511002,228.457733 138.403122,227.717133 140.450180,224.246902 C147.894073,211.627747 155.615234,199.171982 163.255936,186.669327 C163.941406,185.547684 164.800537,184.532166 165.860352,183.082581 C171.067230,185.793274 176.281433,188.314011 181.226837,191.282593 C182.005936,191.750275 182.205063,194.574402 181.595642,195.751572 C174.934769,208.617767 168.126205,221.409195 161.212631,234.142120 C158.114395,239.848236 158.050171,240.372284 163.446030,243.524124 C171.640961,248.310913 179.949585,252.904724 188.103607,257.759094 C191.024124,259.497803 192.712234,259.236267 194.496582,256.142456 C201.816528,243.450790 209.458832,230.944626 216.740646,218.231659 C218.486801,215.183121 219.987122,214.483963 222.909943,216.528854 C226.044006,218.721542 229.232651,220.923752 232.655899,222.591339 C236.204544,224.320038 236.027405,226.218658 234.388123,229.279236 C227.625977,241.904388 221.190979,254.705597 214.363708,267.294556 C212.221985,271.243744 212.197189,273.413330 216.567001,275.953278 C224.761383,280.716217 232.427261,286.380402 240.426651,291.491821 C242.809601,293.014465 243.032944,294.415802 241.732666,296.778168 C233.304123,312.091309 236.343140,309.792755 223.047119,302.343506 C217.094406,299.008423 211.246994,295.465424 205.515427,291.763397 C202.298615,289.685669 200.308899,289.955017 198.363403,293.430695 C194.217102,300.838165 189.886887,308.149811 185.399384,315.355835 C183.443222,318.497009 185.001526,319.786499 187.449326,321.184448 C196.123962,326.138763 204.668655,331.329315 213.451965,336.080200 C216.988647,337.993164 217.531647,339.814575 215.357361,343.078796 C213.267365,346.216461 211.552200,349.603790 209.418228,353.324432 C199.595490,347.456116 190.175858,341.874634 180.804184,336.213745 C174.419083,332.356781 174.481262,332.323669 171.059372,338.984680 C164.978943,350.820740 158.855240,362.634552 152.428360,375.079834 C146.850525,372.294952 141.451065,369.827362 136.365982,366.826996 C135.555023,366.348511 135.515305,363.164124 136.204163,361.765015 C141.427475,351.156616 146.776443,340.602966 152.407654,330.206360 C154.431854,326.469208 154.017502,324.347900 150.298019,322.170502 C142.397232,317.545349 134.633072,312.672791 126.971970,307.658600 C123.552597,305.420624 121.479744,305.799225 119.351547,309.368317 C113.297363,319.521606 106.995422,329.527283 100.776634,339.582214 C100.091774,340.689514 99.313835,341.739227 98.160400,343.428986 C92.944000,340.131165 87.784637,337.148163 83.051537,333.597015 C82.281357,333.019165 82.826042,329.590210 83.733673,328.051727 C89.993454,317.440857 96.368263,306.890503 103.020317,296.522308 C105.463982,292.713440 104.858902,290.861328 100.884659,288.884583 C90.622238,283.780243 80.540154,278.313324 69.801292,272.684723 C72.285530,268.351349 74.304901,264.180481 77.024773,260.531769 C77.721184,259.597565 80.973221,259.634827 82.466766,260.386658 C89.750458,264.053131 96.929665,267.953033 103.970207,272.070618 C114.948433,278.491150 112.728134,276.713715 117.675537,267.714722 M130.938660,288.542542 C140.953079,294.448029 151.024399,300.260284 160.948746,306.313446 C164.099091,308.234924 165.662888,307.266663 167.243774,304.419495 C171.436035,296.869080 175.626968,289.308075 180.154968,281.958588 C182.072052,278.846924 181.353806,277.307312 178.487000,275.654541 C168.414856,269.847778 158.392746,263.952576 148.412704,257.988770 C145.218750,256.080139 143.506042,257.544434 142.028244,260.207855 C137.757080,267.905731 133.345276,275.530273 129.314743,283.351654 C128.732361,284.481781 129.941925,286.535339 130.938660,288.542542 z&quot;/&gt;
  &lt;path fill=&quot;#557F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M164.671646,374.673553 C162.728546,380.053314 159.886215,379.219635 156.160706,376.013428 C162.701248,363.423370 169.294571,350.731659 175.859833,338.094025 C182.509872,341.022003 182.520767,341.399109 179.644043,346.630341 C174.597748,355.806854 169.762848,365.099579 164.671646,374.673553 z&quot;/&gt;
  &lt;path fill=&quot;#557F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M170.327896,237.373291 C168.710587,238.577637 167.261993,239.452759 165.813385,240.327896 C165.510971,238.617981 164.396591,236.486908 165.031357,235.263092 C171.610916,222.578003 178.492340,210.049820 185.242432,197.452621 C187.112976,193.961777 189.204758,194.934570 192.101334,196.933762 C184.801651,210.486023 177.649124,223.765060 170.327896,237.373291 z&quot;/&gt;
  &lt;path fill=&quot;#547F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M217.751343,269.552429 C225.023849,255.310455 232.154236,241.394470 239.394424,227.264175 C242.531738,228.488541 245.130966,229.457199 243.103851,233.330322 C236.771530,245.429337 230.483215,257.551453 224.125427,269.637024 C223.370193,271.072662 222.290802,272.337830 220.572784,274.823395 C219.292938,272.687836 218.451080,271.283112 217.751343,269.552429 z&quot;/&gt;
  &lt;path fill=&quot;#1D1E1D&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M117.303856,260.154602 C109.947037,254.205017 105.596695,246.186691 101.956123,237.346130 C108.459267,240.207596 114.994347,243.316696 121.308289,246.823914 C122.213928,247.326965 122.730446,250.019379 122.250832,251.234222 C121.053123,254.267960 119.178612,257.034546 117.303856,260.154602 z&quot;/&gt;
  &lt;path fill=&quot;#547F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M113.325562,326.320557 C116.110909,321.773163 118.568161,317.436340 121.444595,313.398132 C122.207642,312.326965 124.259392,312.173737 125.719421,311.599060 C125.602699,313.062561 125.951881,314.790070 125.295738,315.947876 C119.907852,325.454956 114.425919,334.913086 108.717583,344.229828 C107.831734,345.675659 105.128807,347.540161 104.165192,347.124908 C101.018806,345.768921 102.750824,343.464691 104.021645,341.439697 C107.102531,336.530426 110.114601,331.577972 113.325562,326.320557 z&quot;/&gt;
  &lt;path fill=&quot;#547F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M189.501663,316.260620 C193.098648,309.904602 196.596054,303.883026 200.103241,297.867188 C202.171890,294.318878 204.340424,294.930267 206.848251,297.830658 C203.398346,304.295929 200.149033,310.815887 196.485718,317.094299 C194.165619,321.070618 192.286041,320.789368 189.501663,316.260620 z&quot;/&gt;
  &lt;path fill=&quot;#537E5C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M239.816681,307.748718 C242.122742,303.770691 244.219971,300.082245 246.317184,296.393768 C246.861023,296.679382 247.404861,296.964996 247.948700,297.250641 C246.289841,302.648895 243.394745,307.434723 240.137497,312.041107 C239.597641,311.864044 239.057800,311.686981 238.517960,311.509918 C238.881256,310.352722 239.244537,309.195496 239.816681,307.748718 z&quot;/&gt;
  &lt;path fill=&quot;#537E5C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M216.665359,347.696381 C218.299942,345.194397 219.764374,343.019196 221.228790,340.843994 C221.821320,341.225006 222.413849,341.606018 223.006393,341.987030 C220.340714,346.705200 217.675049,351.423370 215.009369,356.141541 C214.417328,355.853516 213.825272,355.565491 213.233231,355.277466 C214.320557,352.859344 215.407867,350.441254 216.665359,347.696381 z&quot;/&gt;
  &lt;path fill=&quot;#1D1E1D&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M101.917236,236.780518 C101.755272,236.809753 101.483383,236.602982 101.093094,236.161499 C101.252228,236.132690 101.529770,236.338593 101.917236,236.780518 z&quot;/&gt;
  &lt;path fill=&quot;#A4B2E7&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M470.184692,436.081116 C470.228546,442.860901 467.232025,447.646881 462.430603,451.466400 C452.866180,459.074829 441.671234,463.448822 430.155457,466.801514 C422.638275,468.990082 416.685059,465.300629 413.333374,457.633972 C417.235809,455.713043 420.466064,454.384186 424.951172,457.727417 C427.474426,459.608276 432.556274,459.724670 435.802032,458.622833 C442.668182,456.291931 449.248749,452.936035 455.630035,449.425446 C459.845123,447.106537 461.961761,443.100922 462.864838,438.066650 C463.364136,435.283447 466.213684,432.921906 468.003815,430.370300 C468.491028,430.568451 468.978241,430.766602 469.465485,430.964752 C469.704773,432.525879 469.944031,434.087036 470.184692,436.081116 z&quot;/&gt;
  &lt;path fill=&quot;#8999DC&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M455.194305,446.181091 C448.019684,449.669861 441.273132,453.296967 434.172821,455.992188 C431.611908,456.964325 428.201630,455.699005 425.178955,455.454712 C425.187958,454.852692 425.196960,454.250671 425.205963,453.648682 C436.369049,448.842957 447.532135,444.037262 458.695190,439.231567 C459.006470,439.433502 459.317719,439.635468 459.628998,439.837402 C458.246857,441.875336 456.864716,443.913269 455.194305,446.181091 z&quot;/&gt;
  &lt;path fill=&quot;#4E4E4E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M388.668701,377.042419 C388.359344,372.476624 389.918060,371.110962 393.472473,372.336334 C397.213531,373.626068 400.760406,382.156433 398.726776,385.516815 C397.200714,388.038574 395.479126,387.067261 394.123901,385.103699 C392.352600,382.537170 390.621796,379.942688 388.668701,377.042419 z&quot;/&gt;
  &lt;path fill=&quot;#8F8B8B&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M377.268585,378.571716 C372.113251,374.778412 367.267578,371.146637 362.421936,367.514862 C368.092834,370.440704 374.826019,371.969757 377.268585,378.571716 z&quot;/&gt;
  &lt;path fill=&quot;#8F8B8B&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M379.477356,379.515350 C379.494598,379.536987 379.460144,379.493713 379.477356,379.515350 z&quot;/&gt;
  &lt;path fill=&quot;#35344B&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M428.854187,417.572205 C424.270203,415.371765 421.732727,411.818085 423.138763,407.433044 C424.059845,404.560455 426.830078,401.090729 429.489655,400.299072 C432.168335,399.501801 436.322876,400.906799 438.767365,402.753998 C442.064758,405.245667 442.195465,409.474884 440.200195,413.173126 C437.851715,417.525970 433.964935,418.812408 428.854187,417.572205 z&quot;/&gt;
  &lt;path fill=&quot;#E4CBDC&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M204.006561,452.013977 C203.574188,453.273499 203.452682,454.847198 202.614655,455.770630 C201.615936,456.871124 200.050247,457.538727 198.612991,458.086151 C198.346558,458.187622 196.912781,456.593536 197.069366,456.189392 C197.623108,454.760101 198.423233,453.270142 199.547852,452.275909 C200.239807,451.664246 201.691925,451.912537 202.894989,451.365967 C202.987259,450.957275 202.943802,450.969360 202.738098,451.330780 C203.039413,451.802948 203.546417,451.913696 204.053406,452.024414 C204.053406,452.024445 204.000168,452.040192 204.006561,452.013977 z&quot;/&gt;
  &lt;path fill=&quot;#1C1C1C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M204.237030,451.673859 C203.546417,451.913696 203.039413,451.802948 202.749664,451.307526 C203.451492,451.056335 203.936066,451.189819 204.237030,451.673859 z&quot;/&gt;
  &lt;path fill=&quot;#4A7047&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M130.630463,288.352051 C129.941925,286.535339 128.732361,284.481781 129.314743,283.351654 C133.345276,275.530273 137.757080,267.905731 142.028244,260.207855 C143.506042,257.544434 145.218750,256.080139 148.412704,257.988770 C158.392746,263.952576 168.414856,269.847778 178.487000,275.654541 C181.353806,277.307312 182.072052,278.846924 180.154968,281.958588 C175.626968,289.308075 171.436035,296.869080 167.243774,304.419495 C165.662888,307.266663 164.099091,308.234924 160.948746,306.313446 C151.024399,300.260284 140.953079,294.448029 130.630463,288.352051 M145.757736,287.297943 C144.757965,289.094940 142.631699,290.965454 145.578094,292.764526 C151.362473,296.296600 157.230225,299.692047 163.466583,303.382599 C168.212448,295.164917 172.657608,287.467896 177.341263,279.357910 C171.130676,275.663849 165.504913,272.145874 159.661819,269.036224 C158.831436,268.594299 156.353134,269.748016 155.649048,270.824707 C152.280167,275.976318 149.259705,281.355713 145.757736,287.297943 M151.876038,264.434082 C146.322433,261.165375 146.250229,261.121704 142.849762,266.742523 C140.010254,271.436035 137.436523,276.290100 134.606552,280.989624 C133.120102,283.458008 132.553894,285.178223 135.727020,287.035187 C138.675613,288.760773 140.584473,289.330933 142.508179,285.861176 C145.732285,280.045837 149.298645,274.420044 152.511154,268.598724 C153.046158,267.629242 152.517715,266.072968 151.876038,264.434082 z&quot;/&gt;
  &lt;path fill=&quot;#1C1D1C&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M145.936584,286.976074 C149.259705,281.355713 152.280167,275.976318 155.649048,270.824707 C156.353134,269.748016 158.831436,268.594299 159.661819,269.036224 C165.504913,272.145874 171.130676,275.663849 177.341263,279.357910 C172.657608,287.467896 168.212448,295.164917 163.466583,303.382599 C157.230225,299.692047 151.362473,296.296600 145.578094,292.764526 C142.631699,290.965454 144.757965,289.094940 145.936584,286.976074 z&quot;/&gt;
  &lt;path fill=&quot;#557F5E&quot; opacity=&quot;1.000000&quot; stroke=&quot;none&quot; d=&quot; M152.178375,264.610962 C152.517715,266.072968 153.046158,267.629242 152.511154,268.598724 C149.298645,274.420044 145.732285,280.045837 142.508179,285.861176 C140.584473,289.330933 138.675613,288.760773 135.727020,287.035187 C132.553894,285.178223 133.120102,283.458008 134.606552,280.989624 C137.436523,276.290100 140.010254,271.436035 142.849762,266.742523 C146.250229,261.121704 146.322433,261.165375 152.178375,264.610962 z&quot;/&gt;
&lt;/svg&gt;</file><file path="DisCatSharp.sln">Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.31911.260
MinimumVisualStudioVersion = 10.0.40219.1
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp&quot;, &quot;DisCatSharp\DisCatSharp.csproj&quot;, &quot;{EB3D8310-DFAD-4295-97F9-82E253647583}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.VoiceNext&quot;, &quot;DisCatSharp.VoiceNext\DisCatSharp.VoiceNext.csproj&quot;, &quot;{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Solution Items&quot;, &quot;Solution Items&quot;, &quot;{4255B64D-92EC-46B3-BC3B-ED2C3A8073EE}&quot;
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitattributes = .gitattributes
		.gitignore = .gitignore
		BUILDING.md = BUILDING.md
		CONTRIBUTING.md = CONTRIBUTING.md
		LICENSE.md = LICENSE.md
		README.md = README.md
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.CommandsNext&quot;, &quot;DisCatSharp.CommandsNext\DisCatSharp.CommandsNext.csproj&quot;, &quot;{C8ED55FB-E028-468D-955F-1534C20274EF}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Interactivity&quot;, &quot;DisCatSharp.Interactivity\DisCatSharp.Interactivity.csproj&quot;, &quot;{DD32BEC3-0189-479F-86DC-CCF95E5634A9}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;.nuget&quot;, &quot;.nuget&quot;, &quot;{F953F5D0-F0C9-41E6-ADBF-60A76D295899}&quot;
	ProjectSection(SolutionItems) = preProject
		.nuget\NuGet.config = .nuget\NuGet.config
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Build Items&quot;, &quot;Build Items&quot;, &quot;{84464D70-687B-40A8-836D-C4F737698969}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;.github&quot;, &quot;.github&quot;, &quot;{430C28D8-5F85-4D6E-AA68-211549435245}&quot;
	ProjectSection(SolutionItems) = preProject
		.github\CODEOWNERS = .github\CODEOWNERS
		.github\labeler.yml = .github\labeler.yml
		.github\pull_request_template.md = .github\pull_request_template.md
		.github\SECURITY.md = .github\SECURITY.md
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.VoiceNext.Natives&quot;, &quot;DisCatSharp.VoiceNext.Natives\DisCatSharp.VoiceNext.Natives.csproj&quot;, &quot;{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Common&quot;, &quot;DisCatSharp.Common\DisCatSharp.Common.csproj&quot;, &quot;{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.ApplicationCommands&quot;, &quot;DisCatSharp.ApplicationCommands\DisCatSharp.ApplicationCommands.csproj&quot;, &quot;{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Configuration&quot;, &quot;DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot;, &quot;{603287D3-1EF2-47F1-A611-C7F25869DE14}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Configuration.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.Configuration.Tests\DisCatSharp.Configuration.Tests.csproj&quot;, &quot;{E15E88B4-63AD-42DE-B685-D31697C62194}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting&quot;, &quot;DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot;, &quot;{72CCE5D5-926B-432A-876A-065FA2BC9B7B}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.Hosting.Tests\DisCatSharp.Hosting.Tests.csproj&quot;, &quot;{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting.DependencyInjection&quot;, &quot;DisCatSharp.Hosting.DependencyInjection\DisCatSharp.Hosting.DependencyInjection.csproj&quot;, &quot;{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Experimental&quot;, &quot;DisCatSharp.Experimental\DisCatSharp.Experimental.csproj&quot;, &quot;{CF03EADC-E178-45B3-BD72-B6F70B625C8F}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;workflows&quot;, &quot;workflows&quot;, &quot;{D911BF2D-523E-4504-935D-AEDA353305D8}&quot;
	ProjectSection(SolutionItems) = preProject
		.github\workflows\build.yml = .github\workflows\build.yml
		.github\workflows\codeql-analysis.yml = .github\workflows\codeql-analysis.yml
		.github\workflows\create_diagram.yml = .github\workflows\create_diagram.yml
		.github\workflows\documentation.yml = .github\workflows\documentation.yml
		.github\workflows\documentation_test.yml = .github\workflows\documentation_test.yml
		.github\workflows\internal-release.yml = .github\workflows\internal-release.yml
		.github\workflows\labeler.yml = .github\workflows\labeler.yml
		.github\workflows\public-dev-release.yml = .github\workflows\public-dev-release.yml
		.github\workflows\release.yml = .github\workflows\release.yml
		.github\workflows\sentry.yml = .github\workflows\sentry.yml
		.github\workflows\tweet.yml = .github\workflows\tweet.yml
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Targets&quot;, &quot;Targets&quot;, &quot;{4A7E065C-5EAF-4AD0-8002-306FCEEC946C}&quot;
	ProjectSection(SolutionItems) = preProject
		DisCatSharp.Targets\DisCatSharp.targets = DisCatSharp.Targets\DisCatSharp.targets
		DisCatSharp.Targets\InternalsVisibleTo.targets = DisCatSharp.Targets\InternalsVisibleTo.targets
		DisCatSharp.Targets\Library.targets = DisCatSharp.Targets\Library.targets
		DisCatSharp.Targets\NuGet.targets = DisCatSharp.Targets\NuGet.targets
		DisCatSharp.Targets\Package.targets = DisCatSharp.Targets\Package.targets
		DisCatSharp.Targets\TestProject.targets = DisCatSharp.Targets\TestProject.targets
		DisCatSharp.Targets\Version.targets = DisCatSharp.Targets\Version.targets
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Tools&quot;, &quot;Tools&quot;, &quot;{11D25C98-6D11-412C-8016-BE070315326F}&quot;
	ProjectSection(SolutionItems) = preProject
		DisCatSharp.Tools\DisCatSharp.ruleset = DisCatSharp.Tools\DisCatSharp.ruleset
		DisCatSharp.Tools\pack-docs.ps1 = DisCatSharp.Tools\pack-docs.ps1
		DisCatSharp.Tools\rebuild-lib.ps1 = DisCatSharp.Tools\rebuild-lib.ps1
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.EventHandlers.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.EventHandlers.Tests\DisCatSharp.EventHandlers.Tests.csproj&quot;, &quot;{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Tests&quot;, &quot;Tests&quot;, &quot;{267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.SafetyTests&quot;, &quot;DisCatSharp.Tests\SafetyTests\DisCatSharp.SafetyTests.csproj&quot;, &quot;{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Lavalink&quot;, &quot;DisCatSharp.Lavalink\DisCatSharp.Lavalink.csproj&quot;, &quot;{1ADC1D06-3DB8-4741-B740-13161B40CBA3}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.ApplicationCommands.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.ApplicationCommands.Tests\DisCatSharp.ApplicationCommands.Tests.csproj&quot;, &quot;{B4837A35-F5D1-4CF0-941B-961407E3CC36}&quot;
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Release|Any CPU.Build.0 = Release|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Release|Any CPU.Build.0 = Release|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Release|Any CPU.Build.0 = Release|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Release|Any CPU.Build.0 = Release|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Release|Any CPU.Build.0 = Release|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Release|Any CPU.Build.0 = Release|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Release|Any CPU.Build.0 = Release|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Release|Any CPU.Build.0 = Release|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Release|Any CPU.Build.0 = Release|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Release|Any CPU.Build.0 = Release|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Release|Any CPU.Build.0 = Release|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Release|Any CPU.Build.0 = Release|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Release|Any CPU.Build.0 = Release|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Release|Any CPU.Build.0 = Release|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Release|Any CPU.Build.0 = Release|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Release|Any CPU.Build.0 = Release|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{E15E88B4-63AD-42DE-B685-D31697C62194} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{D911BF2D-523E-4504-935D-AEDA353305D8} = {430C28D8-5F85-4D6E-AA68-211549435245}
		{4A7E065C-5EAF-4AD0-8002-306FCEEC946C} = {84464D70-687B-40A8-836D-C4F737698969}
		{11D25C98-6D11-412C-8016-BE070315326F} = {84464D70-687B-40A8-836D-C4F737698969}
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{B4837A35-F5D1-4CF0-941B-961407E3CC36} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {23F3A981-51B8-4285-A38C-3267F1D25FE7}
	EndGlobalSection
EndGlobal</file><file path="DisCatSharp.Targets/DisCatSharp.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;Authors&gt;AITSYS, DisCatSharp, DisCatSharp Contributors&lt;/Authors&gt;
		&lt;Company&gt;AITSYS&lt;/Company&gt;
		&lt;GeneratePackageOnBuild&gt;False&lt;/GeneratePackageOnBuild&gt;
		&lt;PackageProjectUrl&gt;https://docs.dcs.aitsys.dev&lt;/PackageProjectUrl&gt;
		&lt;RepositoryUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/RepositoryUrl&gt;
		&lt;RepositoryType&gt;Git&lt;/RepositoryType&gt;
		&lt;PackageIcon&gt;logo-pride.png&lt;/PackageIcon&gt;
		&lt;PackageLicenseExpression /&gt;
		&lt;PackageLicenseFile&gt;LICENSE.md&lt;/PackageLicenseFile&gt;
		&lt;PackageRequireLicenseAcceptance&gt;True&lt;/PackageRequireLicenseAcceptance&gt;
		&lt;RunAnalyzersDuringBuild&gt;False&lt;/RunAnalyzersDuringBuild&gt;
		&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\LICENSE.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\RELEASENOTES.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\DisCatSharp.Logos\logo-pride.png&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/InternalsVisibleTo.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;ItemGroup&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.ApplicationCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.CommandsNext&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Common&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Configuration&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Configuration.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.EventHandlers.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting.DependencyInjection&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Interactivity&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Lavalink&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.LavalinkV1&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Phabricator&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Support&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.SafetyTests.Internal&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.ApplicationCommands.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.VoiceNext&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.VoiceNext.Natives&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.DevTools&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.DocsGenerator&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.StaffApps&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Experimental&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.OAuth2Web&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.TwoFactorCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.SimpleMusicCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Nyaw&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;MikuSharp&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Microsoft.DocAsCode&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Microsoft.DocAsCode.Metadata.ManagedReference&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;ProjectMakoto&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;SidePlus_AuthBot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;SidePlus_Helper&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Cache_Design&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Bots.DocBot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Bots.DocBot.Bot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;BeluBOT&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;BeluGANG&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;AITSYS.Pycord&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Library.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
		&lt;TargetFrameworks&gt;net8.0;net9.0&lt;/TargetFrameworks&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;InvariantGlobalization&gt;false&lt;/InvariantGlobalization&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;AccelerateBuildsInVisualStudio&gt;true&lt;/AccelerateBuildsInVisualStudio&gt;
		&lt;CodeAnalysisRuleSet&gt;$(MSBuildProjectDirectory)/../DisCatSharp.Tools/DisCatSharp.ruleset&lt;/CodeAnalysisRuleSet&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;NETSDK1188;CS8600;CS8625;CS8601;CS8604;CS0219;CS8618;CS8619;CS8597;CS8603;CS8602;CS8765;CS8632;CS8633;CS8714;CS8629;CS8767;CS8620;CS0649&lt;/NoWarn&gt;
		&lt;GenerateDocumentationFile&gt;True&lt;/GenerateDocumentationFile&gt;
		&lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/NuGet.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
		&lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;
		&lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;
		&lt;DebugType&gt;Portable&lt;/DebugType&gt;
		&lt;AllowedOutputExtensionsInPackageBuildOutputFolder&gt;$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb&lt;/AllowedOutputExtensionsInPackageBuildOutputFolder&gt;
		&lt;PackageReleaseNotes&gt;$([System.IO.File]::ReadAllText(&quot;$(MSBuildProjectDirectory)/../RELEASENOTES.md&quot;))&lt;/PackageReleaseNotes&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(TF_BUILD)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(CI)&apos; == &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; != &apos;true&apos; And &apos;$(TF_BUILD)&apos; != &apos;true&apos; And &apos;$(CI)&apos; != &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;false&lt;/ContinuousIntegrationBuild&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup
		Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos; And &apos;$(SENTRY_AUTH_TOKEN)&apos; != &apos;&apos;&quot;&gt;
		&lt;SentryOrg&gt;aitsys&lt;/SentryOrg&gt;
		&lt;SentryProject&gt;discatsharp&lt;/SentryProject&gt;
		&lt;SentryUploadSymbols&gt;true&lt;/SentryUploadSymbols&gt;
		&lt;SentryUploadSources&gt;true&lt;/SentryUploadSources&gt;
		&lt;UseSentryCLI&gt;true&lt;/UseSentryCLI&gt;
		&lt;SentryCreateRelease&gt;true&lt;/SentryCreateRelease&gt;
		&lt;SentrySetCommits&gt;true&lt;/SentrySetCommits&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Package.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;NETSDK1188;CS8600;CS8625;CS8601;CS8604;CS0219;CS8618;CS8619;CS8597;CS8603;CS8602;CS8765;CS8632;CS8633;CS8714;CS8629;CS8767;CS8620&lt;/NoWarn&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Debug&apos;&quot;&gt;
		&lt;Optimize&gt;False&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Release&apos;&quot;&gt;
		&lt;Optimize&gt;True&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/TestProject.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
		&lt;TargetFrameworks&gt;net8.0;net9.0&lt;/TargetFrameworks&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;AccelerateBuildsInVisualStudio&gt;true&lt;/AccelerateBuildsInVisualStudio&gt;
		&lt;CodeAnalysisRuleSet&gt;$(MSBuildProjectDirectory)/../../DisCatSharp.Tools/DisCatSharp.ruleset&lt;/CodeAnalysisRuleSet&gt;
		&lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
		&lt;GenerateDocumentationFile&gt;false&lt;/GenerateDocumentationFile&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;CS0271;CS0414&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Version.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;VersionPrefix&gt;10.7.0&lt;/VersionPrefix&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; != &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)-$(BuildNumber)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/AppCommandSplitPartialTests.cs">public class AppCommandSplitPartialTests(ITestOutputHelper testOutputHelper)
	private readonly DiscordClient _client = new(new()
	internal readonly ReadOnlyDictionary&lt;ulong, DiscordGuild&gt; Guilds = new Dictionary&lt;ulong, DiscordGuild&gt;().AsReadOnly();
	public async Task TestSplitRegistrationAndProperLocalRegistration()
		var extension = this._client.UseApplicationCommands(new()
		await this._client.ReadyEv.InvokeAsync(this._client, new(null!));
			await Task.Delay(1);
		Assert.True(regFired);
		var commands = extension.RegisteredCommands.ToList();
		Assert.Single(commands);
		Assert.NotNull(commands.FirstOrDefault(x =&gt; x.Key is null).Value);
		Assert.Single(commands.FirstOrDefault(x =&gt; x.Key is null).Value);
		var command = commands.First(x =&gt; x.Key is null).Value[0];
		Assert.Equal(&quot;test&quot;, command.Name);
		Assert.Equal(&quot;test&quot;, command.Description);
		Assert.NotNull(attributes);
		Assert.Single(attributes);
		Assert.NotNull(command.Options);
		Assert.All(command.Options, x =&gt; Assert.True(x.Type is ApplicationCommandOptionType.SubCommand));
		Assert.Contains(command.Options, x =&gt; x.Name is &quot;test_1&quot;);
		Assert.Contains(command.Options, x =&gt; x.Name is &quot;test_2&quot;);
		Assert.NotNull(command.Options.First(x =&gt; x.Name is &quot;test_2&quot;).Options);
		var option = command.Options.First(x =&gt; x.Name is &quot;test_2&quot;).Options;
		Assert.Contains(option!, y =&gt; y is { Name: &quot;user&quot;, Required: false, Type: ApplicationCommandOptionType.User });
		testOutputHelper.WriteLine(&quot;Command registration successful&quot;);</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/DisCatSharp.ApplicationCommands.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.ApplicationCommands\DisCatSharp.ApplicationCommands.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Folder Include=&quot;SplitTest\&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part0.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part1.cs">internal partial class TestCommand : ApplicationCommandsModule
	internal static async Task Test1Async(InteractionContext ctx)
		await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
			new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Meow&quot;));</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part2.cs">internal partial class TestCommand
	internal static async Task Test2Async(InteractionContext ctx, [Option(&quot;user&quot;, &quot;User to tag&quot;)] DiscordUser? user = null)
		await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
			new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Nya &quot; + user.Mention));</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/ConfigurationExtensionTests.cs">public class ConfigurationExtensionTests
	private class SampleClass
	private class ClassWithArray
	private class ClassWithEnumerable
	private class ClassWithList
	private class SampleClass2(string value)
		public TimeSpan Timeout { get; set; } = TimeSpan.FromMinutes(7);
	private IConfiguration EnumerableTestConfiguration() =&gt;
		new ConfigurationBuilder()
			.AddJsonFile(&quot;enumerable-test.json&quot;)
			.Build();
	private IConfiguration HasSectionWithSuffixConfiguration() =&gt;
			.AddJsonFile(&quot;section-with-suffix.json&quot;)
	private IConfiguration HasSectionNoSuffixConfiguration() =&gt;
			.AddJsonFile(&quot;section-no-suffix.json&quot;)
	private IConfiguration BasicDiscordConfiguration() =&gt; new ConfigurationBuilder()
		.AddJsonFile(&quot;default-discord.json&quot;)
	private IConfiguration DiscordIntentsConfig() =&gt; new ConfigurationBuilder()
		.AddJsonFile(&quot;intents-discord.json&quot;)
	private IConfiguration DiscordHaphazardConfig() =&gt; new ConfigurationBuilder()
		.AddJsonFile(&quot;haphazard-discord.json&quot;)
	private IConfiguration SampleConfig() =&gt; new ConfigurationBuilder()
		.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;
	private IConfiguration SampleClass2Configuration_Default() =&gt; new ConfigurationBuilder()
	private IConfiguration SampleClass2Configuration_Change() =&gt; new ConfigurationBuilder()
	private IConfiguration SampleClass2EnumerableTest() =&gt; new ConfigurationBuilder()
	private IConfiguration SampleClass2ArrayTest() =&gt; new ConfigurationBuilder()
	private IConfiguration SampleClass2ListTest() =&gt; new ConfigurationBuilder()
	public void TestExtractDiscordConfig_Intents()
		var source = this.DiscordIntentsConfig();
		Assert.Equal(expected, config.Intents);
	public void TestExtractDiscordConfig_Haphazard()
		var source = this.DiscordHaphazardConfig();
		Assert.Equal(expectedIntents, config.Intents);
		Assert.True(config.MobileStatus);
		Assert.Equal(1000, config.LargeThreshold);
		Assert.Equal(TimeSpan.FromHours(10), config.HttpTimeout);
	public void TestExtractDiscordConfig_Default()
		var source = this.BasicDiscordConfiguration();
		Assert.Equal(&quot;1234567890&quot;, config.Token);
		Assert.Equal(TokenType.Bot, config.TokenType);
		Assert.Equal(LogLevel.Information, config.MinimumLogLevel);
		Assert.True(config.UseRelativeRatelimit);
		Assert.Equal(&quot;yyyy-MM-dd HH:mm:ss zzz&quot;, config.LogTimestampFormat);
		Assert.Equal(250, config.LargeThreshold);
		Assert.True(config.AutoReconnect);
		Assert.Equal(123123, config.ShardId);
		Assert.Equal(GatewayCompressionLevel.Stream, config.GatewayCompressionLevel);
		Assert.Equal(1024, config.MessageCacheSize);
		Assert.Equal(TimeSpan.FromSeconds(20), config.HttpTimeout);
		Assert.False(config.ReconnectIndefinitely);
		Assert.True(config.AlwaysCacheMembers);
		Assert.Equal(DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent, config.Intents);
		Assert.False(config.MobileStatus);
		Assert.Equal(config.ApiChannel, ApiChannel.Stable);
		Assert.False(config.AutoRefreshChannelCache);
	public void TestSection()
		var source = this.SampleConfig();
		Assert.Equal(200, config.Amount);
		Assert.Equal(&quot;test@gmail.com&quot;, config.Email);
	public void TestExtractConfig_V2_Default()
		var source = this.SampleClass2Configuration_Default();
		var config = (SampleClass2)source.ExtractConfig(&quot;SampleClass&quot;, () =&gt; new SampleClass2(&quot;Test&quot;), null);
		Assert.Equal(TimeSpan.FromMinutes(7), config.Timeout);
		Assert.Equal(&quot;Test&quot;, config.ConstructorValue);
		Assert.Equal(&quot;Sample&quot;, config.Name);
	public void TestExtractConfig_V2_Change()
		var source = this.SampleClass2Configuration_Change();
		var config = (SampleClass2)source.ExtractConfig(&quot;SampleClass&quot;, () =&gt; new SampleClass2(&quot;Test123&quot;), null);
		var span = new TimeSpan(0, 1, 30, 0);
		Assert.Equal(span, config.Timeout);
		Assert.Equal(&quot;Test123&quot;, config.ConstructorValue);
	public void TestExtractConfig_V3_Default()
			(SampleClass2)new ConfigSection(ref source, &quot;SampleClass&quot;, null).ExtractConfig(() =&gt;
				new SampleClass2(&quot;Meow&quot;));
		Assert.Equal(&quot;Meow&quot;, config.ConstructorValue);
	public void TestExtractConfig_V3_Change()
	public void TestExtractConfig_Enumerable()
		var source = this.EnumerableTestConfiguration();
			(ClassWithEnumerable)new ConfigSection(ref source, &quot;ClassWithEnumerable&quot;, null).ExtractConfig(() =&gt;
				new ClassWithEnumerable());
		Assert.NotNull(config.Values);
		Assert.Equal(3, config.Values.Count());
		Assert.NotNull(config.Strings);
	public void TestExtractConfig_Array()
			(ClassWithArray)new ConfigSection(ref source, &quot;ClassWithArray&quot;, null).ExtractConfig(() =&gt;
				new ClassWithArray());
		Assert.Equal(3, config.Values.Length);
	public void TestExtractConfig_List()
			(ClassWithList)new ConfigSection(ref source, &quot;ClassWithList&quot;, null).ExtractConfig(() =&gt;
				new ClassWithList());
		Assert.Equal(3, config.Values.Count);
	public void TestHasSectionWithSuffix()
		var source = this.HasSectionWithSuffixConfiguration();
		Assert.True(source.HasSection(&quot;DiscordConfiguration&quot;));
		Assert.False(source.HasSection(&quot;Discord&quot;));
		Assert.False(source.HasSection(&quot;DiscordConfiguration&quot;, null));
	public void TestHasSectionNoSuffix()
		var source = this.HasSectionNoSuffixConfiguration();
		Assert.True(source.HasSection(&quot;Discord&quot;));
		Assert.False(source.HasSection(&quot;DiscordConfiguration&quot;));
		Assert.False(source.HasSection(&quot;Discord&quot;, null));</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/DisCatSharp.Configuration.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Json&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;enumerable-test.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;section-with-suffix.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;section-no-suffix.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;default-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;intents-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;haphazard-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/BasicEventHandlerTests.cs">public class BasicEventHandlerTests
	private readonly DiscordClient _client = new(new()
	public void TestUtility()
		Assert.False(this.IsEventRegistered(nameof(this._client.MessageCreated)));
		Assert.True(this.IsEventRegistered(nameof(this._client.MessageCreated)));
		Assert.Throws&lt;ArgumentException&gt;(() =&gt; this.IsEventRegistered(&quot;&quot;));
		Assert.Throws&lt;ArgumentException&gt;(() =&gt; this.IsEventRegistered(&quot;ThisEventDoesNotExist&quot;));
	public void TestUnregistrationWithoutRegistration()
		this._client.UnregisterEventHandlers(Assembly.GetExecutingAssembly());
		Assert.False(this.IsEventRegistered(nameof(this._client.MessageDeleted)));
	public void TestSimpleRegistration()
		Assert.True(this.IsEventRegistered(nameof(this._client.MessageDeleted)));
		Assert.False(this.IsEventRegistered(nameof(this._client.ChannelCreated)));
		Assert.True(this.IsEventRegistered(nameof(this._client.ChannelDeleted)));
		Assert.False(this.IsEventRegistered(nameof(this._client.ChannelDeleted)));
	public void TestAssemblyRegistration()
		this._client.RegisterEventHandlers(Assembly.GetExecutingAssembly());
	public void TestInvalidHandlers()
	private bool IsEventRegistered(string name)
			throw new ArgumentException(&quot;name mustn&apos;t be empty&quot;);
		name = &quot;_&quot; + char.ToLower(name[0]) + name[1..];
		var asyncEvent = typeof(DiscordClient).GetField(name, BindingFlags.NonPublic | BindingFlags.Instance)?.GetValue(this._client);
		dynamic handlers = asyncEvent?.GetType().GetField(&quot;_handlers&quot;, BindingFlags.NonPublic | BindingFlags.Instance)?.GetValue(asyncEvent)
		                   ?? throw new ArgumentException($&quot;Unknown event \&quot;{name}\&quot;&quot;);
	private class HandlerA
	private class HandlerB
		public Task MessageCreated(DiscordClient sender, MessageCreateEventArgs args) =&gt; Task.CompletedTask;
		private static Task SomeEvent(DiscordClient sender, MessageDeleteEventArgs args) =&gt; Task.CompletedTask;
	private static class HandlerC
		public static Task MessageCreated(DiscordClient sender, MessageCreateEventArgs args) =&gt; Task.CompletedTask;
	public abstract class HandlerD
		public Task ChannelCreated(DiscordClient sender, ChannelCreateEventArgs args) =&gt; Task.CompletedTask;
		public static Task ChannelDeleted(DiscordClient sender, ChannelDeleteEventArgs args) =&gt; Task.CompletedTask;
	private class BadHandlerA
		public int MessageCreated(object? obj, dynamic dynamic) =&gt; 1;
	private abstract class BadHandlerB
		private static Task ThisEventDoesNotExist() =&gt; Task.CompletedTask;</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/DisCatSharp.EventHandlers.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/EventsEnumIntegrityTests.cs">public class EventsEnumIntegrityTests
	private void TestEnumToEvent()
		foreach (var value in typeof(DiscordEvent).GetEnumValues())
			Assert.NotNull(typeof(DiscordClient).GetEvent(value.ToString()!));
	private void TestEventToEnum()
		var enumNames = typeof(DiscordEvent).GetEnumNames().ToHashSet();
		foreach (var evtn in typeof(DiscordClient).GetEvents())
			Assert.Contains(evtn.Name, enumNames);</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/ServiceProviderTests.cs">public class ServiceProviderTests
	public void Test()
		var poorClient = new DiscordClient(new()
		var richClient = new DiscordClient(new()
			ServiceProvider = new ServiceCollection().AddSingleton&lt;Resource&gt;().BuildServiceProvider()
	private class Resource
	private class Handler</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/DisCatSharp.Hosting.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Json&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Interactivity\DisCatSharp.Interactivity.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Lavalink\DisCatSharp.Lavalink.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;interactivity-lavalink.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;interactivity-different-section.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;lavalink-different-section.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;BotTwo.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/ExtensionTests.cs">public class HostExtensionTests
	private Dictionary&lt;string, string?&gt; DefaultDiscord() =&gt;
	public IConfiguration DiscordInteractivityConfiguration() =&gt; new ConfigurationBuilder()
		.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;(this.DefaultDiscord())
		.Build();
	public IConfiguration DiscordOnlyConfiguration() =&gt; new ConfigurationBuilder()
		.AddInMemoryCollection(this.DefaultDiscord())
	public IConfiguration DiscordInteractivityAndLavaLinkConfiguration() =&gt; new ConfigurationBuilder()
		.AddJsonFile(&quot;interactivity-lavalink.json&quot;)
	public void DiscoverExtensions_Interactivity()
		var source = this.DiscordInteractivityConfiguration();
		var discovered = source.FindImplementedExtensions();
		Assert.Single(discovered);
		var item = discovered.First();
		Assert.Equal(typeof(InteractivityConfiguration), item.Value.ConfigType);
		Assert.Equal(typeof(InteractivityExtension), item.Value.ImplementationType);
		Assert.Equal(&quot;InteractivityExtension&quot;, item.Key);
	public void DiscoverExtensions_InteractivityAndLavaLink()
		var source = this.DiscordInteractivityAndLavaLinkConfiguration();
		Assert.Equal(2, discovered.Count);
		var first = discovered.First();
		var last = discovered.Last();
		Assert.Equal(typeof(InteractivityConfiguration), first.Value.ConfigType);
		Assert.Equal(typeof(InteractivityExtension), first.Value.ImplementationType);
		Assert.Equal(&quot;InteractivityExtension&quot;, first.Key, true);
		Assert.Equal(typeof(LavalinkConfiguration), last.Value.ConfigType);
		Assert.Equal(typeof(LavalinkExtension), last.Value.ImplementationType);
		Assert.Equal(&quot;LavalinkExtension&quot;, last.Key, true);</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/HostTests.cs">public sealed class Bot : DiscordHostedService
		this.ConfigureAsync().GetAwaiter().GetResult();
		this.ConfigureExtensionsAsync().GetAwaiter().GetResult();
public sealed class MyCustomBot : DiscordHostedService
public interface IBotTwoService : IDiscordHostedService
	string GiveMeAResponse();
public sealed class BotTwoService : DiscordHostedService, IBotTwoService
	public string GiveMeAResponse() =&gt; &quot;I&apos;m working&quot;;
public class HostTests
	private Dictionary&lt;string, string?&gt; DefaultDiscord() =&gt;
	public Dictionary&lt;string, string?&gt; DiscordInteractivity() =&gt; new(this.DefaultDiscord())
	public Dictionary&lt;string, string?&gt; DiscordInteractivityAndLavalink() =&gt; new(this.DefaultDiscord())
	private IHostBuilder Create(Dictionary&lt;string, string?&gt; configValues) =&gt;
		Host.CreateDefaultBuilder()
			.ConfigureLogging(logging =&gt;
				logging.ClearProviders();
				logging.AddConsole();
			.ConfigureServices(services =&gt; services.AddSingleton&lt;IDiscordHostedService, Bot&gt;())
			.ConfigureHostConfiguration(builder =&gt; builder.AddInMemoryCollection(configValues));
	private IHostBuilder Create(string filename) =&gt;
			.ConfigureServices(services =&gt; services.AddSingleton&lt;IDiscordHostedService, MyCustomBot&gt;())
			.ConfigureHostConfiguration(builder =&gt; builder.AddJsonFile(filename));
	private IHostBuilder Create&lt;TInterface, TBot&gt;(string filename)
		where TInterface : class, IDiscordHostedService
		where TBot : class, TInterface, IDiscordHostedService =&gt;
			.ConfigureServices(services =&gt; services.AddSingleton&lt;TInterface, TBot&gt;())
	public void TestBotCustomInterface()
			host = this.Create&lt;IBotTwoService, BotTwoService&gt;(&quot;BotTwo.json&quot;).Build();
			Assert.NotNull(service);
			var response = service.GiveMeAResponse();
			Assert.Equal(&quot;I&apos;m working&quot;, response);
	public void TestDifferentSection_InteractivityOnly()
			host = this.Create(&quot;interactivity-different-section.json&quot;).Build();
			Assert.NotNull(service.Client);
			Assert.Null(service.Client.GetExtension&lt;LavalinkExtension&gt;());
			Assert.Equal(intents, service.Client.Intents);
			Assert.NotNull(interactivity);
			Assert.NotNull(host.Services);
			Assert.NotNull(service.Client.ServiceProvider);
	public void TestDifferentSection_LavalinkOnly()
			host = this.Create(&quot;lavalink-different-section.json&quot;).Build();
			Assert.NotNull(service.Client.GetExtension&lt;LavalinkExtension&gt;());
			Assert.Null(service.Client.GetExtension&lt;InteractivityExtension&gt;());
	public void TestNoExtensions()
			host = this.Create(this.DefaultDiscord()).Build();
	public void TestInteractivityExtension()
			host = this.Create(this.DiscordInteractivity()).Build();
			Assert.NotNull(service.Client.GetExtension&lt;InteractivityExtension&gt;());
	public void TestInteractivityLavalinkExtensions()
			host = this.Create(this.DiscordInteractivityAndLavalink()).Build();</file><file path="DisCatSharp.Tests/SafetyTests/DisCatSharp.SafetyTests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;8.1.1&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Scripting&quot; Version=&quot;4.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/SafetyTests/HttpTest.cs">public class HttpTests
	public void BuiltInRestClientEnsureNoAuthorization()
		DiscordClient client = new(new()
		var action = () =&gt; client.RestClient.DefaultRequestHeaders.GetValues(&quot;Authorization&quot;).ToString();
		action.Should()
			.WithMessage(&quot;The given header was not found.&quot;);
		client.RestClient.DefaultRequestHeaders.Add(&quot;Authorization&quot;, &quot;not_so_secret_manual_token&quot;);
		var action2 = () =&gt; client.RestClient.DefaultRequestHeaders.GetValues(&quot;Authorization&quot;).ToString();
		action2.Should()</file><file path="DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/DisCatSharp.Analyzer.VSIX.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project ToolsVersion=&quot;15.0&quot; DefaultTargets=&quot;Build&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;VSToolsPath Condition=&quot;&apos;$(VSToolsPath)&apos; == &apos;&apos;&quot;&gt;$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)&lt;/VSToolsPath&gt;
    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
    &lt;TargetFrameworkProfile /&gt;
  &lt;/PropertyGroup&gt;
  &lt;Import Project=&quot;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&quot; Condition=&quot;Exists(&apos;$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props&apos;)&quot; /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=&quot; &apos;$(Configuration)&apos; == &apos;&apos; &quot;&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=&quot; &apos;$(Platform)&apos; == &apos;&apos; &quot;&gt;AnyCPU&lt;/Platform&gt;
    &lt;SchemaVersion&gt;2.0&lt;/SchemaVersion&gt;
    &lt;ProjectTypeGuids&gt;{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&lt;/ProjectTypeGuids&gt;
    &lt;ProjectGuid&gt;{E2AAF92A-5655-446D-ACBE-3D4EC88249BE}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
    &lt;RootNamespace&gt;DisCatSharp.Analyzer&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;DisCatSharp.Analyzer&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.7.2&lt;/TargetFrameworkVersion&gt;
    &lt;GeneratePkgDefFile&gt;true&lt;/GeneratePkgDefFile&gt;
    &lt;UseCodebase&gt;true&lt;/UseCodebase&gt;
    &lt;IncludeAssemblyInVSIXContainer&gt;true&lt;/IncludeAssemblyInVSIXContainer&gt;
    &lt;IncludeDebugSymbolsInVSIXContainer&gt;true&lt;/IncludeDebugSymbolsInVSIXContainer&gt;
    &lt;IncludeDebugSymbolsInLocalVSIXDeployment&gt;false&lt;/IncludeDebugSymbolsInLocalVSIXDeployment&gt;
    &lt;CopyBuildOutputToOutputDirectory&gt;true&lt;/CopyBuildOutputToOutputDirectory&gt;
    &lt;CopyOutputSymbolsToOutputDirectory&gt;true&lt;/CopyOutputSymbolsToOutputDirectory&gt;
    &lt;StartAction&gt;Program&lt;/StartAction&gt;
    &lt;StartProgram Condition=&quot;&apos;$(DevEnvDir)&apos; != &apos;&apos;&quot;&gt;$(DevEnvDir)devenv.exe&lt;/StartProgram&gt;
    &lt;StartArguments&gt;/rootsuffix Exp&lt;/StartArguments&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=&quot; &apos;$(Configuration)|$(Platform)&apos; == &apos;Debug|AnyCPU&apos; &quot;&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
    &lt;CopyVsixExtensionFiles&gt;False&lt;/CopyVsixExtensionFiles&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=&quot; &apos;$(Configuration)|$(Platform)&apos; == &apos;Release|AnyCPU&apos; &quot;&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;
    &lt;Compile Include=&quot;source.extension.cs&quot;&gt;
      &lt;AutoGen&gt;True&lt;/AutoGen&gt;
      &lt;DesignTime&gt;True&lt;/DesignTime&gt;
      &lt;DependentUpon&gt;source.extension.vsixmanifest&lt;/DependentUpon&gt;
    &lt;/Compile&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Content Include=&quot;LICENSE.md&quot;&gt;
      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
      &lt;IncludeInVSIX&gt;true&lt;/IncludeInVSIX&gt;
    &lt;/Content&gt;
    &lt;None Include=&quot;source.extension.vsixmanifest&quot;&gt;
      &lt;SubType&gt;Designer&lt;/SubType&gt;
      &lt;Generator&gt;VsixManifestGenerator&lt;/Generator&gt;
      &lt;LastGenOutput&gt;source.extension.cs&lt;/LastGenOutput&gt;
    &lt;/None&gt;
    &lt;Content Include=&quot;logo-pride.png&quot;&gt;
      &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
      &lt;IncludeInVSIX&gt;true&lt;/IncludeInVSIX&gt;
    &lt;/Content&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include=&quot;System&quot; /&gt;
    &lt;Reference Include=&quot;System.Design&quot; /&gt;
    &lt;Reference Include=&quot;System.ComponentModel.Composition&quot; /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Community.VisualStudio.VSCT&quot; Version=&quot;16.0.29.6&quot; PrivateAssets=&quot;all&quot; /&gt;
    &lt;PackageReference Include=&quot;Community.VisualStudio.Toolkit.17&quot; Version=&quot;17.0.527&quot; ExcludeAssets=&quot;Runtime&quot;&gt;
      &lt;IncludeAssets&gt;compile; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
    &lt;/PackageReference&gt;
    &lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot;&gt;
      &lt;Version&gt;10.6.6&lt;/Version&gt;
    &lt;/PackageReference&gt;
    &lt;PackageReference Include=&quot;Microsoft.VisualStudio.SDK&quot;&gt;
      &lt;Version&gt;17.7.37357&lt;/Version&gt;
    &lt;/PackageReference&gt;
    &lt;PackageReference Include=&quot;Microsoft.VSSDK.BuildTools&quot; Version=&quot;17.13.2126&quot;&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
    &lt;/PackageReference&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot;&gt;
      &lt;Project&gt;{DA33A3DA-DD7F-4E16-B503-79581CCEA974}&lt;/Project&gt;
      &lt;Name&gt;DisCatSharp.Analyzer&lt;/Name&gt;
      &lt;IncludeOutputGroupsInVSIX&gt;BuiltProjectOutputGroup%3bBuiltProjectOutputGroupDependencies%3bGetCopyToOutputDirectoryItems%3bSatelliteDllsProjectOutputGroup%3b&lt;/IncludeOutputGroupsInVSIX&gt;
      &lt;IncludeOutputGroupsInVSIXLocalOnly&gt;DebugSymbolsProjectOutputGroup%3b&lt;/IncludeOutputGroupsInVSIXLocalOnly&gt;
    &lt;/ProjectReference&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Folder Include=&quot;Resources\&quot; /&gt;
  &lt;/ItemGroup&gt;
  &lt;Import Project=&quot;$(MSBuildToolsPath)\Microsoft.CSharp.targets&quot; /&gt;
  &lt;Import Project=&quot;$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets&quot; Condition=&quot;&apos;$(VSToolsPath)&apos; != &apos;&apos;&quot; /&gt;
  &lt;!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  &lt;Target Name=&quot;BeforeBuild&quot;&gt;
  &lt;/Target&gt;
  &lt;Target Name=&quot;AfterBuild&quot;&gt;
  &lt;/Target&gt;
  --&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/LICENSE.md">The MIT License (MIT)

Copyright (c) 2021-2022 Aiko IT Systems

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</file><file path="DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/Properties/AssemblyInfo.cs">	public class IsExternalInit { }</file><file path="DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/source.extension.cs">    internal sealed partial class Vsix</file><file path="DisCatSharp.Tools/DisCatSharp.Analytics.VSIX/source.extension.vsixmanifest">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;PackageManifest Version=&quot;2.0.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/vsx-schema/2011&quot; xmlns:d=&quot;http://schemas.microsoft.com/developer/vsx-schema-design/2011&quot;&gt;
    &lt;Metadata&gt;
        &lt;Identity Id=&quot;DisCatSharp.Analyzer.a1051cd0-d47d-4397-9917-6a6b45737ea9&quot; Version=&quot;5.3&quot; Language=&quot;en-US&quot; Publisher=&quot;AITSYS&quot; /&gt;
        &lt;DisplayName&gt;DisCatSharp Analyzer&lt;/DisplayName&gt;
        &lt;Description xml:space=&quot;preserve&quot;&gt;DisCatSharp Analyzer Extension for Development&lt;/Description&gt;
        &lt;License&gt;LICENSE.md&lt;/License&gt;
        &lt;Icon&gt;logobig.png&lt;/Icon&gt;
        &lt;PreviewImage&gt;logobig.png&lt;/PreviewImage&gt;
        &lt;Tags&gt;DisCatSharp,Analyzer&lt;/Tags&gt;
        &lt;Preview&gt;true&lt;/Preview&gt;
    &lt;/Metadata&gt;
    &lt;Installation&gt;
        &lt;InstallationTarget Id=&quot;Microsoft.VisualStudio.Community&quot; Version=&quot;[17.0, 18.0)&quot;&gt;
            &lt;ProductArchitecture&gt;amd64&lt;/ProductArchitecture&gt;
        &lt;/InstallationTarget&gt;
    &lt;/Installation&gt;
    &lt;Dependencies&gt;
        &lt;Dependency Id=&quot;Microsoft.Framework.NDP&quot; DisplayName=&quot;Microsoft .NET Framework&quot; d:Source=&quot;Manual&quot; Version=&quot;[4.7,)&quot; /&gt;
    &lt;/Dependencies&gt;
    &lt;Prerequisites&gt;
        &lt;Prerequisite Id=&quot;Microsoft.VisualStudio.Component.CoreEditor&quot; Version=&quot;[17.0,)&quot; DisplayName=&quot;Visual Studio core editor&quot; /&gt;
        &lt;Prerequisite Id=&quot;Microsoft.VisualStudio.Component.Roslyn.LanguageServices&quot; Version=&quot;[17.0,)&quot; DisplayName=&quot;Roslyn Language Services&quot; /&gt;
    &lt;/Prerequisites&gt;
    &lt;Assets&gt;
        &lt;Asset Type=&quot;Microsoft.VisualStudio.VsPackage&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;%CurrentProject%&quot; Path=&quot;|%CurrentProject%;PkgdefProjectOutputGroup|&quot; /&gt;
        &lt;Asset Type=&quot;Microsoft.VisualStudio.Analyzer&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;DisCatSharp.Analyzer&quot; Path=&quot;|DisCatSharp.Analyzer|&quot; /&gt;
    &lt;/Assets&gt;
&lt;/PackageManifest&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;
		&lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
		&lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
		&lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Analyzer.Roselyn&lt;/PackageId&gt;
		&lt;Version&gt;6.2.5&lt;/Version&gt;
		&lt;PackageVersion&gt;6.2.5&lt;/PackageVersion&gt;
		&lt;Authors&gt;AITSYS&lt;/Authors&gt;
		&lt;PackageRequireLicenseAcceptance&gt;false&lt;/PackageRequireLicenseAcceptance&gt;
		&lt;Description&gt;DisCatSharp Analyzer&lt;/Description&gt;
		&lt;PackageReleaseNotes&gt;Various DisCatSharp Analyzers.&lt;/PackageReleaseNotes&gt;
		&lt;Copyright&gt;Copyright 2022-2024 AITSYS&lt;/Copyright&gt;
		&lt;PackageTags&gt;Analyzer, analyzers, DisCatSharp, dcs&lt;/PackageTags&gt;
		&lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
		&lt;NoPackageAnalysis&gt;true&lt;/NoPackageAnalysis&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;

		&lt;TargetsForTfmSpecificContentInPackage&gt;$(TargetsForTfmSpecificContentInPackage);AddNuGetDlls;_AddAnalyzersToOutput&lt;/TargetsForTfmSpecificContentInPackage&gt;

		&lt;ProduceReferenceAssembly&gt;false&lt;/ProduceReferenceAssembly&gt;

		&lt;Title&gt;DisCatSharp Analyzer&lt;/Title&gt;

		&lt;PackageIcon&gt;logo-pride.png&lt;/PackageIcon&gt;

		&lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;

		&lt;RepositoryType&gt;git&lt;/RepositoryType&gt;

		&lt;RepositoryUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/RepositoryUrl&gt;

		&lt;PackageProjectUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/PackageProjectUrl&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\..\..\DisCatSharp.Logos\logo-pride.png&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\..\..\LICENSE.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;README.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt;
		&lt;GenerateBindingRedirectsOutputType&gt;true&lt;/GenerateBindingRedirectsOutputType&gt;
		&lt;IncludeSymbols&gt;False&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
		&lt;PackageLicenseFile&gt;LICENSE.md&lt;/PackageLicenseFile&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)|$(Platform)&apos;==&apos;Debug|AnyCPU&apos;&quot;&gt;
		&lt;WarningLevel&gt;7&lt;/WarningLevel&gt;
		&lt;DebugType&gt;portable&lt;/DebugType&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)|$(Platform)&apos;==&apos;Release|AnyCPU&apos;&quot;&gt;
		&lt;WarningLevel&gt;7&lt;/WarningLevel&gt;
		&lt;DebugType&gt;portable&lt;/DebugType&gt;
	&lt;/PropertyGroup&gt;
	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; PrivateAssets=&quot;all&quot; GeneratePathProperty=&quot;true&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.13.0&quot; PrivateAssets=&quot;all&quot; /&gt;
		&lt;PackageReference Update=&quot;NETStandard.Library&quot; PrivateAssets=&quot;all&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;Target Name=&quot;AddNuGetDlls&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&gt;
		&lt;JoinItems Left=&quot;@(ResolvedCompileFileDefinitions)&quot; LeftKey=&quot;NuGetPackageId&quot; LeftMetadata=&quot;*&quot;
		           Right=&quot;@(PackageReference)&quot; RightKey=&quot;&quot; RightMetadata=&quot;*&quot; ItemSpecToUse=&quot;Left&quot;&gt;
			&lt;Output TaskParameter=&quot;JoinResult&quot; ItemName=&quot;_PackagesToPack&quot; /&gt;
		&lt;/JoinItems&gt;

		&lt;ItemGroup&gt;
			&lt;_PackagesToPack Remove=&quot;@(_PackagesToPack)&quot; Condition=&quot;%(NuGetPackageId) == &apos;NETStandard.Library&apos;&quot; /&gt;
			&lt;_PackagesToPack Remove=&quot;@(_PackagesToPack)&quot;
			                 Condition=&quot;%(NuGetPackageId) == &apos;Microsoft.CodeAnalysis.CSharp.Workspaces&apos;&quot; /&gt;
		&lt;/ItemGroup&gt;

		&lt;Message Importance=&quot;High&quot; Text=&quot;Adding DLLs from the following packages: @(_PackagesToPack-&gt;&apos;%(NuGetPackageId)&apos;)&quot; /&gt;

		&lt;ItemGroup&gt;
			&lt;None Include=&quot;@(_PackagesToPack)&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;

			&lt;!--&lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;--&gt;
		&lt;/ItemGroup&gt;
	&lt;/Target&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;tools\*.ps1&quot; CopyToOutputDirectory=&quot;PreserveNewest&quot; Pack=&quot;true&quot; PackagePath=&quot;&quot; /&gt;
		&lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;Target Name=&quot;_AddAnalyzersToOutput&quot;&gt;
		&lt;ItemGroup&gt;
			&lt;TfmSpecificPackageFile Include=&quot;$(OutputPath)\DisCatSharp.Analyzer.dll&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; /&gt;
		&lt;/ItemGroup&gt;
	&lt;/Target&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/README.md"># DisCatSharp.Analyzer.Roselyn

Analyzer tool for building bots with DisCatSharp</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AnalyzerReleases.Shipped.md">; Shipped analyzer releases
; https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md

## Release 4.3

### New Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0001 |  Usage   |  Warning | DCS0001_Experimental_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0001)


## Release 4.4

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0001 |  Usage   |  Warning | DCS0001_Experimental_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0001)


## Release 4.5

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0001 |  Usage   |  Warning | DCS0001_Experimental_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0001)


## Release 5.0

### New Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0101 |  Usage   |  Warning | DCS0101_DiscordInExperiment_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0101)
DCS0102 |  Usage   |  Warning | DCS0102_DiscordDeprecated_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0102)
DCS0103 |  Usage   |  Warning | DCS0103_DiscordUnreleased_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0103)


## Release 5.1

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0101 |  Usage   |  Warning | DCS0101_DiscordInExperiment_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0101)
DCS0102 |  Usage   |  Warning | DCS0102_DiscordDeprecated_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0102)
DCS0103 |  Usage   |  Warning | DCS0103_DiscordUnreleased_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0103)


## Release 5.3

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0002 |  Usage   |  Warning | DCS0002_Deprecated_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0002)


## Release 5.4

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0103 |  Usage   |  Warning | DCS0103_DiscordUnreleased_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0103)

Release 6.0

### New Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0200 |  Usage   |     Info | DCS0200_Requires_Feature_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0200)


## Release 6.1

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0200 |  Usage   |     Info | DCS0200_Requires_Feature_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0200)


## Release 6.2

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------
DCS0200 |  Usage   |     Info | DCS0200_Requires_Feature_Attribute_Analyzer, [Documentation](https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0200)

## Release 6.2.1

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------

## Release 6.2.2

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------

## Release 6.2.3

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------


## Release 6.2.4

### Changed Rules

Rule ID | Category | Severity | Notes
--------|----------|----------|--------------------</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AnalyzerReleases.Unshipped.md">; Unshipped analyzer release
; https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/AttributeAnalyzer.cs">	public class AttributeAnalyzer : DiagnosticAnalyzer
		private static readonly LocalizableString s_titleExperimental = new LocalizableResourceString(nameof(Resources.AnalyzerTitleExperimental), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatExperimental =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatExperimental), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionExperimental =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionExperimental), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_titleDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerTitleDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatDeprecated =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionDeprecated =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_titleDiscordInExperiment =
			new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatDiscordInExperiment =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionDiscordInExperiment =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_titleDiscordDeprecated =
			new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatDiscordDeprecated =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionDiscordDeprecated =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_titleDiscordUnreleased =
			new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatDiscordUnreleased =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionDiscordUnreleased =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_titleRequiresFeature =
			new LocalizableResourceString(nameof(Resources.AnalyzerTitleRequiresFeature), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_messageFormatRequiresFeature =
			new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatRequiresFeature), Resources.ResourceManager, typeof(Resources));
		private static readonly LocalizableString s_descriptionRequiresFeature =
			new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionRequiresFeature), Resources.ResourceManager, typeof(Resources));
		private static readonly DiagnosticDescriptor s_experimentalRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0001&quot;, s_titleExperimental, s_messageFormatExperimental, CATEGORY,
		private static readonly DiagnosticDescriptor s_deprecatedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0002&quot;, s_titleDeprecated, s_messageFormatDeprecated, CATEGORY,
		private static readonly DiagnosticDescriptor s_discordInExperimentRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0101&quot;, s_titleDiscordInExperiment,
		private static readonly DiagnosticDescriptor s_discordDeprecatedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0102&quot;, s_titleDiscordDeprecated, s_messageFormatDiscordDeprecated,
		private static readonly DiagnosticDescriptor s_discordUnreleasedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0103&quot;, s_titleDiscordUnreleased, s_messageFormatDiscordUnreleased,
		private static readonly DiagnosticDescriptor s_requiresFeatureRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0200&quot;, s_titleRequiresFeature, s_messageFormatRequiresFeature,
			=&gt; ImmutableArray.Create(s_experimentalRule, s_deprecatedRule, s_discordInExperimentRule, s_discordDeprecatedRule, s_discordUnreleasedRule, s_requiresFeatureRule);
		public override void Initialize(AnalysisContext context)
			context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
			context.EnableConcurrentExecution();
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.Parameter);
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.Property);
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.NamedType);
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.Method);
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.Field);
			context.RegisterSymbolAction(ExperimentalAnalyzer, SymbolKind.Event);
			context.RegisterSyntaxNodeAction(StatusAnalyzer, SyntaxKind.InvocationExpression);
			context.RegisterSyntaxNodeAction(StatusAnalyzer, SyntaxKind.ObjectCreationExpression);
			context.RegisterSyntaxNodeAction(StatusAnalyzer, SyntaxKind.ElementAccessExpression);
			context.RegisterSyntaxNodeAction(StatusAnalyzer, SyntaxKind.SimpleMemberAccessExpression);
		private static void StatusAnalyzer(SyntaxNodeAnalysisContext context)
				var declaration = context.SemanticModel.GetSymbolInfo(invocation, context.CancellationToken).Symbol;
					Console.WriteLine(new LocalizableResourceString(nameof(Resources.Faulty), Resources.ResourceManager, typeof(Resources)));
				var attributes = declaration.GetAttributes();
				var kind = declaration.Kind.ToString();
					name = declaration.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var experimentalAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(ExperimentalAttribute)));
				var deprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DeprecatedAttribute)));
				var discordInExperimentAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordInExperimentAttribute)));
				var discordDeprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordDeprecatedAttribute)));
				var discordUnreleasedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordUnreleasedAttribute)));
				var requiresFeatureAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(RequiresFeatureAttribute)));
					context.ReportDiagnostic(Diagnostic.Create(s_experimentalRule, invocation.GetLocation(), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_deprecatedRule, invocation.GetLocation(), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordInExperimentRule, invocation.GetLocation(), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordDeprecatedRule, invocation.GetLocation(), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordUnreleasedRule, invocation.GetLocation(), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_requiresFeatureRule, invocation.GetLocation(), kind, name, message));
				Console.WriteLine($&quot;StatusAnalyzer threw an exception: {ex.Message}&quot;);
				if (!string.IsNullOrEmpty(ex.StackTrace))
					Console.WriteLine(ex.StackTrace);
		private static void ExperimentalAnalyzer(SymbolAnalysisContext context)
				var model = context.Compilation.GetSemanticModel(syntaxTrees.First(), true);
				var experimentalAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(ExperimentalAttribute)));
				var deprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DeprecatedAttribute)));
				var discordInExperimentAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordInExperimentAttribute)));
				var discordDeprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordDeprecatedAttribute)));
				var discordUnreleasedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordUnreleasedAttribute)));
				var requiresFeatureAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(RequiresFeatureAttribute)));
					context.ReportDiagnostic(Diagnostic.Create(s_experimentalRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_deprecatedRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordInExperimentRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordDeprecatedRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_discordUnreleasedRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
					context.ReportDiagnostic(Diagnostic.Create(s_requiresFeatureRule, context.Symbol.Locations.FirstOrDefault(x =&gt; x.IsInSource), kind, name, message));
		private static bool IsRequiredAttribute(SemanticModel semanticModel, AttributeData attribute, Type desiredAttributeType)
			var desiredTypeNamedSymbol = semanticModel.Compilation.GetTypeByMetadataName(desiredAttributeType.FullName);
		private static string GetMessage(AttributeData attribute)
		private static string GetFeatureMessage(AttributeData attribute)
			return $&quot;{featureReqEnum.ToFeaturesString()} | {description}&quot;;
	internal static class Helpers
			var ti = t.GetTypeInfo();
			var vals = Enum.GetValues(t).Cast&lt;Features&gt;();
				var xsv = xv.ToString();
				var xmv = ti.DeclaredMembers.FirstOrDefault(xm =&gt; xm.Name == xsv);
		public static string ToFeaturesString(this Features features)
				.Where(xkvp =&gt; (features &amp; xkvp.Key) == xkvp.Key)
				.Select(xkvp =&gt; xkvp.Value);
			return string.Join(&quot;, &quot;, strs.OrderBy(xs =&gt; xs));</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;

		&lt;!-- Avoid ID conflicts with the package project. --&gt;
		&lt;PackageId&gt;*$(MSBuildProjectFile)*&lt;/PackageId&gt;
		&lt;Authors&gt;AITSYS&lt;/Authors&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;AdditionalFiles Include=&quot;AnalyzerReleases.Shipped.md&quot; /&gt;
		&lt;AdditionalFiles Include=&quot;AnalyzerReleases.Unshipped.md&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt;
		&lt;GenerateBindingRedirectsOutputType&gt;true&lt;/GenerateBindingRedirectsOutputType&gt;
		&lt;EnforceExtendedAnalyzerRules&gt;true&lt;/EnforceExtendedAnalyzerRules&gt;
		&lt;IncludeSymbols&gt;False&lt;/IncludeSymbols&gt;
		&lt;GeneratePackageOnBuild&gt;False&lt;/GeneratePackageOnBuild&gt;
		&lt;RunAnalyzersDuringBuild&gt;False&lt;/RunAnalyzersDuringBuild&gt;
		&lt;RunAnalyzersDuringLiveAnalysis&gt;False&lt;/RunAnalyzersDuringLiveAnalysis&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)|$(Platform)&apos;==&apos;Debug|AnyCPU&apos;&quot;&gt;
		&lt;DebugType&gt;embedded&lt;/DebugType&gt;
		&lt;NoWarn&gt;1701;1702;NU1701&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)|$(Platform)&apos;==&apos;Release|AnyCPU&apos;&quot;&gt;
		&lt;DebugType&gt;embedded&lt;/DebugType&gt;
		&lt;NoWarn&gt;1701;1702;NU1701&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;
	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Bcl.AsyncInterfaces&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.11.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.VisualStudio.SDK&quot; Version=&quot;17.13.40008&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Compile Update=&quot;Resources.Designer.cs&quot; DesignTime=&quot;True&quot; AutoGen=&quot;True&quot; DependentUpon=&quot;Resources.resx&quot; /&gt;
		&lt;EmbeddedResource Update=&quot;Resources.resx&quot; Generator=&quot;ResXFileCodeGenerator&quot; LastGenOutput=&quot;Resources.Designer.cs&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.Designer.cs">    internal class Resources {
                if (object.ReferenceEquals(resourceMan, null)) {
                return ResourceManager.GetString(&quot;AnalyzerDescriptionDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordInExperiment&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordUnreleased&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerDescriptionExperimental&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerDescriptionRequiresFeature&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordInExperiment&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordUnreleased&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatExperimental&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerMessageFormatRequiresFeature&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleDiscordDeprecated&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleDiscordInExperiment&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleDiscordUnreleased&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleExperimental&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;AnalyzerTitleRequiresFeature&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;Faulty&quot;, resourceCulture);
                return ResourceManager.GetString(&quot;Handling&quot;, resourceCulture);</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.resx">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root&gt;
  &lt;!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers &amp; schema ...
    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
    &lt;/data&gt;
    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
        &lt;comment&gt;This is a comment&lt;/comment&gt;
    &lt;/data&gt;
                
    There are any number of &quot;resheader&quot; rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don&apos;t support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    --&gt;
  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
    &lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; /&gt;
    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
          &lt;xsd:element name=&quot;metadata&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;assembly&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;data&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;resheader&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
  &lt;/xsd:schema&gt;
  &lt;resheader name=&quot;resmimetype&quot;&gt;
    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;version&quot;&gt;
    &lt;value&gt;2.0&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;reader&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;writer&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord deprecated this.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord has released it as experiment. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord hasn&apos;t released this yet. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;DisCatSharp considers this as experimental. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is deprecated: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is in experiment: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is not released yet: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is experimental: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Deprecated&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] InExperiment&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Unreleased&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[DCS] Experimental&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[DCS] Deprecated&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is deprecated: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;DisCatSharp considers this as deprecated. Update your code.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;This needs special features to be enabled / set.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; needs features: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Requires Features&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;Handling&quot; xml:space=&quot;preserve&quot;&gt;
	  &lt;value&gt;Handling &lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;Faulty&quot; xml:space=&quot;preserve&quot;&gt;
	  &lt;value&gt;Faulty&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Tools.sln">Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.31911.260
MinimumVisualStudioVersion = 10.0.40219.1
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Analyzer&quot;, &quot;DisCatSharp.Analyzer\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot;, &quot;{888F895F-97AB-4B95-86C8-80CE330EE6A2}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Analyzer.Package&quot;, &quot;DisCatSharp.Analyzer\DisCatSharp.Analyzer.Package\DisCatSharp.Analyzer.Package.csproj&quot;, &quot;{A471D5C5-B629-4727-BE7C-F7E7FA832F84}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Attributes&quot;, &quot;..\DisCatSharp.Attributes\DisCatSharp.Attributes.csproj&quot;, &quot;{6EB1F99C-22FC-44D8-A1B6-539393C34810}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Solution Items&quot;, &quot;Solution Items&quot;, &quot;{6CBDA593-E86C-44F3-9F22-BB5F32D7D48E}&quot;
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		DisCatSharp.ruleset = DisCatSharp.ruleset
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Experimental&quot;, &quot;..\DisCatSharp.Experimental\DisCatSharp.Experimental.csproj&quot;, &quot;{58B4D657-A00E-4C47-B4D6-1EE881E5E387}&quot;
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Release|Any CPU.Build.0 = Release|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Release|Any CPU.Build.0 = Release|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Release|Any CPU.Build.0 = Release|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {35117E8E-0076-4CB1-94BD-D3BC0F0A6CCC}
	EndGlobalSection
EndGlobal</file><file path="DisCatSharp.VoiceNext/AudioFormat.cs">		if (!AllowedSampleRates.Contains(sampleRate))
			throw new ArgumentOutOfRangeException(nameof(sampleRate), &quot;Invalid sample rate specified.&quot;);
		if (!AllowedChannelCounts.Contains(channelCount))
			throw new ArgumentOutOfRangeException(nameof(channelCount), &quot;Invalid channel count specified.&quot;);
			throw new ArgumentOutOfRangeException(nameof(voiceApplication), &quot;Invalid voice application specified.&quot;);
	public int CalculateSampleSize(int sampleDuration)
		if (!AllowedSampleDurations.Contains(sampleDuration))
			throw new ArgumentOutOfRangeException(nameof(sampleDuration), &quot;Invalid sample duration specified.&quot;);
	public int GetMaximumBufferSize()
		=&gt; this.CalculateMaximumFrameSize();
	internal int CalculateSampleDuration(int sampleSize)
	internal int CalculateFrameSize(int sampleDuration)
	internal int CalculateMaximumFrameSize()
	internal int SampleCountToSampleSize(int sampleCount)
	internal bool IsValid()
		=&gt; AllowedSampleRates.Contains(this.SampleRate) &amp;&amp; AllowedChannelCounts.Contains(this.ChannelCount) &amp;&amp;</file><file path="DisCatSharp.VoiceNext/Codec/Helpers.cs">internal static class Helpers
	public static void ZeroFill(Span&lt;byte&gt; buff)
			MemoryMarshal.Write(buff, in zero);
			MemoryMarshal.Write(buff, ref zero);</file><file path="DisCatSharp.VoiceNext/Codec/Interop.cs">internal static class Interop
	private static extern UIntPtr _SodiumSecretBoxKeySize();
	private static extern UIntPtr _SodiumSecretBoxNonceSize();
	private static extern UIntPtr _SodiumSecretBoxMacSize();
	private static extern unsafe int _SodiumSecretBoxCreate(byte* buffer, byte* message, ulong messageLength, byte* nonce, byte* key);
	private static extern unsafe int _SodiumSecretBoxOpen(byte* buffer, byte* encryptedMessage, ulong encryptedLength, byte* nonce, byte* key);
	public static unsafe int Encrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; nonce)
		fixed (byte* sourcePtr = &amp;source.GetPinnableReference())
		fixed (byte* targetPtr = &amp;target.GetPinnableReference())
		fixed (byte* keyPtr = &amp;key.GetPinnableReference())
		fixed (byte* noncePtr = &amp;nonce.GetPinnableReference())
	public static unsafe int Decrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; nonce)
	private static extern IntPtr _OpusCreateEncoder(int sampleRate, int channels, int application, out OpusError error);
	public static extern void OpusDestroyEncoder(IntPtr encoder);
	private static extern unsafe int _OpusEncode(IntPtr encoder, byte* pcmData, int frameSize, byte* data, int maxDataBytes);
	private static extern OpusError _OpusEncoderControl(IntPtr encoder, OpusControl request, int value);
	private static extern IntPtr _OpusCreateDecoder(int sampleRate, int channels, out OpusError error);
	public static extern void OpusDestroyDecoder(IntPtr decoder);
	private static extern unsafe int _OpusDecode(IntPtr decoder, byte* opusData, int opusDataLength, byte* data, int frameSize, int decodeFec);
	private static extern unsafe int _OpusGetPacketChannelCount(byte* opusData);
	private static extern unsafe int _OpusGetPacketFrameCount(byte* opusData, int length);
	private static extern unsafe int _OpusGetPacketSamplePerFrameCount(byte* opusData, int samplingRate);
	private static extern int _OpusDecoderControl(IntPtr decoder, OpusControl request, out int value);
	public static IntPtr OpusCreateEncoder(AudioFormat audioFormat)
	public static void OpusSetEncoderOption(IntPtr encoder, OpusControl option, int value)
	public static unsafe void OpusEncode(IntPtr encoder, ReadOnlySpan&lt;byte&gt; pcm, int frameSize, ref Span&lt;byte&gt; opus)
		fixed (byte* pcmPtr = &amp;pcm.GetPinnableReference())
		fixed (byte* opusPtr = &amp;opus.GetPinnableReference())
	public static IntPtr OpusCreateDecoder(AudioFormat audioFormat)
	public static unsafe int OpusDecode(IntPtr decoder, ReadOnlySpan&lt;byte&gt; opus, int frameSize, Span&lt;byte&gt; pcm, bool useFec)
	public static unsafe int OpusDecode(IntPtr decoder, int frameSize, Span&lt;byte&gt; pcm)
	public static unsafe void OpusGetPacketMetrics(ReadOnlySpan&lt;byte&gt; opus, int samplingRate, out int channels, out int frames, out int samplesPerFrame, out int frameSize)
	public static void OpusGetLastPacketDuration(IntPtr decoder, out int sampleCount)</file><file path="DisCatSharp.VoiceNext/Codec/Opus.cs">public class Opus : IDisposable
	private readonly IntPtr _encoder;
		if (!audioFormat.IsValid())
			throw new ArgumentException(&quot;Invalid audio format specified.&quot;, nameof(audioFormat));
		this._encoder = Interop.OpusCreateEncoder(this.AudioFormat);
		Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetSignal, (int)sig);
		Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetPacketLossPercent, 15);
		Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetInBandFec, 1);
		Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetBitrate, 131072);
	public void Dispose()
		Interop.OpusDestroyEncoder(this._encoder);
				decoder.Dispose();
		GC.SuppressFinalize(this);
	public void Encode(ReadOnlySpan&lt;byte&gt; pcm, ref Span&lt;byte&gt; target)
			throw new ArgumentException(&quot;PCM and Opus buffer lengths need to be equal.&quot;, nameof(target));
		var duration = this.AudioFormat.CalculateSampleDuration(pcm.Length);
		var frameSize = this.AudioFormat.CalculateFrameSize(duration);
		var sampleSize = this.AudioFormat.CalculateSampleSize(duration);
			throw new ArgumentException(&quot;Invalid PCM sample size.&quot;, nameof(target));
		Interop.OpusEncode(this._encoder, pcm, frameSize, ref target);
	public void Decode(OpusDecoder decoder, ReadOnlySpan&lt;byte&gt; opus, ref Span&lt;byte&gt; target, bool useFec, out AudioFormat outputFormat)
		Interop.OpusGetPacketMetrics(opus, this.AudioFormat.SampleRate, out var channels, out _, out _, out var frameSize);
			decoder.Initialize(outputFormat);
		var sampleCount = Interop.OpusDecode(decoder.Decoder, opus, frameSize, target, useFec);
		var sampleSize = outputFormat.SampleCountToSampleSize(sampleCount);
	public void ProcessPacketLoss(OpusDecoder decoder, int frameSize, ref Span&lt;byte&gt; target)
		=&gt; Interop.OpusDecode(decoder.Decoder, frameSize, target);
	public int GetLastPacketSampleCount(OpusDecoder decoder)
		Interop.OpusGetLastPacketDuration(decoder.Decoder, out var sampleCount);
	public OpusDecoder CreateDecoder()
			var managedDecoder = new OpusDecoder(this);
			this._managedDecoders.Add(managedDecoder);
	public void DestroyDecoder(OpusDecoder? decoder)
			if (decoder is null || !this._managedDecoders.Contains(decoder))
			this._managedDecoders.Remove(decoder);
public sealed class OpusDecoder : IDisposable
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
			Interop.OpusDestroyDecoder(this.Decoder);
	internal void Initialize(AudioFormat outputFormat)
		this.Decoder = Interop.OpusCreateDecoder(outputFormat);
		this.Dispose();</file><file path="DisCatSharp.VoiceNext/Codec/Rtp.cs">internal class Rtp : IDisposable
	public void Dispose()
	public void EncodeHeader(ushort sequence, uint timestamp, uint ssrc, Span&lt;byte&gt; target)
			throw new ArgumentException(&quot;Header buffer is too short.&quot;, nameof(target));
		BinaryPrimitives.WriteUInt16BigEndian(target[2..], sequence); // header + magic
		BinaryPrimitives.WriteUInt32BigEndian(target[4..], timestamp); // header + magic + sizeof(sequence)
		BinaryPrimitives.WriteUInt32BigEndian(target[8..], ssrc); // header + magic + sizeof(sequence) + sizeof(timestamp)
	public bool IsRtpHeader(ReadOnlySpan&lt;byte&gt; source)
	public void DecodeHeader(ReadOnlySpan&lt;byte&gt; source, out ushort sequence, out uint timestamp, out uint ssrc, out bool hasExtension)
			throw new ArgumentException(&quot;Header buffer is too short.&quot;, nameof(source));
			throw new ArgumentException(&quot;Invalid RTP header.&quot;, nameof(source));
		sequence = BinaryPrimitives.ReadUInt16BigEndian(source[2..]);
		timestamp = BinaryPrimitives.ReadUInt32BigEndian(source[4..]);
		ssrc = BinaryPrimitives.ReadUInt32BigEndian(source[8..]);
	public int CalculatePacketSize(int encryptedLength, EncryptionMode encryptionMode) =&gt;
			_ =&gt; throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode))
	public void GetDataFromPacket(ReadOnlySpan&lt;byte&gt; packet, out ReadOnlySpan&lt;byte&gt; data, EncryptionMode encryptionMode)
				data = packet.Slice(HEADER_SIZE, packet.Length - HEADER_SIZE - Interop.SodiumNonceSize);
				data = packet.Slice(HEADER_SIZE, packet.Length - HEADER_SIZE - 4);
				throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode));</file><file path="DisCatSharp.VoiceNext/Codec/Sodium.cs">internal class Sodium : IDisposable
	private readonly RandomNumberGenerator _csprng;
			throw new ArgumentException($&quot;Invalid Sodium key size. Key needs to have a length of {Interop.SodiumKeySize} bytes.&quot;, nameof(key));
		this._csprng = RandomNumberGenerator.Create();
	public void Dispose()
		=&gt; this._csprng.Dispose();
	public void GenerateNonce(ReadOnlySpan&lt;byte&gt; rtpHeader, Span&lt;byte&gt; target)
			throw new ArgumentException($&quot;RTP header needs to have a length of exactly {Rtp.HEADER_SIZE} bytes.&quot;, nameof(rtpHeader));
			throw new ArgumentException($&quot;Invalid nonce buffer size. Target buffer for the nonce needs to have a capacity of {Interop.SodiumNonceSize} bytes.&quot;, nameof(target));
		rtpHeader.CopyTo(target);
		Helpers.ZeroFill(target[rtpHeader.Length..]);
	public void GenerateNonce(Span&lt;byte&gt; target)
		this._csprng.GetBytes(this._buffer);
		this._buffer.AsSpan().CopyTo(target);
	public void GenerateNonce(uint nonce, Span&lt;byte&gt; target)
		BinaryPrimitives.WriteUInt32BigEndian(target, nonce);
		Helpers.ZeroFill(target[4..]);
	public void AppendNonce(ReadOnlySpan&lt;byte&gt; nonce, Span&lt;byte&gt; target, EncryptionMode encryptionMode)
				nonce.CopyTo(target[^12..]);
				nonce[..4].CopyTo(target[^4..]);
				throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode));
	public void GetNonce(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, EncryptionMode encryptionMode)
				source[..12].CopyTo(target);
				source[^Interop.SodiumNonceSize..].CopyTo(target);
				source[^4..].CopyTo(target);
	public void Encrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; nonce)
			throw new ArgumentException($&quot;Invalid nonce size. Nonce needs to have a length of {Interop.SodiumNonceSize} bytes.&quot;, nameof(nonce));
			throw new ArgumentException($&quot;Invalid target buffer size. Target buffer needs to have a length that is a sum of input buffer length and Sodium MAC size ({Interop.SodiumMacSize} bytes).&quot;, nameof(target));
		if ((result = Interop.Encrypt(source, target, this._key.Span, nonce)) is not 0)
			throw new CryptographicException($&quot;Could not encrypt the buffer. Sodium returned code {result}.&quot;);
	public void Decrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; nonce)
			throw new ArgumentException($&quot;Invalid target buffer size. Target buffer needs to have a length that is input buffer decreased by Sodium MAC size ({Interop.SodiumMacSize} bytes).&quot;, nameof(target));
		if ((result = Interop.Decrypt(source, target, this._key.Span, nonce)) is not 0)
			throw new CryptographicException($&quot;Could not decrypt the buffer. Sodium returned code {result}.&quot;);
	public static KeyValuePair&lt;string, EncryptionMode&gt; SelectMode(IEnumerable&lt;string&gt; availableModes)
			if (availableModes.Contains(kvMode.Key))
		throw new CryptographicException(&quot;Could not negotiate Sodium encryption modes, as none of the modes offered by Discord are supported. This is usually an indicator that something went very wrong.&quot;);
	public static int CalculateTargetSize(ReadOnlySpan&lt;byte&gt; source)
	public static int CalculateSourceSize(ReadOnlySpan&lt;byte&gt; source)</file><file path="DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.VoiceNext&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.VoiceNext&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.VoiceNext&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Voice Next Extension

			Easy made audio player for discord bots.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/audio/voicenext/prerequisites.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Voice,Audio Player&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Threading.Channels&quot; Version=&quot;9.0.2&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.VoiceNext/Entities/AudioSender.cs">internal class AudioSender : IDisposable
	private SequenceWrapState _currentSequenceWrapState = SequenceWrapState.AssumeNextHighSequenceIsOutOfOrder;
	public void Dispose()
	public ulong GetTrueSequenceAfterWrapping(ushort originalSequence)
				throw new ArgumentOutOfRangeException(null, &quot;CurrentSequenceWrapState was out of range&quot;);</file><file path="DisCatSharp.VoiceNext/Entities/VoiceDispatch.cs">internal sealed class VoiceDispatch</file><file path="DisCatSharp.VoiceNext/Entities/VoiceIdentifyPayload.cs">internal sealed class VoiceIdentifyPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoicePacket.cs"></file><file path="DisCatSharp.VoiceNext/Entities/VoiceReadyPayload.cs">internal sealed class VoiceReadyPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayload.cs">internal sealed class VoiceSelectProtocolPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayloadData.cs">internal class VoiceSelectProtocolPayloadData</file><file path="DisCatSharp.VoiceNext/Entities/VoiceServerUpdatePayload.cs">internal sealed class VoiceServerUpdatePayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSessionDescriptionPayload.cs">internal sealed class VoiceSessionDescriptionPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSpeakingPayload.cs">internal sealed class VoiceSpeakingPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceStateUpdatePayload.cs">internal sealed class VoiceStateUpdatePayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceUserJoinPayload.cs">internal sealed class VoiceUserJoinPayload</file><file path="DisCatSharp.VoiceNext/Entities/VoiceUserLeavePayload.cs">internal sealed class VoiceUserLeavePayload</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceReceiveEventArgs.cs">public class VoiceReceiveEventArgs : DiscordEventArgs</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceUserJoinEventArgs.cs">public sealed class VoiceUserJoinEventArgs : DiscordEventArgs</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceUserLeaveEventArgs.cs">public sealed class VoiceUserLeaveEventArgs : DiscordEventArgs</file><file path="DisCatSharp.VoiceNext/ExtensionMethods.cs">public static class ExtensionMethods
	public static VoiceNextExtension UseVoiceNext(this DiscordClient client, VoiceNextConfiguration? config = null)
			throw new InvalidOperationException(&quot;VoiceNext is already enabled for that client.&quot;);
		var vnext = new VoiceNextExtension(config ?? new());
		client.AddExtension(vnext);
	public static async Task&lt;IReadOnlyDictionary&lt;int, VoiceNextExtension&gt;&gt; UseVoiceNextAsync(this DiscordShardedClient client, VoiceNextConfiguration? config = null)
		await client.InitializeShardsAsync().ConfigureAwait(false);
		foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
			vnext ??= shard.UseVoiceNext(config);
	public static VoiceNextExtension? GetVoiceNext(this DiscordClient client)
	public static async Task&lt;IReadOnlyDictionary&lt;int, VoiceNextExtension?&gt;&gt; GetVoiceNextAsync(this DiscordShardedClient client)
		var extensions = client.ShardClients.Values.ToDictionary(shard =&gt; shard.ShardId, shard =&gt; shard.GetExtension&lt;VoiceNextExtension&gt;());
		return extensions.AsReadOnly();
	public static Task&lt;VoiceNextConnection&gt; ConnectAsync(this DiscordChannel channel)
		ArgumentNullException.ThrowIfNull(channel);
			throw new InvalidOperationException(&quot;VoiceNext can only be used with guild channels.&quot;);
			throw new InvalidOperationException(&quot;You can only connect to voice or stage channels.&quot;);
			throw new NullReferenceException();
		var vnext = discord.GetVoiceNext() ?? throw new InvalidOperationException(&quot;VoiceNext is not initialized for this Discord client.&quot;);
		var vnc = vnext.GetConnection(channel.Guild);
			? throw new InvalidOperationException(&quot;VoiceNext is already connected in this guild.&quot;)
			: vnext.ConnectAsync(channel);</file><file path="DisCatSharp.VoiceNext/GlobalSuppressions.cs"></file><file path="DisCatSharp.VoiceNext/Interop/Bindings.cs">internal static unsafe class Bindings
	private static extern IntPtr opus_encoder_create(int samplingRate, int channels, int application, out OpusError error);
	private static extern void opus_encoder_destroy(IntPtr encoder);
	private static extern int opus_encode(IntPtr encoder, byte* pcm, int frameSize, byte* data, int maxDataBytes);
	private static extern OpusError opus_encoder_ctl(IntPtr encoder, OpusControl ctl, int value);
	private static extern IntPtr opus_decoder_create(int sampleRate, int channels, out OpusError error);
	private static extern void opus_decoder_destroy(IntPtr decoder);
	private static extern int opus_decode(IntPtr decoder, byte* opusData, int opusDataLength, byte* data, int frameSize, int decodeFec);
	private static extern int opus_packet_get_nb_channels(byte* data);
	private static extern int opus_packet_get_nb_frames(byte* data, int length);
	private static extern int opus_packet_get_samples_per_frame(byte* data, int samplingRate);
	private static extern int opus_decoder_ctl(IntPtr decoder, OpusControl ctl, out int value);
	public static IntPtr CreateEncoder(int sampleRate, int channelCount, int application)
	public static void SetEncoderOption(IntPtr encoder, OpusControl option, int value)
	public static void Encode(IntPtr encoder, ReadOnlySpan&lt;byte&gt; pcm, int frameSize, ref Span&lt;byte&gt; data)
	public static IntPtr CreateDecoder(int sampleRate, int channelCount)
	public static int Decode(IntPtr decoder, ReadOnlySpan&lt;byte&gt; data, int frameSize, Span&lt;byte&gt; pcm, bool useFec)
	public static int Decode(IntPtr decoder, int frameSize, Span&lt;byte&gt; pcm)
	public static OpusPacketMetrics GetPacketMetrics(ReadOnlySpan&lt;byte&gt; data, int samplingRate)
	public static void GetLastPacketDuration(IntPtr decoder, out int sampleCount)</file><file path="DisCatSharp.VoiceNext/Interop/OpusControl.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusError.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusPacketMetrics.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusSignal.cs"></file><file path="DisCatSharp.VoiceNext/IVoiceFilter.cs">public interface IVoiceFilter
	void Transform(Span&lt;short&gt; pcmData, AudioFormat pcmFormat, int duration);</file><file path="DisCatSharp.VoiceNext/RawVoicePacket.cs"></file><file path="DisCatSharp.VoiceNext/StreamExtensions.cs">public static class StreamExtensions
	public static async Task CopyToAsync(this Stream source, VoiceTransmitSink destination, int? bufferSize = null, CancellationToken cancellationToken = default)
		ArgumentNullException.ThrowIfNull(source);
		ArgumentNullException.ThrowIfNull(destination);
			throw new ArgumentOutOfRangeException(nameof(bufferSize), bufferSize, &quot;bufferSize cannot be less than or equal to zero&quot;);
		var buffer = ArrayPool&lt;byte&gt;.Shared.Rent(bufferLength);
			while ((bytesRead = await source.ReadAsync(buffer.AsMemory(0, bufferLength), cancellationToken).ConfigureAwait(false)) is not 0)
				await destination.WriteAsync(new(buffer, 0, bytesRead), cancellationToken).ConfigureAwait(false);
			ArrayPool&lt;byte&gt;.Shared.Return(buffer);</file><file path="DisCatSharp.VoiceNext/VoiceApplication.cs"></file><file path="DisCatSharp.VoiceNext/VoiceNextConfiguration.cs">public sealed class VoiceNextConfiguration</file><file path="DisCatSharp.VoiceNext/VoiceNextConnection.cs">public sealed class VoiceNextConnection : IDisposable
	private readonly VoiceNextConfiguration _configuration;
	private readonly DiscordClient _discord;
	private readonly DiscordGuild _guild;
	private readonly AsyncManualResetEvent _pauseEvent;
	private readonly BaseUdpClient _udpClient;
	private IpEndpoint _discoveredEndpoint;
	private Task _heartbeatTask;
	private Task _keepaliveTask;
	private CancellationTokenSource _keepaliveTokenSource;
	private DateTimeOffset _lastHeartbeat;
	private Opus _opus;
	private Task _receiverTask;
	private CancellationTokenSource _receiverTokenSource;
	private Rtp _rtp;
	private EncryptionMode _selectedEncryptionMode;
	private Task _senderTask;
	private CancellationTokenSource _senderTokenSource;
	private Sodium _sodium;
	private SpeakingFlags _speakingFlags;
	private CancellationTokenSource _tokenSource;
	private IWebSocketClient _voiceWs;
		var epi = eps.LastIndexOf(&apos;:&apos;);
			epp = int.Parse(eps[(epi + 1)..]);
		this._transmitChannel = Channel.CreateBounded&lt;RawVoicePacket&gt;(new BoundedChannelOptions(this._configuration.PacketQueueSize));
		this._udpClient = this._discord.Configuration.UdpClientFactory();
		this._voiceWs = this._discord.Configuration.WebSocketClientFactory(this._discord.Configuration.Proxy, this._discord.ServiceProvider);
		=&gt; Volatile.Read(ref this._wsPing);
		=&gt; Volatile.Read(ref this._udpPing);
	public void Dispose()
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
			this._discord.Logger.LogError(ex, &quot;{Message}&quot;, ex.Message);
			this._voiceWs.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
			this._udpClient.Close();
		GC.SuppressFinalize(this);
		add =&gt; this._userSpeaking.Register(value);
		remove =&gt; this._userSpeaking.Unregister(value);
		add =&gt; this._userJoined.Register(value);
		remove =&gt; this._userJoined.Unregister(value);
		add =&gt; this._userLeft.Register(value);
		remove =&gt; this._userLeft.Unregister(value);
		add =&gt; this._voiceReceived.Register(value);
		remove =&gt; this._voiceReceived.Unregister(value);
		add =&gt; this._voiceSocketError.Register(value);
		remove =&gt; this._voiceSocketError.Unregister(value);
	internal event VoiceDisconnectedEventHandler VoiceDisconnected;
		this.Dispose();
	internal Task ConnectAsync()
		var gwuri = new UriBuilder
		return this._voiceWs.ConnectAsync(gwuri.Uri);
	internal Task ReconnectAsync()
		=&gt; this._voiceWs.DisconnectAsync();
	internal async Task StartAsync()
		var vdp = new VoiceDispatch();
			vdp.Payload = new VoiceIdentifyPayload
		var vdj = JsonConvert.SerializeObject(vdp, Formatting.None);
		await this.WsSendAsync(vdj).ConfigureAwait(false);
	internal Task WaitForReadyAsync()
	internal async Task EnqueuePacketAsync(RawVoicePacket packet, CancellationToken token = default)
		await this._transmitChannel.Writer.WriteAsync(packet, token).ConfigureAwait(false);
	internal bool PreparePacket(ReadOnlySpan&lt;byte&gt; pcm, [NotNullWhen(true)] out byte[]? target, out int length)
		var packetArray = ArrayPool&lt;byte&gt;.Shared.Rent(this._rtp.CalculatePacketSize(audioFormat.SampleCountToSampleSize(audioFormat.CalculateMaximumFrameSize()), this._selectedEncryptionMode));
		var packet = packetArray.AsSpan();
		this._rtp.EncodeHeader(this._sequence, this._timestamp, this._ssrc, packet);
		var opus = packet.Slice(Rtp.HEADER_SIZE, pcm.Length);
		this._opus.Encode(pcm, ref opus);
		this._timestamp += (uint)audioFormat.CalculateFrameSize(audioFormat.CalculateSampleDuration(pcm.Length));
				this._sodium.GenerateNonce(packet[..Rtp.HEADER_SIZE], nonce);
				this._sodium.GenerateNonce(nonce);
				this._sodium.GenerateNonce(this._nonce++, nonce);
				ArrayPool&lt;byte&gt;.Shared.Return(packetArray);
		Span&lt;byte&gt; encrypted = stackalloc byte[Sodium.CalculateTargetSize(opus)];
		this._sodium.Encrypt(opus, encrypted, nonce);
		encrypted.CopyTo(packet[Rtp.HEADER_SIZE..]);
		packet = packet[..this._rtp.CalculatePacketSize(encrypted.Length, this._selectedEncryptionMode)];
		this._sodium.AppendNonce(nonce, packet, this._selectedEncryptionMode);
	private async Task VoiceSenderTask()
		var synchronizerTicks = (double)Stopwatch.GetTimestamp();
		this._discord.Logger.LogDebug(VoiceNextEvents.Misc, &quot;Timer accuracy: {Frequency}/{SynchronizerResolution} (high resolution? {IsHighResolution})&quot;, Stopwatch.Frequency, synchronizerResolution, Stopwatch.IsHighResolution);
			await this._pauseEvent.WaitAsync().ConfigureAwait(false);
			var hasPacket = reader.TryRead(out var rawPacket);
				hasPacket = this.PreparePacket(rawPacket.Bytes.Span, out data, out length);
					ArrayPool&lt;byte&gt;.Shared.Return(rawPacket.RentedBuffer);
			var cts = Math.Max(Stopwatch.GetTimestamp() - synchronizerTicks, 0);
				await Task.Delay(TimeSpan.FromTicks((long)(((synchronizerResolution * durationModifier) - cts) * tickResolution)), CancellationToken.None).ConfigureAwait(false);
			await this.SendSpeakingAsync(this._speakingFlags is not SpeakingFlags.NotSpeaking ? this._speakingFlags : SpeakingFlags.Microphone).ConfigureAwait(false);
			ArgumentNullException.ThrowIfNull(data);
			await this._udpClient.SendAsync(data, length).ConfigureAwait(false);
			ArrayPool&lt;byte&gt;.Shared.Return(data);
				var nullpcm = new byte[this.AudioFormat.CalculateSampleSize(20)];
					var nullpacketmem = nullpacket.AsMemory();
					await this.EnqueuePacketAsync(new(nullpacketmem, 20, true), CancellationToken.None).ConfigureAwait(false);
				await this.SendSpeakingAsync(this._speakingFlags).ConfigureAwait(false);
	private bool ProcessPacket(ReadOnlySpan&lt;byte&gt; data, ref Memory&lt;byte&gt; opus, ref Memory&lt;byte&gt; pcm, List&lt;ReadOnlyMemory&lt;byte&gt;&gt; pcmPackets, [NotNullWhen(true)] out AudioSender? voiceSender, out AudioFormat outputFormat)
		if (!this._rtp.IsRtpHeader(data))
		this._rtp.DecodeHeader(data, out var shortSequence, out _, out var ssrc, out var hasExtension);
		if (!this._transmittingSsrCs.TryGetValue(ssrc, out var vtx))
			var decoder = this._opus.CreateDecoder();
			this._transmittingSsrCs.TryAdd(ssrc, vtx);
		var sequence = vtx.GetTrueSequenceAfterWrapping(shortSequence);
				this._discord.Logger.LogWarning(VoiceNextEvents.VoiceReceiveFailure, &quot;5 or more voice packets were dropped when receiving&quot;);
		this._sodium.GetNonce(data, nonce, this._selectedEncryptionMode);
		this._rtp.GetDataFromPacket(data, out var encryptedOpus, this._selectedEncryptionMode);
		var opusSize = Sodium.CalculateSourceSize(encryptedOpus);
			this._sodium.Decrypt(encryptedOpus, opusSpan, nonce);
					var lastSampleCount = this._opus.GetLastPacketSampleCount(vtx.Decoder);
					var fecpcm = new byte[this.AudioFormat.SampleCountToSampleSize(lastSampleCount)];
					var fecpcmMem = fecpcm.AsSpan();
					this._opus.Decode(vtx.Decoder, opusSpan, ref fecpcmMem, true, out _);
					pcmPackets.Add(fecpcm.AsMemory(0, fecpcmMem.Length));
						this._opus.ProcessPacketLoss(vtx.Decoder, lastSampleCount, ref fecpcmMem);
			this._opus.Decode(vtx.Decoder, opusSpan, ref pcmSpan, false, out outputFormat);
	private async Task ProcessVoicePacket(byte[] data)
			var pcm = new byte[this.AudioFormat.CalculateMaximumFrameSize()];
			var pcmMem = pcm.AsMemory();
			var opusMem = opus.AsMemory();
			if (!this.ProcessPacket(data, ref opusMem, ref pcmMem, pcmFillers, out var vtx, out var audioFormat))
				await this._voiceReceived.InvokeAsync(this, new(this._discord.ServiceProvider)
					OpusData = Array.Empty&lt;byte&gt;().AsMemory(),
					AudioDuration = audioFormat.CalculateSampleDuration(pcmFiller.Length)
				}).ConfigureAwait(false);
				AudioDuration = audioFormat.CalculateSampleDuration(pcmMem.Length)
			this._discord.Logger.LogError(VoiceNextEvents.VoiceReceiveFailure, ex, &quot;Exception occurred when decoding incoming audio data&quot;);
	private void ProcessKeepalive(byte[] data)
			var keepalive = BinaryPrimitives.ReadUInt64LittleEndian(data);
			if (!this._keepaliveTimestamps.TryRemove(keepalive, out var timestamp))
			var tdelta = (int)((Stopwatch.GetTimestamp() - timestamp) / (double)Stopwatch.Frequency * 1000);
			this._discord.Logger.LogDebug(VoiceNextEvents.VoiceKeepalive, &quot;Received UDP keepalive {KeepAlive} (ping {TimeDelta}ms)&quot;, keepalive, tdelta);
			Volatile.Write(ref this._udpPing, tdelta);
			this._discord.Logger.LogError(VoiceNextEvents.VoiceKeepalive, ex, &quot;Exception occurred when handling keepalive&quot;);
	private async Task UdpReceiverTask()
			var data = await this._udpClient.ReceiveAsync().ConfigureAwait(false);
				this.ProcessKeepalive(data);
				await this.ProcessVoicePacket(data).ConfigureAwait(false);
	public async Task SendSpeakingAsync(SpeakingFlags flags = SpeakingFlags.Microphone)
			throw new InvalidOperationException(&quot;The connection is not initialized&quot;);
			var pld = new VoiceDispatch
				Payload = new VoiceSpeakingPayload
			var plj = JsonConvert.SerializeObject(pld, Formatting.None);
			await this.WsSendAsync(plj).ConfigureAwait(false);
	public VoiceTransmitSink GetTransmitSink(int sampleDuration = 20)
		if (!AudioFormat.AllowedSampleDurations.Contains(sampleDuration))
			throw new ArgumentOutOfRangeException(nameof(sampleDuration), &quot;Invalid PCM sample duration specified.&quot;);
	public async Task WaitForPlaybackFinishAsync()
			await this._playingWait.Task.ConfigureAwait(false);
	public void Pause()
		=&gt; this._pauseEvent.Reset();
	public async Task ResumeAsync()
		=&gt; await this._pauseEvent.SetAsync().ConfigureAwait(false);
	public void Disconnect()
		=&gt; this.Dispose();
	private async Task HeartbeatAsync()
		await Task.Yield();
				token.ThrowIfCancellationRequested();
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHeartbeat, &quot;Sent heartbeat&quot;);
				var hbd = new VoiceDispatch
				var hbj = JsonConvert.SerializeObject(hbd);
				await this.WsSendAsync(hbj).ConfigureAwait(false);
				await Task.Delay(this._heartbeatInterval, CancellationToken.None).ConfigureAwait(false);
	private async Task KeepaliveAsync()
			var timestamp = Stopwatch.GetTimestamp();
			var keepalive = Volatile.Read(ref this._lastKeepalive);
			Volatile.Write(ref this._lastKeepalive, keepalive + 1);
			this._keepaliveTimestamps.TryAdd(keepalive, timestamp);
			BinaryPrimitives.WriteUInt64LittleEndian(packet, keepalive);
			await this._udpClient.SendAsync(packet, packet.Length).ConfigureAwait(false);
			await Task.Delay(5000, token).ConfigureAwait(false);
	private async Task Stage1(VoiceReadyPayload voiceReady)
		this._udpClient.Setup(this.UdpEndpoint);
		await this._udpClient.SendAsync(pck, pck.Length).ConfigureAwait(false);
		var ipd = await this._udpClient.ReceiveAsync().ConfigureAwait(false);
		this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Endpoint discovery finished - discovered endpoint is {IP}:{Port}&quot;, ip, port);
		var selectedEncryptionMode = Sodium.SelectMode(voiceReady.Modes);
		this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Selected encryption mode is {EncryptionMode}&quot;, selectedEncryptionMode.Key);
		var vsp = new VoiceDispatch
			Payload = new VoiceSelectProtocolPayload
					Address = this._discoveredEndpoint.Address.ToString(),
		var vsj = JsonConvert.SerializeObject(vsp, Formatting.None);
		await this.WsSendAsync(vsj).ConfigureAwait(false);
		this._senderTask = Task.Run(this.VoiceSenderTask, this.SENDER_TOKEN);
		this._receiverTask = Task.Run(this.UdpReceiverTask, this.RECEIVER_TOKEN);
			var packetSpan = packet.AsSpan();
			var ipString = Utilities.UTF8.GetString(packet, 8, 64 /* 74 - 10 */).TrimEnd(&apos;\0&apos;);
			decodedIp = IPAddress.Parse(ipString);
			decodedPort = BinaryPrimitives.ReadUInt16BigEndian(packetSpan[72..] /* 74 - 2 */);
			BinaryPrimitives.WriteUInt16BigEndian(packetSpan[..2], type);
			BinaryPrimitives.WriteUInt16BigEndian(packetSpan.Slice(2, 2), length);
			BinaryPrimitives.WriteUInt32BigEndian(packetSpan.Slice(4, 4), ssrc);
			packetSpan[8..].Clear();
	private async Task Stage2(VoiceSessionDescriptionPayload voiceSessionDescription)
		this._selectedEncryptionMode = Sodium.SupportedModes[voiceSessionDescription.Mode.ToLowerInvariant()];
		this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Discord updated encryption mode - new mode is {EncryptionMode}&quot;, this._selectedEncryptionMode);
		this._keepaliveTask = this.KeepaliveAsync();
			var nullpacketmem = nullPcm.AsMemory();
		this._readyWait.SetResult(true);
	private async Task HandleDispatch(JObject jo)
		ArgumentNullException.ThrowIfNull(opc);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received READY (OP2)&quot;);
				ArgumentNullException.ThrowIfNull(opp);
				this._heartbeatTask = Task.Run(this.HeartbeatAsync, CancellationToken.None);
				await this.Stage1(vrp).ConfigureAwait(false);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received SESSION_DESCRIPTION (OP4)&quot;);
				this._sodium = new(this._key.AsMemory());
				await this.Stage2(vsd).ConfigureAwait(false);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received SPEAKING (OP5)&quot;);
				ArgumentNullException.ThrowIfNull(spd.Ssrc);
				var foundUserInCache = spd.UserId.HasValue &amp;&amp; this._discord.TryGetCachedUserInternal(spd.UserId.Value, out resolvedUser);
				var spk = new UserSpeakingEventArgs(this._discord.ServiceProvider)
				if (foundUserInCache &amp;&amp; this._transmittingSsrCs.TryGetValue(spk.Ssrc, out var txssrc5) &amp;&amp; txssrc5.Id is 0)
					var opus = this._opus.CreateDecoder();
					var vtx = new AudioSender(spk.Ssrc, opus)
						User = spd.UserId.HasValue ? await this._discord.GetUserAsync(spd.UserId.Value, true).ConfigureAwait(false) : null
					if (!this._transmittingSsrCs.TryAdd(spk.Ssrc, vtx))
						this._opus.DestroyDecoder(opus);
				await this._userSpeaking.InvokeAsync(this, spk).ConfigureAwait(false);
				Volatile.Write(ref this._wsPing, ping);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received HEARTBEAT_ACK (OP6, {Ping}ms)&quot;, ping);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received HELLO (OP8)&quot;);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received RESUMED (OP9)&quot;);
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received CLIENT_CONNECTED (OP12)&quot;);
				var usrj = await this._discord.GetUserAsync(ujpd.UserId, true).ConfigureAwait(false);
				var vtx = new AudioSender(ujpd.Ssrc, opus)
				if (!this._transmittingSsrCs.TryAdd(vtx.Ssrc, vtx))
				await this._userJoined.InvokeAsync(this, new(this._discord.ServiceProvider)
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received CLIENT_DISCONNECTED (OP13)&quot;);
				var txssrc = this._transmittingSsrCs.FirstOrDefault(x =&gt; x.Value.Id == ulpd.UserId);
				if (this._transmittingSsrCs.ContainsKey(txssrc.Key))
					this._transmittingSsrCs.TryRemove(txssrc.Key, out var txssrc13);
					this._opus.DestroyDecoder(txssrc13?.Decoder);
				var usrl = await this._discord.GetUserAsync(ulpd.UserId, true).ConfigureAwait(false);
				await this._userLeft.InvokeAsync(this, new(this._discord.ServiceProvider)
				this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received unknown voice opcode (OP{OpCode})&quot;, opc);
	private async Task VoiceWS_SocketClosed(IWebSocketClient client, SocketCloseEventArgs e)
		this._discord.Logger.LogDebug(VoiceNextEvents.VoiceConnectionClose, &quot;Voice WebSocket closed ({Code}, &apos;{Message}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
			this._tokenSource.Cancel();
				await this.ConnectAsync().ConfigureAwait(false);
	private Task VoiceWS_SocketMessage(IWebSocketClient client, SocketMessageEventArgs e)
			this._discord.Logger.LogCritical(VoiceNextEvents.VoiceGatewayError, &quot;Discord Voice Gateway sent binary data - unable to process&quot;);
		this._discord.Logger.LogTrace(VoiceNextEvents.VoiceWsRx, &quot;{Message}&quot;, et.Message);
		return this.HandleDispatch(JObject.Parse(et.Message));
	private Task VoiceWS_SocketOpened(IWebSocketClient client, SocketEventArgs e)
		=&gt; this.StartAsync();
	private Task VoiceWs_SocketException(IWebSocketClient client, SocketErrorEventArgs e)
		=&gt; this._voiceSocketError.InvokeAsync(this, new(this._discord.ServiceProvider)
	private async Task WsSendAsync(string payload)
		this._discord.Logger.LogTrace(VoiceNextEvents.VoiceWsTx, payload);
		await this._voiceWs.SendMessageAsync(payload).ConfigureAwait(false);
	private static uint UnixTimestamp(DateTime dt)</file><file path="DisCatSharp.VoiceNext/VoiceNextEvents.cs">public static class VoiceNextEvents</file><file path="DisCatSharp.VoiceNext/VoiceNextExtension.cs">public sealed class VoiceNextExtension : BaseExtension
	private readonly VoiceNextConfiguration _configuration;
	protected internal override void Setup(DiscordClient client)
			throw new InvalidOperationException(&quot;What did I tell you?&quot;);
	public async Task&lt;VoiceNextConnection&gt; ConnectAsync(DiscordChannel channel)
			throw new ArgumentException(&quot;Invalid channel specified; needs to be voice or stage channel&quot;, nameof(channel));
			throw new ArgumentException(&quot;Invalid channel specified; needs to be guild channel&quot;, nameof(channel));
		if (!channel.PermissionsFor(channel.Guild.CurrentMember).HasPermission(Permissions.AccessChannels | Permissions.UseVoice))
			throw new InvalidOperationException(&quot;You need AccessChannels and UseVoice permission to connect to this voice channel&quot;);
		if (this._activeConnections.ContainsKey(gld.Id))
			throw new InvalidOperationException(&quot;This guild already has a voice connection&quot;);
		var vsd = new VoiceDispatch
			Payload = new VoiceStateUpdatePayload
		var vsj = JsonConvert.SerializeObject(vsd, Formatting.None);
		await (channel.Discord as DiscordClient).WsSendAsync(vsj).ConfigureAwait(false);
		var vstu = await vstut.Task.ConfigureAwait(false);
		var vstup = new VoiceStateUpdatePayload
		var vsru = await vsrut.Task.ConfigureAwait(false);
		var vsrup = new VoiceServerUpdatePayload
		var vnc = new VoiceNextConnection(this.Client, gld, channel, this._configuration, vsrup, vstup);
		await vnc.ConnectAsync().ConfigureAwait(false);
		await vnc.WaitForReadyAsync().ConfigureAwait(false);
	public VoiceNextConnection GetConnection(DiscordGuild guild) =&gt; this._activeConnections.TryGetValue(guild.Id, out var value) ? value : null;
	private async Task Vnc_VoiceDisconnected(DiscordGuild guild)
		if (this._activeConnections.ContainsKey(guild.Id))
			this._activeConnections.TryRemove(guild.Id, out _);
		await (guild.Discord as DiscordClient).WsSendAsync(vsj).ConfigureAwait(false);
	private Task Client_VoiceStateUpdate(DiscordClient client, VoiceStateUpdateEventArgs e)
			if (e.After.Channel is null &amp;&amp; this._activeConnections.TryRemove(gld.Id, out var ac))
				ac.Disconnect();
			if (this._activeConnections.TryGetValue(e.Guild.Id, out var vnc))
			if (!string.IsNullOrWhiteSpace(e.SessionId) &amp;&amp; e.Channel is not null &amp;&amp; this._voiceStateUpdates.TryRemove(gld.Id, out var xe))
				xe.SetResult(e);
	private async Task Client_VoiceServerUpdate(DiscordClient client, VoiceServerUpdateEventArgs e)
			var epi = eps.LastIndexOf(&apos;:&apos;);
				epp = int.Parse(eps[(epi + 1)..]);
			await vnc.ReconnectAsync().ConfigureAwait(false);
		if (this._voiceServerUpdates.ContainsKey(gld.Id))
			this._voiceServerUpdates.TryRemove(gld.Id, out var xe);</file><file path="DisCatSharp.VoiceNext/VoiceTransmitSink.cs">public sealed class VoiceTransmitSink : IDisposable
	private readonly VoiceNextConnection _connection;
	private readonly SemaphoreSlim _writeSemaphore;
		this._pcmBuffer = new byte[vnc.AudioFormat.CalculateSampleSize(pcmBufferDuration)];
		this._pcmMemory = this._pcmBuffer.AsMemory();
				throw new ArgumentOutOfRangeException(nameof(value), &quot;Volume needs to be between 0% and 250%.&quot;);
	public void Dispose()
	public async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default)
		=&gt; await this.WriteAsync(new(buffer, offset, count), cancellationToken).ConfigureAwait(false);
	public async Task WriteAsync(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken = default)
		await this._writeSemaphore.WaitAsync(cancellationToken).ConfigureAwait(false);
				var len = Math.Min(pcmSpan.Length - this._pcmBufferLength, remaining);
				src.CopyTo(tgt);
				this.ApplyFiltersSync(pcmSpan);
				var packet = ArrayPool&lt;byte&gt;.Shared.Rent(this._pcmMemory.Length);
				var packetMemory = packet.AsMemory()[..this._pcmMemory.Length];
				this._pcmMemory.CopyTo(packetMemory);
				await this._connection.EnqueuePacketAsync(new(packetMemory, this.SampleDuration, false, packet), cancellationToken).ConfigureAwait(false);
			this._writeSemaphore.Release();
	public async Task FlushAsync(CancellationToken cancellationToken = default)
		Helpers.ZeroFill(pcm[this._pcmBufferLength..].Span);
		this.ApplyFiltersSync(pcm);
		var packet = ArrayPool&lt;byte&gt;.Shared.Rent(pcm.Length);
		var packetMemory = packet.AsMemory()[..pcm.Length];
		pcm.CopyTo(packetMemory);
	public void Pause()
		=&gt; this._connection.Pause();
	public async Task ResumeAsync()
		=&gt; await this._connection.ResumeAsync().ConfigureAwait(false);
	public IEnumerable&lt;IVoiceFilter&gt; GetInstalledFilters()
	public void InstallFilter(IVoiceFilter filter, int order = int.MaxValue)
		ArgumentNullException.ThrowIfNull(filter);
			throw new ArgumentOutOfRangeException(nameof(order), &quot;Filter order must be greater than or equal to 0.&quot;);
				this._filters.Add(filter);
				this._filters.Insert(order, filter);
	public bool UninstallFilter(IVoiceFilter filter)
			return this._filters.Contains(filter) &amp;&amp; this._filters.Remove(filter);
	private void ApplyFiltersSync(Memory&lt;byte&gt; pcmSpan)
					filter.Transform(pcm16, this._connection.AudioFormat, this.SampleDuration);</file><file path="DisCatSharp/BaseExtension.cs">public abstract class BaseExtension
	protected internal abstract void Setup(DiscordClient client);</file><file path="DisCatSharp/Clients/BaseDiscordClient.cs">public abstract class BaseDiscordClient : IDisposable
				this.Configuration.LoggerFactory = new DefaultLoggerFactory();
				this.Configuration.LoggerFactory.AddProvider(new DefaultLoggerProvider(this));
				var l = new ConsoleLoggerProvider(optionsMonitor);
				this.Configuration.LoggerFactory = new LoggerFactory();
				this.Configuration.LoggerFactory.AddProvider(l);
		var ass = typeof(DiscordClient).GetTypeInfo().Assembly;
			var v = ass.GetName().Version;
				this.Configuration.LoggerFactory.AddSentry(o =&gt;
					o.AddInAppInclude(&quot;DisCatSharp&quot;);
						o.AddExceptionFilter(new DisCatSharpExceptionFilter(this.Configuration));
					o.SetBeforeSend((e, _) =&gt;
								if (!this.Configuration.TrackExceptions.Contains(e.Exception.GetType()))
							else if (e.Extra.Count == 0 || !e.Extra.ContainsKey(&quot;Found Fields&quot;))
						if (e.HasUser())
								Id = this.CurrentUser.Id.ToString(),
			SentryOptions options = new()
				options.SetBeforeBreadcrumb(b
					=&gt; new(Utilities.StripTokensAndOptIds(b.Message, this.Configuration.EnableDiscordIdScrubber)!,
						b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripTokensAndOptIds(x.Value, this.Configuration.EnableDiscordIdScrubber)!))
							.ToDictionary(x =&gt; x.Key, x =&gt; x.Value),
				options.SetBeforeSendTransaction(tr =&gt;
						tr.Request.Data = Utilities.StripTokensAndOptIds(str, this.Configuration.EnableDiscordIdScrubber);
			options.SetBeforeSend((e, _) =&gt;
				if (!e.HasUser())
				if (!e.Extra.ContainsKey(&quot;Found Fields&quot;))
					e.SetFingerprint(GenerateSentryFingerPrint(e));
		var httphandler = new HttpClientHandler
		this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
		this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, this.Configuration.Locale);
		if (!string.IsNullOrWhiteSpace(this.Configuration.Timezone))
			this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, this.Configuration.Timezone);
			this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, this.Configuration.Override);
		var a = typeof(DiscordClient).GetTypeInfo().Assembly;
			var v = a.GetName().Version;
			var vs = v.ToString(3);
				[DisCatSharpStatisticType.Users] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.MemberCount ?? 0)),
				[DisCatSharpStatisticType.Channels] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Channels.Count)),
				[DisCatSharpStatisticType.Threads] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Threads.Count)),
				[DisCatSharpStatisticType.Roles] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Roles.Count)),
				[DisCatSharpStatisticType.Emojis] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Emojis.Count)),
				[DisCatSharpStatisticType.Stickers] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Stickers.Count)),
				[DisCatSharpStatisticType.SoundboardSounds] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.SoundboardSounds.Count)),
				[DisCatSharpStatisticType.StageInstances] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.StageInstances.Count)),
				[DisCatSharpStatisticType.ScheduledEvents] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.ScheduledEvents.Count))
	public abstract void Dispose();
	public async Task&lt;DiscordApplication&gt; GetCurrentApplicationAsync()
		var tapp = await this.ApiClient.GetCurrentApplicationOauth2InfoAsync().ConfigureAwait(false);
	public async Task&lt;DiscordApplication&gt; UpdateCurrentApplicationInfoAsync(
		var iconb64 = MediaTool.Base64FromStream(icon);
		var coverImageb64 = MediaTool.Base64FromStream(coverImage);
			if (tags.Value.Any(x =&gt; x.Length &gt; 20))
				throw new InvalidOperationException(&quot;Tags can not exceed 20 chars.&quot;);
		DiscordApplication app = new(await this.ApiClient.ModifyCurrentApplicationInfoAsync(description, interactionsEndpointUrl, roleConnectionsVerificationUrl, customInstallUrl, tags, iconb64, coverImageb64, flags, installParams, Optional.None).ConfigureAwait(false));
	public async Task&lt;DiscordApplication&gt; EnableUserAppsAsync()
		var currentApplication = await this.GetCurrentApplicationAsync().ConfigureAwait(false);
		DiscordIntegrationTypesConfig integrationTypesConfig = new()
		var app = await this.UpdateCurrentApplicationInfoAsync(Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, integrationTypesConfig).ConfigureAwait(false);
		DiscordApplication app = new(await this.ApiClient.ModifyCurrentApplicationInfoAsync(description, interactionsEndpointUrl, roleConnectionsVerificationUrl, customInstallUrl, tags, iconb64, coverImageb64, flags, Optional.None, integrationTypesConfig).ConfigureAwait(false));
	public Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
		=&gt; this.ApiClient.ListVoiceRegionsAsync();
	public virtual async Task InitializeAsync()
			this.CurrentUser = await this.ApiClient.GetCurrentUserAsync().ConfigureAwait(false);
			this.UserCache.AddOrUpdate(this.CurrentUser.Id, this.CurrentUser, (id, xu) =&gt; this.CurrentUser);
			this.CurrentApplication = await this.GetCurrentApplicationAsync().ConfigureAwait(false);
			var vrs = await this.ListVoiceRegionsAsync().ConfigureAwait(false);
				this.InternalVoiceRegions.TryAdd(xvr.Id, xvr);
			SentrySdk.ConfigureScope(x =&gt; x.User = new()
	public async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync(string? token = null)
			throw new InvalidOperationException(&quot;Only bot tokens can access this info.&quot;);
		if (!string.IsNullOrEmpty(this.Configuration.Token))
			return await this.ApiClient.GetGatewayInfoAsync().ConfigureAwait(false);
		if (string.IsNullOrEmpty(token))
			throw new InvalidOperationException(&quot;Could not locate a valid token.&quot;);
		var res = await this.ApiClient.GetGatewayInfoAsync().ConfigureAwait(false);
	internal DiscordUser GetCachedOrEmptyUserInternal(ulong userId)
		if (!this.TryGetCachedUserInternal(userId, out var user))
	internal bool TryGetCachedUserInternal(ulong userId, [MaybeNullWhen(false)] out DiscordUser user)
		=&gt; this.UserCache.TryGetValue(userId, out user);
	internal abstract IReadOnlyDictionary&lt;ulong, DiscordApplicationEmoji&gt; UpdateCachedApplicationEmojis(JArray? rawEmojis);
	internal abstract DiscordApplicationEmoji UpdateCachedApplicationEmoji(DiscordApplicationEmoji emoji);
	internal static IEnumerable&lt;string&gt; GenerateSentryFingerPrint(SentryEvent ev, string? additional = null)
			ev.Level.ToString(),
			fingerPrint.Add(ev.Message.Message);
			fingerPrint.Add(additional);
		fingerPrint.Add(ex.GetType().FullName);
		if (!string.IsNullOrEmpty(ex.Message))
			fingerPrint.Add(ex.Message);
			fingerPrint.Add(ex.TargetSite.ToString());
		fingerPrint.Add(ex.InnerException.GetType().FullName);
		if (!string.IsNullOrEmpty(ex.InnerException.Message))
			fingerPrint.Add(ex.InnerException.Message);</file><file path="DisCatSharp/Clients/DiscordClient.cs">public sealed partial class DiscordClient : BaseDiscordClient
	private readonly ManualResetEventSlim _connectionLock = new(true);
		=&gt; Volatile.Read(ref this._ping);
			this.MessageCache = intents.HasIntent(DiscordIntents.GuildMessages) || intents.HasIntent(DiscordIntents.DirectMessages)
		this.InternalSetup();
	internal void InternalSetup()
		this.GuildsInternal.Clear();
		this.EmojisInternal.Clear();
	public void AddExtension(BaseExtension ext)
		ext.Setup(this);
		this._extensions.Add(ext);
	public T? GetExtension&lt;T&gt;() where T : BaseExtension
		=&gt; this._extensions.FirstOrDefault(x =&gt; x.GetType() == typeof(T)) as T;
	public async Task ConnectAsync(DiscordActivity? activity = null, UserStatus? status = null, DateTimeOffset? idlesince = null)
		if (!this._connectionLock.Wait(0))
			throw new InvalidOperationException(&quot;This client is already connected.&quot;);
		this._connectionLock.Set();
			var sinceUnix = idlesince != null ? (long?)Utilities.GetUnixTime(idlesince.Value) : null;
				this.Logger.LogWarning(LoggerEvents.Misc, &quot;You are logging in with a token that is not a bot token. This is not officially supported by Discord, and can result in your account being terminated if you aren&apos;t careful&quot;);
			this.Logger.LogInformation(LoggerEvents.Startup, &quot;Lib {LibraryName}, version {LibraryVersion}&quot;, this.BotLibrary, this.VersionString);
			this.Logger.LogInformation(&quot;Checking versions..&quot;);
			await Utilities.CheckVersionAsync(this, true, this.IsShard, githubToken: this.Configuration.UpdateCheckGitHubToken, includePrerelease: this.Configuration.IncludePrereleaseInUpdateCheck, checkMode: this.Configuration.UpdateCheckMode);
			foreach (var extension in this._extensions.Where(extension =&gt; extension.HasVersionCheckSupport))
				await Utilities.CheckVersionAsync(this, true, this.IsShard, extension.RepositoryOwner, extension.Repository, extension.PackageId, extension.VersionString, this.Configuration.UpdateCheckGitHubToken, this.Configuration.IncludePrereleaseInUpdateCheck, this.Configuration.UpdateCheckMode);
			this.Logger.LogInformation(&quot;Done&quot;);
			this.Logger.LogInformation(&quot;Skipped version check&quot;);
				await this.InternalConnectAsync().ConfigureAwait(false);
				this.Logger.LogError(LoggerEvents.ConnectionFailure, ex, &quot;Connection attempt failed, retrying in {Seconds}s&quot;, w / 1000);
				await Task.Delay(w, this._cancelToken).ConfigureAwait(false);
				var skus = await this.ApiClient.GetSkusAsync(this.CurrentApplication.Id).ConfigureAwait(false);
				if (!skus.Any())
				this.Configuration.SkuId = skus.FirstOrDefault(x =&gt; x.Type is SkuType.Subscription)?.Id;
				this.Logger.LogError(LoggerEvents.Startup, ex, &quot;Failed to fetch SKU IDs&quot;);
				await this.ApiClient.GetApplicationEmojisAsync(this.CurrentApplication.Id);
				this.Logger.LogError(LoggerEvents.Startup, ex, &quot;Failed to fetch application emojis&quot;);
	public Task ReconnectAsync(bool startNewSession = true)
		=&gt; this.InternalReconnectAsync(startNewSession, startNewSession ? 1000 : 4002);
	public async Task DisconnectAsync()
			await this.WebSocketClient.DisconnectAsync().ConfigureAwait(false);
	public async Task RequestSoundboardSoundsAsync(IEnumerable&lt;ulong&gt; guildIds)
		var payload = new DiscordDispatchPayload
			Payload = new RequestSoundboardSoundsPayload
		await this.WsSendAsync(DiscordJson.SerializeObject(payload)).ConfigureAwait(false);
	public async Task&lt;IReadOnlyDictionary&lt;ulong, IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt;&gt; RequestAndWaitForSoundboardSoundsAsync(IEnumerable&lt;ulong&gt; guildIds)
		var targetGuildIds = guildIds.ToList();
			if (targetGuildIds.Contains(e.GuildId))
				guildSoundsKvp.TryAdd(e.GuildId, e.Sounds);
		await this.RequestSoundboardSoundsAsync(targetGuildIds);
			await Task.Delay(TimeSpan.FromSeconds(1), this._cancelToken);
		return guildSoundsKvp.AsReadOnly();
	public async Task&lt;DiscordUser&gt; GetUserAsync(ulong userId, bool fetch = false)
		if (!fetch &amp;&amp; this.TryGetCachedUserInternal(userId, out var cachedUsr))
		var usr = await this.ApiClient.GetUserAsync(userId).ConfigureAwait(false);
		usr = this.UserCache.AddOrUpdate(userId, usr, (id, old) =&gt;
	public async Task&lt;DiscordRpcApplication&gt; GetRpcApplicationAsync(ulong applicationId)
		=&gt; await this.ApiClient.GetApplicationRpcInfoAsync(applicationId).ConfigureAwait(false);
	public async Task&lt;DiscordApplication&gt; GetCurrentApplicationInfoAsync()
		var tapp = await this.ApiClient.GetCurrentApplicationInfoAsync().ConfigureAwait(false);
	public bool TryGetUser(ulong userId, [NotNullWhen(true)] out DiscordUser? user, bool fetch = true)
			user = this.GetUserAsync(userId, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
	public async Task&lt;IReadOnlyList&lt;DiscordStoreSku&gt;&gt; GetPublishedListingsAsync(ulong applicationId)
		=&gt; await this.ApiClient.GetPublishedListingsAsync(applicationId).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordSku&gt;&gt; GetSkusAsync()
		=&gt; await this.ApiClient.GetSkusAsync(this.CurrentApplication.Id).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordEntitlement&gt;&gt; GetEntitlementsAsync(ulong? guildId = null, ulong? userId = null, List&lt;ulong&gt;? skuIds = null, ulong? before = null, ulong? after = null, int limit = 100, bool? excludeEnded = null, bool? excludeDeleted = null)
		=&gt; await this.ApiClient.GetEntitlementsAsync(this.CurrentApplication.Id, guildId, userId, skuIds, before, after, limit, excludeEnded, excludeDeleted).ConfigureAwait(false);
	public async Task&lt;DiscordEntitlement?&gt; GetEntitlementAsync(ulong entitlementId)
		=&gt; await this.ApiClient.GetEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
	public async Task&lt;bool&gt; ConsumeEntitlementAsync(ulong entitlementId)
		=&gt; await this.ApiClient.ConsumeEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSkuSubscriptionsAsync(ulong skuId, ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
		=&gt; await this.ApiClient.GetSkuSubscriptionsAsync(skuId, userId, before, after, limit).ConfigureAwait(false);
	public async Task&lt;DiscordSubscription?&gt; GetSkuSubscriptionAsync(ulong skuId, ulong subscriptionId)
		=&gt; await this.ApiClient.GetSkuSubscriptionAsync(skuId, subscriptionId).ConfigureAwait(false);
	public async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong skuId, ulong ownerId, EntitlementOwnerType ownerType)
		=&gt; await this.ApiClient.CreateTestEntitlementAsync(this.CurrentApplication.Id, skuId, ownerId, ownerType).ConfigureAwait(false);
	public async Task DeleteTestEntitlementAsync(ulong entitlementId)
		=&gt; await this.ApiClient.DeleteTestEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; GetRoleConnectionMetadata()
		=&gt; await this.ApiClient.GetRoleConnectionMetadataRecords(this.CurrentApplication.Id).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; UpdateRoleConnectionMetadata(IEnumerable&lt;DiscordApplicationRoleConnectionMetadata&gt; metadata)
		=&gt; await this.ApiClient.UpdateRoleConnectionMetadataRecords(this.CurrentApplication.Id, metadata).ConfigureAwait(false);
	public async Task RemoveGlobalApplicationCommandsAsync()
		=&gt; await this.ApiClient.BulkOverwriteGlobalApplicationCommandsAsync(this.CurrentApplication.Id, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
	public async Task RemoveGuildApplicationCommandsAsync(ulong guildId)
		=&gt; await this.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
	public async Task RemoveGuildApplicationCommandsAsync(DiscordGuild guild)
		=&gt; await this.RemoveGuildApplicationCommandsAsync(guild.Id).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordApplicationEmoji&gt;&gt; GetApplicationEmojisAsync(bool fetch = false)
		=&gt; (fetch ? null : this.InternalGetCachedApplicationEmojis()) ?? await this.ApiClient.GetApplicationEmojisAsync(this.CurrentApplication.Id).ConfigureAwait(false);
	public async Task&lt;DiscordApplicationEmoji?&gt; GetApplicationEmojiAsync(ulong id, bool fetch = false)
		=&gt; (fetch ? null : this.InternalGetCachedApplicationEmoji(id)) ?? await this.ApiClient.GetApplicationEmojiAsync(this.CurrentApplication.Id, id).ConfigureAwait(false);
	public async Task&lt;DiscordApplicationEmoji&gt; CreateApplicationEmojiAsync(string name, Stream image)
		var imageb64 = MediaTool.Base64FromStream(image);
		return await this.ApiClient.CreateApplicationEmojiAsync(this.CurrentApplication.Id, name, imageb64);
	public Task&lt;DiscordApplicationEmoji&gt; ModifyApplicationEmojiAsync(ulong id, string name)
		=&gt; this.ApiClient.ModifyApplicationEmojiAsync(this.CurrentApplication.Id, id, name);
	public Task DeleteApplicationEmojiAsync(ulong id)
		=&gt; this.ApiClient.DeleteApplicationEmojiAsync(this.CurrentApplication.Id, id);
	public async Task&lt;DiscordChannel&gt; GetChannelAsync(ulong id, bool fetch = false)
		=&gt; (fetch ? null : this.InternalGetCachedChannel(id)) ?? await this.ApiClient.GetChannelAsync(id).ConfigureAwait(false);
	public bool TryGetChannel(ulong id, [NotNullWhen(true)] out DiscordChannel? channel, bool fetch = true)
			channel = this.GetChannelAsync(id, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
	public async Task&lt;DiscordThreadChannel&gt; GetThreadAsync(ulong id, bool fetch = false)
		=&gt; (fetch ? null : this.InternalGetCachedThread(id)) ?? await this.ApiClient.GetThreadAsync(id).ConfigureAwait(false);
	public bool TryGetThread(ulong id, [NotNullWhen(true)] out DiscordThreadChannel? thread, bool fetch = true)
			thread = this.GetThreadAsync(id, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, string content)
		=&gt; this.ApiClient.CreateMessageAsync(channel.Id, content, null, null, null, false, false);
	public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, DiscordEmbed embed)
		=&gt; this.ApiClient.CreateMessageAsync(channel.Id, null, embed != null
		Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, string content, DiscordEmbed embed)
		=&gt; this.ApiClient.CreateMessageAsync(channel.Id, content, embed != null
		Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, DiscordMessageBuilder builder)
		=&gt; this.ApiClient.CreateMessageAsync(channel.Id, builder);
	public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, Action&lt;DiscordMessageBuilder&gt; action)
		var builder = new DiscordMessageBuilder();
		return this.ApiClient.CreateMessageAsync(channel.Id, builder);
	public Task&lt;DiscordGuild&gt; CreateGuildAsync(
		var iconb64 = MediaTool.Base64FromStream(icon);
		return this.ApiClient.CreateGuildAsync(name, region, iconb64, verificationLevel, defaultMessageNotifications, systemChannelFlags);
	public Task&lt;DiscordGuild&gt; CreateGuildFromTemplateAsync(string code, string name, Optional&lt;Stream&gt; icon = default)
		return this.ApiClient.CreateGuildFromTemplateAsync(code, name, iconb64);
	public async Task&lt;DiscordGuild&gt; GetGuildAsync(ulong id, bool? withCounts = null, bool fetch = false)
		if (!fetch &amp;&amp; this.GuildsInternal.TryGetValue(id, out var guild) &amp;&amp; (!withCounts.HasValue || !withCounts.Value))
		guild = await this.ApiClient.GetGuildAsync(id, withCounts).ConfigureAwait(false);
		var channels = await this.ApiClient.GetGuildChannelsAsync(guild.Id).ConfigureAwait(false);
	public bool TryGetGuild(ulong id, [NotNullWhen(true)] out DiscordGuild? guild, bool? withCounts = null, bool fetch = true)
			guild = this.GetGuildAsync(id, withCounts, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordGuildPreview&gt; GetGuildPreviewAsync(ulong id)
		=&gt; this.ApiClient.GetGuildPreviewAsync(id);
	public bool TryGetGuildPreview(ulong id, [NotNullWhen(true)] out DiscordGuildPreview? preview)
			preview = this.ApiClient.GetGuildPreviewAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordWidget&gt; GetGuildWidgetAsync(ulong id)
		=&gt; this.ApiClient.GetGuildWidgetAsync(id);
	public bool TryGetGuildWidget(ulong id, [NotNullWhen(true)] out DiscordWidget? widget)
			widget = this.ApiClient.GetGuildWidgetAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordInvite&gt; GetInviteByCodeAsync(string code, bool? withCounts = null, bool? withExpiration = null, ulong? scheduledEventId = null)
		=&gt; this.ApiClient.GetInviteAsync(code, withCounts, withExpiration, scheduledEventId);
	public bool TryGetInviteByCode(string code, [NotNullWhen(true)] out DiscordInvite? invite, bool? withCounts = null, bool? withExpiration = null, ulong? scheduledEventId = null)
			invite = this.GetInviteByCodeAsync(code, withCounts, withExpiration, scheduledEventId).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetConnectionsAsync()
		=&gt; this.ApiClient.GetUserConnectionsAsync();
	public Task&lt;DiscordSticker&gt; GetStickerAsync(ulong id)
		=&gt; this.ApiClient.GetStickerAsync(id);
	public bool TryGetSticker(ulong id, [NotNullWhen(true)] out DiscordSticker? sticker)
			sticker = this.GetStickerAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordStickerPack&gt; GetStickerPackAsync(ulong id)
		=&gt; this.ApiClient.GetStickerPackAsync(id);
	public Task&lt;IReadOnlyList&lt;DiscordStickerPack&gt;&gt; GetStickerPacksAsync()
		=&gt; this.ApiClient.GetStickerPacksAsync();
	public Uri GetInAppOAuth(Permissions permissions = Permissions.None, OAuthScopes scopes = OAuthScopes.BOT_DEFAULT, string? redir = null, bool user_install = false, ulong? guild_id = null, string? state = null, string? access_type = null, string? response_type = null, bool prompt = true, string? manual_scopes = null)
		return new(new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
			.AddParameter(&quot;client_id&quot;, this.CurrentApplication.Id.ToString(CultureInfo.InvariantCulture))
			.AddParameter(&quot;scope&quot;, manual_scopes ?? OAuth.ResolveScopes(scopes))
			.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
			.AddParameter(&quot;state&quot;, state ?? string.Empty)
			.AddParameter(&quot;redirect_uri&quot;, redir ?? string.Empty)
			.AddParameter(&quot;integration_type&quot;, user_install ? &quot;1&quot; : &quot;0&quot;)
			.AddParameter(&quot;guild_id&quot;, guild_id.HasValue ? guild_id.Value.ToString(CultureInfo.InvariantCulture) : string.Empty)
			.AddParameter(&quot;access_type&quot;, access_type ?? string.Empty)
			.AddParameter(&quot;response_type&quot;, response_type ?? string.Empty)
			.AddParameter(&quot;prompt&quot;, prompt ? &quot;consent&quot; : &quot;none&quot;)
			.ToString());
	public Uri GenerateInAppOauthFor(DiscordUser bot, Permissions permissions = Permissions.None, OAuthScopes scopes = OAuthScopes.BOT_DEFAULT, string? redir = null, bool user_install = false, ulong? guild_id = null, string? state = null, string? access_type = null, string? response_type = null, bool prompt = true, string? manual_scopes = null)
			throw new ArgumentException(&quot;The user must be a bot.&quot;, nameof(bot));
			.AddParameter(&quot;client_id&quot;, bot.Id.ToString(CultureInfo.InvariantCulture))
	public Task&lt;DiscordWebhook&gt; GetWebhookAsync(ulong id)
		=&gt; this.ApiClient.GetWebhookAsync(id);
	public bool TryGetWebhook(ulong id, [NotNullWhen(true)] out DiscordWebhook? webhook)
			webhook = this.GetWebhookAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task&lt;DiscordWebhook&gt; GetWebhookWithTokenAsync(ulong id, string token)
		=&gt; this.ApiClient.GetWebhookWithTokenAsync(id, token);
	public bool TryGetWebhookWithToken(ulong id, string token, [NotNullWhen(true)] out DiscordWebhook? webhook)
			webhook = this.GetWebhookWithTokenAsync(id, token).ConfigureAwait(false).GetAwaiter().GetResult();
	public Task UpdateStatusAsync(DiscordActivity activity = null, UserStatus? userStatus = null, DateTimeOffset? idleSince = null)
		=&gt; this.InternalUpdateStatusAsync(activity, userStatus, idleSince);
	public async Task&lt;DiscordUser&gt; UpdateCurrentUserAsync(string? username = null, Optional&lt;Stream?&gt; avatar = default, Optional&lt;Stream?&gt; banner = default)
		var av64 = MediaTool.Base64FromStream(avatar);
		var ba64 = MediaTool.Base64FromStream(banner);
		var usr = await this.ApiClient.ModifyCurrentUserAsync(username ?? this.CurrentUser.Username, av64, ba64).ConfigureAwait(false);
	public Task&lt;DiscordGuildTemplate&gt; GetTemplateAsync(string code)
		=&gt; this.ApiClient.GetTemplateAsync(code);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGlobalApplicationCommandsAsync(bool withLocalizations = false) =&gt;
		this.ApiClient.GetGlobalApplicationCommandsAsync(this.CurrentApplication.Id, withLocalizations);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGlobalApplicationCommandsAsync(IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
		this.ApiClient.BulkOverwriteGlobalApplicationCommandsAsync(this.CurrentApplication.Id, commands);
	public Task&lt;DiscordApplicationCommand&gt; CreateGlobalApplicationCommandAsync(DiscordApplicationCommand command) =&gt;
		this.ApiClient.CreateGlobalApplicationCommandAsync(this.CurrentApplication.Id, command);
	public Task&lt;DiscordApplicationCommand&gt; GetGlobalApplicationCommandAsync(ulong commandId) =&gt;
		this.ApiClient.GetGlobalApplicationCommandAsync(this.CurrentApplication.Id, commandId);
	public async Task&lt;DiscordApplicationCommand&gt; EditGlobalApplicationCommandAsync(ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
		var mdl = new ApplicationCommandEditModel();
		var applicationId = this.CurrentApplication?.Id ?? (await this.GetCurrentApplicationAsync().ConfigureAwait(false)).Id;
		return await this.ApiClient.EditGlobalApplicationCommandAsync(applicationId, commandId, mdl.Name, mdl.Description, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
	public Task DeleteGlobalApplicationCommandAsync(ulong commandId) =&gt;
		this.ApiClient.DeleteGlobalApplicationCommandAsync(this.CurrentApplication.Id, commandId);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGuildApplicationCommandsAsync(ulong guildId, bool withLocalizations = false) =&gt;
		this.ApiClient.GetGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, withLocalizations);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGuildApplicationCommandsAsync(ulong guildId, IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
		this.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, commands);
	public Task&lt;DiscordApplicationCommand&gt; CreateGuildApplicationCommandAsync(ulong guildId, DiscordApplicationCommand command) =&gt;
		this.ApiClient.CreateGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, command);
	public Task&lt;DiscordApplicationCommand&gt; GetGuildApplicationCommandAsync(ulong guildId, ulong commandId) =&gt;
		this.ApiClient.GetGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, commandId);
	public async Task&lt;DiscordApplicationCommand&gt; EditGuildApplicationCommandAsync(ulong guildId, ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
		return await this.ApiClient.EditGuildApplicationCommandAsync(applicationId, guildId, commandId, mdl.Name, mdl.Description, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
	public Task DeleteGuildApplicationCommandAsync(ulong guildId, ulong commandId) =&gt;
		this.ApiClient.DeleteGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, commandId);
	public Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListDefaultSoundboardSoundsAsync()
		=&gt; this.ApiClient.ListDefaultSoundboardSoundsAsync();
	internal DiscordThreadChannel? InternalGetCachedThread(ulong threadId)
			if (guild.Threads.TryGetValue(threadId, out var foundThread))
	internal DiscordApplicationEmoji? InternalGetCachedApplicationEmoji(ulong emojiId)
		=&gt; this.EmojisInternal is null || this.EmojisInternal.Count is 0 ? null : this.EmojisInternal.GetValueOrDefault(emojiId);
	internal IReadOnlyList&lt;DiscordApplicationEmoji&gt;? InternalGetCachedApplicationEmojis()
		=&gt; this.EmojisInternal is null || this.EmojisInternal.Count is 0 ? null : this.EmojisInternal.Values.ToList();
	internal DiscordScheduledEvent? InternalGetCachedScheduledEvent(ulong scheduledEventId)
			if (guild.ScheduledEvents.TryGetValue(scheduledEventId, out var foundScheduledEvent))
	internal DiscordChannel? InternalGetCachedChannel(ulong channelId, ulong? guildId = null)
			if (guild.Channels.TryGetValue(channelId, out var foundChannel))
	internal DiscordGuild? InternalGetCachedGuild(ulong? guildId)
			if (this.GuildsInternal.TryGetValue(guildId.Value, out var guild))
	private void UpdateMessage(DiscordMessage message, TransportUser? author, DiscordGuild guild, TransportMember? member)
			var usr = new DiscordUser(author)
			message.Author = this.UpdateUser(usr, guild?.Id, guild, member);
		var channel = this.InternalGetCachedChannel(message.ChannelId);
			? new DiscordDmChannel
			: new DiscordChannel
	private DiscordScheduledEvent UpdateScheduledEvent(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
		ObjectDisposedException.ThrowIf(this._disposed, this);
			_ = guild.ScheduledEventsInternal.AddOrUpdate(scheduledEvent.Id, scheduledEvent, (id, old) =&gt;
	private DiscordUser UpdateUser(DiscordUser usr, ulong? guildId, DiscordGuild? guild, TransportMember? mbr)
				_ = this.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
				usr = new DiscordMember(mbr)
			if (intents.HasAllPrivilegedIntents() &amp;&amp; !guild.IsLarge) // we have the necessary privileged intents, no need to worry about caching here unless guild is large.
			if (!guild.MembersInternal.TryGetValue(usr.Id, out var member))
				if (intents.HasIntent(DiscordIntents.GuildMembers) || this.Configuration.AlwaysCacheMembers) // member can be updated by events, so cache it
					guild.MembersInternal.TryAdd(usr.Id, (DiscordMember)usr);
			else if (intents.HasIntent(DiscordIntents.GuildPresences) || this.Configuration.AlwaysCacheMembers) // we can attempt to update it if it&apos;s already in cache.
				if (!intents.HasIntent(DiscordIntents.GuildMembers)) // no need to update if we already have the member events
					_ = guild.MembersInternal.TryUpdate(usr.Id, (DiscordMember)usr, member);
	private void UpdateCachedScheduledEvents(DiscordGuild guild, JArray? rawEvents)
			guild.ScheduledEventsInternal.Clear();
	internal override IReadOnlyDictionary&lt;ulong, DiscordApplicationEmoji&gt; UpdateCachedApplicationEmojis(JArray? rawEmojis)
					this.UpdateUser(xtm.User, null, null, null);
	internal override DiscordApplicationEmoji UpdateCachedApplicationEmoji(DiscordApplicationEmoji emoji)
			_ = this.EmojisInternal.AddOrUpdate(emoji.Id, emoji, (id, old) =&gt;
			this.UpdateUser(emoji.User, null, null, null);
	private void UpdateCachedGuild(DiscordGuild newGuild, JArray? rawMembers)
		this.GuildsInternal.TryAdd(newGuild.Id, newGuild);
				if (guild.ChannelsInternal.TryGetValue(channel.Id, out _))
				channel.Initialize(this);
				if (guild.ThreadsInternal.TryGetValue(thread.Id, out _))
				if (guild.ScheduledEventsInternal.TryGetValue(@event.Id, out _))
				if (guild.SoundboardSoundsInternal.TryGetValue(sound.Id, out _))
			_ = guild.EmojisInternal.GetOrAdd(newEmoji.Id, newEmoji);
			_ = guild.StickersInternal.GetOrAdd(newSticker.Id, newSticker);
			_ = guild.StageInstancesInternal.GetOrAdd(newStageInstance.Id, newStageInstance);
			guild.MembersInternal.Clear();
				ArgumentNullException.ThrowIfNull(xtm.User);
				var usr = new DiscordUser(xtm.User)
				_ = this.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
			if (guild.RolesInternal.TryGetValue(role.Id, out _))
	private void PopulateMessageReactionsAndCache(DiscordMessage message, TransportUser author, TransportMember? member)
		var guild = message.Channel?.Guild ?? this.InternalGetCachedGuild(message.GuildId);
		this.UpdateMessage(message, author, guild, member);
		this.Dispose();
	public override void Dispose()
			this.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
		this.ApiClient.Rest.Dispose();
		this.CommandCooldownBuckets.Clear();
		this._extensions.Clear();
				disposable.Dispose();
			SentrySdk.EndSession();
		GC.SuppressFinalize(this);</file><file path="DisCatSharp/Clients/DiscordClient.Dispatch.cs">public sealed partial class DiscordClient
	internal async Task HandleDispatchAsync(GatewayPayload payload)
			this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Invalid payload body (this message is probably safe to ignore); opcode: {op} event: {event}; payload: {payload}&quot;, payload.OpCode, payload.EventName, payload.Data);
			await this._payloadReceived.InvokeAsync(this, new(this.ServiceProvider)
			}).ConfigureAwait(false);
		var payloadString = dat.ToString();
		DiscordChannel chn;
		DiscordStageInstance stg = default;
		DiscordIntegration itg = default;
		DiscordThreadChannel trd = default;
		DiscordThreadChannelMember trdm = default;
		DiscordScheduledEvent gse = default;
		TransportUser usr = default;
		TransportMember mbr = default;
		TransportUser refUsr = default;
		TransportMember refMbr = default;
		DiscordApplicationCommand ac = default;
		DiscordEntitlement ent = default;
		DiscordSubscription sub = default;
		JToken rawMbr = default;
		DiscordGuildJoinRequest joinRequest = default;
		JoinRequestStatusType joinRequestStatusType = default;
		switch (payload.EventName.ToLowerInvariant())
				await this.OnReadyEventAsync(dat!.ToObject&lt;ReadyPayload&gt;()!, glds).ConfigureAwait(false);
				await this.OnResumedAsync().ConfigureAwait(false);
				await this.OnChannelCreateEventAsync(chn).ConfigureAwait(false);
				await this.OnChannelUpdateEventAsync(chn).ConfigureAwait(false);
				await this.OnChannelDeleteEventAsync(chn.IsPrivate ? chn as DiscordDmChannel : chn).ConfigureAwait(false);
				await this.OnChannelPinsUpdateAsync((ulong?)dat[&quot;guild_id&quot;], cid, ts != null ? DateTimeOffset.Parse(ts, CultureInfo.InvariantCulture) : default(DateTimeOffset?)).ConfigureAwait(false);
				await this.OnVoiceChannelStatusUpdateAsync((ulong)dat[&quot;guild_id&quot;], cid, voiceChannelStatus).ConfigureAwait(false);
				await this.OnGuildCreateEventAsync(dat.ToDiscordObject&lt;DiscordGuild&gt;(), (JArray)dat[&quot;members&quot;]!, dat[&quot;presences&quot;]!.ToDiscordObject&lt;IEnumerable&lt;DiscordPresence&gt;&gt;()).ConfigureAwait(false);
				await this.OnGuildUpdateEventAsync(dat.ToDiscordObject&lt;DiscordGuild&gt;(), (JArray)dat[&quot;members&quot;]!).ConfigureAwait(false);
				await this.OnGuildDeleteEventAsync(DiscordJson.DeserializeObject&lt;DiscordGuild&gt;(payloadString, this)).ConfigureAwait(false);
				dat.Remove(&quot;guild_id&quot;);
				await this.OnGuildAuditLogEntryCreateEventAsync(this.GuildsInternal[gid], dat).ConfigureAwait(false);
				await this.OnGuildSyncEventAsync(this.GuildsInternal[gid], (bool)dat[&quot;large&quot;]!, (JArray)dat[&quot;members&quot;]!, dat[&quot;presences&quot;]!.ToDiscordObject&lt;IEnumerable&lt;DiscordPresence&gt;&gt;()).ConfigureAwait(false);
				await this.OnGuildEmojisUpdateEventAsync(this.GuildsInternal[gid], ems).ConfigureAwait(false);
				await this.OnStickersUpdatedAsync(strs, gid).ConfigureAwait(false);
				if (!this.GuildsInternal.TryGetValue(gid, out var value))
				await this.OnGuildIntegrationsUpdateEventAsync(value).ConfigureAwait(false);
				await this.OnAutomodRuleCreated(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
				await this.OnAutomodRuleUpdated(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
				await this.OnAutomodRuleDeleted(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
				await this.OnAutomodActionExecuted(this.GuildsInternal[gid], dat).ConfigureAwait(false);
				usr = DiscordJson.DeserializeObject&lt;TransportUser&gt;(dat[&quot;user&quot;]!.ToString(), this);
				await this.OnGuildBanAddEventAsync(usr, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildBanRemoveEventAsync(usr, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildScheduledEventCreateEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildScheduledEventUpdateEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildScheduledEventDeleteEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildScheduledEventUserAddedEventAsync((ulong)dat[&quot;guild_scheduled_event_id&quot;]!, uid, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildScheduledEventUserRemovedEventAsync((ulong)dat[&quot;guild_scheduled_event_id&quot;]!, uid, this.GuildsInternal[gid]).ConfigureAwait(false);
				if (!this.GuildsInternal.TryGetValue(gid, out var icGuildVal))
				await this.OnGuildIntegrationCreateEventAsync(icGuildVal, itg).ConfigureAwait(false);
				if (!this.GuildsInternal.TryGetValue(gid, out var iuGuildVal))
				await this.OnGuildIntegrationUpdateEventAsync(iuGuildVal, itg).ConfigureAwait(false);
				if (!this.GuildsInternal.TryGetValue(gid, out var idGuildVal))
				await this.OnGuildIntegrationDeleteEventAsync(idGuildVal, (ulong)dat[&quot;id&quot;], (ulong?)dat[&quot;application_id&quot;]).ConfigureAwait(false);
				await this.OnGuildMemberAddEventAsync(DiscordJson.DeserializeObject&lt;TransportMember&gt;(payloadString, this), this.GuildsInternal[gid]).ConfigureAwait(false);
				if (!this.GuildsInternal.TryGetValue(gid, out var gmrGuildVal))
						this.Logger.LogError(LoggerEvents.WebSocketReceive, &quot;Could not find {0} in guild cache&quot;, gid);
				await this.OnGuildMemberRemoveEventAsync(usr, gmrGuildVal).ConfigureAwait(false);
				await this.OnGuildMemberUpdateEventAsync(DiscordJson.DeserializeObject&lt;TransportMember&gt;(payloadString, this), this.GuildsInternal[gid], dat[&quot;roles&quot;]!.ToObject&lt;IEnumerable&lt;ulong&gt;&gt;()!, (string)dat[&quot;nick&quot;]!, (bool?)dat[&quot;pending&quot;]).ConfigureAwait(false);
				await this.OnGuildMembersChunkEventAsync(dat).ConfigureAwait(false);
				await this.OnGuildRoleCreateEventAsync(DiscordJson.DeserializeObject&lt;DiscordRole&gt;(dat[&quot;role&quot;]!.ToString(), this), this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildRoleUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordRole&gt;(dat[&quot;role&quot;]!.ToString(), this), this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildRoleDeleteEventAsync((ulong)dat[&quot;role_id&quot;]!, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnGuildSoundboardSoundCreateEventAsync(DiscordJson.DeserializeObject&lt;DiscordSoundboardSound&gt;(dat.ToString(), this), gid).ConfigureAwait(false);
				await this.OnGuildSoundboardSoundUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordSoundboardSound&gt;(dat.ToString(), this), gid).ConfigureAwait(false);
				await this.OnGuildSoundboardSoundDeleteEventAsync(Convert.ToUInt64(dat[&quot;sound_id&quot;]!.ToString()), gid).ConfigureAwait(false);
				await this.OnGuildSoundboardSoundsUpdateEventAsync(DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordSoundboardSound&gt;&gt;(dat[&quot;soundboard_sounds&quot;]!.ToString(), this), gid).ConfigureAwait(false);
				var sounds = DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordSoundboardSound&gt;&gt;(dat[&quot;soundboard_sounds&quot;].ToString(), this);
				await this.OnSoundboardSoundsEventAsync(sounds, gid).ConfigureAwait(false);
				await this.OnGuildJoinRequestCreateAsync(this.Guilds[gid], joinRequestStatusType, joinRequest).ConfigureAwait(false);
					await this.OnGuildJoinRequestUpdateAsync(this.Guilds[gid], joinRequestStatusType, joinRequest).ConfigureAwait(false);
				await this.OnGuildJoinRequestDeleteAsync(requestId, uid, this.Guilds[gid]).ConfigureAwait(false);
				await this.OnInviteCreateEventAsync(cid, gid, DiscordJson.DeserializeObject&lt;DiscordInvite&gt;(payloadString, this)).ConfigureAwait(false);
				await this.OnInviteDeleteEventAsync(cid, gid, dat).ConfigureAwait(false);
				await this.OnMessageAckEventAsync(this.InternalGetCachedChannel(cid) ?? this.InternalGetCachedThread(cid), mid).ConfigureAwait(false);
					mbr = DiscordJson.DeserializeObject&lt;TransportMember&gt;(rawMbr.ToString(), this);
					if (rawRefMsg.SelectToken(&quot;author&quot;) != null)
						refUsr = DiscordJson.DeserializeObject&lt;TransportUser&gt;(rawRefMsg.SelectToken(&quot;author&quot;)!.ToString(), this);
					if (rawRefMsg.SelectToken(&quot;member&quot;) != null)
						refMbr = DiscordJson.DeserializeObject&lt;TransportMember&gt;(rawRefMsg.SelectToken(&quot;member&quot;)!.ToString(), this);
				await this.OnMessageCreateEventAsync(dat.ToDiscordObject&lt;DiscordMessage&gt;(), dat[&quot;author&quot;].ToObject&lt;TransportUser&gt;(), mbr, refUsr, refMbr).ConfigureAwait(false);
				await this.OnMessageUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordMessage&gt;(payloadString, this), dat[&quot;author&quot;] != null ? DiscordJson.DeserializeObject&lt;TransportUser&gt;(dat[&quot;author&quot;]!.ToString(), this) : null, mbr!, refUsr!, refMbr!).ConfigureAwait(false);
				await this.OnMessageDeleteEventAsync((ulong)dat[&quot;id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnMessageBulkDeleteEventAsync(dat[&quot;ids&quot;]!.ToObject&lt;ulong[]&gt;()!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnMessagePollVoteAddEventAsync(dat).ConfigureAwait(false);
				await this.OnMessagePollVoteRemoveEventAsync(dat).ConfigureAwait(false);
				await this.OnMessageReactionAddAsync((ulong)dat[&quot;user_id&quot;]!, (ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;], mbr, DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this), (bool)dat[&quot;burst&quot;]!).ConfigureAwait(false);
				await this.OnMessageReactionRemoveAsync((ulong)dat[&quot;user_id&quot;]!, (ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;], DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this), (bool)dat[&quot;burst&quot;]!).ConfigureAwait(false);
				await this.OnMessageReactionRemoveAllAsync((ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnMessageReactionRemoveEmojiAsync((ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong)dat[&quot;guild_id&quot;]!, DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this)).ConfigureAwait(false);
				await this.OnStageInstanceCreateEventAsync(stg).ConfigureAwait(false);
				await this.OnStageInstanceUpdateEventAsync(stg).ConfigureAwait(false);
				await this.OnStageInstanceDeleteEventAsync(stg).ConfigureAwait(false);
				await this.OnThreadCreateEventAsync(trd).ConfigureAwait(false);
				await this.OnThreadUpdateEventAsync(trd).ConfigureAwait(false);
				await this.OnThreadDeleteEventAsync(trd).ConfigureAwait(false);
				var trds = DiscordJson.DeserializeIEnumerableObject&lt;IReadOnlyList&lt;DiscordThreadChannel&gt;&gt;(dat[&quot;threads&quot;]!.ToString(), this);
				var trms = DiscordJson.DeserializeIEnumerableObject&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt;(dat[&quot;members&quot;]!.ToString(), this);
				await this.OnThreadListSyncEventAsync(this.GuildsInternal[gid], dat[&quot;channel_ids&quot;]!.ToObject&lt;IReadOnlyList&lt;ulong?&gt;&gt;()!, trds, trms).ConfigureAwait(false);
				await this.OnThreadMemberUpdateEventAsync(trdm).ConfigureAwait(false);
				await this.OnThreadMembersUpdateEventAsync(this.GuildsInternal[gid], (ulong)dat[&quot;id&quot;]!, (JArray)dat[&quot;added_members&quot;]!, (JArray)dat[&quot;removed_member_ids&quot;]!, (int)dat[&quot;member_count&quot;]!).ConfigureAwait(false);
				await this.OnEmbeddedActivityUpdateAsync((JObject)dat[&quot;embedded_activity&quot;]!, this.GuildsInternal[gid], cid, (JArray)dat[&quot;users&quot;]!, (ulong)dat[&quot;embedded_activity&quot;][&quot;application_id&quot;]!).ConfigureAwait(false);
				await this.OnPresenceUpdateEventAsync(dat, (JObject)dat[&quot;user&quot;]!).ConfigureAwait(false);
				await this.OnUserSettingsUpdateEventAsync(usr).ConfigureAwait(false);
				await this.OnUserUpdateEventAsync(usr).ConfigureAwait(false);
				await this.OnVoiceStateUpdateEventAsync(dat).ConfigureAwait(false);
				await this.OnVoiceServerUpdateEventAsync((string)dat[&quot;endpoint&quot;]!, (string)dat[&quot;token&quot;]!, this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnVoiceChannelEffectSendEventAsync(gid, cid, uid, dat);
				await this.OnInteractionCreateAsync((ulong?)dat[&quot;guild_id&quot;], cid, usr, mbr, DiscordJson.DeserializeObject&lt;DiscordInteraction&gt;(payloadString, this), payloadString).ConfigureAwait(false);
				await this.OnApplicationCommandCreateAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnApplicationCommandUpdateAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnApplicationCommandDeleteAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				await this.OnGuildApplicationCommandCountsUpdateAsync((int)counts[&quot;1&quot;], (int)counts[&quot;2&quot;], (int)counts[&quot;3&quot;], (ulong)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
				var pms = DiscordJson.DeserializeIEnumerableObject&lt;IEnumerable&lt;DiscordApplicationCommandPermission&gt;&gt;(dat[&quot;permissions&quot;]!.ToString(), this);
				await this.OnApplicationCommandPermissionsUpdateAsync(pms, (ulong)dat[&quot;id&quot;]!, gid, aid).ConfigureAwait(false);
				await this.OnTypingStartEventAsync((ulong)dat[&quot;user_id&quot;], cid, this.InternalGetCachedChannel(cid) ?? this.InternalGetCachedThread(cid), (ulong?)dat[&quot;guild_id&quot;], Utilities.GetDateTimeOffset((long)dat[&quot;timestamp&quot;]), mbr).ConfigureAwait(false);
				await this.OnWebhooksUpdateAsync(this.GuildsInternal[gid].GetChannel(cid), this.GuildsInternal[gid]).ConfigureAwait(false);
				await this.OnEntitlementCreateAsync(ent).ConfigureAwait(false);
				await this.OnEntitlementUpdateAsync(ent).ConfigureAwait(false);
				await this.OnEntitlementDeleteAsync(ent).ConfigureAwait(false);
				await this.OnSubscriptionCreateAsync(sub).ConfigureAwait(false);
				await this.OnSubscriptionUpdateAsync(sub).ConfigureAwait(false);
				await this.OnUnknownEventAsync(payload).ConfigureAwait(false);
				this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Unknown event: {name}\npayload: {payload}&quot;, payload.EventName, dat.ToString(Formatting.Indented));
	private readonly Lock _guildDownloadCompletedLock = new();
	internal async Task OnReadyEventAsync(ReadyPayload ready, JArray rawGuilds)
		var rawGuildIndex = rawGuilds.Any() ? rawGuilds.ToDictionary(xt =&gt; (ulong)xt[&quot;id&quot;]!, xt =&gt; (JObject)xt) : null;
			this.ReadyGuildIds.Clear();
			this.ReadyGuildIds.AddRange(rawGuildIndex.Select(x =&gt; x.Key));
		this.GuildsInternal.Clear();
					xc.Initialize(this);
					guild.MembersInternal.Clear();
						var usr = new DiscordUser(xtm.User)
						usr = this.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
			this._guildDownloadCompletedLock.Enter();
			Volatile.Write(ref this._guildDownloadCompleted, true);
			this._guildDownloadCompletedLock.Exit();
			await this.GuildDownloadCompletedEv.InvokeAsync(this, new(this.Guilds, true, this.ServiceProvider)).ConfigureAwait(false);
			this.Logger.LogInformation(LoggerEvents.Startup, &quot;Application has no guilds. Firing GuildDownloadCompleted event for internal tools&quot;);
		await this.ReadyEv.InvokeAsync(this, new(this.ServiceProvider)).ConfigureAwait(false);
	internal Task OnResumedAsync()
		this.Logger.LogInformation(LoggerEvents.SessionUpdate, &quot;Session resumed&quot;);
		return this._resumed.InvokeAsync(this, new(this.ServiceProvider));
	internal async Task OnChannelCreateEventAsync(DiscordChannel channel)
		channel.Initialize(this);
		await this._channelCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnChannelUpdateEventAsync(DiscordChannel channel)
		var channelNew = this.InternalGetCachedChannel(channel.Id);
		DiscordChannel channelOld = null;
			channelNew.PermissionOverwritesInternal.Clear();
			channelNew.PermissionOverwritesInternal.AddRange(channel.PermissionOverwritesInternal);
					channelNew.InternalAvailableTags.Clear();
					channelNew.InternalAvailableTags.AddRange(channel.InternalAvailableTags);
			channelOld.Initialize(this);
			channelNew.Initialize(this);
				await this.RefreshChannelsAsync(channel.Guild.Id).ConfigureAwait(false);
		await this._channelUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnChannelDeleteEventAsync(DiscordChannel channel)
			await this._dmChannelDeleted.InvokeAsync(this, new(this.ServiceProvider)
			if (gld.ChannelsInternal.TryRemove(channel.Id, out var cachedChannel)) channel = cachedChannel;
			await this._channelDeleted.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task RefreshChannelsAsync(ulong guildId)
		var guild = this.InternalGetCachedGuild(guildId);
		var channels = await this.ApiClient.GetGuildChannelsAsync(guildId).ConfigureAwait(false);
		guild.ChannelsInternal.Clear();
		foreach (var channel in channels.ToList())
	internal async Task OnChannelPinsUpdateAsync(ulong? guildId, ulong channelId, DateTimeOffset? lastPinTimestamp)
		var channel = this.InternalGetCachedChannel(channelId) ?? this.InternalGetCachedThread(channelId);
		var ea = new ChannelPinsUpdateEventArgs(this.ServiceProvider)
		await this._channelPinsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnVoiceChannelStatusUpdateAsync(ulong guildId, ulong channelId, string? status)
		var channel = this.InternalGetCachedChannel(channelId);
		var ea = new VoiceChannelStatusUpdateEventArgs(this.ServiceProvider)
		await this._voiceChannelStatusUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildCreateEventAsync(DiscordGuild guild, JArray rawMembers, IEnumerable&lt;DiscordPresence&gt; presences)
						.Select(x =&gt; new DiscordActivity(x)).ToArray();
		var exists = this.GuildsInternal.TryGetValue(guild.Id, out var foundGuild);
		this.UpdateCachedGuild(eventGuild, rawMembers);
		guild.MemberCount = Math.Max(eventGuild.MemberCount.Value, guild.MembersInternal.Count);
			this.GuildsInternal.TryAdd(guild.Id, guild);
			this.GuildsInternal.TryUpdate(guild.Id, guild, foundGuild);
		var old = Volatile.Read(ref this._guildDownloadCompleted);
		var dcompl = this.GuildsInternal.Values.All(xg =&gt; xg.GuildReadyThrown);
		Volatile.Write(ref this._guildDownloadCompleted, dcompl);
			await this._guildAvailable.InvokeAsync(this, new(this.ServiceProvider)
			await this._guildCreated.InvokeAsync(this, new(this.ServiceProvider)
			await this.GuildDownloadCompletedEv.InvokeAsync(this, new(this.Guilds, false, this.ServiceProvider)).ConfigureAwait(false);
	internal async Task OnGuildUpdateEventAsync(DiscordGuild guild, JArray rawMembers)
		DiscordGuild oldGuild;
		if (!this.GuildsInternal.TryGetValue(guild.Id, out var value))
		await this._guildUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildDeleteEventAsync(DiscordGuild guild)
			if (!this.GuildsInternal.TryGetValue(guild.Id, out var gld))
			await this._guildUnavailable.InvokeAsync(this, new(this.ServiceProvider)
			if (!this.GuildsInternal.TryRemove(guild.Id, out var gld))
			await this._guildDeleted.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildAuditLogEntryCreateEventAsync(DiscordGuild guild, JObject auditLogCreateEntry)
			var dataList = await guild.ProcessAuditLog(workaroundAuditLogEntryList).ConfigureAwait(false);
			await this._guildAuditLogEntryCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildSyncEventAsync(DiscordGuild guild, bool isLarge, JArray rawMembers, IEnumerable&lt;DiscordPresence&gt; presences)
		presences = presences.Select(xp =&gt;
		this.UpdateCachedGuild(guild, rawMembers);
	internal async Task OnGuildEmojisUpdateEventAsync(DiscordGuild guild, IEnumerable&lt;DiscordEmoji&gt; newEmojis)
		guild.EmojisInternal.Clear();
		var ea = new GuildEmojisUpdateEventArgs(this.ServiceProvider)
		await this._guildEmojisUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnStickersUpdatedAsync(IEnumerable&lt;DiscordSticker&gt; newStickers, ulong guildId)
		guild.StickersInternal.Clear();
				this.UserCache.AddOrUpdate(nst.User.Id, nst.User, (old, @new) =&gt; @new);
		var sea = new GuildStickersUpdateEventArgs(this.ServiceProvider)
		await this._guildStickersUpdated.InvokeAsync(this, sea).ConfigureAwait(false);
	internal async Task OnAutomodRuleCreated(AutomodRule newRule)
		var sea = new AutomodRuleCreateEventArgs(this.ServiceProvider)
		await this._automodRuleCreated.InvokeAsync(this, sea).ConfigureAwait(false);
	internal async Task OnAutomodRuleUpdated(AutomodRule updatedRule)
		var sea = new AutomodRuleUpdateEventArgs(this.ServiceProvider)
		await this._automodRuleUpdated.InvokeAsync(this, sea).ConfigureAwait(false);
	internal async Task OnAutomodRuleDeleted(AutomodRule deletedRule)
		var sea = new AutomodRuleDeleteEventArgs(this.ServiceProvider)
		await this._automodRuleDeleted.InvokeAsync(this, sea).ConfigureAwait(false);
	internal async Task OnAutomodActionExecuted(DiscordGuild guild, JObject rawPayload)
		var channelId = rawPayload.TryGetValue(&quot;channel_id&quot;, out var value) ? (ulong?)value : null;
		var messageId = rawPayload.TryGetValue(&quot;message_id&quot;, out var value1) ? (ulong?)value1 : null;
		var alertMessageId = rawPayload.TryGetValue(&quot;alert_system_message_id&quot;, out var value2) ? (ulong?)value2 : null;
		var content = rawPayload.TryGetValue(&quot;content&quot;, out var value3) ? (string?)value3 : null;
		var matchedKeyword = rawPayload.TryGetValue(&quot;matched_keyword&quot;, out var value4) ? (string?)value4 : null;
		var matchedContent = rawPayload.TryGetValue(&quot;matched_content&quot;, out var value5) ? (string?)value5 : null;
		var ea = new AutomodActionExecutedEventArgs(this.ServiceProvider)
		await this._automodActionExecuted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildBanAddEventAsync(TransportUser user, DiscordGuild guild)
		var usr = new DiscordUser(user)
		usr = this.UserCache.AddOrUpdate(user.Id, usr, (id, old) =&gt;
		if (!guild.Members.TryGetValue(user.Id, out var mbr))
		var ea = new GuildBanAddEventArgs(this.ServiceProvider)
		await this._guildBanAdded.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildBanRemoveEventAsync(TransportUser user, DiscordGuild guild)
		var ea = new GuildBanRemoveEventArgs(this.ServiceProvider)
		await this._guildBanRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildScheduledEventCreateEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
		guild.ScheduledEventsInternal.AddOrUpdate(scheduledEvent.Id, scheduledEvent, (old, newScheduledEvent) =&gt; newScheduledEvent);
			this.UserCache.AddOrUpdate(scheduledEvent.Creator.Id, scheduledEvent.Creator, (id, old) =&gt;
		await this._guildScheduledEventCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildScheduledEventUpdateEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
		DiscordScheduledEvent oldEvent;
		if (!guild.ScheduledEventsInternal.TryGetValue(scheduledEvent.Id, out var value))
			guild.ScheduledEventsInternal.TryRemove(scheduledEvent.Id, out var deletedEvent);
			await this._guildScheduledEventDeleted.InvokeAsync(this, new(this.ServiceProvider)
			this.UpdateScheduledEvent(scheduledEvent, guild);
			await this._guildScheduledEventUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildScheduledEventDeleteEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
	internal async Task OnGuildScheduledEventUserAddedEventAsync(ulong guildScheduledEventId, ulong userId, DiscordGuild guild)
		var scheduledEvent = this.InternalGetCachedScheduledEvent(guildScheduledEventId) ?? this.UpdateScheduledEvent(new()
		var user = this.GetUserAsync(userId, true).Result;
		var member = guild.Members.TryGetValue(userId, out var mem) ? mem : guild.GetMemberAsync(userId).Result;
		await this._guildScheduledEventUserAdded.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildScheduledEventUserRemovedEventAsync(ulong guildScheduledEventId, ulong userId, DiscordGuild guild)
		await this._guildScheduledEventUserRemoved.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildIntegrationCreateEventAsync(DiscordGuild guild, DiscordIntegration integration)
		await this._guildIntegrationCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildIntegrationUpdateEventAsync(DiscordGuild guild, DiscordIntegration integration)
		await this._guildIntegrationUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildIntegrationsUpdateEventAsync(DiscordGuild guild)
		var ea = new GuildIntegrationsUpdateEventArgs(this.ServiceProvider)
		await this._guildIntegrationsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildIntegrationDeleteEventAsync(DiscordGuild guild, ulong integrationId, ulong? applicationId)
		=&gt; await this._guildIntegrationDeleted.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildMemberAddEventAsync(TransportMember member, DiscordGuild guild)
		var usr = new DiscordUser(member.User)
		usr = this.UserCache.AddOrUpdate(member.User.Id, usr, (id, old) =&gt;
		var mbr = new DiscordMember(member)
		var ea = new GuildMemberAddEventArgs(this.ServiceProvider)
		await this._guildMemberAdded.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildMemberRemoveEventAsync(TransportUser user, DiscordGuild guild)
		var usr = new DiscordUser(user);
		if (!guild.MembersInternal.TryRemove(user.Id, out var mbr))
		_ = this.UserCache.AddOrUpdate(user.Id, usr, (old, @new) =&gt; @new);
		var ea = new GuildMemberRemoveEventArgs(this.ServiceProvider)
		await this._guildMemberRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildMemberUpdateEventAsync(TransportMember member, DiscordGuild guild, IEnumerable&lt;ulong&gt; roles, string nick, bool? pending)
		usr = this.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
		if (!guild.Members.TryGetValue(member.User.Id, out var mbr))
		mbr.RoleIdsInternal.Clear();
		mbr.RoleIdsInternal.AddRange(roles);
		guild.MembersInternal.AddOrUpdate(member.User.Id, mbr, (id, oldMbr) =&gt; oldMbr);
		var eargs = new GuildMemberUpdateEventArgs(this.ServiceProvider)
		await this._guildMemberUpdated.InvokeAsync(this, eargs).ConfigureAwait(false);
			await this._guildMemberTimeoutAdded.InvokeAsync(this, new(this.ServiceProvider)
			await this._guildMemberTimeoutChanged.InvokeAsync(this, new(this.ServiceProvider)
			await this._guildMemberTimeoutRemoved.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnGuildMembersChunkEventAsync(JObject dat)
			if (!this.UserCache.ContainsKey(mbr.Id))
			mbrs.Add(mbr);
		var ea = new GuildMembersChunkEventArgs(this.ServiceProvider)
				pres.Add(presence);
		await this._guildMembersChunked.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildRoleCreateEventAsync(DiscordRole role, DiscordGuild guild)
		var ea = new GuildRoleCreateEventArgs(this.ServiceProvider)
		await this._guildRoleCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildRoleUpdateEventAsync(DiscordRole role, DiscordGuild guild)
		var newRole = guild.GetRole(role.Id);
		var oldRole = new DiscordRole
		var ea = new GuildRoleUpdateEventArgs(this.ServiceProvider)
		await this._guildRoleUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildRoleDeleteEventAsync(ulong roleId, DiscordGuild guild)
		if (!guild.RolesInternal.TryRemove(roleId, out var role))
			this.Logger.LogWarning($&quot;Attempted to delete a nonexistent role ({roleId}) from guild ({guild}).&quot;);
		var ea = new GuildRoleDeleteEventArgs(this.ServiceProvider)
		await this._guildRoleDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildSoundboardSoundCreateEventAsync(DiscordSoundboardSound sound, ulong guildId)
		guild.SoundboardSoundsInternal.TryAdd(sound.Id, sound);
		var args = new GuildSoundboardSoundCreateEventArgs(this.ServiceProvider)
		await this._guildSoundboardSoundCreated.InvokeAsync(this, args).ConfigureAwait(false);
	internal async Task OnGuildSoundboardSoundUpdateEventAsync(DiscordSoundboardSound sound, ulong guildId)
		guild.SoundboardSoundsInternal.TryRemove(sound.Id, out _);
		var args = new GuildSoundboardSoundUpdateEventArgs(this.ServiceProvider)
		await this._guildSoundboardSoundUpdated.InvokeAsync(this, args).ConfigureAwait(false);
	internal async Task OnGuildSoundboardSoundDeleteEventAsync(ulong soundId, ulong guildId)
		guild.SoundboardSoundsInternal.TryRemove(soundId, out var sound);
		var args = new GuildSoundboardSoundDeleteEventArgs(this.ServiceProvider)
		await this._guildSoundboardSoundDeleted.InvokeAsync(this, args).ConfigureAwait(false);
	internal async Task OnGuildSoundboardSoundsUpdateEventAsync(List&lt;DiscordSoundboardSound&gt; sounds, ulong guildId)
		var args = new GuildSoundboardSoundsUpdateEventArgs(this.ServiceProvider)
		await this._guildSoundboardSoundsUpdated.InvokeAsync(this, args).ConfigureAwait(false);
	internal async Task OnSoundboardSoundsEventAsync(List&lt;DiscordSoundboardSound&gt; sounds, ulong guildId)
		var guild = this.Guilds.TryGetValue(guildId, out var cachedGuild)
		if (this.Guilds.ContainsKey(guildId))
			this.Guilds[guildId].SoundboardSoundsInternal.Clear();
				this.Guilds[guildId].SoundboardSoundsInternal.TryAdd(sound.Id, sound);
			await this._soundboardSounds.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnInviteCreateEventAsync(ulong channelId, ulong guildId, DiscordInvite invite)
			this.UserCache.AddOrUpdate(invite.Inviter.Id, invite.Inviter, (old, @new) =&gt; @new);
		var ea = new InviteCreateEventArgs(this.ServiceProvider)
		await this._inviteCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnInviteDeleteEventAsync(ulong channelId, ulong guildId, JToken dat)
		var guild = this.InternalGetCachedGuild(guildId)!;
		if (!guild.Invites.TryRemove(dat[&quot;code&quot;]!.ToString(), out var invite))
		var ea = new InviteDeleteEventArgs(this.ServiceProvider)
		await this._inviteDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildJoinRequestCreateAsync(DiscordGuild guild, JoinRequestStatusType statusType, DiscordGuildJoinRequest request)
		var ea = new GuildJoinRequestCreateEventArgs(this.ServiceProvider)
		await this._guildJoinRequestCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildJoinRequestUpdateAsync(DiscordGuild guild, JoinRequestStatusType statusType, DiscordGuildJoinRequest request)
		var ea = new GuildJoinRequestUpdateEventArgs(this.ServiceProvider)
		await this._guildJoinRequestUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildJoinRequestDeleteAsync(ulong requestId, ulong userId, DiscordGuild guild)
		var user = this.GetCachedOrEmptyUserInternal(userId);
		var ea = new GuildJoinRequestDeleteEventArgs(this.ServiceProvider)
		await this._guildJoinRequestDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageAckEventAsync(DiscordChannel chn, ulong messageId)
		if (this.MessageCache == null || !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == chn.Id, out var msg))
		await this._messageAcknowledged.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnMessageCreateEventAsync(DiscordMessage message, TransportUser author, TransportMember member, TransportUser referenceAuthor, TransportMember referenceMember)
		this.PopulateMessageReactionsAndCache(message, author, member);
		message.PopulateMentions();
			this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Channel which the last message belongs to is not in cache - cache state might be invalid!&quot;);
			this.PopulateMessageReactionsAndCache(message.ReferencedMessage, referenceAuthor, referenceMember);
			message.ReferencedMessage.PopulateMentions();
				x.Message.MentionedUsersInternal.ForEach(u =&gt; u.Discord = this);
				x.Message.AttachmentsInternal.ForEach(a =&gt; a.Discord = this);
				x.Message.EmbedsInternal.ForEach(a =&gt; a.Discord = this);
				x.Message.MentionedChannelsInternal.ForEach(u =&gt; u.Discord = this);
				x.Message.MentionedRolesInternal.ForEach(u =&gt; u.Discord = this);
			x.Message.PopulateMentions();
		var ea = new MessageCreateEventArgs(this.ServiceProvider)
		await this._messageCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageUpdateEventAsync(DiscordMessage message, TransportUser author, TransportMember member, TransportUser referenceAuthor, TransportMember referenceMember)
		DiscordGuild guild;
		DiscordMessage oldmsg = null;
		    || !this.MessageCache.TryGet(xm =&gt; xm.Id == eventMessage.Id &amp;&amp; xm.ChannelId == eventMessage.ChannelId, out message))
			message.EmbedsInternal.Clear();
			message.EmbedsInternal.AddRange(eventMessage.EmbedsInternal);
		var ea = new MessageUpdateEventArgs(this.ServiceProvider)
		await this._messageUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageDeleteEventAsync(ulong messageId, ulong channelId, ulong? guildId)
		    || !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == channelId, out var msg))
		var ea = new MessageDeleteEventArgs(this.ServiceProvider)
		await this._messageDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageBulkDeleteEventAsync(ulong[] messageIds, ulong channelId, ulong? guildId)
			msgs.Add(msg);
		var ea = new MessageBulkDeleteEventArgs(this.ServiceProvider)
		await this._messagesBulkDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessagePollVoteAddEventAsync(JObject dat)
		if (!this.UserCache.TryGetValue(userId, out var user))
		    || !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == channelId, out var message))
		var ea = new MessagePollVoteAddEventArgs(this.ServiceProvider)
		await this._messagePollVoteAdded.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessagePollVoteRemoveEventAsync(JObject dat)
		var ea = new MessagePollVoteRemoveEventArgs(this.ServiceProvider)
		await this._messagePollVoteRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageReactionAddAsync(ulong userId, ulong messageId, ulong channelId, ulong? guildId, TransportMember mbr, DiscordEmoji emoji, bool isBurst)
		var channel = this.InternalGetCachedChannel(channelId) ?? this.InternalGetCachedThread(channelId) ?? new DiscordChannel
		var usr = this.UpdateUser(new()
		var react = msg.ReactionsInternal.FirstOrDefault(xr =&gt; xr.Emoji == emoji);
			msg.ReactionsInternal.Add(react = new()
		var ea = new MessageReactionAddEventArgs(this.ServiceProvider)
		await this._messageReactionAdded.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageReactionRemoveAsync(ulong userId, ulong messageId, ulong channelId, ulong? guildId, DiscordEmoji emoji, bool isBurst)
		if (!this.UserCache.TryGetValue(userId, out var usr))
			usr = channel.Guild.Members.TryGetValue(userId, out var member)
				msg.ReactionsInternal.RemoveFirst(x =&gt; x.Emoji == emoji);
		var ea = new MessageReactionRemoveEventArgs(this.ServiceProvider)
		await this._messageReactionRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageReactionRemoveAllAsync(ulong messageId, ulong channelId, ulong? guildId)
		var ea = new MessageReactionsClearEventArgs(this.ServiceProvider)
		await this._messageReactionsCleared.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnMessageReactionRemoveEmojiAsync(ulong messageId, ulong channelId, ulong guildId, DiscordEmoji partialEmoji)
		if (!guild.EmojisInternal.TryGetValue(partialEmoji.Id, out var emoji))
		msg.ReactionsInternal?.RemoveAll(r =&gt; r.Emoji.Equals(emoji));
		var ea = new MessageReactionRemoveEmojiEventArgs(this.ServiceProvider)
		await this._messageReactionRemovedEmoji.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnStageInstanceCreateEventAsync(DiscordStageInstance stage)
		var guild = this.InternalGetCachedGuild(stage.GuildId);
		await this._stageInstanceCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnStageInstanceUpdateEventAsync(DiscordStageInstance stage)
		await this._stageInstanceUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnStageInstanceDeleteEventAsync(DiscordStageInstance stage)
		await this._stageInstanceDeleted.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnThreadCreateEventAsync(DiscordThreadChannel thread)
		this.InternalGetCachedGuild(thread.GuildId).ThreadsInternal.AddOrUpdate(thread.Id, thread, (oldThread, newThread) =&gt; newThread);
		await this._threadCreated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnThreadUpdateEventAsync(DiscordThreadChannel thread)
		var threadNew = this.InternalGetCachedThread(thread.Id);
		DiscordThreadChannel threadOld = null;
		ThreadUpdateEventArgs updateEvent;
				if (thread.ParentId.HasValue &amp;&amp; this.InternalGetCachedChannel(thread.ParentId.Value).Type == ChannelType.Forum)
		await this._threadUpdated.InvokeAsync(this, updateEvent).ConfigureAwait(false);
	internal async Task OnThreadDeleteEventAsync(DiscordThreadChannel thread)
		if (gld.ThreadsInternal.TryRemove(thread.Id, out var cachedThread))
		await this._threadDeleted.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnThreadListSyncEventAsync(DiscordGuild guild, IReadOnlyList&lt;ulong?&gt; channelIds, IReadOnlyList&lt;DiscordThreadChannel&gt; threads, IReadOnlyList&lt;DiscordThreadChannelMember&gt; members)
		var channels = channelIds.Select(x =&gt; guild.GetChannel(x.Value)); //getting channel objects
		_ = threads.Select(x =&gt; x.Discord = this);
		await this._threadListSynced.InvokeAsync(this, new(this.ServiceProvider)
			Channels = channels.ToList().AsReadOnly(),
			Members = members.ToList().AsReadOnly()
	internal async Task OnThreadMemberUpdateEventAsync(DiscordThreadChannelMember member)
		var thread = this.InternalGetCachedThread(member.Id);
			var tempThread = await this.ApiClient.GetThreadAsync(member.Id).ConfigureAwait(false);
			thread = this.GuildsInternal[member.GuildId].ThreadsInternal.AddOrUpdate(member.Id, tempThread, (old, newThread) =&gt; newThread);
		thread.Guild.ThreadsInternal.AddOrUpdate(member.Id, thread, (oldThread, newThread) =&gt; newThread);
		await this._threadMemberUpdated.InvokeAsync(this, new(this.ServiceProvider)
	internal async Task OnThreadMembersUpdateEventAsync(DiscordGuild guild, ulong threadId, JArray membersAdded, JArray membersRemoved, int memberCount)
		var thread = this.InternalGetCachedThread(threadId);
			var tempThread = await this.ApiClient.GetThreadAsync(threadId).ConfigureAwait(false);
			thread = guild.ThreadsInternal.AddOrUpdate(threadId, tempThread, (old, newThread) =&gt; newThread);
					addedMembers.Add(xtm);
				removedMembers.Add(guild.MembersInternal.TryGetValue((ulong)removedId, out var member)
		if (removedMemberIds.Contains(this.CurrentUser.Id)) //indicates the bot was removed from the thread
		var threadMembersUpdateArg = new ThreadMembersUpdateEventArgs(this.ServiceProvider)
		await this._threadMembersUpdated.InvokeAsync(this, threadMembersUpdateArg).ConfigureAwait(false);
	internal async Task OnEmbeddedActivityUpdateAsync(JObject trActivity, DiscordGuild guild, ulong channelId, JArray jUsers, ulong appId)
		=&gt; await Task.Delay(20).ConfigureAwait(false);
	internal async Task OnPresenceUpdateEventAsync(JObject rawPresence, JObject rawUser)
		DiscordPresence old = null;
		if (this.PresencesInternal.TryGetValue(uid, out var presence))
			DiscordJson.PopulateObject(rawPresence, presence);
			presence = DiscordJson.DeserializeObject&lt;DiscordPresence&gt;(rawPresence.ToString(), this);
					presence.Activity.UpdateWith(presence.RawActivity);
		var ea = new PresenceUpdateEventArgs(this.ServiceProvider)
		await this._presenceUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnUserSettingsUpdateEventAsync(TransportUser user)
		var ea = new UserSettingsUpdateEventArgs(this.ServiceProvider)
		await this._userSettingsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnUserUpdateEventAsync(TransportUser user)
		var usrOld = new DiscordUser
		var ea = new UserUpdateEventArgs(this.ServiceProvider)
		await this._userUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnVoiceStateUpdateEventAsync(JObject raw)
		var vstateNew = DiscordJson.DeserializeObject&lt;DiscordVoiceState&gt;(raw.ToString(), this);
		gld.VoiceStatesInternal.TryRemove(uid, out var vstateOld);
		if (gld.MembersInternal.TryGetValue(uid, out var mbr))
			this.UpdateUser(new(transportMbr.User)
		var ea = new VoiceStateUpdateEventArgs(this.ServiceProvider)
		await this._voiceStateUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnVoiceServerUpdateEventAsync(string endpoint, string token, DiscordGuild guild)
		var ea = new VoiceServerUpdateEventArgs(this.ServiceProvider)
		await this._voiceServerUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnVoiceChannelEffectSendEventAsync(ulong gid, ulong cid, ulong uid, JObject rawObject)
		var emoji = rawObject.TryGetValue(&quot;emoji&quot;, out var rawEmoji) ? rawEmoji.ToDiscordObject&lt;DiscordEmoji&gt;() : null;
		AnimationType? animationType = rawObject.TryGetValue(&quot;animation_type&quot;, out var rawAnimationType) &amp;&amp; Enum.TryParse&lt;AnimationType&gt;((string)rawAnimationType!, out var parsedType) ? parsedType : null;
		int? animationId = rawObject.TryGetValue(&quot;animation_id&quot;, out var rawAnimationId) ? Convert.ToInt32(rawAnimationId.ToString()) : null;
		ulong? soundId = rawObject.TryGetValue(&quot;sound_id&quot;, out var rawSoundId) ? Convert.ToUInt64(rawSoundId.ToString()) : null;
		double? soundVolume = rawObject.TryGetValue(&quot;sound_volume&quot;, out var rawSoundVolume) ? Convert.ToDouble(rawSoundVolume.ToString()) : null;
		VoiceChannelEffectSendEventArgs ea = new(this.ServiceProvider)
			Channel = this.Guilds.TryGetValue(gid, out var cacheGuild)
				? cacheGuild.Channels.TryGetValue(cid, out var channel)
			Guild = this.Guilds.TryGetValue(gid, out var guild)
			User = this.UserCache.TryGetValue(uid, out var user)
		await this._voiceChannelEffectSend.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnApplicationCommandCreateAsync(DiscordApplicationCommand cmd, ulong? guildId)
		var ea = new ApplicationCommandEventArgs(this.ServiceProvider)
		await this._applicationCommandCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnApplicationCommandUpdateAsync(DiscordApplicationCommand cmd, ulong? guildId)
		await this._applicationCommandUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnApplicationCommandDeleteAsync(DiscordApplicationCommand cmd, ulong? guildId)
		await this._applicationCommandDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnGuildApplicationCommandCountsUpdateAsync(int chatInputCommandCount, int userContextMenuCommandCount, int messageContextMenuCount, ulong guildId)
		var guild = this.InternalGetCachedGuild(guildId) ?? new DiscordGuild
		var ea = new GuildApplicationCommandCountEventArgs(this.ServiceProvider)
		await this._guildApplicationCommandCountUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnApplicationCommandPermissionsUpdateAsync(IEnumerable&lt;DiscordApplicationCommandPermission&gt; perms, ulong channelId, ulong guildId, ulong applicationId)
		DiscordApplicationCommand cmd;
			cmd = await this.GetGuildApplicationCommandAsync(guildId, channelId).ConfigureAwait(false);
			cmd = await this.GetGlobalApplicationCommandAsync(channelId).ConfigureAwait(false);
		var ea = new ApplicationCommandPermissionsUpdateEventArgs(this.ServiceProvider)
			Permissions = perms.ToList(),
		await this._applicationCommandPermissionsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnInteractionCreateAsync(ulong? guildId, ulong channelId, TransportUser user, TransportMember member, DiscordInteraction interaction, string rawInteraction)
		this.UserCache.AddOrUpdate(usr.Id, usr, (old, @new) =&gt; @new);
			usr = new DiscordMember(member)
				this.UpdateUser(usr, guildId, interaction.Guild, member);
					this.UserCache.AddOrUpdate(c.Value.Id, c.Value, (old, @new) =&gt; @new);
					this.UserCache.AddOrUpdate(c.Value.User.Id, c.Value.User, (old, @new) =&gt; @new);
							if (this.Guilds.TryGetValue(guildId.Value, out var guild))
								if (guild.ChannelsInternal.TryGetValue(c.Key, out var channel) &amp;&amp; channel.PermissionOverwritesInternal != null &amp;&amp; channel.PermissionOverwritesInternal.Count != 0)
			var cea = new ComponentInteractionCreateEventArgs(this.ServiceProvider)
			await this._componentInteractionCreated.InvokeAsync(this, cea).ConfigureAwait(false);
				DiscordUser targetUser = null;
				DiscordMember targetMember = null;
				DiscordMessage targetMessage = null;
				var ea = new ContextMenuInteractionCreateEventArgs(this.ServiceProvider)
				await this._contextMenuInteractionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
				var ea = new InteractionCreateEventArgs(this.ServiceProvider)
				await this._interactionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnEntitlementCreateAsync(DiscordEntitlement entitlement)
		var ea = new EntitlementCreateEventArgs(this.ServiceProvider)
		await this._entitlementCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnEntitlementUpdateAsync(DiscordEntitlement entitlement)
		var ea = new EntitlementUpdateEventArgs(this.ServiceProvider)
		await this._entitlementUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnEntitlementDeleteAsync(DiscordEntitlement entitlement)
		var ea = new EntitlementDeleteEventArgs(this.ServiceProvider)
		await this._entitlementDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnSubscriptionCreateAsync(DiscordSubscription subscription)
		var ea = new SubscriptionCreateEventArgs(this.ServiceProvider)
		await this._subscriptionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnSubscriptionUpdateAsync(DiscordSubscription subscription)
		var ea = new SubscriptionUpdateEventArgs(this.ServiceProvider)
		await this._subscriptionUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnTypingStartEventAsync(ulong userId, ulong channelId, DiscordChannel channel, ulong? guildId, DateTimeOffset started, TransportMember mbr)
		var ea = new TypingStartEventArgs(this.ServiceProvider)
		await this._typingStarted.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnWebhooksUpdateAsync(DiscordChannel channel, DiscordGuild guild)
		var ea = new WebhooksUpdateEventArgs(this.ServiceProvider)
		await this._webhooksUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
	internal async Task OnUnknownEventAsync(GatewayPayload payload)
		var ea = new UnknownEventArgs(this.ServiceProvider)
		await this._unknownEvent.InvokeAsync(this, ea).ConfigureAwait(false);</file><file path="DisCatSharp/Clients/DiscordClient.EventHandlers.cs">public sealed partial class DiscordClient
	public IReadOnlyDictionary&lt;Type, object&gt; RegisteredEventhandlers =&gt; this._registeredEventhandlers.AsReadOnly();
	public void RegisterEventHandler(object handler, bool registerStatic = false)
		=&gt; this.RegisterEventHandlerImpl(handler, handler.GetType(), registerStatic);
	public void RegisterStaticEventHandler(Type t)
		=&gt; this.RegisterEventHandlerImpl(null, t);
	public void RegisterStaticEventHandler&lt;T&gt;()
		=&gt; this.RegisterStaticEventHandler(typeof(T));
	public void RegisterEventHandler(Type type)
			this.RegisterStaticEventHandler(type);
			var anon = ActivatorUtilities.CreateInstance(this.Configuration.ServiceProvider, type);
			this._typeToAnonymousHandlers[type] = this._typeToAnonymousHandlers.TryGetValue(type, out var anonObjs) ? anonObjs : anonObjs = [];
			anonObjs.Add(anon);
			this.RegisterEventHandlerImpl(anon, type);
	public void RegisterEventHandler&lt;T&gt;()
		=&gt; this.RegisterEventHandler(typeof(T));
	public void RegisterEventHandlers(Assembly assembly)
			this.RegisterEventHandler(t);
	public void UnregisterEventHandler(object handler, bool wasRegisteredWithStatic = false)
		=&gt; this.UnregisterEventHandlerImpl(handler, handler.GetType(), wasRegisteredWithStatic);
	public void UnregisterStaticEventHandler(Type t)
		=&gt; this.UnregisterEventHandlerImpl(null, t);
	public void UnregisterStaticEventHandler&lt;T&gt;()
		=&gt; this.UnregisterEventHandler(typeof(T));
	public void UnregisterEventHandler(Type t)
			this.UnregisterStaticEventHandler(t);
			if (!this._typeToAnonymousHandlers.TryGetValue(t, out var anonObjs) || anonObjs.Count == 0)
			anonObjs.RemoveAt(0);
				this._typeToAnonymousHandlers.Remove(t);
			this.UnregisterEventHandlerImpl(anon, t);
	public void UnregisterEventHandler&lt;T&gt;() =&gt; this.UnregisterEventHandler(typeof(T));
	public void UnregisterEventHandlers(Assembly assembly)
			this.UnregisterEventHandler(t);
	private static IEnumerable&lt;Type&gt; GetEventHandlersFromAssembly(Assembly assembly)
		=&gt; assembly.GetTypes().Where(t =&gt; t.GetCustomAttribute&lt;EventHandlerAttribute&gt;() is not null);
	private void UnregisterEventHandlerImpl(object? handler, Type type, bool wasRegisteredWithStatic = true)
		if (this._registeredEventhandlers.ContainsKey(type))
			this._registeredEventhandlers.Remove(type);
		if (!this._registrationToDelegate.TryGetValue((handler, type, wasRegisteredWithStatic), out var delegateLists) || delegateLists.Count == 0)
			evnt.RemoveEventHandler(this, dlgt);
		delegateLists.RemoveAt(0);
			this._registrationToDelegate.Remove((handler, type, wasRegisteredWithStatic));
	private void RegisterEventHandlerImpl(object? handler, Type type, bool registerStatic = true)
			from method in type.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
			let eventInfo = this.GetType().GetEvent(eventName)
			                ?? throw new ArgumentException($&quot;Tried to register handler to non-existent event \&quot;{eventName}\&quot;&quot;)
				           ? Delegate.CreateDelegate(eventHandlerType, method, false)
				           : Delegate.CreateDelegate(eventHandlerType, handler, method, false))
			           ?? throw new ArgumentException($&quot;Method \&quot;{method}\&quot; does not adhere to event specification \&quot;{eventHandlerType}\&quot;&quot;)
		).ToArray();
		this._registrationToDelegate[(handler, type, registerStatic)] = this._registrationToDelegate.TryGetValue((handler, type, registerStatic), out var delList) ? delList : delList = [];
		delList.Add(delegates);
		this._registeredEventhandlers.Add(type, handler);
			evnt.AddEventHandler(this, dlgt);</file><file path="DisCatSharp/Clients/DiscordClient.Events.cs">public sealed partial class DiscordClient
	internal static TimeSpan EventExecutionLimit { get; } = TimeSpan.FromSeconds(1);
		add =&gt; this._socketErrored.Register(value);
		remove =&gt; this._socketErrored.Unregister(value);
		add =&gt; this._socketOpened.Register(value);
		remove =&gt; this._socketOpened.Unregister(value);
		add =&gt; this._socketClosed.Register(value);
		remove =&gt; this._socketClosed.Unregister(value);
		add =&gt; this.ReadyEv.Register(value);
		remove =&gt; this.ReadyEv.Unregister(value);
		add =&gt; this._resumed.Register(value);
		remove =&gt; this._resumed.Unregister(value);
		add =&gt; this._heartbeated.Register(value);
		remove =&gt; this._heartbeated.Unregister(value);
		add =&gt; this._channelCreated.Register(value);
		remove =&gt; this._channelCreated.Unregister(value);
		add =&gt; this._channelUpdated.Register(value);
		remove =&gt; this._channelUpdated.Unregister(value);
		add =&gt; this._channelDeleted.Register(value);
		remove =&gt; this._channelDeleted.Unregister(value);
		add =&gt; this._dmChannelDeleted.Register(value);
		remove =&gt; this._dmChannelDeleted.Unregister(value);
		add =&gt; this._channelPinsUpdated.Register(value);
		remove =&gt; this._channelPinsUpdated.Unregister(value);
		add =&gt; this._voiceChannelStatusUpdated.Register(value);
		remove =&gt; this._voiceChannelStatusUpdated.Unregister(value);
		add =&gt; this._guildCreated.Register(value);
		remove =&gt; this._guildCreated.Unregister(value);
		add =&gt; this._guildAvailable.Register(value);
		remove =&gt; this._guildAvailable.Unregister(value);
		add =&gt; this._guildUpdated.Register(value);
		remove =&gt; this._guildUpdated.Unregister(value);
		add =&gt; this._guildDeleted.Register(value);
		remove =&gt; this._guildDeleted.Unregister(value);
		add =&gt; this._guildUnavailable.Register(value);
		remove =&gt; this._guildUnavailable.Unregister(value);
		add =&gt; this.GuildDownloadCompletedEv.Register(value);
		remove =&gt; this.GuildDownloadCompletedEv.Unregister(value);
		add =&gt; this._guildEmojisUpdated.Register(value);
		remove =&gt; this._guildEmojisUpdated.Unregister(value);
		add =&gt; this._guildStickersUpdated.Register(value);
		remove =&gt; this._guildStickersUpdated.Unregister(value);
		add =&gt; this._guildIntegrationsUpdated.Register(value);
		remove =&gt; this._guildIntegrationsUpdated.Unregister(value);
		add =&gt; this._guildAuditLogEntryCreated.Register(value);
		remove =&gt; this._guildAuditLogEntryCreated.Unregister(value);
		add =&gt; this._automodRuleCreated.Register(value);
		remove =&gt; this._automodRuleCreated.Unregister(value);
		add =&gt; this._automodRuleUpdated.Register(value);
		remove =&gt; this._automodRuleUpdated.Unregister(value);
		add =&gt; this._automodRuleDeleted.Register(value);
		remove =&gt; this._automodRuleDeleted.Unregister(value);
		add =&gt; this._automodActionExecuted.Register(value);
		remove =&gt; this._automodActionExecuted.Unregister(value);
		add =&gt; this._guildBanAdded.Register(value);
		remove =&gt; this._guildBanAdded.Unregister(value);
		add =&gt; this._guildBanRemoved.Register(value);
		remove =&gt; this._guildBanRemoved.Unregister(value);
		add =&gt; this._guildMemberTimeoutAdded.Register(value);
		remove =&gt; this._guildMemberTimeoutAdded.Unregister(value);
		add =&gt; this._guildMemberTimeoutChanged.Register(value);
		remove =&gt; this._guildMemberTimeoutChanged.Unregister(value);
		add =&gt; this._guildMemberTimeoutRemoved.Register(value);
		remove =&gt; this._guildMemberTimeoutRemoved.Unregister(value);
		add =&gt; this._guildScheduledEventCreated.Register(value);
		remove =&gt; this._guildScheduledEventCreated.Unregister(value);
		add =&gt; this._guildScheduledEventUpdated.Register(value);
		remove =&gt; this._guildScheduledEventUpdated.Unregister(value);
		add =&gt; this._guildScheduledEventDeleted.Register(value);
		remove =&gt; this._guildScheduledEventDeleted.Unregister(value);
		add =&gt; this._guildScheduledEventUserAdded.Register(value);
		remove =&gt; this._guildScheduledEventUserAdded.Unregister(value);
		add =&gt; this._guildScheduledEventUserRemoved.Register(value);
		remove =&gt; this._guildScheduledEventUserRemoved.Unregister(value);
		add =&gt; this._guildIntegrationCreated.Register(value);
		remove =&gt; this._guildIntegrationCreated.Unregister(value);
		add =&gt; this._guildIntegrationUpdated.Register(value);
		remove =&gt; this._guildIntegrationUpdated.Unregister(value);
		add =&gt; this._guildIntegrationDeleted.Register(value);
		remove =&gt; this._guildIntegrationDeleted.Unregister(value);
		add =&gt; this._guildMemberAdded.Register(value);
		remove =&gt; this._guildMemberAdded.Unregister(value);
		add =&gt; this._guildMemberRemoved.Register(value);
		remove =&gt; this._guildMemberRemoved.Unregister(value);
		add =&gt; this._guildMemberUpdated.Register(value);
		remove =&gt; this._guildMemberUpdated.Unregister(value);
		add =&gt; this._guildMembersChunked.Register(value);
		remove =&gt; this._guildMembersChunked.Unregister(value);
		add =&gt; this._guildRoleCreated.Register(value);
		remove =&gt; this._guildRoleCreated.Unregister(value);
		add =&gt; this._guildRoleUpdated.Register(value);
		remove =&gt; this._guildRoleUpdated.Unregister(value);
		add =&gt; this._guildRoleDeleted.Register(value);
		remove =&gt; this._guildRoleDeleted.Unregister(value);
		add =&gt; this._guildSoundboardSoundCreated.Register(value);
		remove =&gt; this._guildSoundboardSoundCreated.Unregister(value);
		add =&gt; this._guildSoundboardSoundUpdated.Register(value);
		remove =&gt; this._guildSoundboardSoundUpdated.Unregister(value);
		add =&gt; this._guildSoundboardSoundDeleted.Register(value);
		remove =&gt; this._guildSoundboardSoundDeleted.Unregister(value);
		add =&gt; this._guildSoundboardSoundsUpdated.Register(value);
		remove =&gt; this._guildSoundboardSoundsUpdated.Unregister(value);
		add =&gt; this._soundboardSounds.Register(value);
		remove =&gt; this._soundboardSounds.Unregister(value);
		add =&gt; this._guildJoinRequestCreated.Register(value);
		remove =&gt; this._guildJoinRequestCreated.Unregister(value);
		add =&gt; this._guildJoinRequestUpdated.Register(value);
		remove =&gt; this._guildJoinRequestUpdated.Unregister(value);
		add =&gt; this._guildJoinRequestDeleted.Register(value);
		remove =&gt; this._guildJoinRequestDeleted.Unregister(value);
		add =&gt; this._inviteCreated.Register(value);
		remove =&gt; this._inviteCreated.Unregister(value);
		add =&gt; this._inviteDeleted.Register(value);
		remove =&gt; this._inviteDeleted.Unregister(value);
		add =&gt; this._messageCreated.Register(value);
		remove =&gt; this._messageCreated.Unregister(value);
		add =&gt; this._messageAcknowledged.Register(value);
		remove =&gt; this._messageAcknowledged.Unregister(value);
		add =&gt; this._messageUpdated.Register(value);
		remove =&gt; this._messageUpdated.Unregister(value);
		add =&gt; this._messageDeleted.Register(value);
		remove =&gt; this._messageDeleted.Unregister(value);
		add =&gt; this._messagesBulkDeleted.Register(value);
		remove =&gt; this._messagesBulkDeleted.Unregister(value);
		add =&gt; this._messagePollVoteAdded.Register(value);
		remove =&gt; this._messagePollVoteAdded.Unregister(value);
		add =&gt; this._messagePollVoteRemoved.Register(value);
		remove =&gt; this._messagePollVoteRemoved.Unregister(value);
		add =&gt; this._messageReactionAdded.Register(value);
		remove =&gt; this._messageReactionAdded.Unregister(value);
		add =&gt; this._messageReactionRemoved.Register(value);
		remove =&gt; this._messageReactionRemoved.Unregister(value);
		add =&gt; this._messageReactionsCleared.Register(value);
		remove =&gt; this._messageReactionsCleared.Unregister(value);
		add =&gt; this._messageReactionRemovedEmoji.Register(value);
		remove =&gt; this._messageReactionRemovedEmoji.Unregister(value);
		add =&gt; this._embeddedActivityUpdated.Register(value);
		remove =&gt; this._embeddedActivityUpdated.Unregister(value);
		add =&gt; this._presenceUpdated.Register(value);
		remove =&gt; this._presenceUpdated.Unregister(value);
		add =&gt; this._userSettingsUpdated.Register(value);
		remove =&gt; this._userSettingsUpdated.Unregister(value);
		add =&gt; this._userUpdated.Register(value);
		remove =&gt; this._userUpdated.Unregister(value);
		add =&gt; this._stageInstanceCreated.Register(value);
		remove =&gt; this._stageInstanceCreated.Unregister(value);
		add =&gt; this._stageInstanceUpdated.Register(value);
		remove =&gt; this._stageInstanceUpdated.Unregister(value);
		add =&gt; this._stageInstanceDeleted.Register(value);
		remove =&gt; this._stageInstanceDeleted.Unregister(value);
		add =&gt; this._threadCreated.Register(value);
		remove =&gt; this._threadCreated.Unregister(value);
		add =&gt; this._threadUpdated.Register(value);
		remove =&gt; this._threadUpdated.Unregister(value);
		add =&gt; this._threadDeleted.Register(value);
		remove =&gt; this._threadDeleted.Unregister(value);
		add =&gt; this._threadListSynced.Register(value);
		remove =&gt; this._threadListSynced.Unregister(value);
		add =&gt; this._threadMemberUpdated.Register(value);
		remove =&gt; this._threadMemberUpdated.Unregister(value);
		add =&gt; this._threadMembersUpdated.Register(value);
		remove =&gt; this._threadMembersUpdated.Unregister(value);
		add =&gt; this._voiceStateUpdated.Register(value);
		remove =&gt; this._voiceStateUpdated.Unregister(value);
		add =&gt; this._voiceServerUpdated.Register(value);
		remove =&gt; this._voiceServerUpdated.Unregister(value);
		add =&gt; this._voiceChannelEffectSend.Register(value);
		remove =&gt; this._voiceChannelEffectSend.Unregister(value);
		add =&gt; this._applicationCommandCreated.Register(value);
		remove =&gt; this._applicationCommandCreated.Unregister(value);
		add =&gt; this._applicationCommandUpdated.Register(value);
		remove =&gt; this._applicationCommandUpdated.Unregister(value);
		add =&gt; this._applicationCommandDeleted.Register(value);
		remove =&gt; this._applicationCommandDeleted.Unregister(value);
		add =&gt; this._guildApplicationCommandCountUpdated.Register(value);
		remove =&gt; this._guildApplicationCommandCountUpdated.Unregister(value);
		add =&gt; this._contextMenuInteractionCreated.Register(value);
		remove =&gt; this._contextMenuInteractionCreated.Unregister(value);
		add =&gt; this._applicationCommandPermissionsUpdated.Register(value);
		remove =&gt; this._applicationCommandPermissionsUpdated.Unregister(value);
		add =&gt; this._interactionCreated.Register(value);
		remove =&gt; this._interactionCreated.Unregister(value);
		add =&gt; this._componentInteractionCreated.Register(value);
		remove =&gt; this._componentInteractionCreated.Unregister(value);
		add =&gt; this._entitlementCreated.Register(value);
		remove =&gt; this._entitlementCreated.Unregister(value);
		add =&gt; this._entitlementUpdated.Register(value);
		remove =&gt; this._entitlementUpdated.Unregister(value);
		add =&gt; this._entitlementDeleted.Register(value);
		remove =&gt; this._entitlementDeleted.Unregister(value);
		add =&gt; this._subscriptionCreated.Register(value);
		remove =&gt; this._subscriptionCreated.Unregister(value);
		add =&gt; this._subscriptionUpdated.Register(value);
		remove =&gt; this._subscriptionUpdated.Unregister(value);
		add =&gt; this._typingStarted.Register(value);
		remove =&gt; this._typingStarted.Unregister(value);
		add =&gt; this._unknownEvent.Register(value);
		remove =&gt; this._unknownEvent.Unregister(value);
		add =&gt; this._webhooksUpdated.Register(value);
		remove =&gt; this._webhooksUpdated.Unregister(value);
		add =&gt; this._clientErrored.Register(value);
		remove =&gt; this._clientErrored.Unregister(value);
	internal void EventErrorHandler&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs
			this.Logger.LogWarning(LoggerEvents.EventHandlerException, &quot;An event handler for {AsyncEventName} took too long to execute. Defined as \&quot;{TrimStart}\&quot; located in \&quot;{MethodDeclaringType}\&quot;&quot;, asyncEvent.Name, handler.Method.ToString()?.Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart(), handler.Method.DeclaringType);
		this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {Name} thrown from {Method} (defined in {DeclaringType})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
		this._clientErrored.InvokeAsync(this, new(this.ServiceProvider)
		}).ConfigureAwait(false).GetAwaiter().GetResult();
		add =&gt; this.RateLimitHitInternal.Register(value);
		remove =&gt; this.RateLimitHitInternal.Unregister(value);
		add =&gt; this._zombied.Register(value);
		remove =&gt; this._zombied.Unregister(value);
		add =&gt; this._payloadReceived.Register(value);
		remove =&gt; this._payloadReceived.Unregister(value);
	private void Goof&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {0} (defined in {1}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);</file><file path="DisCatSharp/Clients/DiscordClient.WebSocket.cs">public sealed partial class DiscordClient
	private SocketLock GetSocketLock()
		=&gt; s_socketLocks.GetOrAdd(this.CurrentApplication.Id, new SocketLock(this.CurrentApplication.Id, this.GatewayInfo!.SessionBucket.MaxConcurrency));
	private DateTimeOffset _lastHeartbeat;
	private Task _heartbeatTask;
	internal static DateTimeOffset DiscordEpoch = new(2015, 1, 1, 0, 0, 0, TimeSpan.Zero);
	internal IWebSocketClient WebSocketClient;
	private CancellationTokenSource _cancelTokenSource;
	private CancellationToken _cancelToken;
	private readonly ManualResetEventSlim _sessionLock = new(true);
	private Task InternalReconnectAsync(bool startNewSession = false, int code = 1000, string message = &quot;&quot;)
		_ = this.WebSocketClient.DisconnectAsync(code, message);
	internal async Task InternalConnectAsync()
				await this.InternalUpdateGatewayAsync().ConfigureAwait(false);
			await this.InitializeAsync().ConfigureAwait(false);
			socketLock = this.GetSocketLock();
			await socketLock.LockAsync().ConfigureAwait(false);
		if (!this.Presences.ContainsKey(this.CurrentUser.Id))
		Volatile.Write(ref this._skippedHeartbeats, 0);
		this.WebSocketClient = this.Configuration.WebSocketClientFactory(this.Configuration.Proxy, this.ServiceProvider);
		this.WebSocketClient.AddDefaultHeader(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
			? new PayloadDecompressor(this.Configuration.GatewayCompressionLevel)
		var gwuri = this.GatewayUri.AddParameter(&quot;v&quot;, this.Configuration.ApiVersion).AddParameter(&quot;encoding&quot;, &quot;json&quot;);
			gwuri = gwuri.AddParameter(&quot;compress&quot;, &quot;zlib-stream&quot;);
		this.Logger.LogDebug(LoggerEvents.Startup, &quot;Connecting to {gw}&quot;, this.GatewayUri.AbsoluteUri);
		await this.WebSocketClient.ConnectAsync(this.GatewayUri).ConfigureAwait(false);
			=&gt; this._socketOpened.InvokeAsync(this, e);
					using var ms = new MemoryStream();
						this.Logger.LogError(LoggerEvents.WebSocketReceiveFailure, &quot;Payload decompression failed&quot;);
					using var sr = new StreamReader(ms, Utilities.UTF8);
					msg = await sr.ReadToEndAsync(this._cancelToken).ConfigureAwait(false);
					this.Logger.LogTrace(LoggerEvents.GatewayWsRx, &quot;{Message}&quot;, msg);
					await this.HandleSocketMessageAsync(msg).ConfigureAwait(false);
				this.Logger.LogError(LoggerEvents.WebSocketReceiveFailure, ex, &quot;Socket handler suppressed an exception&quot;);
					this.Sentry.CaptureException(ex);
					_ = Task.Run(this.Sentry.FlushAsync, this._cancelToken);
			=&gt; this._socketErrored.InvokeAsync(this, e);
			this._connectionLock.Set();
			this._sessionLock.Set();
				await this._cancelTokenSource.CancelAsync();
			this.Logger.LogDebug(LoggerEvents.ConnectionClose, &quot;Connection closed ({CloseCode}, &apos;{Reason}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
			await this._socketClosed.InvokeAsync(this, e).ConfigureAwait(false);
				this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Fatal close code received ({CloseCode}, &apos;{Reason}&apos;). No reconnection attempt.&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
				this.Logger.LogWarning(LoggerEvents.ConnectionClose, &quot;Session is invalid. Clearing session ID before reconnecting.&quot;);
				this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Connection terminated ({CloseCode}, &apos;{Reason}&apos;), reconnecting&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
					this.Logger.LogInformation(LoggerEvents.ConnectionClose, &quot;Attempting to resume session with ID {SessionId}.&quot;, this._sessionId);
					this.Logger.LogWarning(LoggerEvents.ConnectionClose, &quot;No valid session to resume, starting a new connection.&quot;);
				await this.ConnectAsync(this._status?.ActivityInternal, this._status?.Status, this._status is not null &amp;&amp; this._status.IdleSince.HasValue ? Utilities.GetDateTimeOffsetFromMilliseconds(this._status.IdleSince.Value) : null).ConfigureAwait(false);
				this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Connection terminated ({CloseCode}, &apos;{Reason}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
	internal async Task HandleSocketMessageAsync(string data)
				_ = Task.Run(async () =&gt; await this.HandleDispatchAsync(payload).ConfigureAwait(false), this._cancelToken);
				await this.OnHeartbeatAsync((long)payload.Data).ConfigureAwait(false);
				await this.OnReconnectAsync().ConfigureAwait(false);
				await this.OnInvalidateSessionAsync((bool)payload.Data).ConfigureAwait(false);
				await this.OnHelloAsync((payload.Data as JObject).ToObject&lt;GatewayHello&gt;()).ConfigureAwait(false);
				await this.OnHeartbeatAckAsync().ConfigureAwait(false);
				this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received op code for non-bot event&quot;);
				this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Unknown Discord opcode: {OpCode}\nPayload: {Payload}&quot;, payload.OpCode, payload.Data);
	internal async Task OnHeartbeatAsync(long seq)
		this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HEARTBEAT (OP1)&quot;);
		await this.SendHeartbeatAsync(seq).ConfigureAwait(false);
	internal async Task OnReconnectAsync()
		this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received RECONNECT (OP7)&quot;);
		await this.InternalReconnectAsync(code: 4000, message: &quot;OP7 acknowledged&quot;).ConfigureAwait(false);
	internal async Task OnInvalidateSessionAsync(bool data)
		if (this._sessionLock.Wait(0))
			this._sessionLock.Reset();
		var socketLock = this.GetSocketLock();
		socketLock.UnlockAfter(TimeSpan.FromSeconds(5));
			this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received INVALID_SESSION (OP9, true)&quot;);
			await Task.Delay(6000, this._cancelToken).ConfigureAwait(false);
			await this.SendResumeAsync().ConfigureAwait(false);
			this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received INVALID_SESSION (OP9, false)&quot;);
			await this.SendIdentifyAsync(this._status).ConfigureAwait(false);
	internal async Task OnHelloAsync(GatewayHello hello)
		this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HELLO (OP10)&quot;);
			this.GetSocketLock().UnlockAfter(TimeSpan.FromSeconds(5));
			this.Logger.LogWarning(LoggerEvents.SessionUpdate, &quot;Attempt to start a session while another session is active&quot;);
		Interlocked.CompareExchange(ref this._skippedHeartbeats, 0, 0);
		this._heartbeatTask = Task.Run(this.HeartbeatLoopAsync, this._cancelToken);
		if (string.IsNullOrEmpty(this._sessionId))
	internal async Task OnHeartbeatAckAsync()
		Interlocked.Decrement(ref this._skippedHeartbeats);
		this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HEARTBEAT_ACK (OP11, {0}ms)&quot;, ping);
		Volatile.Write(ref this._ping, ping);
		var args = new HeartbeatEventArgs(this.ServiceProvider)
		await this._heartbeated.InvokeAsync(this, args).ConfigureAwait(false);
	internal async Task HeartbeatLoopAsync()
		this.Logger.LogDebug(LoggerEvents.Heartbeat, &quot;Heartbeat task started&quot;);
				await this.SendHeartbeatAsync(this._lastSequence).ConfigureAwait(false);
				await Task.Delay(this._heartbeatInterval, token).ConfigureAwait(false);
				token.ThrowIfCancellationRequested();
	internal async Task InternalUpdateStatusAsync(DiscordActivity activity, UserStatus? userStatus, DateTimeOffset? idleSince)
		var sinceUnix = idleSince != null ? (long?)Utilities.GetUnixTime(idleSince.Value) : null;
		var act = activity ?? new DiscordActivity();
		var status = new StatusUpdate
		var statusUpdate = new GatewayPayload
		var statusstr = JsonConvert.SerializeObject(statusUpdate);
		await this.WsSendAsync(statusstr).ConfigureAwait(false);
		if (!this.PresencesInternal.TryGetValue(this.CurrentUser.Id, out var value))
	internal async Task SendHeartbeatAsync(long seq)
		var moreThan5 = Volatile.Read(ref this._skippedHeartbeats) &gt; 5;
		var guildsComp = Volatile.Read(ref this._guildDownloadCompleted);
				this.Logger.LogCritical(LoggerEvents.HeartbeatFailure, &quot;Server failed to acknowledge more than 5 heartbeats - connection is zombie&quot;);
				var args = new ZombiedEventArgs(this.ServiceProvider)
					Failures = Volatile.Read(ref this._skippedHeartbeats),
				await this._zombied.InvokeAsync(this, args).ConfigureAwait(false);
				await this.InternalReconnectAsync(code: 4001, message: &quot;Too many heartbeats missed&quot;).ConfigureAwait(false);
				this.Logger.LogWarning(LoggerEvents.HeartbeatFailure, &quot;Server failed to acknowledge more than 5 heartbeats, but the guild download is still running - check your connection speed&quot;);
		Volatile.Write(ref this._lastSequence, seq);
		this.Logger.LogTrace(LoggerEvents.Heartbeat, &quot;Sending heartbeat&quot;);
		var heartbeat = new GatewayPayload
		var heartbeatStr = JsonConvert.SerializeObject(heartbeat);
		await this.WsSendAsync(heartbeatStr).ConfigureAwait(false);
		Interlocked.Increment(ref this._skippedHeartbeats);
	internal async Task SendIdentifyAsync(StatusUpdate? status)
		var identify = new GatewayIdentify
			Token = Utilities.GetFormattedToken(this),
		var payload = new GatewayPayload
		var payloadstr = JsonConvert.SerializeObject(payload);
		await this.WsSendAsync(payloadstr).ConfigureAwait(false);
		this.Logger.LogDebug(LoggerEvents.Intents, &quot;Registered gateway intents ({Intents})&quot;, this.Configuration.Intents);
	internal async Task SendResumeAsync()
		ArgumentNullException.ThrowIfNull(this._sessionId);
		ArgumentNullException.ThrowIfNull(this._resumeGatewayUrl);
		var resume = new GatewayResume
			SequenceNumber = Volatile.Read(ref this._lastSequence)
		var resumePayload = new GatewayPayload
		var resumestr = JsonConvert.SerializeObject(resumePayload);
		this.Logger.LogDebug(LoggerEvents.ConnectionClose, &quot;Request to resume via {gw}&quot;, this.GatewayUri.AbsoluteUri);
		await this.WsSendAsync(resumestr).ConfigureAwait(false);
	internal async Task InternalUpdateGatewayAsync()
		var info = await this.GetGatewayInfoAsync().ConfigureAwait(false);
	internal async Task WsSendAsync(string payload)
		this.Logger.LogTrace(LoggerEvents.GatewayWsTx, &quot;{Payload}&quot;, payload);
		await this.WebSocketClient.SendMessageAsync(payload).ConfigureAwait(false);</file><file path="DisCatSharp/Clients/DiscordOAuth2Client.cs">public sealed class DiscordOAuth2Client : IDisposable
	internal readonly DiscordApiClient ApiClient;
	internal readonly LogLevel MinimumLogLevel;
	public readonly Uri RedirectUri;
			loggerFactory = new DefaultLoggerFactory();
			loggerFactory.AddProvider(new DefaultLoggerProvider(this));
		this.ServiceProvider = provider ?? new ServiceCollection().BuildServiceProvider(true);
		var parsedTimeout = timeout ?? TimeSpan.FromSeconds(10);
		this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;client_id&quot;, this.ClientId.ToString());
		this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;client_secret&quot;, this.ClientSecret);
		var a = typeof(DiscordOAuth2Client).GetTypeInfo().Assembly;
			var v = a.GetName().Version;
		this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, this.VersionHeader);
		if (File.Exists(RSA_KEY_FILE_NAME))
				var privatePublicKeyPemBytes = File.ReadAllText(RSA_KEY_FILE_NAME);
				this.RSA_KEY = new RSACryptoServiceProvider(2048);
				this.RSA_KEY.ImportFromPem(privatePublicKeyPemBytes.ToCharArray());
				this.Logger.LogCritical(ex, &quot;Exception in RSA Import: {msg}&quot;, ex.Message);
				var privatePublicKeyPem = this.RSA_KEY.ExportRSAPrivateKeyPem();
				File.WriteAllText(RSA_KEY_FILE_NAME, privatePublicKeyPem);
				this.Logger.LogCritical(ex, &quot;Exception in RSA Export: {msg}&quot;, ex.Message);
	internal static TimeSpan EventExecutionLimit { get; } = TimeSpan.FromMinutes(1);
	public void Dispose()
		this.RSA_KEY.Dispose();
		GC.SuppressFinalize(this);
	public Uri GenerateOAuth2Url(string scopes, string state, bool suppressPrompt = false) =&gt;
		new(new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
			.AddParameter(&quot;client_id&quot;, this.ClientId.ToString(CultureInfo.InvariantCulture))
			.AddParameter(&quot;scope&quot;, scopes)
			.AddParameter(&quot;state&quot;, state)
			.AddParameter(&quot;redirect_uri&quot;, this.RedirectUri.AbsoluteUri)
			.AddParameter(&quot;response_type&quot;, &quot;code&quot;)
			.AddParameter(&quot;prompt&quot;, suppressPrompt ? &quot;none&quot; : &quot;consent&quot;)
			.ToString());
	public string GenerateState()
		=&gt; $&quot;{DateTimeOffset.UtcNow.UtcTicks}::{this.ClientId.GetHashCode()}::{Guid.NewGuid()}&quot;;
	public string GenerateSecureState(ulong userId)
		=&gt; Uri.EscapeDataString(Convert.ToBase64String(this.RSA_KEY.Encrypt(Encoding.UTF8.GetBytes($&quot;{DateTimeOffset.UtcNow.UtcTicks}::{userId}::{this.ClientId.GetHashCode()}::{Guid.NewGuid()}&quot;), RSAEncryptionPadding.OaepSHA1)));
	public string ReadSecureState(string state)
		=&gt; Encoding.UTF8.GetString(this.RSA_KEY.Decrypt(Convert.FromBase64String(Uri.UnescapeDataString(state)), RSAEncryptionPadding.OaepSHA1));
	public bool ValidateState(Uri requestUrl, Uri responseUrl, bool secure = false)
		var requestQueryDictionary = HttpUtility.ParseQueryString(requestUrl.Query, Encoding.UTF8);
		var responseQueryDictionary = HttpUtility.ParseQueryString(responseUrl.Query, Encoding.UTF8);
		var requestState = requestQueryDictionary.GetValues(&quot;state&quot;)?.First();
		var responseState = responseQueryDictionary.GetValues(&quot;state&quot;)?.First();
			       int.Parse(requestState.Split(&quot;::&quot;)[1]) == this.ClientId.GetHashCode() &amp;&amp;
			       int.Parse(responseState.Split(&quot;::&quot;)[1]) == this.ClientId.GetHashCode() &amp;&amp;
			throw new NullReferenceException(&quot;State was null&quot;);
		var decryptedReqState = this.ReadSecureState(requestState);
		var decryptedResState = this.ReadSecureState(responseState);
		return int.Parse(decryptedReqState.Split(&quot;::&quot;)[2]) == this.ClientId.GetHashCode() &amp;&amp; int.Parse(decryptedResState.Split(&quot;::&quot;)[2]) == this.ClientId.GetHashCode() &amp;&amp; decryptedReqState == decryptedResState
			: throw new SecurityException(&quot;States invalid&quot;);
	public string GetCodeFromUri(Uri url)
		var responseQueryDictionary = HttpUtility.ParseQueryString(url.Query, Encoding.UTF8);
		var code = responseQueryDictionary.GetValues(&quot;code&quot;)?.First();
		return code ?? throw new NullReferenceException(&quot;Could not find code in url.&quot;);
	public string GetStateFromUri(Uri url)
		var state = responseQueryDictionary.GetValues(&quot;state&quot;)?.First();
		return state ?? throw new NullReferenceException(&quot;Could not find code in url.&quot;);
	public async Task&lt;DiscordAccessToken&gt; ExchangeAccessTokenAsync(string code)
		=&gt; await this.ApiClient.ExchangeOAuth2AccessTokenAsync(code);
	public async Task&lt;DiscordAccessToken&gt; RefreshAccessTokenAsync(DiscordAccessToken accessToken)
		=&gt; await this.ApiClient.RefreshOAuth2AccessTokenAsync(accessToken.RefreshToken);
	public async Task RevokeByAccessTokenAsync(DiscordAccessToken accessToken)
		=&gt; await this.ApiClient.RevokeOAuth2TokenAsync(accessToken.AccessToken, &quot;access_token&quot;);
	public async Task RevokeByRefreshTokenAsync(DiscordAccessToken accessToken)
		=&gt; await this.ApiClient.RevokeOAuth2TokenAsync(accessToken.RefreshToken, &quot;refresh_token&quot;);
	public async Task&lt;DiscordAuthorizationInformation&gt; GetCurrentAuthorizationInformationAsync(DiscordAccessToken accessToken)
		=&gt; await this.ApiClient.GetCurrentOAuth2AuthorizationInformationAsync(accessToken.AccessToken);
	public async Task&lt;DiscordUser&gt; GetCurrentUserAsync(DiscordAccessToken accessToken)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;identify&quot;) ? await this.ApiClient.GetCurrentUserAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include identify scope&quot;);
	public async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetCurrentUserConnectionsAsync(DiscordAccessToken accessToken)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;connections&quot;) ? await this.ApiClient.GetCurrentUserConnectionsAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include connections scope&quot;);
	public async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(DiscordAccessToken accessToken)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds&quot;) ? await this.ApiClient.GetCurrentUserGuildsAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include guilds scope&quot;);
	public async Task&lt;DiscordMember&gt; GetCurrentUserGuildMemberAsync(DiscordAccessToken accessToken, ulong guildId)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.members.read&quot;) ? await this.ApiClient.GetCurrentUserGuildMemberAsync(accessToken.AccessToken, guildId) : throw new AccessViolationException(&quot;Access token does not include guilds.members.read scope&quot;);
	public async Task&lt;DiscordMember&gt; AddCurrentUserToGuildAsync(DiscordAccessToken accessToken, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.join&quot;) ? await this.ApiClient.AddGuildMemberAsync(guildId, (await this.GetCurrentUserAsync(accessToken)).Id, accessToken.AccessToken, nickname, roles, muted, deafened) : throw new AccessViolationException(&quot;Access token does not include guilds.join scope&quot;);
	public async Task&lt;DiscordMember&gt; AddCurrentUserToGuildAsync(DiscordAccessToken accessToken, ulong userId, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.join&quot;) ? await this.ApiClient.AddGuildMemberAsync(guildId, userId, accessToken.AccessToken, nickname, roles, muted, deafened) : throw new AccessViolationException(&quot;Access token does not include guilds.join scope&quot;);
	public async Task&lt;DiscordApplicationRoleConnection&gt; GetCurrentUserApplicationRoleConnectionAsync(DiscordAccessToken accessToken)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;role_connections.write&quot;) ? await this.ApiClient.GetCurrentUserApplicationRoleConnectionAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include role_connections.write scope&quot;);
	public async Task&lt;DiscordApplicationRoleConnection&gt; UpdateCurrentUserApplicationRoleConnectionAsync(DiscordAccessToken accessToken, string platformName, string platformUsername, ApplicationRoleConnectionMetadata metadata)
		=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;role_connections.write&quot;) ? await this.ApiClient.ModifyCurrentUserApplicationRoleConnectionAsync(accessToken.AccessToken, platformName, platformUsername, metadata) : throw new AccessViolationException(&quot;Access token does not include role_connections.write scope&quot;);
		add =&gt; this.OAuth2ClientErroredInternal.Register(value);
		remove =&gt; this.OAuth2ClientErroredInternal.Unregister(value);
	internal void EventErrorHandler&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs
			this.Logger.LogWarning(LoggerEvents.EventHandlerException, &quot;An event handler for {AsyncEventName} took too long to execute. Defined as \&quot;{TrimStart}\&quot; located in \&quot;{MethodDeclaringType}\&quot;&quot;, asyncEvent.Name, handler.Method.ToString()?.Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart(), handler.Method.DeclaringType);
		this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {Name} thrown from {@Method} (defined in {Type})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
		this.OAuth2ClientErroredInternal.InvokeAsync(this, new(this.ServiceProvider)
		}).ConfigureAwait(false).GetAwaiter().GetResult();
	private void Goof&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {Method} (defined in {DeclaringType}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);
		this.Dispose();</file><file path="DisCatSharp/Clients/DiscordShardedClient.cs">public sealed partial class DiscordShardedClient
		this.InternalSetup();
			this._configuration.LoggerFactory = new DefaultLoggerFactory();
			this._configuration.LoggerFactory.AddProvider(new DefaultLoggerProvider(this._configuration.MinimumLogLevel, this._configuration.LogTimestampFormat));
			var l = new ConsoleLoggerProvider(optionsMonitor);
			this._configuration.LoggerFactory = new LoggerFactory();
			this._configuration.LoggerFactory.AddProvider(l);
			this._configuration.LoggerFactory.AddSentry(o =&gt;
				var a = typeof(DiscordClient).GetTypeInfo().Assembly;
					var v = a.GetName().Version;
				o.AddInAppInclude(&quot;DisCatSharp&quot;);
					o.AddExceptionFilter(new DisCatSharpExceptionFilter(this._configuration));
				o.SetBeforeSend((e, _) =&gt;
							if (!this._configuration.TrackExceptions.Contains(e.Exception.GetType()))
						else if (e.Extra.Count == 0 || !e.Extra.ContainsKey(&quot;Found Fields&quot;))
					if (!e.HasUser())
								Id = this.CurrentUser.Id.ToString(),
					if (!e.Extra.ContainsKey(&quot;Found Fields&quot;))
						e.SetFingerprint(BaseDiscordClient.GenerateSentryFingerPrint(e));
	internal async Task&lt;int&gt; InitializeShardsAsync()
		this.GatewayInfo = await this.GetGatewayInfoAsync().ConfigureAwait(false);
		var lf = new ShardedLoggerFactory(this.Logger);
			var cfg = new DiscordConfiguration(this._configuration)
			var client = new DiscordClient(cfg);
			if (!this._shards.TryAdd(i, client))
				throw new InvalidOperationException(&quot;Could not initialize shards.&quot;);
		this.InternalStopAsync(false).GetAwaiter().GetResult();
			var combinedStats = Enum.GetValues(typeof(DisCatSharpStatisticType))
				.ToDictionary(stat =&gt; stat, _ =&gt; 0);
	private readonly DiscordConfiguration _configuration;
	public async Task StartAsync()
			throw new InvalidOperationException(&quot;This client has already been started.&quot;);
				this.Logger.LogWarning(LoggerEvents.Misc, &quot;You are logging in with a token that is not a bot token. This is not officially supported by Discord, and can result in your account being terminated if you aren&apos;t careful&quot;);
			this.Logger.LogInformation(LoggerEvents.Startup, &quot;Lib {LibraryName}, version {LibraryVersion}&quot;, this._botLibrary, this._versionString.Value);
			var shardc = await this.InitializeShardsAsync().ConfigureAwait(false);
			this.Logger.LogInformation(LoggerEvents.ShardStartup, &quot;Booting {NumShards} shards&quot;, shardc);
					await this.ConnectShardAsync(i).ConfigureAwait(false);
					connectTasks.Add(this.ConnectShardAsync(i));
						await Task.WhenAll(connectTasks).ConfigureAwait(false);
						connectTasks.Clear();
			await this.InternalStopAsync(false).ConfigureAwait(false);
			this.Logger.LogCritical(LoggerEvents.ShardClientError, &quot;{Message}\n{Ex}&quot;, message, ex);
			throw new AggregateException(message, ex);
	public Task StopAsync()
		=&gt; this.InternalStopAsync();
	public DiscordClient GetShard(ulong guildId)
		var index = this._manuallySharding ? this.GetShardIdFromGuilds(guildId) : Utilities.GetShardId(guildId, this.ShardClients.Count);
	public DiscordClient GetShard(DiscordGuild guild)
		=&gt; this.GetShard(guild.Id);
	public async Task UpdateStatusAsync(DiscordActivity activity = null, UserStatus? userStatus = null, DateTimeOffset? idleSince = null)
			tasks.Add(client.UpdateStatusAsync(activity, userStatus, idleSince));
		await Task.WhenAll(tasks).ConfigureAwait(false);
	private async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync()
		var httphandler = new HttpClientHandler
		var url = $&quot;{Utilities.GetApiBaseUri(this._configuration)}{Endpoints.GATEWAY}{Endpoints.BOT}&quot;;
		var http = new HttpClient(httphandler)
			BaseAddress = new(Utilities.GetApiBaseUri(this._configuration)),
		http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
		http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, Utilities.GetFormattedToken(this._configuration));
		http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, this._configuration.Locale);
		if (!string.IsNullOrWhiteSpace(this._configuration.Timezone))
			http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, this._configuration.Timezone);
			http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, this._configuration.Override);
		this.Logger.LogDebug(LoggerEvents.ShardRest, $&quot;Obtaining gateway information from GET {Endpoints.GATEWAY}{Endpoints.BOT}...&quot;);
		var resp = await http.GetAsync(url).ConfigureAwait(false);
		http.Dispose();
			var ratelimited = await HandleHttpError(url, resp).ConfigureAwait(false);
				return await this.GetGatewayInfoAsync().ConfigureAwait(false);
		var timer = new Stopwatch();
		timer.Start();
		var jo = JObject.Parse(await resp.Content.ReadAsStringAsync().ConfigureAwait(false));
		timer.Stop();
		info.SessionBucket.ResetAfter = DateTimeOffset.UtcNow + TimeSpan.FromMilliseconds(info.SessionBucket.ResetAfterInternal);
				this.Logger.LogError(LoggerEvents.ShardClientError, $&quot;Ratelimit hit, requeuing request to {reqUrl}&quot;);
				var hs = msg.Headers.ToDictionary(xh =&gt; xh.Key, xh =&gt; string.Join(&quot;\n&quot;, xh.Value), StringComparer.OrdinalIgnoreCase);
				if (hs.TryGetValue(&quot;Retry-After&quot;, out var retryAfterRaw))
					waitInterval = int.Parse(retryAfterRaw, CultureInfo.InvariantCulture);
				await Task.Delay(waitInterval).ConfigureAwait(false);
		var a = typeof(DiscordShardedClient).GetTypeInfo().Assembly;
		var vs = v.ToString(3);
	private async Task ConnectShardAsync(int i)
		if (!this._shards.TryGetValue(i, out var client))
		this.HookEventHandlers(client);
		await client.ConnectAsync().ConfigureAwait(false);
		this.Logger.LogInformation(LoggerEvents.ShardStartup, &quot;Booted shard {0}.&quot;, i);
	private Task InternalStopAsync(bool enableLogger = true)
			throw new InvalidOperationException(&quot;This client has not been started.&quot;);
			this.Logger.LogInformation(LoggerEvents.ShardShutdown, &quot;Disposing {0} shards.&quot;, this._shards.Count);
			if (this._shards.TryGetValue(i, out var client))
				this.UnhookEventHandlers(client);
				client.Dispose();
					this.Logger.LogInformation(LoggerEvents.ShardShutdown, &quot;Disconnected shard {0}.&quot;, i);
		this._shards.Clear();
	private void InternalSetup()
	private void HookEventHandlers(DiscordClient client)
	private void UnhookEventHandlers(DiscordClient client)
	private int GetShardIdFromGuilds(ulong id)
			if (s.GuildsInternal.TryGetValue(id, out _))</file><file path="DisCatSharp/Clients/DiscordShardedClient.Events.cs">public sealed partial class DiscordShardedClient
		add =&gt; this._socketErrored.Register(value);
		remove =&gt; this._socketErrored.Unregister(value);
		add =&gt; this._socketOpened.Register(value);
		remove =&gt; this._socketOpened.Unregister(value);
		add =&gt; this._socketClosed.Register(value);
		remove =&gt; this._socketClosed.Unregister(value);
		add =&gt; this._ready.Register(value);
		remove =&gt; this._ready.Unregister(value);
		add =&gt; this._resumed.Register(value);
		remove =&gt; this._resumed.Unregister(value);
		add =&gt; this._heartbeated.Register(value);
		remove =&gt; this._heartbeated.Unregister(value);
		add =&gt; this._channelCreated.Register(value);
		remove =&gt; this._channelCreated.Unregister(value);
		add =&gt; this._channelUpdated.Register(value);
		remove =&gt; this._channelUpdated.Unregister(value);
		add =&gt; this._channelDeleted.Register(value);
		remove =&gt; this._channelDeleted.Unregister(value);
		add =&gt; this._dmChannelDeleted.Register(value);
		remove =&gt; this._dmChannelDeleted.Unregister(value);
		add =&gt; this._channelPinsUpdated.Register(value);
		remove =&gt; this._channelPinsUpdated.Unregister(value);
		add =&gt; this._voiceChannelStatusUpdated.Register(value);
		remove =&gt; this._voiceChannelStatusUpdated.Unregister(value);
		add =&gt; this._guildCreated.Register(value);
		remove =&gt; this._guildCreated.Unregister(value);
		add =&gt; this._guildAvailable.Register(value);
		remove =&gt; this._guildAvailable.Unregister(value);
		add =&gt; this._guildUpdated.Register(value);
		remove =&gt; this._guildUpdated.Unregister(value);
		add =&gt; this._guildDeleted.Register(value);
		remove =&gt; this._guildDeleted.Unregister(value);
		add =&gt; this._guildUnavailable.Register(value);
		remove =&gt; this._guildUnavailable.Unregister(value);
		add =&gt; this._guildDownloadCompleted.Register(value);
		remove =&gt; this._guildDownloadCompleted.Unregister(value);
		add =&gt; this._guildEmojisUpdated.Register(value);
		remove =&gt; this._guildEmojisUpdated.Unregister(value);
		add =&gt; this._guildStickersUpdated.Register(value);
		remove =&gt; this._guildStickersUpdated.Unregister(value);
		add =&gt; this._guildIntegrationsUpdated.Register(value);
		remove =&gt; this._guildIntegrationsUpdated.Unregister(value);
		add =&gt; this._automodRuleCreated.Register(value);
		remove =&gt; this._automodRuleCreated.Unregister(value);
		add =&gt; this._automodRuleUpdated.Register(value);
		remove =&gt; this._automodRuleUpdated.Unregister(value);
		add =&gt; this._automodRuleDeleted.Register(value);
		remove =&gt; this._automodRuleDeleted.Unregister(value);
		add =&gt; this._automodActionExecuted.Register(value);
		remove =&gt; this._automodActionExecuted.Unregister(value);
		add =&gt; this._guildAuditLogEntryCreated.Register(value);
		remove =&gt; this._guildAuditLogEntryCreated.Unregister(value);
		add =&gt; this._guildBanAdded.Register(value);
		remove =&gt; this._guildBanAdded.Unregister(value);
		add =&gt; this._guildBanRemoved.Register(value);
		remove =&gt; this._guildBanRemoved.Unregister(value);
		add =&gt; this._guildMemberTimeoutAdded.Register(value);
		remove =&gt; this._guildMemberTimeoutAdded.Unregister(value);
		add =&gt; this._guildMemberTimeoutChanged.Register(value);
		remove =&gt; this._guildMemberTimeoutChanged.Unregister(value);
		add =&gt; this._guildMemberTimeoutRemoved.Register(value);
		remove =&gt; this._guildMemberTimeoutRemoved.Unregister(value);
		add =&gt; this._guildScheduledEventCreated.Register(value);
		remove =&gt; this._guildScheduledEventCreated.Unregister(value);
		add =&gt; this._guildScheduledEventUpdated.Register(value);
		remove =&gt; this._guildScheduledEventUpdated.Unregister(value);
		add =&gt; this._guildScheduledEventDeleted.Register(value);
		remove =&gt; this._guildScheduledEventDeleted.Unregister(value);
		add =&gt; this._guildScheduledEventUserAdded.Register(value);
		remove =&gt; this._guildScheduledEventUserAdded.Unregister(value);
		add =&gt; this._guildScheduledEventUserRemoved.Register(value);
		remove =&gt; this._guildScheduledEventUserRemoved.Unregister(value);
		add =&gt; this._guildIntegrationCreated.Register(value);
		remove =&gt; this._guildIntegrationCreated.Unregister(value);
		add =&gt; this._guildIntegrationUpdated.Register(value);
		remove =&gt; this._guildIntegrationUpdated.Unregister(value);
		add =&gt; this._guildIntegrationDeleted.Register(value);
		remove =&gt; this._guildIntegrationDeleted.Unregister(value);
		add =&gt; this._guildMemberAdded.Register(value);
		remove =&gt; this._guildMemberAdded.Unregister(value);
		add =&gt; this._guildMemberRemoved.Register(value);
		remove =&gt; this._guildMemberRemoved.Unregister(value);
		add =&gt; this._guildMemberUpdated.Register(value);
		remove =&gt; this._guildMemberUpdated.Unregister(value);
		add =&gt; this._guildMembersChunk.Register(value);
		remove =&gt; this._guildMembersChunk.Unregister(value);
		add =&gt; this._guildRoleCreated.Register(value);
		remove =&gt; this._guildRoleCreated.Unregister(value);
		add =&gt; this._guildRoleUpdated.Register(value);
		remove =&gt; this._guildRoleUpdated.Unregister(value);
		add =&gt; this._guildRoleDeleted.Register(value);
		remove =&gt; this._guildRoleDeleted.Unregister(value);
		add =&gt; this._inviteCreated.Register(value);
		remove =&gt; this._inviteCreated.Unregister(value);
		add =&gt; this._inviteDeleted.Register(value);
		remove =&gt; this._inviteDeleted.Unregister(value);
		add =&gt; this._messageCreated.Register(value);
		remove =&gt; this._messageCreated.Unregister(value);
		add =&gt; this._messageUpdated.Register(value);
		remove =&gt; this._messageUpdated.Unregister(value);
		add =&gt; this._messageDeleted.Register(value);
		remove =&gt; this._messageDeleted.Unregister(value);
		add =&gt; this._messageBulkDeleted.Register(value);
		remove =&gt; this._messageBulkDeleted.Unregister(value);
		add =&gt; this._messagePollVoteAdded.Register(value);
		remove =&gt; this._messagePollVoteAdded.Unregister(value);
		add =&gt; this._messagePollVoteRemoved.Register(value);
		remove =&gt; this._messagePollVoteRemoved.Unregister(value);
		add =&gt; this._guildSoundboardSoundCreated.Register(value);
		remove =&gt; this._guildSoundboardSoundCreated.Unregister(value);
		add =&gt; this._guildSoundboardSoundUpdated.Register(value);
		remove =&gt; this._guildSoundboardSoundUpdated.Unregister(value);
		add =&gt; this._guildSoundboardSoundDeleted.Register(value);
		remove =&gt; this._guildSoundboardSoundDeleted.Unregister(value);
		add =&gt; this._guildSoundboardSoundsUpdated.Register(value);
		remove =&gt; this._guildSoundboardSoundsUpdated.Unregister(value);
		add =&gt; this._soundboardSounds.Register(value);
		remove =&gt; this._soundboardSounds.Unregister(value);
		add =&gt; this._guildJoinRequestCreated.Register(value);
		remove =&gt; this._guildJoinRequestCreated.Unregister(value);
		add =&gt; this._guildJoinRequestUpdated.Register(value);
		remove =&gt; this._guildJoinRequestUpdated.Unregister(value);
		add =&gt; this._guildJoinRequestDeleted.Register(value);
		remove =&gt; this._guildJoinRequestDeleted.Unregister(value);
		add =&gt; this._messageReactionAdded.Register(value);
		remove =&gt; this._messageReactionAdded.Unregister(value);
		add =&gt; this._messageReactionRemoved.Register(value);
		remove =&gt; this._messageReactionRemoved.Unregister(value);
		add =&gt; this._messageReactionsCleared.Register(value);
		remove =&gt; this._messageReactionsCleared.Unregister(value);
		add =&gt; this._messageReactionRemovedEmoji.Register(value);
		remove =&gt; this._messageReactionRemovedEmoji.Unregister(value);
		add =&gt; this._stageInstanceCreated.Register(value);
		remove =&gt; this._stageInstanceCreated.Unregister(value);
		add =&gt; this._stageInstanceUpdated.Register(value);
		remove =&gt; this._stageInstanceUpdated.Unregister(value);
		add =&gt; this._stageInstanceDeleted.Register(value);
		remove =&gt; this._stageInstanceDeleted.Unregister(value);
		add =&gt; this._threadCreated.Register(value);
		remove =&gt; this._threadCreated.Unregister(value);
		add =&gt; this._threadUpdated.Register(value);
		remove =&gt; this._threadUpdated.Unregister(value);
		add =&gt; this._threadDeleted.Register(value);
		remove =&gt; this._threadDeleted.Unregister(value);
		add =&gt; this._threadListSynced.Register(value);
		remove =&gt; this._threadListSynced.Unregister(value);
		add =&gt; this._threadMemberUpdated.Register(value);
		remove =&gt; this._threadMemberUpdated.Unregister(value);
		add =&gt; this._threadMembersUpdated.Register(value);
		remove =&gt; this._threadMembersUpdated.Unregister(value);
		add =&gt; this._embeddedActivityUpdated.Register(value);
		remove =&gt; this._embeddedActivityUpdated.Unregister(value);
		add =&gt; this._presenceUpdated.Register(value);
		remove =&gt; this._presenceUpdated.Unregister(value);
		add =&gt; this._userSettingsUpdated.Register(value);
		remove =&gt; this._userSettingsUpdated.Unregister(value);
		add =&gt; this._userUpdated.Register(value);
		remove =&gt; this._userUpdated.Unregister(value);
		add =&gt; this._voiceStateUpdated.Register(value);
		remove =&gt; this._voiceStateUpdated.Unregister(value);
		add =&gt; this._voiceServerUpdated.Register(value);
		remove =&gt; this._voiceServerUpdated.Unregister(value);
		add =&gt; this._voiceChannelEffectSend.Register(value);
		remove =&gt; this._voiceChannelEffectSend.Unregister(value);
		add =&gt; this._applicationCommandCreated.Register(value);
		remove =&gt; this._applicationCommandCreated.Unregister(value);
		add =&gt; this._applicationCommandUpdated.Register(value);
		remove =&gt; this._applicationCommandUpdated.Unregister(value);
		add =&gt; this._applicationCommandDeleted.Register(value);
		remove =&gt; this._applicationCommandDeleted.Unregister(value);
		add =&gt; this._guildApplicationCommandCountUpdated.Register(value);
		remove =&gt; this._guildApplicationCommandCountUpdated.Unregister(value);
		add =&gt; this._contextMenuInteractionCreated.Register(value);
		remove =&gt; this._contextMenuInteractionCreated.Unregister(value);
		add =&gt; this._applicationCommandPermissionsUpdated.Register(value);
		remove =&gt; this._applicationCommandPermissionsUpdated.Unregister(value);
		add =&gt; this._interactionCreated.Register(value);
		remove =&gt; this._interactionCreated.Unregister(value);
		add =&gt; this._componentInteractionCreated.Register(value);
		remove =&gt; this._componentInteractionCreated.Unregister(value);
		add =&gt; this._entitlementCreated.Register(value);
		remove =&gt; this._entitlementCreated.Unregister(value);
		add =&gt; this._entitlementUpdated.Register(value);
		remove =&gt; this._entitlementUpdated.Unregister(value);
		add =&gt; this._entitlementDeleted.Register(value);
		remove =&gt; this._entitlementDeleted.Unregister(value);
		add =&gt; this._subscriptionCreated.Register(value);
		remove =&gt; this._subscriptionCreated.Unregister(value);
		add =&gt; this._subscriptionUpdated.Register(value);
		remove =&gt; this._subscriptionUpdated.Unregister(value);
		add =&gt; this._typingStarted.Register(value);
		remove =&gt; this._typingStarted.Unregister(value);
		add =&gt; this._unknownEvent.Register(value);
		remove =&gt; this._unknownEvent.Unregister(value);
		add =&gt; this._webhooksUpdated.Register(value);
		remove =&gt; this._webhooksUpdated.Unregister(value);
		add =&gt; this._clientErrored.Register(value);
		remove =&gt; this._clientErrored.Unregister(value);
	internal void EventErrorHandler&lt;TArgs&gt;(AsyncEvent&lt;DiscordClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;DiscordClient, TArgs&gt; handler, DiscordClient sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs
			this.Logger.LogWarning(LoggerEvents.EventHandlerException, $&quot;An event handler for {asyncEvent.Name} took too long to execute. Defined as \&quot;{handler.Method.ToString().Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart()}\&quot; located in \&quot;{handler.Method.DeclaringType}\&quot;.&quot;);
		this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {0} thrown from {1} (defined in {2})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
		this._clientErrored.InvokeAsync(sender, new(this.ShardClients[0].ServiceProvider)
		}).ConfigureAwait(false).GetAwaiter().GetResult();
		add =&gt; this._zombied.Register(value);
		remove =&gt; this._zombied.Unregister(value);
		add =&gt; this._payloadReceived.Register(value);
		remove =&gt; this._payloadReceived.Unregister(value);
	private void Goof&lt;TArgs&gt;(AsyncEvent&lt;DiscordClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;DiscordClient, TArgs&gt; handler, DiscordClient sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {0} (defined in {1}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);
	private Task Client_Zombied(DiscordClient client, ZombiedEventArgs e)
		=&gt; this._zombied.InvokeAsync(client, e);
	private Task Client_GuildMemberTimeoutRemoved(DiscordClient client, GuildMemberTimeoutRemoveEventArgs e)
		=&gt; this._guildMemberTimeoutRemoved.InvokeAsync(client, e);
	private Task Client_GuildMemberTimeoutChanged(DiscordClient client, GuildMemberTimeoutUpdateEventArgs e)
		=&gt; this._guildMemberTimeoutChanged.InvokeAsync(client, e);
	private Task Client_GuildMemberTimeoutAdded(DiscordClient client, GuildMemberTimeoutAddEventArgs e)
		=&gt; this._guildMemberTimeoutAdded.InvokeAsync(client, e);
	private Task Client_EmbeddedActivityUpdated(DiscordClient client, EmbeddedActivityUpdateEventArgs e)
		=&gt; this._embeddedActivityUpdated.InvokeAsync(client, e);
	private Task Client_PayloadReceived(DiscordClient client, PayloadReceivedEventArgs e)
		=&gt; this._payloadReceived.InvokeAsync(client, e);
	private Task Client_ClientError(DiscordClient client, ClientErrorEventArgs e)
		=&gt; this._clientErrored.InvokeAsync(client, e);
	private Task Client_SocketError(DiscordClient client, SocketErrorEventArgs e)
		=&gt; this._socketErrored.InvokeAsync(client, e);
	private Task Client_SocketOpened(DiscordClient client, SocketEventArgs e)
		=&gt; this._socketOpened.InvokeAsync(client, e);
	private Task Client_SocketClosed(DiscordClient client, SocketCloseEventArgs e)
		=&gt; this._socketClosed.InvokeAsync(client, e);
	private Task Client_Ready(DiscordClient client, ReadyEventArgs e)
		=&gt; this._ready.InvokeAsync(client, e);
	private Task Client_Resumed(DiscordClient client, ReadyEventArgs e)
		=&gt; this._resumed.InvokeAsync(client, e);
	private Task Client_ChannelCreated(DiscordClient client, ChannelCreateEventArgs e)
		=&gt; this._channelCreated.InvokeAsync(client, e);
	private Task Client_ChannelUpdated(DiscordClient client, ChannelUpdateEventArgs e)
		=&gt; this._channelUpdated.InvokeAsync(client, e);
	private Task Client_ChannelDeleted(DiscordClient client, ChannelDeleteEventArgs e)
		=&gt; this._channelDeleted.InvokeAsync(client, e);
	private Task Client_DMChannelDeleted(DiscordClient client, DmChannelDeleteEventArgs e)
		=&gt; this._dmChannelDeleted.InvokeAsync(client, e);
	private Task Client_ChannelPinsUpdated(DiscordClient client, ChannelPinsUpdateEventArgs e)
		=&gt; this._channelPinsUpdated.InvokeAsync(client, e);
	private Task Client_GuildCreated(DiscordClient client, GuildCreateEventArgs e)
		=&gt; this._guildCreated.InvokeAsync(client, e);
	private Task Client_GuildAvailable(DiscordClient client, GuildCreateEventArgs e)
		=&gt; this._guildAvailable.InvokeAsync(client, e);
	private Task Client_GuildUpdated(DiscordClient client, GuildUpdateEventArgs e)
		=&gt; this._guildUpdated.InvokeAsync(client, e);
	private Task Client_GuildDeleted(DiscordClient client, GuildDeleteEventArgs e)
		=&gt; this._guildDeleted.InvokeAsync(client, e);
	private Task Client_GuildUnavailable(DiscordClient client, GuildDeleteEventArgs e)
		=&gt; this._guildUnavailable.InvokeAsync(client, e);
	private Task Client_GuildDownloadCompleted(DiscordClient client, GuildDownloadCompletedEventArgs e)
		=&gt; this._guildDownloadCompleted.InvokeAsync(client, e);
	private Task Client_MessageCreated(DiscordClient client, MessageCreateEventArgs e)
		=&gt; this._messageCreated.InvokeAsync(client, e);
	private Task Client_InviteCreated(DiscordClient client, InviteCreateEventArgs e)
		=&gt; this._inviteCreated.InvokeAsync(client, e);
	private Task Client_InviteDeleted(DiscordClient client, InviteDeleteEventArgs e)
		=&gt; this._inviteDeleted.InvokeAsync(client, e);
	private Task Client_PresenceUpdate(DiscordClient client, PresenceUpdateEventArgs e)
		=&gt; this._presenceUpdated.InvokeAsync(client, e);
	private Task Client_GuildBanAdd(DiscordClient client, GuildBanAddEventArgs e)
		=&gt; this._guildBanAdded.InvokeAsync(client, e);
	private Task Client_GuildBanRemove(DiscordClient client, GuildBanRemoveEventArgs e)
		=&gt; this._guildBanRemoved.InvokeAsync(client, e);
	private Task Client_GuildEmojisUpdate(DiscordClient client, GuildEmojisUpdateEventArgs e)
		=&gt; this._guildEmojisUpdated.InvokeAsync(client, e);
	private Task Client_GuildStickersUpdate(DiscordClient client, GuildStickersUpdateEventArgs e)
		=&gt; this._guildStickersUpdated.InvokeAsync(client, e);
	private Task Client_GuildIntegrationsUpdate(DiscordClient client, GuildIntegrationsUpdateEventArgs e)
		=&gt; this._guildIntegrationsUpdated.InvokeAsync(client, e);
	private Task Client_GuildMemberAdd(DiscordClient client, GuildMemberAddEventArgs e)
		=&gt; this._guildMemberAdded.InvokeAsync(client, e);
	private Task Client_GuildMemberRemove(DiscordClient client, GuildMemberRemoveEventArgs e)
		=&gt; this._guildMemberRemoved.InvokeAsync(client, e);
	private Task Client_GuildMemberUpdate(DiscordClient client, GuildMemberUpdateEventArgs e)
		=&gt; this._guildMemberUpdated.InvokeAsync(client, e);
	private Task Client_GuildRoleCreate(DiscordClient client, GuildRoleCreateEventArgs e)
		=&gt; this._guildRoleCreated.InvokeAsync(client, e);
	private Task Client_GuildRoleUpdate(DiscordClient client, GuildRoleUpdateEventArgs e)
		=&gt; this._guildRoleUpdated.InvokeAsync(client, e);
	private Task Client_GuildRoleDelete(DiscordClient client, GuildRoleDeleteEventArgs e)
		=&gt; this._guildRoleDeleted.InvokeAsync(client, e);
	private Task Client_MessageUpdate(DiscordClient client, MessageUpdateEventArgs e)
		=&gt; this._messageUpdated.InvokeAsync(client, e);
	private Task Client_MessageDelete(DiscordClient client, MessageDeleteEventArgs e)
		=&gt; this._messageDeleted.InvokeAsync(client, e);
	private Task Client_MessageBulkDelete(DiscordClient client, MessageBulkDeleteEventArgs e)
		=&gt; this._messageBulkDeleted.InvokeAsync(client, e);
	private Task Client_TypingStart(DiscordClient client, TypingStartEventArgs e)
		=&gt; this._typingStarted.InvokeAsync(client, e);
	private Task Client_UserSettingsUpdate(DiscordClient client, UserSettingsUpdateEventArgs e)
		=&gt; this._userSettingsUpdated.InvokeAsync(client, e);
	private Task Client_UserUpdate(DiscordClient client, UserUpdateEventArgs e)
		=&gt; this._userUpdated.InvokeAsync(client, e);
	private Task Client_VoiceStateUpdate(DiscordClient client, VoiceStateUpdateEventArgs e)
		=&gt; this._voiceStateUpdated.InvokeAsync(client, e);
	private Task Client_VoiceServerUpdate(DiscordClient client, VoiceServerUpdateEventArgs e)
		=&gt; this._voiceServerUpdated.InvokeAsync(client, e);
	private Task Client_VoiceChannelEffectSend(DiscordClient client, VoiceChannelEffectSendEventArgs e)
		=&gt; this._voiceChannelEffectSend.InvokeAsync(client, e);
	private Task Client_GuildMembersChunk(DiscordClient client, GuildMembersChunkEventArgs e)
		=&gt; this._guildMembersChunk.InvokeAsync(client, e);
	private Task Client_UnknownEvent(DiscordClient client, UnknownEventArgs e)
		=&gt; this._unknownEvent.InvokeAsync(client, e);
	private Task Client_MessageReactionAdd(DiscordClient client, MessageReactionAddEventArgs e)
		=&gt; this._messageReactionAdded.InvokeAsync(client, e);
	private Task Client_MessageReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs e)
		=&gt; this._messageReactionRemoved.InvokeAsync(client, e);
	private Task Client_MessageReactionRemoveAll(DiscordClient client, MessageReactionsClearEventArgs e)
		=&gt; this._messageReactionsCleared.InvokeAsync(client, e);
	private Task Client_MessageReactionRemovedEmoji(DiscordClient client, MessageReactionRemoveEmojiEventArgs e)
		=&gt; this._messageReactionRemovedEmoji.InvokeAsync(client, e);
	private Task Client_InteractionCreated(DiscordClient client, InteractionCreateEventArgs e)
		=&gt; this._interactionCreated.InvokeAsync(client, e);
	private Task Client_EntitlementCreated(DiscordClient client, EntitlementCreateEventArgs e)
		=&gt; this._entitlementCreated.InvokeAsync(client, e);
	private Task Client_EntitlementUpdated(DiscordClient client, EntitlementUpdateEventArgs e)
		=&gt; this._entitlementUpdated.InvokeAsync(client, e);
	private Task Client_EntitlementDeleted(DiscordClient client, EntitlementDeleteEventArgs e)
		=&gt; this._entitlementDeleted.InvokeAsync(client, e);
	private Task Client_SubscriptionCreated(DiscordClient client, SubscriptionCreateEventArgs e)
		=&gt; this._subscriptionCreated.InvokeAsync(client, e);
	private Task Client_SubscriptionUpdated(DiscordClient client, SubscriptionUpdateEventArgs e)
		=&gt; this._subscriptionUpdated.InvokeAsync(client, e);
	private Task Client_ComponentInteractionCreate(DiscordClient client, ComponentInteractionCreateEventArgs e)
		=&gt; this._componentInteractionCreated.InvokeAsync(client, e);
	private Task Client_ContextMenuInteractionCreate(DiscordClient client, ContextMenuInteractionCreateEventArgs e)
		=&gt; this._contextMenuInteractionCreated.InvokeAsync(client, e);
	private Task Client_WebhooksUpdate(DiscordClient client, WebhooksUpdateEventArgs e)
		=&gt; this._webhooksUpdated.InvokeAsync(client, e);
	private Task Client_HeartBeated(DiscordClient client, HeartbeatEventArgs e)
		=&gt; this._heartbeated.InvokeAsync(client, e);
	private Task Client_ApplicationCommandCreated(DiscordClient client, ApplicationCommandEventArgs e)
		=&gt; this._applicationCommandCreated.InvokeAsync(client, e);
	private Task Client_ApplicationCommandUpdated(DiscordClient client, ApplicationCommandEventArgs e)
		=&gt; this._applicationCommandUpdated.InvokeAsync(client, e);
	private Task Client_ApplicationCommandDeleted(DiscordClient client, ApplicationCommandEventArgs e)
		=&gt; this._applicationCommandDeleted.InvokeAsync(client, e);
	private Task Client_GuildApplicationCommandCountUpdated(DiscordClient client, GuildApplicationCommandCountEventArgs e)
		=&gt; this._guildApplicationCommandCountUpdated.InvokeAsync(client, e);
	private Task Client_ApplicationCommandPermissionsUpdated(DiscordClient client, ApplicationCommandPermissionsUpdateEventArgs e)
		=&gt; this._applicationCommandPermissionsUpdated.InvokeAsync(client, e);
	private Task Client_GuildIntegrationCreated(DiscordClient client, GuildIntegrationCreateEventArgs e)
		=&gt; this._guildIntegrationCreated.InvokeAsync(client, e);
	private Task Client_GuildIntegrationUpdated(DiscordClient client, GuildIntegrationUpdateEventArgs e)
		=&gt; this._guildIntegrationUpdated.InvokeAsync(client, e);
	private Task Client_GuildIntegrationDeleted(DiscordClient client, GuildIntegrationDeleteEventArgs e)
		=&gt; this._guildIntegrationDeleted.InvokeAsync(client, e);
	private Task Client_StageInstanceCreated(DiscordClient client, StageInstanceCreateEventArgs e)
		=&gt; this._stageInstanceCreated.InvokeAsync(client, e);
	private Task Client_StageInstanceUpdated(DiscordClient client, StageInstanceUpdateEventArgs e)
		=&gt; this._stageInstanceUpdated.InvokeAsync(client, e);
	private Task Client_StageInstanceDeleted(DiscordClient client, StageInstanceDeleteEventArgs e)
		=&gt; this._stageInstanceDeleted.InvokeAsync(client, e);
	private Task Client_ThreadCreated(DiscordClient client, ThreadCreateEventArgs e)
		=&gt; this._threadCreated.InvokeAsync(client, e);
	private Task Client_ThreadUpdated(DiscordClient client, ThreadUpdateEventArgs e)
		=&gt; this._threadUpdated.InvokeAsync(client, e);
	private Task Client_ThreadDeleted(DiscordClient client, ThreadDeleteEventArgs e)
		=&gt; this._threadDeleted.InvokeAsync(client, e);
	private Task Client_ThreadListSynced(DiscordClient client, ThreadListSyncEventArgs e)
		=&gt; this._threadListSynced.InvokeAsync(client, e);
	private Task Client_ThreadMemberUpdated(DiscordClient client, ThreadMemberUpdateEventArgs e)
		=&gt; this._threadMemberUpdated.InvokeAsync(client, e);
	private Task Client_ThreadMembersUpdated(DiscordClient client, ThreadMembersUpdateEventArgs e)
		=&gt; this._threadMembersUpdated.InvokeAsync(client, e);
	private Task Client_GuildScheduledEventCreated(DiscordClient client, GuildScheduledEventCreateEventArgs e)
		=&gt; this._guildScheduledEventCreated.InvokeAsync(client, e);
	private Task Client_GuildScheduledEventUpdated(DiscordClient client, GuildScheduledEventUpdateEventArgs e)
		=&gt; this._guildScheduledEventUpdated.InvokeAsync(client, e);
	private Task Client_GuildScheduledEventDeleted(DiscordClient client, GuildScheduledEventDeleteEventArgs e)
		=&gt; this._guildScheduledEventDeleted.InvokeAsync(client, e);
	private Task Client_GuildScheduledEventUserAdded(DiscordClient client, GuildScheduledEventUserAddEventArgs e)
		=&gt; this._guildScheduledEventUserAdded.InvokeAsync(client, e);
	private Task Client_GuildScheduledEventUserRemoved(DiscordClient client, GuildScheduledEventUserRemoveEventArgs e)
		=&gt; this._guildScheduledEventUserRemoved.InvokeAsync(client, e);
	private Task Client_AutomodRuleCreated(DiscordClient client, AutomodRuleCreateEventArgs e)
		=&gt; this._automodRuleCreated.InvokeAsync(client, e);
	private Task Client_AutomodRuleUpdated(DiscordClient client, AutomodRuleUpdateEventArgs e)
		=&gt; this._automodRuleUpdated.InvokeAsync(client, e);
	private Task Client_AutomodRuleDeleted(DiscordClient client, AutomodRuleDeleteEventArgs e)
		=&gt; this._automodRuleDeleted.InvokeAsync(client, e);
	private Task Client_AutomodActionExecuted(DiscordClient client, AutomodActionExecutedEventArgs e)
		=&gt; this._automodActionExecuted.InvokeAsync(client, e);
	private Task Client_GuildAuditLogEntryCreated(DiscordClient client, GuildAuditLogEntryCreateEventArgs e)
		=&gt; this._guildAuditLogEntryCreated.InvokeAsync(client, e);
	private Task Client_VoiceChannelStatusUpdated(DiscordClient client, VoiceChannelStatusUpdateEventArgs e)
		=&gt; this._voiceChannelStatusUpdated.InvokeAsync(client, e);
	private Task Client_MessagePollVoteAdded(DiscordClient client, MessagePollVoteAddEventArgs e)
		=&gt; this._messagePollVoteAdded.InvokeAsync(client, e);
	private Task Client_MessagePollVoteRemoved(DiscordClient client, MessagePollVoteRemoveEventArgs e)
		=&gt; this._messagePollVoteRemoved.InvokeAsync(client, e);
	private Task Client_SoundboardSoundCreated(DiscordClient client, GuildSoundboardSoundCreateEventArgs e)
		=&gt; this._guildSoundboardSoundCreated.InvokeAsync(client, e);
	private Task Client_SoundboardSoundUpdated(DiscordClient client, GuildSoundboardSoundUpdateEventArgs e)
		=&gt; this._guildSoundboardSoundUpdated.InvokeAsync(client, e);
	private Task Client_SoundboardSoundDeleted(DiscordClient client, GuildSoundboardSoundDeleteEventArgs e)
		=&gt; this._guildSoundboardSoundDeleted.InvokeAsync(client, e);
	private Task Client_SoundboardSoundsUpdated(DiscordClient client, GuildSoundboardSoundsUpdateEventArgs e)
		=&gt; this._guildSoundboardSoundsUpdated.InvokeAsync(client, e);
	private Task Client_SoundboardSounds(DiscordClient client, SoundboardSoundsEventArgs e)
		=&gt; this._soundboardSounds.InvokeAsync(client, e);
	private Task Client_GuildJoinRequestCreated(DiscordClient client, GuildJoinRequestCreateEventArgs e)
		=&gt; this._guildJoinRequestCreated.InvokeAsync(client, e);
	private Task Client_GuildJoinRequestUpdated(DiscordClient client, GuildJoinRequestUpdateEventArgs e)
		=&gt; this._guildJoinRequestUpdated.InvokeAsync(client, e);
	private Task Client_GuildJoinRequestDeleted(DiscordClient client, GuildJoinRequestDeleteEventArgs e)
		=&gt; this._guildJoinRequestDeleted.InvokeAsync(client, e);</file><file path="DisCatSharp/Clients/DiscordWebhookClient.cs">public class DiscordWebhookClient
	internal readonly DiscordApiClient ApiClient;
	internal readonly LogLevel MinimumLogLevel;
			loggerFactory = new DefaultLoggerFactory();
			loggerFactory.AddProvider(new DefaultLoggerProvider(this));
		var parsedTimeout = timeout ?? TimeSpan.FromSeconds(10);
	public async Task&lt;DiscordWebhook&gt; AddWebhookAsync(ulong id, string token)
		if (string.IsNullOrWhiteSpace(token))
			throw new ArgumentNullException(nameof(token));
		token = token.Trim();
		if (this.Hooks.Any(x =&gt; x.Id == id))
			throw new InvalidOperationException(&quot;This webhook is registered with this client.&quot;);
		var wh = await this.ApiClient.GetWebhookWithTokenAsync(id, token).ConfigureAwait(false);
		this.Hooks.Add(wh);
	public Task&lt;DiscordWebhook&gt; AddWebhookAsync(Uri url)
		ArgumentNullException.ThrowIfNull(url);
		var m = DiscordRegEx.WebhookRegex().Match(url.ToString());
			throw new ArgumentException(&quot;Invalid webhook URL supplied.&quot;, nameof(url));
		if (!ulong.TryParse(idRaw.Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var id))
		return this.AddWebhookAsync(id, token);
	public async Task&lt;DiscordWebhook&gt; AddWebhookAsync(ulong id, BaseDiscordClient client)
		ArgumentNullException.ThrowIfNull(client);
			throw new ArgumentException(&quot;This webhook is already registered with this client.&quot;);
		var wh = await client.ApiClient.GetWebhookAsync(id).ConfigureAwait(false);
	public DiscordWebhook AddWebhook(DiscordWebhook webhook)
		ArgumentNullException.ThrowIfNull(webhook);
		if (this.Hooks.Any(x =&gt; x.Id == webhook.Id))
		this.Hooks.Add(webhook);
	public DiscordWebhook RemoveWebhook(ulong id)
		if (this.Hooks.All(x =&gt; x.Id != id))
			throw new ArgumentException(&quot;This webhook is not registered with this client.&quot;);
		var wh = this.GetRegisteredWebhook(id);
		this.Hooks.Remove(wh!);
	public DiscordWebhook? GetRegisteredWebhook(ulong id)
		=&gt; this.Hooks.FirstOrDefault(xw =&gt; xw.Id == id);
	public async Task&lt;Dictionary&lt;DiscordWebhook, DiscordMessage&gt;&gt; BroadcastMessageAsync(DiscordWebhookBuilder builder)
					builder = builder.WithUsername(this.Username);
					builder = builder.WithAvatarUrl(this.AvatarUrl);
				messages.Add(hook, await hook.ExecuteAsync(builder).ConfigureAwait(false));
				deadHooks.Add(hook);
			this.Hooks.Remove(xwh);
		this.Hooks.Clear();
		this.ApiClient.Rest.Dispose();</file><file path="DisCatSharp/DisCatSharp.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp

			Your library to write discord bots in C# with a focus on always providing access to the latest discord features.
			Written with love and for everyone.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer.Roselyn&quot; Version=&quot;6.2.5&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;10.6.6&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Bcl.HashCode&quot; Version=&quot;6.0.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Console&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;NuGet.Protocol&quot; Version=&quot;6.13.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Octokit&quot; Version=&quot;14.0.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Sentry&quot; Version=&quot;5.2.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Sentry.Extensions.Logging&quot; Version=&quot;5.2.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.Http&quot; Version=&quot;4.3.4&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.WebSockets&quot; Version=&quot;4.3.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.WebSockets.Client&quot; Version=&quot;4.3.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Runtime.InteropServices.RuntimeInformation&quot; Version=&quot;4.3.0&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp/DisCatSharp.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp/DiscordConfiguration.cs">public sealed class DiscordConfiguration
	private UdpClientFactoryDelegate _udpClientFactory = DcsUdpClient.CreateNew;
	private WebSocketClientFactoryDelegate _webSocketClientFactory = WebSocketClient.CreateNew;
			if (string.IsNullOrWhiteSpace(value))
				throw new ArgumentNullException(nameof(value), &quot;Token cannot be null, empty, or all whitespace.&quot;);
			this._token = value.Trim();
	public TimeSpan HttpTimeout { internal get; set; } = TimeSpan.FromSeconds(20);
		set =&gt; this._webSocketClientFactory = value ?? throw new InvalidOperationException(&quot;You need to supply a valid WebSocket client factory method.&quot;);
		set =&gt; this._udpClientFactory = value ?? throw new InvalidOperationException(&quot;You need to supply a valid UDP client factory method.&quot;);
	public IServiceProvider ServiceProvider { internal get; init; } = new ServiceCollection().BuildServiceProvider(true);
				throw new AccessViolationException(&quot;Cannot set this as non-library-dev&quot;);
				this._exceptions.Clear();
				this._exceptions = value.All(val =&gt; val.BaseType == typeof(DisCatSharpException))
					: throw new InvalidOperationException(&quot;Can only track exceptions who inherit from &quot; + nameof(DisCatSharpException) + &quot; and must be constructed with typeof(Type)&quot;);</file><file path="DisCatSharp/Entities/Application/DiscordApplication.cs">public sealed class DiscordApplication : DiscordMessageApplication, IEquatable&lt;DiscordApplication&gt;
		this.RoleConnectionsVerificationUrl = tapp.RoleConnectionsVerificationUrl.ValueOrDefault();
					new DiscordUser(tapp.Owner)
				.Select(x =&gt; new DiscordTeamMember(x)
				.ToArray();
				.Where(x =&gt; x.MembershipStatus == DiscordTeamMembershipStatus.Accepted)
				.Select(x =&gt; x.User)
			this.Team.Owner = members.First(x =&gt; x.Role == &quot;owner&quot;).User;
		this.GuildId = tapp.GuildId.ValueOrDefault();
		this.Slug = tapp.Slug.ValueOrDefault();
		this.PrimarySkuId = tapp.PrimarySkuId.ValueOrDefault();
		this.VerifyKey = tapp.VerifyKey.ValueOrDefault();
		this.CoverImageHash = tapp.CoverImageHash.ValueOrDefault();
		this.Guild = tapp.Guild.ValueOrDefault();
		this.ApproximateGuildCount = tapp.ApproximateGuildCount.ValueOrDefault();
		this.ApproximateUserInstallCount = tapp.ApproximateUserInstallCount.ValueOrDefault();
		this.RequiresCodeGrant = tapp.BotRequiresCodeGrant.ValueOrDefault();
		this.IsPublic = tapp.IsPublicBot.ValueOrDefault();
		this.InteractionsEndpointUrl = tapp.InteractionsEndpointUrl.ValueOrDefault();
		this.RpcOrigins = tapp.RpcOrigins.AsReadOnly();
		this.InteractionsEventTypes = tapp.InteractionsEventTypes.AsReadOnly();
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash)
			? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=1024&quot;
		=&gt; !string.IsNullOrWhiteSpace(this.CoverImageHash)
			? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.CoverImageHash}.png?size=1024&quot;
	public bool Equals(DiscordApplication e)
	public string? GetAvatarUrl(MediaFormat fmt, ushort size = 1024)
			throw new ArgumentException(&quot;You must specify valid image format.&quot;, nameof(fmt));
			throw new ArgumentOutOfRangeException(nameof(size));
		var log = Math.Log(size, 2);
			_ =&gt; throw new ArgumentOutOfRangeException(nameof(fmt))
		var ssize = size.ToString(CultureInfo.InvariantCulture);
		return !string.IsNullOrWhiteSpace(this.CoverImageHash)
			? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{sfmt}?size={ssize}&quot;
	public async Task&lt;IReadOnlyList&lt;DiscordApplicationAsset&gt;&gt; GetAssetsAsync()
		this._assets ??= await this.Discord.ApiClient.GetApplicationAssetsAsync(this).ConfigureAwait(false);
	public string GenerateBotOAuth(Permissions permissions = Permissions.None)
		return new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
			.AddParameter(&quot;client_id&quot;, this.Id.ToString(CultureInfo.InvariantCulture))
			.AddParameter(&quot;scope&quot;, &quot;bot&quot;)
			.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
			.ToString();
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordApplication);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
public abstract class DiscordAsset
public sealed class DiscordApplicationAsset : DiscordAsset, IEquatable&lt;DiscordApplicationAsset&gt;
		=&gt; new($&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ASSETS}/{this.Application.Id.ToString(CultureInfo.InvariantCulture)}/{this.Id}.png&quot;);
	public bool Equals(DiscordApplicationAsset e)
		=&gt; this.Equals(obj as DiscordApplicationAsset);
public sealed class DiscordSpotifyAsset : DiscordAsset
			var ids = this.Id.Split(&apos;:&apos;);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommand.cs">public class DiscordApplicationCommand : SnowflakeObject, IEquatable&lt;DiscordApplicationCommand&gt;
			if (!Utilities.IsValidSlashCommandName(name))
				throw new ArgumentException($&quot;Invalid slash command name specified. It must be below 32 characters and not contain any whitespace. Error for command {name}.&quot;, nameof(name));
			if (name.Any(char.IsUpper))
				throw new ArgumentException($&quot;Slash command name cannot have any upper case characters. Error for command {name}.&quot;, nameof(name));
				throw new ArgumentException($&quot;Slash command description cannot exceed 100 characters. Error for command {name}.&quot;, nameof(description));
			if (string.IsNullOrWhiteSpace(description))
				throw new ArgumentException($&quot;Slash commands need a description. Error for command {name}.&quot;, nameof(description));
			this.Options = options != null &amp;&amp; options.Any() ? options.ToList() : null;
				throw new ArgumentException($&quot;Primary entrypoints do not support options. Error for command {name}.&quot;);
			if (!string.IsNullOrWhiteSpace(description))
				throw new ArgumentException($&quot;Context menus do not support descriptions. Error for command {name}.&quot;);
				throw new ArgumentException($&quot;Context menus do not support options. Error for command {name}.&quot;);
	public bool Equals(DiscordApplicationCommand other)
		=&gt; e1.Equals(e2);
	public override bool Equals(object other)
		=&gt; other is DiscordApplicationCommand dac &amp;&amp; this.Equals(dac);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandAutocompleteChoice.cs">public sealed class DiscordApplicationCommandAutocompleteChoice
			throw new ArgumentException(&quot;Application command choice name cannot exceed 100 characters.&quot;, nameof(name));
			throw new ArgumentException(&quot;Application command choice value cannot exceed 100 characters.&quot;, nameof(value));
			throw new InvalidOperationException($&quot;Only {typeof(string)}, {typeof(long)}, {typeof(double)} or {typeof(int)} types may be passed to a autocomplete choice.&quot;);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandLocalization.cs">public sealed class DiscordApplicationCommandLocalization
		foreach (var locale in localizations.Keys.Where(locale =&gt; !this.Validate(locale)))
			throw new NotSupportedException($&quot;The provided locale \&quot;{locale}\&quot; is not valid for Discord.\n&quot; +
			                                $&quot;Valid locales: {string.Join(&quot;, &quot;, this.ValidLocales)}&quot;);
	public void AddLocalization(string locale, string value)
		if (this.Validate(locale))
			this.Localizations.Add(locale, value);
	public void RemoveLocalization(string locale)
		=&gt; this.Localizations.Remove(locale);
	public Dictionary&lt;string, string&gt; GetKeyValuePairs()
	public bool Validate(string lang)
		=&gt; this.ValidLocales.Contains(lang);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandOption.cs">public class DiscordApplicationCommandOption
		if (!Utilities.IsValidSlashCommandName(name))
			throw new ArgumentException(&quot;Invalid application command option name specified. It must be below 32 characters and not contain any whitespace.&quot;, nameof(name));
		if (name.Any(char.IsUpper))
			throw new ArgumentException(&quot;Application command option name cannot have any upper case characters.&quot;, nameof(name));
			throw new ArgumentException(&quot;Application command option description cannot exceed 100 characters.&quot;, nameof(description));
			throw new InvalidOperationException(&quot;Auto-complete slash command options cannot provide choices.&quot;);
			if (string.IsNullOrWhiteSpace(description))
				throw new ArgumentException(&quot;Slash commands need a description.&quot;, nameof(description));
		this.Choices = choices is not null &amp;&amp; choices.Any() ? choices.ToList() : null;
		this.Options = options is not null &amp;&amp; options.Any() ? options.ToList() : null;
		this.ChannelTypes = channelTypes is not null &amp;&amp; channelTypes.Any() ? channelTypes.ToList() : null;</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandOptionChoice.cs">public sealed class DiscordApplicationCommandOptionChoice
			throw new InvalidOperationException($&quot;Only {typeof(string)}, {typeof(long)}, {typeof(double)} or {typeof(int)} types may be passed to a command option choice.&quot;);
			throw new ArgumentException(&quot;Application command choice name cannot exceed 100 characters.&quot;, nameof(name));
			throw new ArgumentException(&quot;Application command choice value cannot exceed 100 characters.&quot;, nameof(value));</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandPermission.cs">public sealed class DiscordApplicationCommandPermission : SnowflakeObject, IEquatable&lt;DiscordApplicationCommandPermission&gt;
	public bool Equals(DiscordApplicationCommandPermission other)
		=&gt; e1.Equals(e2);
	public override bool Equals(object other) =&gt; other is DiscordApplicationCommandPermission dacp &amp;&amp; this.Equals(dacp);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordApplicationEmoji.cs">public sealed class DiscordApplicationEmoji : DiscordEmoji
	public Task&lt;DiscordApplicationEmoji&gt; ModifyAsync(string name)
		=&gt; this.Discord.ApiClient.ModifyApplicationEmojiAsync(this.Discord.CurrentApplication.Id, this.Id, name);
	public Task DeleteAsync()
		=&gt; this.Discord.ApiClient.DeleteApplicationEmojiAsync(this.Discord.CurrentApplication.Id, this.Id);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationInstallParams.cs">public sealed class DiscordApplicationInstallParams : ObservableApiObject</file><file path="DisCatSharp/Entities/Application/DiscordApplicationIntegrationTypeConfiguration.cs">public sealed class DiscordApplicationIntegrationTypeConfiguration : ObservableApiObject</file><file path="DisCatSharp/Entities/Application/DiscordApplicationRoleConnectionMetadata.cs">public sealed class DiscordApplicationRoleConnectionMetadata : ObservableApiObject, IEquatable&lt;DiscordApplicationRoleConnectionMetadata&gt;
	public bool Equals(DiscordApplicationRoleConnectionMetadata other)
		=&gt; e1.Equals(e2);
	public override bool Equals(object other)
		=&gt; other is DiscordApplicationRoleConnectionMetadata dac &amp;&amp; this.Equals(dac);
	public override int GetHashCode()
		=&gt; this.Key.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordGuildApplicationCommandPermission.cs">public sealed class DiscordGuildApplicationCommandPermission : SnowflakeObject, IEquatable&lt;DiscordGuildApplicationCommandPermission&gt;
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
	public bool Equals(DiscordGuildApplicationCommandPermission other)
		=&gt; e1.Equals(e2);
	public override bool Equals(object other) =&gt; other is DiscordGuildApplicationCommandPermission dgacp &amp;&amp; this.Equals(dgacp);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordIntegrationTypesConfig.cs">public sealed class DiscordIntegrationTypesConfig</file><file path="DisCatSharp/Entities/Application/DiscordOAuth2InstallParams.cs">public sealed class DiscordOAuth2InstallParams</file><file path="DisCatSharp/Entities/Application/DiscordRpcApplication.cs">public sealed class DiscordRpcApplication : SnowflakeObject, IEquatable&lt;DiscordRpcApplication&gt;
	public ApplicationFlags Flags;
	public DiscordApplicationInstallParams InstallParams;
	public bool Equals(DiscordRpcApplication e)
	public string GenerateBotOAuth(Permissions permissions = Permissions.None)
		return new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
			.AddParameter(&quot;client_id&quot;, this.Id.ToString(CultureInfo.InvariantCulture))
			.AddParameter(&quot;scope&quot;, &quot;bot&quot;)
			.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
			.ToString();
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordRpcApplication);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Channel/ChannelTypeExtensions.cs">public static class ChannelTypeExtensions
	public static bool IsCallable(this ChannelType type)
		=&gt; s_callable.Contains((int)type);
	public static bool IsTextual(this ChannelType type)
		=&gt; s_textual.Contains((int)type);
	public static bool IsGuildThreadsOnly(this ChannelType type)
		=&gt; s_guildThreadsOnly.Contains((int)type);
	public static bool IsStickers(this ChannelType type)
		=&gt; s_stickers.Contains((int)type);
	public static bool IsReadable(this ChannelType type)
		=&gt; s_readable.Contains((int)type);
	public static bool IsGuild(this ChannelType type)
		=&gt; s_guild.Contains((int)type);
	public static bool IsThreads(this ChannelType type)
		=&gt; s_threads.Contains((int)type);
	public static bool IsPublicThreads(this ChannelType type)
		=&gt; s_publicThreads.Contains((int)type);
	public static bool IsGuildThreaded(this ChannelType type)
		=&gt; s_guildThreaded.Contains((int)type);
	public static bool IsGuildStored(this ChannelType type)
		=&gt; s_guildStored.Contains((int)type);
	public static bool IsGuildTextual(this ChannelType type)
		=&gt; s_guildTextual.Contains((int)type);
	public static bool IsGuildVocal(this ChannelType type)
		=&gt; s_guildVocal.Contains((int)type);
	public static bool IsVocalThread(this ChannelType type)
		=&gt; s_vocalThread.Contains((int)type);
	public static bool IsVocal(this ChannelType type)
		=&gt; s_vocal.Contains((int)type);
	public static bool IsVoiceEffects(this ChannelType type)
		=&gt; s_voiceEffects.Contains((int)type);
	public static bool IsGuildTextOnly(this ChannelType type)
		=&gt; s_guildTextOnly.Contains((int)type);
	public static bool IsLimitedChannelName(this ChannelType type)
		=&gt; s_limitedChannelName.Contains((int)type);
	public static bool IsSearchable(this ChannelType type)
		=&gt; s_searchable.Contains((int)type);
	public static bool IsGuildUserContent(this ChannelType type)
		=&gt; s_guildUserContent.Contains((int)type);
	public static bool IsGuildTopical(this ChannelType type)
		=&gt; s_guildTopical.Contains((int)type);
	public static bool IsGuildWebhooks(this ChannelType type)
		=&gt; s_guildWebhooks.Contains((int)type);
	public static bool IsGuildSystemChannel(this ChannelType type)
		=&gt; s_guildSystemChannel.Contains((int)type);
	public static bool IsGuildParentable(this ChannelType type)
		=&gt; s_guildParentable.Contains((int)type);
	public static bool IsGuildAutoModerated(this ChannelType type)
		=&gt; s_guildAutoModerated.Contains((int)type);
	public static bool IsGuildBasic(this ChannelType type)
		=&gt; s_guildBasic.Contains((int)type);
	public static bool IsCreateableGuildChannels(this ChannelType type)
		=&gt; s_createableGuildChannels.Contains((int)type);
	public static bool IsMultiUserDms(this ChannelType type)
		=&gt; s_multiUserDms.Contains((int)type);
	public static bool IsAllDms(this ChannelType type)
		=&gt; s_allDms.Contains((int)type);
	public static bool IsInvitable(this ChannelType type)
		=&gt; s_invitable.Contains((int)type);
	public static bool IsGuildFeedFeaturableMessages(this ChannelType type)
		=&gt; s_guildFeedFeaturableMessages.Contains((int)type);
	public static bool IsRoleSubscriptions(this ChannelType type)
		=&gt; s_roleSubscriptions.Contains((int)type);
	public static bool IsIconEmojis(this ChannelType type)
		=&gt; s_iconEmojis.Contains((int)type);
	public static bool IsSummarizeable(this ChannelType type)
		=&gt; s_summarizeable.Contains((int)type);
	public static bool IsContentEntryEmbeds(this ChannelType type) =&gt; s_contentEntryEmbeds.Contains((int)type);
	public static bool IsPolls(this ChannelType type)
		=&gt; s_polls.Contains((int)type);
	public static bool IsActivityLaunchable(this ChannelType type)
		=&gt; s_activityLaunchable.Contains((int)type);
	public static bool IsAll(this ChannelType type)
		=&gt; s_all.Contains((int)type);</file><file path="DisCatSharp/Entities/Channel/DiscordChannel.cs">public class DiscordChannel : SnowflakeObject, IEquatable&lt;DiscordChannel&gt;
		=&gt; this.ParentId.HasValue ? this.Guild.GetChannel(this.ParentId.Value) : null;
		=&gt; this.ThemeColorInt.HasValue ? new DiscordColor(this.ThemeColorInt.Value) : null;
		=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
		=&gt; !string.IsNullOrWhiteSpace(this.LastPinTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.LastPinTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; this.Mention();
			? throw new ArgumentException(&quot;Only channel categories contain children.&quot;)
			: this.Guild.ChannelsInternal.Values.Where(e =&gt; e.ParentId == this.Id).ToList();
			? throw new InvalidOperationException(&quot;Cannot query users outside of guild channels.&quot;)
			: this.IsVoiceJoinable()
				? this.Guild.Members.Values.Where(x =&gt; x.VoiceState?.ChannelId == this.Id).ToList()
				: this.Guild.Members.Values.Where(x =&gt; (this.PermissionsFor(x) &amp; Permissions.AccessChannels) == Permissions.AccessChannels).ToList();
	public bool Equals(DiscordChannel e)
	public int GetMaxPosition()
				? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News)).OrderBy(xc =&gt; xc.Position).Last().Position
					? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage)).OrderBy(xc =&gt; xc.Position).Last().Position
					: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).Last().Position
			: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).Last().Position;
	public int GetMinPosition()
				? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News)).OrderBy(xc =&gt; xc.Position).First().Position
					? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage)).OrderBy(xc =&gt; xc.Position).First().Position
					: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).First().Position
			: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).First().Position;
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordChannel);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public Task&lt;DiscordMessage&gt; SendMessageAsync(string content) =&gt;
		!this.IsWritable()
			? throw new ArgumentException(&quot;Cannot send a text message to a non-text channel.&quot;)
			: this.Discord.ApiClient.CreateMessageAsync(this.Id, content, null, null, null, false, false);
	public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordEmbed embed) =&gt;
			: this.Discord.ApiClient.CreateMessageAsync(this.Id, null, embed != null
		Task&lt;DiscordMessage&gt; SendMessageAsync(string content, DiscordEmbed embed) =&gt;
			: this.Discord.ApiClient.CreateMessageAsync(this.Id, content, embed != null
		Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordMessageBuilder builder)
		=&gt; this.Discord.ApiClient.CreateMessageAsync(this.Id, builder);
	public Task&lt;DiscordMessage&gt; SendMessageAsync(Action&lt;DiscordMessageBuilder&gt; action)
		var builder = new DiscordMessageBuilder();
		return !this.IsWritable()
			: this.Discord.ApiClient.CreateMessageAsync(this.Id, builder);
	public Task SendSoundboardSoundAsync(ulong soundId, ulong? sourceGuildId = null)
			? throw new ArgumentException(&quot;Cannot send a soundboard sound to a non-voice channel.&quot;)
			: this.Discord.ApiClient.SendSoundboardSoundAsync(this.Id, soundId, sourceGuildId);
	public Task DeleteAsync(string reason = null)
		=&gt; this.Discord.ApiClient.DeleteChannelAsync(this.Id, reason);
	public async Task&lt;DiscordChannel&gt; CloneAsync(string reason = null)
			throw new InvalidOperationException(&quot;Non-guild channels cannot be cloned.&quot;);
			ovrs.Add(new(ovr));
		if (!this.IsVoiceJoinable())
		if (!this.IsWritable())
		return await this.Guild.CreateChannelAsync(this.Name, this.Type, this.Parent, this.Topic, bitrate, userLimit, ovrs, this.IsNsfw, perUserRateLimit, this.QualityMode, this.DefaultAutoArchiveDuration, this.Flags, reason).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; GetMessageAsync(ulong id, bool fetch = false) =&gt;
		&amp;&amp; dc.MessageCache.TryGet(xm =&gt; xm.Id == id &amp;&amp; xm.ChannelId == this.Id, out var msg)
			: await this.Discord.ApiClient.GetMessageAsync(this.Id, id).ConfigureAwait(false);
	public async Task&lt;DiscordMessage?&gt; TryGetMessageAsync(ulong id, bool fetch = true)
			return await this.GetMessageAsync(id, fetch).ConfigureAwait(false);
	public Task ModifyAsync(Action&lt;ChannelEditModel&gt; action)
			throw new NotSupportedException(&quot;Cannot execute this request on a forum channel.&quot;);
		var mdl = new ChannelEditModel();
		return this.Discord.ApiClient.ModifyChannelAsync(this.Id, mdl.Name, mdl.Position, mdl.Topic, mdl.Nsfw,
			mdl.Parent.Map(p =&gt; p?.Id), mdl.Bitrate, mdl.UserLimit, mdl.PerUserRateLimit, mdl.RtcRegion.Map(r =&gt; r?.Id),
	public Task ModifyForumAsync(Action&lt;ForumChannelEditModel&gt; action)
			throw new NotSupportedException(&quot;Cannot execute this request on a non-forum channel.&quot;);
		var mdl = new ForumChannelEditModel();
			? throw new NotSupportedException(&quot;Cannot have more than 20 tags in a forum channel.&quot;)
			: (Task)this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, mdl.Name, mdl.Position, mdl.Topic, mdl.Template, mdl.Nsfw,
				mdl.Parent.Map(p =&gt; p?.Id), mdl.AvailableTags, mdl.DefaultReactionEmoji, mdl.PerUserRateLimit, mdl.PostCreateUserRateLimit,
	public Task ModifyPositionAsync(int position, string reason = null)
			throw new ArgumentException(&quot;Cannot modify order of non-guild channels.&quot;);
		if (!this.IsMovable())
			throw new NotSupportedException(&quot;You can&apos;t move this type of channel in categories.&quot;);
			throw new ArgumentException(&quot;Cannot modify order of channels within a category. Use ModifyPositionInCategoryAsync instead.&quot;);
		var pmds = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position)
			.Select(x =&gt; new RestGuildChannelReorderPayload
		return this.Discord.ApiClient.ModifyGuildChannelPositionAsync(this.Guild.Id, pmds, reason);
	public async Task ModifyPositionInCategoryAsync(int position, string reason = null)
		if (!this.IsMovableInParent())
		var channels = await this.InternalRefreshChannelsAsync().ConfigureAwait(false);
				? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News))
					? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage))
					: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type)
				? channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News))
					? channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage))
					: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type);
		var ochns = chns.OrderBy(xc =&gt; xc.Position).ToArray();
		var min = ochns.First().Position;
		var max = ochns.Last().Position;
			throw new IndexOutOfRangeException($&quot;Position is not in range. {position} is {(position &gt; max ? &quot;greater then the maximal&quot; : &quot;lower then the minimal&quot;)} position.&quot;);
		var pmds = ochns.Select(x =&gt;
			new RestGuildChannelReorderPayload
		await this.Discord.ApiClient.ModifyGuildChannelPositionAsync(this.Guild.Id, pmds, reason).ConfigureAwait(false);
	private async Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; InternalRefreshChannelsAsync()
		await this.RefreshPositionsAsync().ConfigureAwait(false);
		return this.Guild.Channels.Values.ToList().AsReadOnly();
	internal void Initialize(BaseDiscordClient client)
	public async Task RefreshPositionsAsync()
		var channels = await this.Discord.ApiClient.GetGuildChannelsAsync(this.Guild.Id).ConfigureAwait(false);
		this.Guild.ChannelsInternal.Clear();
		foreach (var channel in channels.ToList())
			channel.Initialize(this.Discord);
	public Task ModifyPositionInCategorySmartAsync(string mode, int position, string reason = null)
			throw new ArgumentException(&quot;Error with the selected mode: Valid is &apos;+&apos; or &apos;down&apos; to move a channel down and &apos;-&apos; or &apos;up&apos; to move a channel up&quot;);
			? position &lt; this.GetMaxPosition()
				? this.ModifyPositionInCategoryAsync(this.Position + position, reason)
				: throw new IndexOutOfRangeException(&quot;Position is not in range of category.&quot;)
				? position &gt; this.GetMinPosition()
					? this.ModifyPositionInCategoryAsync(this.Position - position, reason)
				: throw new ArgumentException(&quot;You can only modify with +X or -X. 0 is not valid.&quot;);
	public Task ModifyParentAsync(DiscordChannel newParent, bool? lockPermissions = null, string reason = null)
			throw new ArgumentException(&quot;Cannot modify parent of non-guild channels.&quot;);
			throw new ArgumentException(&quot;Only category type channels can be parents.&quot;);
		var position = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type &amp;&amp; xc.ParentId == newParent.Id) // gets list same type channels in parent
			.Select(xc =&gt; xc.Position).DefaultIfEmpty(-1).Max() + 1; // returns highest position of list +1, default val: 0
		var pmds = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type)
			.OrderBy(xc =&gt; xc.Position)
			.Select(x =&gt;
				var pmd = new RestGuildChannelNewParentPayload
		return this.Discord.ApiClient.ModifyGuildChannelParentAsync(this.Guild.Id, pmds, reason);
	public Task RemoveParentAsync(string reason = null)
				var pmd = new RestGuildChannelNoParentPayload
		return this.Discord.ApiClient.DetachGuildChannelParentAsync(this.Guild.Id, pmds, reason);
	public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesBeforeAsync(ulong before, int limit = 100)
		=&gt; this.GetMessagesInternalAsync(limit, before);
	public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAfterAsync(ulong after, int limit = 100)
		=&gt; this.GetMessagesInternalAsync(limit, null, after);
	public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAroundAsync(ulong around, int limit = 100)
		=&gt; this.GetMessagesInternalAsync(limit, null, null, around);
	public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAsync(int limit = 100) =&gt;
		this.GetMessagesInternalAsync(limit);
	private async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesInternalAsync(int limit = 100, ulong? before = null, ulong? after = null, ulong? around = null)
			throw new ArgumentException(&quot;Cannot get the messages of a non-text channel.&quot;);
			throw new ArgumentException(&quot;Cannot get a negative number of messages.&quot;);
			throw new InvalidOperationException(&quot;Cannot get more than 100 messages around the specified ID.&quot;);
			var fetch = await this.Discord.ApiClient.GetChannelMessagesAsync(this.Id, fetchSize, !isAfter ? last ?? before : null, isAfter ? last ?? after : null, around).ConfigureAwait(false);
				msgs.AddRange(fetch);
				last = fetch.LastOrDefault()?.Id;
				msgs.InsertRange(0, fetch);
				last = fetch.FirstOrDefault()?.Id;
	public async Task DeleteMessagesAsync(IEnumerable&lt;DiscordMessage&gt; messages, string reason = null)
		var msgs = messages.Where(x =&gt; x.Channel.Id == this.Id).Select(x =&gt; x.Id).ToArray();
		if (messages == null || !msgs.Any())
			throw new ArgumentException(&quot;You need to specify at least one message to delete.&quot;);
			await this.Discord.ApiClient.DeleteMessageAsync(this.Id, msgs.Single(), reason).ConfigureAwait(false);
			await this.Discord.ApiClient.DeleteMessagesAsync(this.Id, msgs.Skip(i).Take(100), reason).ConfigureAwait(false);
	public Task DeleteMessageAsync(DiscordMessage message, string reason = null)
		=&gt; this.Discord.ApiClient.DeleteMessageAsync(this.Id, message.Id, reason);
	public Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetInvitesAsync() =&gt;
			? throw new ArgumentException(&quot;Cannot get the invites of a channel that does not belong to a guild.&quot;)
			: this.Discord.ApiClient.GetChannelInvitesAsync(this.Id);
	public Task&lt;DiscordInvite&gt; CreateInviteAsync(int maxAge = 86400, int maxUses = 0, bool temporary = false, bool unique = false, TargetType? targetType = null, ulong? targetApplicationId = null, ulong? targetUser = null, string reason = null)
		=&gt; this.Discord.ApiClient.CreateChannelInviteAsync(this.Id, maxAge, maxUses, targetType, targetApplicationId, targetUser, temporary, unique, reason);
	public Task SetVoiceChannelStatusAsync(string status)
		=&gt; this.Type != ChannelType.Voice ? throw new NotSupportedException(&quot;Cannot execute this request on a non-voice channel.&quot;) : this.Discord.ApiClient.ModifyVoiceChannelStatusAsync(this.Id, status);
	public Task RemoveVoiceChannelStatusAsync(string reason = null)
		=&gt; this.Type != ChannelType.Voice ? throw new NotSupportedException(&quot;Cannot execute this request on a non-voice channel.&quot;) : this.Discord.ApiClient.ModifyVoiceChannelStatusAsync(this.Id, null);
	public async Task&lt;DiscordStageInstance&gt; OpenStageAsync(string topic, bool sendStartNotification = false, ulong? scheduledEventId = null, string reason = null)
		=&gt; await this.Discord.ApiClient.CreateStageInstanceAsync(this.Id, topic, sendStartNotification, scheduledEventId, reason).ConfigureAwait(false);
	public async Task ModifyStageAsync(Optional&lt;string&gt; topic, string reason = null)
		=&gt; await this.Discord.ApiClient.ModifyStageInstanceAsync(this.Id, topic, reason).ConfigureAwait(false);
	public async Task CloseStageAsync(string reason = null)
		=&gt; await this.Discord.ApiClient.DeleteStageInstanceAsync(this.Id, reason).ConfigureAwait(false);
	public async Task&lt;DiscordStageInstance&gt; GetStageAsync()
		=&gt; await this.Discord.ApiClient.GetStageInstanceAsync(this.Id).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; CreateScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, string description = null, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
			throw new NotSupportedException(&quot;Cannot create a scheduled event for this type of channel. Channel type must be either voice or stage.&quot;);
		return await this.Guild.CreateScheduledEventAsync(name, scheduledStartTime, null, this, null, description, type, coverImage, recurrenceRule, reason).ConfigureAwait(false);
	public async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(string name, ThreadAutoArchiveDuration autoArchiveDuration = ThreadAutoArchiveDuration.OneHour, ChannelType type = ChannelType.PublicThread, int? rateLimitPerUser = null, string reason = null) =&gt;
			? throw new NotSupportedException(&quot;Wrong thread type given.&quot;)
			: !this.IsThreadHolder()
				? throw new NotSupportedException(&quot;Parent channel can&apos;t have threads.&quot;)
				: await this.Discord.ApiClient.CreateThreadAsync(this.Id, null, name, autoArchiveDuration, this.Type == ChannelType.News
						: ChannelType.PublicThread, rateLimitPerUser, isForum: false, reason: reason).ConfigureAwait(false);
	public async Task&lt;DiscordThreadChannel&gt; CreatePostAsync(string name, DiscordMessageBuilder builder, int? rateLimitPerUser = null, IEnumerable&lt;ForumPostTag&gt;? tags = null, string reason = null)
		=&gt; this.Type != ChannelType.Forum ? throw new NotSupportedException(&quot;Parent channel must be forum.&quot;) : await this.Discord.ApiClient.CreateThreadAsync(this.Id, null, name, null, null, rateLimitPerUser, tags, builder, true, reason).ConfigureAwait(false);
	public async Task&lt;DiscordThreadResult&gt; GetJoinedPrivateArchivedThreadsAsync(ulong? before, int? limit)
		=&gt; await this.Discord.ApiClient.GetJoinedPrivateArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
	public async Task&lt;DiscordThreadResult&gt; GetPublicArchivedThreadsAsync(ulong? before, int? limit)
		=&gt; await this.Discord.ApiClient.GetPublicArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
	public async Task&lt;DiscordThreadResult&gt; GetPrivateArchivedThreadsAsync(ulong? before, int? limit)
		=&gt; await this.Discord.ApiClient.GetPrivateArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
	public ForumPostTag GetForumPostTag(ulong id)
		var tag = this.InternalAvailableTags.First(x =&gt; x.Id == id);
	public ForumPostTag? TryGetForumPostTag(ulong id)
		var tag = this.InternalAvailableTags.FirstOrDefault(x =&gt; x.Id == id);
	public async Task&lt;DiscordChannel&gt; CreateForumPostTagAsync(string name, DiscordEmoji emoji = null, bool moderated = false, string reason = null)
			? throw new NotSupportedException(&quot;Channel needs to be type of Forum&quot;)
				: await this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, null, null, Optional.None, Optional.None, null, Optional.None, this.InternalAvailableTags.Append(new()
				}).ToList(), Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, null, Optional.None, reason).ConfigureAwait(false);
	public async Task&lt;DiscordChannel&gt; DeleteForumPostTag(ulong id, string reason = null)
		=&gt; this.Type != ChannelType.Forum ? throw new NotSupportedException(&quot;Channel needs to be type of Forum&quot;) : await this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, null, null, Optional.None, Optional.None, null, Optional.None, this.InternalAvailableTags?.Where(x =&gt; x.Id != id)?.ToList(), Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, null, Optional.None, reason).ConfigureAwait(false);
	public Task AddOverwriteAsync(DiscordRole role, Permissions allow = Permissions.None, Permissions deny = Permissions.None, string reason = null)
		=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.Id, role.Id, allow, deny, &quot;role&quot;, reason);
	public Task AddOverwriteAsync(DiscordMember member, Permissions allow = Permissions.None, Permissions deny = Permissions.None, string reason = null)
		=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.Id, member.Id, allow, deny, &quot;member&quot;, reason);
	public Task DeleteOverwriteAsync(DiscordMember member, string reason = null)
		=&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.Id, member.Id, reason);
	public Task DeleteOverwriteAsync(DiscordRole role, string reason = null)
		=&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.Id, role.Id, reason);
	public Task TriggerTypingAsync() =&gt;
			? throw new ArgumentException(&quot;Cannot start typing in a non-text channel.&quot;)
			: this.Discord.ApiClient.TriggerTypingAsync(this.Id);
	public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetPinnedMessagesAsync() =&gt;
			? throw new ArgumentException(&quot;A non-text channel does not have pinned messages.&quot;)
			: this.Discord.ApiClient.GetPinnedMessagesAsync(this.Id);
	public async Task&lt;DiscordWebhook&gt; CreateWebhookAsync(string name, Optional&lt;Stream&gt; avatar = default, string reason = null)
		=&gt; await this.Discord.ApiClient.CreateWebhookAsync(this.IsThread() ? this.ParentId!.Value : this.Id, name,
			MediaTool.Base64FromStream(avatar), reason).ConfigureAwait(false);
	public Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetWebhooksAsync()
		=&gt; this.Discord.ApiClient.GetChannelWebhooksAsync(this.IsThread() ? this.ParentId!.Value : this.Id);
	public async Task PlaceMemberAsync(DiscordMember member)
			throw new ArgumentException(&quot;Cannot place a member in a non-voice channel.&quot;);
		await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, member.Id, default, default, default,
			default, this.Id, default, member.MemberFlags, null).ConfigureAwait(false);
	public Task&lt;DiscordFollowedChannel&gt; FollowAsync(DiscordChannel targetChannel) =&gt;
			? throw new ArgumentException(&quot;Cannot follow a non-news channel.&quot;)
			: this.Discord.ApiClient.FollowChannelAsync(this.Id, targetChannel.Id);
	public Task&lt;DiscordMessage&gt; CrosspostMessageAsync(DiscordMessage message) =&gt;
			? throw new ArgumentException(&quot;Message is already crossposted.&quot;)
			: this.Discord.ApiClient.CrosspostMessageAsync(this.Id, message.Id);
	public async Task UpdateCurrentUserVoiceStateAsync(bool? suppress, DateTimeOffset? requestToSpeakTimestamp = null)
			throw new ArgumentException(&quot;Voice state can only be updated in a stage channel.&quot;);
		await this.Discord.ApiClient.UpdateCurrentUserVoiceStateAsync(this.GuildId.Value, this.Id, suppress, requestToSpeakTimestamp).ConfigureAwait(false);
	public Permissions PermissionsFor(DiscordMember mbr)
		Permissions perms;
		var mbRoles = mbr.Roles.Where(xr =&gt; xr.Id != everyoneRole.Id);
		perms |= mbRoles.Aggregate(Permissions.None, (c, role) =&gt; c | role.Permissions);
			.Select(xr =&gt; this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == xr.Id))
			.Where(xo =&gt; xo != null)
			.ToList();
		var everyoneOverwrites = this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == everyoneRole.Id);
		perms &amp;= ~mbRoleOverrides.Aggregate(Permissions.None, (c, overs) =&gt; c | overs.Denied);
		perms |= mbRoleOverrides.Aggregate(Permissions.None, (c, overs) =&gt; c | overs.Allowed);
		var mbOverrides = this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == mbr.Id);
	public override string ToString() =&gt;
			: this.Type == ChannelType.Text || this.Type == ChannelType.News || this.IsThread()
					: !string.IsNullOrWhiteSpace(this.Name)</file><file path="DisCatSharp/Entities/Channel/DiscordDmChannel.cs">public class DiscordDmChannel : DiscordChannel
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CHANNEL_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png&quot; : null;
	public Task AddDmRecipientAsync(ulong userId, string accessToken, string nickname)
		=&gt; this.Discord.ApiClient.AddGroupDmRecipientAsync(this.Id, userId, accessToken, nickname);
	public Task RemoveDmRecipientAsync(ulong userId, string accessToken)
		=&gt; this.Discord.ApiClient.RemoveGroupDmRecipientAsync(this.Id, userId);</file><file path="DisCatSharp/Entities/Channel/DiscordFollowedChannel.cs">public class DiscordFollowedChannel : ObservableApiObject</file><file path="DisCatSharp/Entities/Channel/DiscordGuildDirectoryChannel.cs">public class DiscordGuildDirectoryChannel : DiscordChannel, IEquatable&lt;DiscordGuildDirectoryChannel&gt;
		this.Guild.ChannelsInternal.Values.Where(e =&gt; e.ParentId == this.Id).Select(x =&gt; x as DiscordGuildDirectoryEntry).ToList();
	public bool Equals(DiscordGuildDirectoryChannel e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordGuildDirectoryChannel);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Channel/DiscordGuildDirectoryEntry.cs">public class DiscordGuildDirectoryEntry : DiscordChannel, IEquatable&lt;DiscordGuildDirectoryEntry&gt;
	public bool Equals(DiscordGuildDirectoryEntry e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordGuildDirectoryEntry);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Channel/Overwrite/DiscordOverwrite.cs">public class DiscordOverwrite : SnowflakeObject
	public PermissionLevel CheckPermission(Permissions permission) =&gt;
	public Task DeleteAsync(string reason = null) =&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.ChannelId, this.Id, reason);
	public Task UpdateAsync(Permissions? allow = null, Permissions? deny = null, string reason = null)
		=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.ChannelId, this.Id, allow ?? this.Allowed, deny ?? this.Denied, this.Type.ToString().ToLowerInvariant(), reason);
	public async Task&lt;DiscordMember&gt; GetMemberAsync() =&gt;
			? throw new ArgumentException(nameof(this.Type), &quot;This overwrite is for a role, not a member.&quot;)
			: await (await this.Discord.ApiClient.GetChannelAsync(this.ChannelId).ConfigureAwait(false)).Guild.GetMemberAsync(this.Id).ConfigureAwait(false);
	public async Task&lt;DiscordRole&gt; GetRoleAsync() =&gt;
			? throw new ArgumentException(nameof(this.Type), &quot;This overwrite is for a member, not a role.&quot;)
			: (await this.Discord.ApiClient.GetChannelAsync(this.ChannelId).ConfigureAwait(false)).Guild.GetRole(this.Id);
	public DiscordOverwriteBuilder ConvertToBuilder()</file><file path="DisCatSharp/Entities/Channel/Overwrite/DiscordOverwriteBuilder.cs">public sealed class DiscordOverwriteBuilder
		set =&gt; this.Remove(value);
	public DiscordOverwriteBuilder Allow(Permissions permission)
		this.Remove(permission);
	public DiscordOverwriteBuilder Deny(Permissions permission)
	public DiscordOverwriteBuilder Remove(Permissions permission)
		this.Allowed = this.Allowed.Revoke(permission);
		this.Denied = this.Denied.Revoke(permission);
	public DiscordOverwriteBuilder SetTarget(DiscordMember member)
	public DiscordOverwriteBuilder For(DiscordMember member)
		=&gt; this.SetTarget(member);
	public DiscordOverwriteBuilder SetTarget(DiscordRole role)
	public DiscordOverwriteBuilder For(DiscordRole role)
		=&gt; this.SetTarget(role);
	internal DiscordRestOverwrite Build()
public static class DiscordOverwriteBuilderExtensions
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, OverwriteType type, ulong target, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		var newList = builderList.ToList();
		if (!newList.Any(x =&gt; x.Target == target &amp;&amp; x.Type == type))
			newList.Add(new()
		var discordOverwriteBuilder = newList.First(x =&gt; x.Target == target &amp;&amp; x.Type == type);
		discordOverwriteBuilder.Allow(allowed);
		discordOverwriteBuilder.Deny(denied);
		discordOverwriteBuilder.Remove(unset);
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, DiscordMember member, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		=&gt; builderList.Merge(OverwriteType.Member, member.Id, allowed, denied, unset);
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, DiscordRole role, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		=&gt; builderList.Merge(OverwriteType.Role, role.Id, allowed, denied, unset);
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, DiscordMember member, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(OverwriteType.Member, member.Id, allowed, denied, unset);
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, DiscordRole role, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(OverwriteType.Role, role.Id, allowed, denied, unset);
	public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, OverwriteType type, ulong target, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
		=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(type, target, allowed, denied, unset);</file><file path="DisCatSharp/Entities/Color/DiscordColor.Colors.cs"></file><file path="DisCatSharp/Entities/Color/DiscordColor.cs">			throw new ArgumentOutOfRangeException(null, &quot;Each component must be between 0.0 and 1.0 inclusive.&quot;);
		if (string.IsNullOrWhiteSpace(color))
			throw new ArgumentNullException(nameof(color), &quot;Null or empty values are not allowed!&quot;);
			throw new ArgumentException(&quot;Color must be 6 or 7 characters in length.&quot;, nameof(color));
		color = color.ToUpper();
			throw new ArgumentException(&quot;7-character colors must begin with #.&quot;, nameof(color));
		if (color.Any(xc =&gt; !s_hexAlphabet.Contains(xc)))
			throw new ArgumentException(&quot;Colors must consist of hexadecimal characters only.&quot;, nameof(color));
		this.Value = int.Parse(color, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
	public override string ToString() =&gt; $&quot;#{this.Value:X6}&quot;;</file><file path="DisCatSharp/Entities/Core/CooldownBucket.cs">public class CooldownBucket : IBucket, IEquatable&lt;CooldownBucket&gt;
	internal readonly SemaphoreSlim UsageSemaphore;
		=&gt; Volatile.Read(ref this.RemainingUsesInternal);
	public bool Equals(CooldownBucket? other)
	internal async Task&lt;bool&gt; DecrementUseAsync(DisCatSharpCommandContext ctx)
		await this.UsageSemaphore.WaitAsync().ConfigureAwait(false);
		ctx.Client.Logger.LogDebug($&quot;[Cooldown::prev_check({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
			Interlocked.Exchange(ref this.RemainingUsesInternal, this.MaxUses);
		ctx.Client.Logger.LogDebug($&quot;[Cooldown::check({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
			Interlocked.Decrement(ref this.RemainingUsesInternal);
		this.UsageSemaphore.Release();
		ctx.Client.Logger.LogWarning($&quot;[Cooldown::hit({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
	public override bool Equals(object? obj)
		=&gt; this.Equals(obj as CooldownBucket);
	public override int GetHashCode()
		=&gt; HashCode.Combine(this.UserId, this.ChannelId, this.GuildId, this.MemberId);
		return (null1 &amp;&amp; null2) || (null1 == null2 &amp;&amp; null1.Equals(null2));
	public static string MakeId(string commandId, string commandName, ulong userId = 0, ulong channelId = 0, ulong guildId = 0, ulong memberId = 0)
		=&gt; $&quot;{commandId}:{commandName}::{userId.ToString(CultureInfo.InvariantCulture)}:{channelId.ToString(CultureInfo.InvariantCulture)}:{guildId.ToString(CultureInfo.InvariantCulture)}:{memberId.ToString(CultureInfo.InvariantCulture)}&quot;;</file><file path="DisCatSharp/Entities/Core/DisCatSharpBuilder.cs">public class DisCatSharpBuilder
				throw new InvalidOperationException(&quot;You cannot set the content for UI Kit / Voice messages&quot;);
				throw new ArgumentException(&quot;Content length cannot exceed 2000 characters.&quot;, nameof(value));
				throw new InvalidOperationException(&quot;You cannot set embeds suppressed for UI Kit messages since they cannot have embeds&quot;);
	public void ClearComponents()
		=&gt; this.ComponentsInternal.Clear();
	public virtual void Clear()
		this.FilesInternal.Clear();
		this.EmbedsInternal.Clear();
		this.AttachmentsInternal.Clear();
		this.ComponentsInternal.Clear();
		this.MentionsInternal.Clear();
	internal virtual void Validate()
				this.CheckComponentIds(component, ids, duplicateIds);
				var duplicateDetails = string.Join(&quot;, &quot;, duplicateIds.Select(kvp =&gt; $&quot;ID: {kvp.Key}, Types: {string.Join(&quot;, &quot;, kvp.Value)}&quot;));
				throw new AggregateException($&quot;You provided one or more components with the same id. They have to be unique. Duplicates: {duplicateDetails}&quot;);
	private void CheckComponentIds(DiscordComponent component, HashSet&lt;int&gt; ids, Dictionary&lt;int, List&lt;string&gt;&gt; duplicateIds)
				this.AddId(actionRowComponentChild, ids, duplicateIds);
						this.AddId(sectionComponentChild, ids, duplicateIds);
					this.AddId(subSectionComponent.Accessory, ids, duplicateIds);
				this.AddId(containerComponentChild, ids, duplicateIds);
			this.AddId(sectionComponent.Accessory, ids, duplicateIds);
		this.AddId(component, ids, duplicateIds);
	private void AddId(DiscordComponent component, HashSet&lt;int&gt; ids, Dictionary&lt;int, List&lt;string&gt;&gt; duplicateIds)
			if (!ids.Add(id))
				if (!duplicateIds.ContainsKey(id))
				duplicateIds[id].Add(component.Type.ToString());</file><file path="DisCatSharp/Entities/Core/DisCatSharpCommandContext.cs">public class DisCatSharpCommandContext</file><file path="DisCatSharp/Entities/Core/IBucket.cs">public interface IBucket</file><file path="DisCatSharp/Entities/Core/ICooldown.cs">public interface ICooldown&lt;in TContextType, out TBucketType&gt;
	where TContextType : DisCatSharpCommandContext
	where TBucketType : CooldownBucket
	TimeSpan GetRemainingCooldown(TContextType ctx);
	TBucketType GetBucket(TContextType ctx);
	Task&lt;bool&gt; RespondRatelimitHitAsync(TContextType ctx, bool noHit, CooldownBucket bucket);</file><file path="DisCatSharp/Entities/DiscordLocales.cs">public static class DiscordLocales</file><file path="DisCatSharp/Entities/DiscordProtocol.cs">public sealed class DiscordProtocol</file><file path="DisCatSharp/Entities/DiscordSignedLink.cs">public sealed class DiscordSignedLink : DiscordUri
		ArgumentNullException.ThrowIfNull(uri);
		if (string.IsNullOrWhiteSpace(uri.Query))
		var queries = HttpUtility.ParseQueryString(uri.Query);
		if (!queries.HasKeys())
		if (queries.Get(&quot;ex&quot;) is { } expiresString &amp;&amp; long.TryParse(expiresString, NumberStyles.HexNumber,
			this.ExpiresAt = DateTimeOffset.FromUnixTimeSeconds(expiresTimeStamp);
		if (queries.Get(&quot;is&quot;) is { } issuedString &amp;&amp;
		    long.TryParse(issuedString, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var issuedTimeStamp))
			this.IssuedAt = DateTimeOffset.FromUnixTimeSeconds(issuedTimeStamp);
		this.Signature = queries.Get(&quot;hm&quot;);
		ArgumentNullException.ThrowIfNull(uriString);
		var uri = this.ToUri() ?? throw new UriFormatException(&quot;Invalid URI format.&quot;);
		=&gt; this.ExpiresAt.HasValue &amp;&amp; this.IssuedAt.HasValue &amp;&amp; !string.IsNullOrWhiteSpace(this.Signature);
	public override string? ToString()
		=&gt; duri.ToUri();
	internal sealed class DiscordSignedLinkJsonConverter : JsonConverter
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
			=&gt; writer.WriteValue((value as DiscordSignedLink)?._value);
		public override object? ReadJson(
					? throw new JsonReaderException(&quot;DiscordSignedLink value invalid format! This is a bug in DisCatSharp. &quot; +
					: new DiscordSignedLink(s);
		public override bool CanConvert(Type objectType)</file><file path="DisCatSharp/Entities/DiscordUri.cs">public class DiscordUri
		this._value = value ?? throw new ArgumentNullException(nameof(value));
		ArgumentNullException.ThrowIfNull(value);
			this._value = new Uri(value);
	private static bool IsStandard(string value)
		=&gt; !value.StartsWith(&quot;attachment://&quot;, StringComparison.Ordinal);
	public override string? ToString()
		=&gt; duri.ToUri();
	public Uri? ToUri()
			: throw new UriFormatException(
	internal sealed class DiscordUriJsonConverter : JsonConverter
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
			=&gt; writer.WriteValue((value as DiscordUri)?._value);
		public override object? ReadJson(
					? throw new JsonReaderException(&quot;DiscordUri value invalid format! This is a bug in DisCatSharp. &quot; +
						? new(new Uri(s))
						: new DiscordUri(s);
		public override bool CanConvert(Type objectType)</file><file path="DisCatSharp/Entities/Embed/DiscordEmbed.cs">public sealed class DiscordEmbed : ObservableApiObject</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedAuthor.cs">public sealed class DiscordEmbedAuthor : ObservableApiObject</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedBuilder.cs">public sealed class DiscordEmbedBuilder
		if (original.Fields.Any())
			this._fields.AddRange(original.Fields);
			this._fields.RemoveAt(this._fields.Count - 1);
				throw new ArgumentException(&quot;Title length cannot exceed 256 characters.&quot;, nameof(value));
				throw new ArgumentException(&quot;Description length cannot exceed 4096 characters.&quot;, nameof(value));
		set =&gt; this._url = string.IsNullOrEmpty(value) ? null : new Uri(value);
		set =&gt; this._imageUri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);
	public DiscordEmbedBuilder WithTitle(string title)
	public DiscordEmbedBuilder WithDescription(string description)
	public DiscordEmbedBuilder WithUrl(string url)
	public DiscordEmbedBuilder WithUrl(Uri url)
	public DiscordEmbedBuilder WithColor(DiscordColor color)
	public DiscordEmbedBuilder WithTimestamp(DateTimeOffset? timestamp)
	public DiscordEmbedBuilder WithTimestamp(DateTime? timestamp)
		this.Timestamp = timestamp == null ? null : new DateTimeOffset(timestamp.Value);
	public DiscordEmbedBuilder WithTimestamp(ulong snowflake)
		this.Timestamp = new DateTimeOffset(2015, 1, 1, 0, 0, 0, TimeSpan.Zero).AddMilliseconds(snowflake &gt;&gt; 22);
	public DiscordEmbedBuilder WithImageUrl(string url)
	public DiscordEmbedBuilder WithImageUrl(Uri url)
	public DiscordEmbedBuilder WithThumbnail(string url, int height = 0, int width = 0)
	public DiscordEmbedBuilder WithThumbnail(Uri url, int height = 0, int width = 0)
	public DiscordEmbedBuilder WithAuthor(string? name = null, string? url = null, string? iconUrl = null)
		if (!string.IsNullOrEmpty(name) &amp;&amp; name.Length &gt; 256)
			throw new NotSupportedException(&quot;Embed author name can not exceed 256 chars. See https://discord.com/developers/docs/resources/channel#embed-limits.&quot;);
		this.Author = string.IsNullOrEmpty(name) &amp;&amp; string.IsNullOrEmpty(url) &amp;&amp; string.IsNullOrEmpty(iconUrl)
			: new EmbedAuthor
	public DiscordEmbedBuilder WithFooter(string? text = null, string? iconUrl = null)
			throw new ArgumentException(&quot;Footer text length cannot exceed 2048 characters.&quot;, nameof(text));
		this.Footer = string.IsNullOrEmpty(text) &amp;&amp; string.IsNullOrEmpty(iconUrl)
			: new EmbedFooter
	public DiscordEmbedBuilder AddField(DiscordEmbedField field)
			throw new InvalidOperationException(&quot;Cannot add more than 25 fields.&quot;);
		if (string.IsNullOrWhiteSpace(field.Name))
			ArgumentNullException.ThrowIfNull(field.Name);
			throw new ArgumentException(&quot;Name cannot be empty or whitespace.&quot;, nameof(field));
			throw new ArgumentException(&quot;Embed field name length cannot exceed 256 characters.&quot;, nameof(field));
		if (string.IsNullOrWhiteSpace(field.Value))
			ArgumentNullException.ThrowIfNull(field.Value);
			throw new ArgumentException(&quot;Value cannot be empty or whitespace.&quot;, nameof(field));
			throw new ArgumentException(&quot;Embed field value length cannot exceed 1024 characters.&quot;, nameof(field));
		this._fields.Add(field);
	public DiscordEmbedBuilder AddFields(params DiscordEmbedField[] fields)
		=&gt; this.AddFields((IEnumerable&lt;DiscordEmbedField&gt;)fields);
	public DiscordEmbedBuilder AddFields(IEnumerable&lt;DiscordEmbedField&gt; fields)
		=&gt; fields.Aggregate(this, (x, y) =&gt; x.AddField(y));
	public DiscordEmbedBuilder RemoveField(DiscordEmbedField field)
		this._fields.Remove(field);
	public DiscordEmbedBuilder RemoveFields(params DiscordEmbedField[] fields)
		this.RemoveFields((IEnumerable&lt;DiscordEmbedField&gt;)fields);
	public DiscordEmbedBuilder RemoveFields(IEnumerable&lt;DiscordEmbedField&gt; fields)
		this._fields.RemoveAll(fields.Contains);
	public DiscordEmbedBuilder RemoveFieldAt(int index)
		this._fields.RemoveAt(index);
	public DiscordEmbedBuilder RemoveFieldRange(int index, int count)
		this._fields.RemoveRange(index, count);
	public DiscordEmbedBuilder ClearFields()
		this._fields.Clear();
	public DiscordEmbed Build()
		var embed = new DiscordEmbed
			ColorInternal = this.Color.Map(e =&gt; e.Value),
		if (embed.Fields.Any())
		if (embed.Author is not null &amp;&amp; !string.IsNullOrEmpty(embed.Author.Name))
		if (embed.Footer is not null &amp;&amp; !string.IsNullOrEmpty(embed.Footer.Text))
		if (!string.IsNullOrEmpty(embed.Title))
		if (!string.IsNullOrEmpty(embed.Description))
			? throw new NotSupportedException(&quot;Total char count can not exceed 6000 chars. See https://discord.com/developers/docs/resources/channel#embed-limits.&quot;)
		=&gt; builder is not null ? builder.Build() : throw new NullReferenceException(&quot;Argument builder was null&quot;);
	public sealed class EmbedAuthor
					throw new ArgumentException(&quot;Author name length cannot exceed 256 characters.&quot;, nameof(value));
			set =&gt; this.Uri = string.IsNullOrEmpty(value) ? null : new Uri(value);
			set =&gt; this.IconUri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);
	public sealed class EmbedFooter
					throw new ArgumentException(&quot;Footer text length cannot exceed 2048 characters.&quot;, nameof(value));
	public sealed class EmbedThumbnail
			set =&gt; this.Uri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedField.cs">public sealed class DiscordEmbedField : ObservableApiObject</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedFooter.cs">public sealed class DiscordEmbedFooter : ObservableApiObject</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedImage.cs">public sealed class DiscordEmbedImage : DiscordUnfurledMedia</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedProvider.cs">public sealed class DiscordEmbedProvider : ObservableApiObject</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedThumbnail.cs">public sealed class DiscordEmbedThumbnail : DiscordUnfurledMedia</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedVideo.cs">public sealed class DiscordEmbedVideo : DiscordUnfurledMedia</file><file path="DisCatSharp/Entities/Emoji/DiscordEmoji.cs">public partial class DiscordEmoji : SnowflakeObject, IEquatable&lt;DiscordEmoji&gt;
			? throw new InvalidOperationException(&quot;Cannot get URL of unicode emojis.&quot;)
				? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMOJIS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.gif&quot;
				: $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMOJIS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.png&quot;;
			? throw new InvalidOperationException(&quot;Emoji is not a unicode emoji&quot;)
			: s_unicodeEmojis.TryGetValue(this.Name, out var value)
				: s_discordNameLookup.ContainsKey(this.Name)
					: throw new InvalidOperationException(&quot;Emoji is not a unicode emoji&quot;);
	public bool Equals(DiscordEmoji e)
	public string GetDiscordName()
		s_discordNameLookup.TryGetValue(this.Name, out var name);
	public override string ToString()
				? $&quot;&lt;a:{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
				: $&quot;&lt;:{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordEmoji);
	public override int GetHashCode()
		hash = (hash * 7) + this.Id.GetHashCode();
		hash = (hash * 7) + this.Name.GetHashCode();
	internal string ToReactionString()
		=&gt; this.Id != 0 ? $&quot;{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&quot; : this.Name;
	public static bool IsValidUnicode(string unicodeEntity)
		=&gt; s_discordNameLookup.ContainsKey(unicodeEntity);
	public static DiscordEmoji FromUnicode(BaseDiscordClient client, string unicodeEntity)
			? throw new ArgumentException(&quot;Specified unicode entity is not a valid unicode emoji.&quot;, nameof(unicodeEntity))
			: new DiscordEmoji
	public static DiscordEmoji FromUnicode(string unicodeEntity)
	public static bool TryFromUnicode(BaseDiscordClient client, string unicodeEntity, out DiscordEmoji emoji)
		if (!s_discordNameLookup.TryGetValue(unicodeEntity, out var discordName))
		if (!s_unicodeEmojis.TryGetValue(discordName, out unicodeEntity))
	public static bool TryFromUnicode(string unicodeEntity, out DiscordEmoji emoji)
	public static DiscordEmoji FromGuildEmote(BaseDiscordClient client, ulong id)
			throw new ArgumentNullException(nameof(client), &quot;Client cannot be null.&quot;);
			if (guild.Emojis.TryGetValue(id, out var found))
		throw new KeyNotFoundException(&quot;Given emote was not found.&quot;);
	public static DiscordEmoji FromApplicationEmote(BaseDiscordClient client, ulong id)
		if (client.Emojis.TryGetValue(id, out var found))
	public static bool TryFromGuildEmote(BaseDiscordClient client, ulong id, out DiscordEmoji emoji)
			if (guild.Emojis.TryGetValue(id, out emoji))
	public static DiscordEmoji FromName(BaseDiscordClient client, string name, bool includeGuilds = true, bool includeApplication = true)
		if (string.IsNullOrWhiteSpace(name))
			throw new ArgumentNullException(nameof(name), &quot;Name cannot be empty or null.&quot;);
		if (s_unicodeEmojis.TryGetValue(name, out var unicodeEntity))
				.SelectMany(xg =&gt; xg.Emojis.Values); // save cycles - don&apos;t order
			var ek = name.AsSpan().Slice(1, name.Length - 2);
				if (emoji.Name.AsSpan().SequenceEqual(ek))
		throw new ArgumentException(&quot;Invalid emoji name specified.&quot;, nameof(name));
	public static bool TryFromName(BaseDiscordClient client, string name, out DiscordEmoji emoji)
	public static bool TryFromName(BaseDiscordClient client, string name, bool includeGuilds, bool includeApplication, out DiscordEmoji emoji)
				if (xemoji.Name.AsSpan().SequenceEqual(ek))</file><file path="DisCatSharp/Entities/Emoji/DiscordEmoji.EmojiUtils.cs">public partial class DiscordEmoji</file><file path="DisCatSharp/Entities/Emoji/DiscordUnicodeEmoji.cs">public class DiscordUnicodeEmoji</file><file path="DisCatSharp/Entities/Emoji/PartialEmoji.cs">public sealed class PartialEmoji</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodAction.cs">public class AutomodAction : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodActionMetadata.cs">public class AutomodActionMetadata : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodRule.cs">public class AutomodRule : SnowflakeObject
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
	public async Task&lt;AutomodRule&gt; ModifyAsync(Action&lt;AutomodRuleEditModel&gt; action)
		var mdl = new AutomodRuleEditModel();
				throw new ArgumentException($&quot;Cannot use KeywordFilter and RegexPattern for a {this.TriggerType} rule. Only {AutomodTriggerType.Keyword} is valid in this context.&quot;);
				throw new ArgumentException($&quot;Cannot use AllowList for a {this.TriggerType} rule. Only {AutomodTriggerType.KeywordPreset} is valid in this context.&quot;);
				throw new ArgumentException($&quot;Cannot use MentionTotalLimit for a {this.TriggerType} rule. Only {AutomodTriggerType.MentionSpam} is valid in this context.&quot;);
				throw new ArgumentException($&quot;Cannot use MentionRaidProtectionEnabled for a {this.TriggerType} rule. Only {AutomodTriggerType.MentionSpam} is valid in this context.&quot;);
		return await this.Discord.ApiClient.ModifyAutomodRuleAsync(this.GuildId, this.Id, mdl.Name, mdl.EventType, mdl.TriggerMetadata, mdl.Actions, mdl.Enabled, mdl.ExemptRoles, mdl.ExemptChannels, mdl.AuditLogReason).ConfigureAwait(false);
	public async Task DeleteAsync(string reason = null)
		=&gt; await this.Discord.ApiClient.DeleteAutomodRuleAsync(this.GuildId, this.Id, reason).ConfigureAwait(false);</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodTriggerMetadata.cs">public class AutomodTriggerMetadata : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordAuditLogObjects.cs">public abstract class DiscordAuditLogEntry : SnowflakeObject
public sealed class PropertyChange&lt;T&gt;
public sealed class DiscordAuditLogGuildEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogChannelEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogOverwriteEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogKickEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogPruneEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogBanEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogMemberUpdateEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogRoleUpdateEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogInviteEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogWebhookEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogEmojiEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogStickerEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogMessageEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogMessagePinEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogBotAddEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogMemberMoveEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogMemberDisconnectEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogIntegrationEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogStageEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogGuildScheduledEventEntry : DiscordAuditLogEntry
public sealed class DiscordAuditLogThreadEntry : DiscordAuditLogEntry</file><file path="DisCatSharp/Entities/Guild/DiscordBan.cs">public class DiscordBan : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordBulkBanResponse.cs">public sealed class DiscordBulkBanResponse : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordClanSettings.cs">public sealed class DiscordClanSettings : ObservableApiObject
		=&gt; string.IsNullOrWhiteSpace(this.BadgeHash) ? null! : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CLAN_BADGES}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}/{this.BadgeHash}.{(this.BadgeHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=512&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.BannerHash) ? null! : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CLAN_BANNERS}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=16&quot;;</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.AuditLog.cs">public partial class DiscordGuild
	public async Task&lt;IReadOnlyList&lt;DiscordAuditLogEntry&gt;&gt; GetAuditLogsAsync(int? limit = null, DiscordMember byMember = null, AuditLogActionType? actionType = null)
			rmn = Math.Min(100, rmn);
			var alr = await this.Discord.ApiClient.GetAuditLogsAsync(this.Id, rmn, null, last == 0 ? null : last, byMember?.Id, (int?)actionType).ConfigureAwait(false);
				alrs.Add(alr);
		var auditLogResult = await this.ProcessAuditLog(alrs).ConfigureAwait(false);
	internal async Task&lt;IReadOnlyList&lt;DiscordAuditLogEntry&gt;&gt; ProcessAuditLog(List&lt;AuditLog&gt; auditLogApiResult)
		if (auditLogApiResult.Any(ar =&gt; ar.Users != null &amp;&amp; ar.Users.Any()))
			amr = auditLogApiResult.SelectMany(xa =&gt; xa.Users)
				.GroupBy(xu =&gt; xu.Id)
				.Select(xgu =&gt; xgu.First()).ToList();
				if (this.Discord.UserCache.ContainsKey(xau.Id))
				var xtu = new TransportUser
				var xu = new DiscordUser(xtu)
				xu = this.Discord.UserCache.AddOrUpdate(xu.Id, xu, (id, old) =&gt;
		if (auditLogApiResult.Any(ar =&gt; ar.ScheduledEvents != null &amp;&amp; ar.ScheduledEvents.Any()))
			atgse = auditLogApiResult.SelectMany(xa =&gt; xa.ScheduledEvents)
				.GroupBy(xse =&gt; xse.Id)
				.Select(xgse =&gt; xgse.First()).ToList();
		if (auditLogApiResult.Any(ar =&gt; ar.Threads != null &amp;&amp; ar.Threads.Any()))
			ath = auditLogApiResult.SelectMany(xa =&gt; xa.Threads)
				.GroupBy(xt =&gt; xt.Id)
				.Select(xgt =&gt; xgt.First()).ToList();
		if (auditLogApiResult.Any(ar =&gt; ar.Integrations != null &amp;&amp; ar.Integrations.Any()))
			aig = auditLogApiResult.SelectMany(xa =&gt; xa.Integrations)
				.GroupBy(xi =&gt; xi.Id)
				.Select(xgi =&gt; xgi.First()).ToList();
		if (auditLogApiResult.Any(ar =&gt; ar.Webhooks != null &amp;&amp; ar.Webhooks.Any()))
			ahr = auditLogApiResult.SelectMany(xa =&gt; xa.Webhooks)
				.GroupBy(xh =&gt; xh.Id)
				.Select(xgh =&gt; xgh.First()).ToList();
			ams = amr.Select(xau =&gt; this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xau.Id, out var member)
				}).ToList();
			amd = ams.ToDictionary(xm =&gt; xm.Id, xm =&gt; xm);
			var whr = await this.GetWebhooksAsync().ConfigureAwait(false);
			var whs = whr.ToDictionary(xh =&gt; xh.Id, xh =&gt; xh);
			var amh = ahr.Select(xah =&gt; whs.TryGetValue(xah.Id, out var webhook)
			ahd = amh.ToDictionary(xh =&gt; xh.Id, xh =&gt; xh);
		var acs = auditLogApiResult.SelectMany(xa =&gt; xa.Entries).OrderByDescending(xa =&gt; xa.Id);
			DiscordAuditLogEntry entry = null;
					entry = new DiscordAuditLogGuildEntry
							ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
							ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
								Before = this.GetChannel(t1) ?? new DiscordChannel
								After = this.GetChannel(t2) ?? new DiscordChannel
						switch (xc.Key.ToLowerInvariant())
									Before = this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xc.OldValueUlong, out var oldMember) ? oldMember : await this.GetMemberAsync(xc.OldValueUlong).ConfigureAwait(false),
									After = this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xc.NewValueUlong, out var newMember) ? newMember : await this.GetMemberAsync(xc.NewValueUlong).ConfigureAwait(false)
									Before = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id}/{xc.OldValueString}.webp&quot; : null,
									After = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id}/{xc.NewValueString}.webp&quot; : null
									Before = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id}/{xc.OldValueString}.webp?size=2048&quot; : null,
									After = xc.NewValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id}/{xc.NewValueString}.webp?size=2048&quot; : null
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in guild update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogChannelEntry
						Target = this.GetChannel(xac.TargetId.Value) ?? new DiscordChannel
								p1 = ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
								p2 = ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in channel update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogOverwriteEntry
						Target = this.GetChannel(xac.TargetId.Value)?.PermissionOverwrites.FirstOrDefault(xo =&gt; xo.Id == xac.Options.Id),
						Channel = this.GetChannel(xac.TargetId.Value)
								p1 = ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
								p2 = ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in overwrite update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogKickEntry
						Target = amd.TryGetValue(xac.TargetId.Value, out var kickMember)
					entry = new DiscordAuditLogPruneEntry
					entry = new DiscordAuditLogBanEntry
						Target = amd.TryGetValue(xac.TargetId.Value, out var unbanMember)
					entry = new DiscordAuditLogMemberUpdateEntry
						Target = amd.TryGetValue(xac.TargetId.Value, out var roleUpdMember)
								entrymbu.AddedRoles = new ReadOnlyCollection&lt;DiscordRole&gt;(xc.NewValues.Select(xo =&gt; (ulong)xo[&quot;id&quot;]).Select(this.GetRole).ToList());
								entrymbu.RemovedRoles = new ReadOnlyCollection&lt;DiscordRole&gt;(xc.NewValues.Select(xo =&gt; (ulong)xo[&quot;id&quot;]).Select(this.GetRole).ToList());
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in member update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogRoleUpdateEntry
						Target = this.GetRole(xac.TargetId.Value) ?? new DiscordRole
								p1 = int.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t3);
								p2 = int.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t4);
									Before = xc.OldValue != null ? (Permissions?)long.Parse((string)xc.OldValue) : null,
									After = xc.NewValue != null ? (Permissions?)long.Parse((string)xc.NewValue) : null
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in role update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogInviteEntry();
					var inv = new DiscordInvite
								p2 = int.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t4);
									Before = amd.TryGetValue(t1, out var propBeforeMember)
									After = amd.TryGetValue(t2, out var propAfterMember)
										? this.GetChannel(t1) ?? new DiscordChannel
										? this.GetChannel(t2) ?? new DiscordChannel
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in invite update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogWebhookEntry
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in webhook update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogEmojiEntry
						Target = this.EmojisInternal.TryGetValue(xac.TargetId.Value, out var target)
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in emote update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogStageEntry
						Target = this.StageInstancesInternal.TryGetValue(xac.TargetId.Value, out var stage)
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in stage instance update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogStickerEntry
						Target = this.StickersInternal.TryGetValue(xac.TargetId.Value, out var sticker)
									Before = ulong.TryParse(xc.OldValueString, out var ogid) ? ogid : null,
									After = ulong.TryParse(xc.NewValueString, out var ngid) ? ngid : null
									Before = ulong.TryParse(xc.OldValueString, out var oid) ? oid : null,
									After = ulong.TryParse(xc.NewValueString, out var nid) ? nid : null
								p1 = long.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t5);
								p2 = long.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t6);
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in sticker update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogMessageEntry();
						entrymsg.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
						                  &amp;&amp; dc.MessageCache.TryGet(xm =&gt; xm.Id == xac.TargetId.Value &amp;&amp; xm.ChannelId == entrymsg.Channel.Id, out var msg)
					entry = new DiscordAuditLogMessagePinEntry();
						DiscordMessage message = default;
						entrypin.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
						entrypin.Message = message ?? new DiscordMessage
						dc.UserCache.TryGetValue(xac.TargetId.Value, out var user);
						entrypin.Target = user ?? new DiscordUser
					entry = new DiscordAuditLogBotAddEntry();
					dc.UserCache.TryGetValue(xac.TargetId.Value, out var bot);
					(entry as DiscordAuditLogBotAddEntry).TargetBot = bot ?? new DiscordUser
					entry = new DiscordAuditLogMemberMoveEntry();
					moveentry.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
					entry = new DiscordAuditLogMemberDisconnectEntry
					entry = new DiscordAuditLogIntegrationEntry();
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in integration update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogThreadEntry
						Target = this.ThreadsInternal.TryGetValue(xac.TargetId.Value, out var thread)
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in thread update: {Key} - this should be reported to library developers&quot;, xc.Key);
					entry = new DiscordAuditLogGuildScheduledEventEntry
						Target = this.ScheduledEventsInternal.TryGetValue(xac.TargetId.Value, out var scheduledEvent)
									this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in scheduled event update: {Key} - this should be reported to library developers&quot;, xc.Key);
					this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown audit log action type: {Key} - this should be reported to library developers&quot;, (int)xac.ActionType);
			entry.UserResponsible = amd.Count != 0 &amp;&amp; amd.TryGetValue(xac.UserId, out var resp) ? resp : this.MembersInternal[xac.UserId];
			entries.Add(entry);</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.cs">public partial class DiscordGuild : SnowflakeObject, IEquatable&lt;DiscordGuild&gt;
		this._currentMemberLazy = new(() =&gt; this.MembersInternal.GetValueOrDefault(this.Discord.CurrentUser.Id));
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{(this.IconHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.png?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.DiscoverySplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_DISCOVERY_SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.DiscoverySplashHash}.png?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.HomeHeaderHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_HOME_HEADERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.HomeHeaderHash}.jpg?size=1280&quot; : null;
			? this.Members.TryGetValue(this.OwnerId.Value, out var owner)
				: this.Discord.ApiClient.GetGuildMemberAsync(this.Id, this.OwnerId.Value).ConfigureAwait(false).GetAwaiter().GetResult()
			? this.GetChannel(this.AfkChannelId.Value)
			? this.GetChannel(this.SystemChannelId.Value)
			? this.GetChannel(this.WidgetChannelId.Value)
			? this.GetChannel(this.SafetyAlertsChannelId.Value)
			? this.GetChannel(this.RulesChannelId.Value)
			? this.GetChannel(this.PublicUpdatesChannelId.Value)
		=&gt; this.GetRole(this.Id);
		=&gt; !string.IsNullOrWhiteSpace(this.BannerHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}&quot; : null;
		=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled);
		=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasWelcomeScreenEnabled);
		=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasMembershipScreeningEnabled);
			? this.GetChannel(this.EmbedChannelId.Value)
		=&gt; new ReadOnlyDictionary&lt;ulong, DiscordChannel&gt;(this.InternalSortChannels());
	public bool Equals(DiscordGuild e)
	public async Task&lt;DiscordVoiceState?&gt; GetCurrentMemberVoiceStateAsync()
		=&gt; await this.Discord.ApiClient.GetCurrentUserVoiceStateAsync(this.Id);
	public async Task&lt;DiscordVoiceState?&gt; GetMemberVoiceStateAsync(ulong memberId)
		=&gt; await this.Discord.ApiClient.GetMemberVoiceStateAsync(this.Id, memberId);
	private Dictionary&lt;ulong, DiscordChannel&gt; InternalSortChannels()
		var orderedChannels = this.GetOrderedChannels();
				keyValuePairs.Add(orderedChannel.Key, this.GetChannel(orderedChannel.Key));
				keyValuePairs.Add(chan.Id, chan);
	public Dictionary&lt;ulong, List&lt;DiscordChannel&gt;&gt; GetOrderedChannels()
		foreach (var channel in rawChannels.Where(c =&gt; c.Type == ChannelType.Category).OrderBy(c =&gt; c.Position))
			orderedChannels.Add(channel.Id, []);
		foreach (var channel in rawChannels.Where(c =&gt; c is { ParentId: not null, Type: ChannelType.Text or ChannelType.News or ChannelType.Forum }).OrderBy(c =&gt; c.Position))
			orderedChannels[channel.ParentId.Value!].Add(channel);
		foreach (var channel in rawChannels.Where(c =&gt; c is { ParentId: not null, Type: ChannelType.Voice or ChannelType.Stage }).OrderBy(c =&gt; c.Position))
		foreach (var channel in rawChannels.Where(c =&gt; !c.ParentId.HasValue &amp;&amp; c.Type != ChannelType.Category &amp;&amp; c.Type is ChannelType.Text or ChannelType.News or ChannelType.Forum).OrderBy(c =&gt; c.Position))
			orderedChannels[0].Add(channel);
		foreach (var channel in rawChannels.Where(c =&gt; !c.ParentId.HasValue &amp;&amp; c.Type != ChannelType.Category &amp;&amp; c.Type is ChannelType.Voice or ChannelType.Stage).OrderBy(c =&gt; c.Position))
	public async Task&lt;Dictionary&lt;ulong, List&lt;DiscordChannel&gt;&gt;&gt; GetOrderedChannelsAsync()
		var rawChannels = await this.Discord.ApiClient.GetGuildChannelsAsync(this.Id).ConfigureAwait(false);
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordGuild);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public Task&lt;DiscordOnboarding&gt; GetOnboardingAsync()
		=&gt; this.Discord.ApiClient.GetGuildOnboardingAsync(this.Id);
	public Task&lt;DiscordOnboarding&gt; ModifyOnboardingAsync(
		=&gt; this.Discord.ApiClient.ModifyGuildOnboardingAsync(this.Id, prompts, defaultChannelIds, enabled, mode,
	public Task&lt;DiscordServerGuide&gt; GetServerGuideAsync()
		=&gt; this.Discord.ApiClient.GetGuildServerGuideAsync(this.Id);
	public Task&lt;DiscordServerGuide&gt; ModifyServerGuideAsync(Optional&lt;bool&gt; enabled = default, Optional&lt;WelcomeMessage&gt; welcomeMessage = default, Optional&lt;List&lt;NewMemberAction&gt;&gt; newMemberActions = default, Optional&lt;List&lt;ResourceChannel&gt;&gt; resourceChannels = default, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildServerGuideAsync(this.Id, enabled, welcomeMessage, newMemberActions, resourceChannels, reason);
	public Task&lt;IReadOnlyList&lt;DiscordMember&gt;&gt; SearchMembersAsync(string name, int? limit = 1)
		=&gt; this.Discord.ApiClient.SearchGuildMembersAsync(this.Id, name, limit);
	public Task AddMemberAsync(
		=&gt; this.Discord.ApiClient.AddGuildMemberAsync(this.Id, user.Id, accessToken, nickname, roles, muted, deaf);
	public Task DeleteAsync()
		=&gt; this.Discord.ApiClient.DeleteGuildAsync(this.Id);
	public Task EnableMfaAsync(string? reason = null)
		=&gt; this.IsOwner ? this.Discord.ApiClient.EnableGuildMfaAsync(this.Id, reason) : throw new(&quot;The current user does not own the guild.&quot;);
	public Task DisableMfaAsync(string? reason = null)
		=&gt; this.IsOwner ? this.Discord.ApiClient.DisableGuildMfaAsync(this.Id, reason) : throw new(&quot;The current user does not own the guild.&quot;);
	public async Task&lt;DiscordGuild&gt; ModifyAsync(Action&lt;GuildEditModel&gt; action)
		var mdl = new GuildEditModel();
				? throw new ArgumentException(&quot;AFK channel needs to be a text channel.&quot;)
				? throw new ArgumentException($&quot;{name} channel needs to be a text channel.&quot;)
		var iconb64 = MediaTool.Base64FromStream(mdl.Icon);
		var splashb64 = MediaTool.Base64FromStream(mdl.Splash);
		var bannerb64 = MediaTool.Base64FromStream(mdl.Banner);
		var discoverySplashb64 = MediaTool.Base64FromStream(mdl.DiscoverySplash);
		var homeHeaderb64 = MediaTool.Base64FromStream(mdl.HomeHeader);
		return await this.Discord.ApiClient.ModifyGuildAsync(this.Id, mdl.Name,
			afkChannelId, mdl.AfkTimeout, iconb64, mdl.Owner.Map(e =&gt; e.Id), splashb64,
			mdl.Description, bannerb64, discoverySplashb64, homeHeaderb64, mdl.PreferredLocale, mdl.PremiumProgressBarEnabled, mdl.AuditLogReason).ConfigureAwait(false);
	public async Task&lt;DiscordGuild&gt; ModifyCommunitySettingsAsync(bool enabled, DiscordChannel rulesChannel, DiscordChannel publicUpdatesChannel, string preferredLocale = &quot;en-US&quot;, string description = null, DefaultMessageNotifications defaultMessageNotifications = Enums.DefaultMessageNotifications.MentionsOnly, string? reason = null)
		if (!rfeatures.Contains(&quot;COMMUNITY&quot;) &amp;&amp; enabled)
			rfeatures.Add(&quot;COMMUNITY&quot;);
		else if (rfeatures.Contains(&quot;COMMUNITY&quot;) &amp;&amp; !enabled)
			rfeatures.Remove(&quot;COMMUNITY&quot;);
		return await this.Discord.ApiClient.ModifyGuildCommunitySettingsAsync(this.Id, rfeatures, rulesChannelId, publicUpdatesChannelId, preferredLocale, description, defaultMessageNotifications, explicitContentFilter, verificationLevel ?? Optional&lt;VerificationLevel&gt;.None, reason).ConfigureAwait(false);
	public Task&lt;DiscordGuild&gt; ModifyInventorySettingsAsync(bool enabled, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildInventorySettingsAsync(this.Id, enabled, reason);
	public async Task&lt;DiscordGuild&gt; ModifySafetyAlertsSettingsAsync(bool enabled, DiscordChannel safetyAlertsChannel, string? reason = null)
		if (!rfeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;) &amp;&amp; enabled)
			rfeatures.Add(&quot;RAID_ALERTS_ENABLED&quot;);
		else if (rfeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;) &amp;&amp; !enabled)
			rfeatures.Remove(&quot;RAID_ALERTS_ENABLED&quot;);
		return await this.Discord.ApiClient.ModifyGuildSafetyAlertsSettingsAsync(this.Id, rfeatures, safetyAlertsChannelId, reason).ConfigureAwait(false);
	public async Task&lt;DiscordGuild&gt; EnableInvitesAsync(string? reason = null)
		if (this.Features.HasFeature(GuildFeaturesEnum.InvitesDisabled))
			rfeatures.Remove(&quot;INVITES_DISABLED&quot;);
		return await this.Discord.ApiClient.ModifyGuildFeaturesAsync(this.Id, rfeatures, reason).ConfigureAwait(false);
	public async Task&lt;DiscordGuild&gt; DisableInvitesAsync(string? reason = null)
		if (!this.Features.HasFeature(GuildFeaturesEnum.InvitesDisabled))
			rfeatures.Add(&quot;INVITES_DISABLED&quot;);
	public async Task&lt;IncidentsData&gt; ModifyIncidentActionsAsync(DateTimeOffset? invitesDisabledUntil = null, DateTimeOffset? dmsDisabledUntil = null)
		   invitesDisabledUntil.Value.UtcDateTime &gt; DateTimeOffset.UtcNow.UtcDateTime.AddHours(24)
			? throw new InvalidOperationException(&quot;Cannot disable invites for more than 24 hours.&quot;)
			  dmsDisabledUntil.Value.UtcDateTime &gt; DateTimeOffset.UtcNow.UtcDateTime.AddHours(24)
				? throw new InvalidOperationException(&quot;Cannot disable direct messages for more than 24 hours.&quot;)
				: await this.Discord.ApiClient.ModifyGuildIncidentActionsAsync(this.Id, invitesDisabledUntil, dmsDisabledUntil).ConfigureAwait(false);
	public Task TimeoutAsync(ulong memberId, DateTimeOffset until, string? reason = null)
		=&gt; until.Subtract(DateTimeOffset.UtcNow).Days &gt; 28
			? throw new ArgumentException(&quot;Timeout can not be longer than 28 days&quot;)
			: this.Discord.ApiClient.ModifyTimeoutAsync(this.Id, memberId, until, reason);
	public Task TimeoutAsync(ulong memberId, TimeSpan until, string? reason = null)
		=&gt; this.TimeoutAsync(memberId, DateTimeOffset.UtcNow + until, reason);
	public Task TimeoutAsync(ulong memberId, DateTime until, string? reason = null)
		=&gt; this.TimeoutAsync(memberId, until.ToUniversalTime() - DateTime.UtcNow, reason);
	public Task RemoveTimeoutAsync(ulong memberId, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyTimeoutAsync(this.Id, memberId, null, reason);
	public Task BanMemberAsync(DiscordMember member, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string? reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, member.Id, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
	public Task BanMemberAsync(DiscordUser user, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string? reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, user.Id, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
	public Task BanMemberAsync(ulong userId, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, userId, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
	private int DaysToSeconds(int days)
	public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;DiscordMember&gt; members, int deleteMessageSeconds = 0, string? reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, members.Select(x =&gt; x.Id).ToList(), deleteMessageSeconds, reason);
	public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;DiscordUser&gt; users, int deleteMessageSeconds = 0, string? reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, users.Select(x =&gt; x.Id).ToList(), deleteMessageSeconds, reason);
	public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;ulong&gt; userIds, int deleteMessageSeconds = 0, string reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, userIds, deleteMessageSeconds, reason);
	public Task UnbanMemberAsync(DiscordUser user, string? reason = null)
		=&gt; this.Discord.ApiClient.RemoveGuildBanAsync(this.Id, user.Id, reason);
	public Task UnbanMemberAsync(ulong userId, string? reason = null)
		=&gt; this.Discord.ApiClient.RemoveGuildBanAsync(this.Id, userId, reason);
	public Task LeaveAsync()
		=&gt; this.Discord.ApiClient.LeaveGuildAsync(this.Id);
	public Task&lt;IReadOnlyList&lt;DiscordBan&gt;&gt; GetBansAsync(int? limit = null, ulong? before = null, ulong? after = null)
		=&gt; this.Discord.ApiClient.GetGuildBansAsync(this.Id, limit, before, after);
	public Task&lt;DiscordBan&gt; GetBanAsync(ulong userId)
		=&gt; this.Discord.ApiClient.GetGuildBanAsync(this.Id, userId);
	public async Task&lt;DiscordBan?&gt; TryGetBanAsync(ulong userId)
			return await this.GetBanAsync(userId).ConfigureAwait(false);
	public Task&lt;DiscordBan&gt; GetBanAsync(DiscordUser user)
		=&gt; this.GetBanAsync(user.Id);
	public async Task&lt;DiscordBan?&gt; TryGetBanAsync(DiscordUser user)
			return await this.GetBanAsync(user).ConfigureAwait(false);
	public Task&lt;ReadOnlyCollection&lt;AutomodRule&gt;&gt; GetAutomodRulesAsync()
		=&gt; this.Discord.ApiClient.GetAutomodRulesAsync(this.Id);
	public Task&lt;AutomodRule&gt; GetAutomodRuleAsync(ulong ruleId)
		=&gt; this.Discord.ApiClient.GetAutomodRuleAsync(this.Id, ruleId);
	public async Task&lt;AutomodRule&gt; CreateAutomodRuleAsync(
		=&gt; await this.Discord.ApiClient.CreateAutomodRuleAsync(this.Id, name, eventType, triggerType, actions, triggerMetadata, enabled, exemptRoles, exemptChannels, reason).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; CreateScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, DateTimeOffset? scheduledEndTime = null, DiscordChannel channel = null, DiscordScheduledEventEntityMetadata metadata = null, string description = null, ScheduledEventEntityType type = ScheduledEventEntityType.StageInstance, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
		var coverb64 = MediaTool.Base64FromStream(coverImage);
		return await this.Discord.ApiClient.CreateGuildScheduledEventAsync(this.Id, type is ScheduledEventEntityType.External ? null : channel?.Id, type is ScheduledEventEntityType.External ? metadata : null, name, scheduledStartTime, scheduledEndTime.HasValue &amp;&amp; type is ScheduledEventEntityType.External ? scheduledEndTime.Value : null, description, type, coverb64, recurrenceRule, reason).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; CreateExternalScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, DateTimeOffset scheduledEndTime, string location, string description = null, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
		return await this.Discord.ApiClient.CreateGuildScheduledEventAsync(this.Id, null, new(location), name, scheduledStartTime, scheduledEndTime, description, ScheduledEventEntityType.External, coverb64, recurrenceRule, reason).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; GetScheduledEventAsync(ulong scheduledEventId, bool? withUserCount = null)
		=&gt; this.ScheduledEventsInternal.TryGetValue(scheduledEventId, out var ev) ? ev : await this.Discord.ApiClient.GetGuildScheduledEventAsync(this.Id, scheduledEventId, withUserCount).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent?&gt; TryGetScheduledEventAsync(ulong scheduledEventId, bool? withUserCount = null)
			return await this.GetScheduledEventAsync(scheduledEventId, withUserCount).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; GetScheduledEventAsync(DiscordScheduledEvent scheduledEvent, bool? withUserCount = null)
		=&gt; await this.GetScheduledEventAsync(scheduledEvent.Id, withUserCount).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent?&gt; TryGetScheduledEventAsync(DiscordScheduledEvent scheduledEvent, bool? withUserCount = null)
			return await this.GetScheduledEventAsync(scheduledEvent, withUserCount).ConfigureAwait(false);
	public async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEvent&gt;&gt; GetScheduledEventsAsync(bool? withUserCount = null)
		=&gt; await this.Discord.ApiClient.ListGuildScheduledEventsAsync(this.Id, withUserCount).ConfigureAwait(false);
	public Task&lt;DiscordChannel&gt; CreateTextChannelAsync(string name, DiscordChannel? parent = null, Optional&lt;string&gt; topic = default, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, bool? nsfw = null, Optional&lt;int?&gt; perUserRateLimit = default, ThreadAutoArchiveDuration defaultAutoArchiveDuration = ThreadAutoArchiveDuration.OneDay, Optional&lt;ChannelFlags?&gt; flags = default, string? reason = null)
		=&gt; this.CreateChannelAsync(name, ChannelType.Text, parent, topic, null, null, overwrites, nsfw, perUserRateLimit, null, defaultAutoArchiveDuration, flags, reason);
	public Task&lt;DiscordChannel&gt; CreateForumChannelAsync(
		=&gt; this.Discord.ApiClient.CreateGuildForumChannelAsync(this.Id, name, parent?.Id, topic, null, nsfw, defaultReactionEmoji, perUserRateLimit, postCreateUserRateLimit, defaultSortOrder, defaultLayout, defaultAutoArchiveDuration, overwrites, flags, reason);
	public Task&lt;DiscordChannel&gt; CreateChannelCategoryAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt; overwrites = null, string reason = null)
		=&gt; this.CreateChannelAsync(name, ChannelType.Category, null, Optional.None, null, null, overwrites, null, Optional.None, null, null, Optional.None, reason);
	public Task&lt;DiscordChannel&gt; CreateStageChannelAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt; overwrites = null, string reason = null)
		=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled) ? this.CreateChannelAsync(name, ChannelType.Stage, null, Optional.None, null, null, overwrites, null, Optional.None, null, null, Optional.None, reason) : throw new NotSupportedException(&quot;Guild has not enabled community. Can not create a stage channel.&quot;);
	public Task&lt;DiscordChannel&gt; CreateNewsChannelAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, string? reason = null, ThreadAutoArchiveDuration defaultAutoArchiveDuration = ThreadAutoArchiveDuration.OneDay, Optional&lt;ChannelFlags?&gt; flags = default)
		=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled) ? this.CreateChannelAsync(name, ChannelType.News, null, Optional.None, null, null, overwrites, null, Optional.None, null, defaultAutoArchiveDuration, flags, reason) : throw new NotSupportedException(&quot;Guild has not enabled community. Can not create a news channel.&quot;);
	public Task&lt;DiscordChannel&gt; CreateVoiceChannelAsync(string name, DiscordChannel? parent = null, int? bitrate = null, int? userLimit = null, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, VideoQualityMode? qualityMode = null, Optional&lt;ChannelFlags?&gt; flags = default, string? reason = null)
		=&gt; this.CreateChannelAsync(name, ChannelType.Voice, parent, Optional.None, bitrate, userLimit, overwrites, null, Optional.None, qualityMode, null, flags, reason);
	public Task&lt;DiscordChannel&gt; CreateChannelAsync(
			? throw new ArgumentException(&quot;Channel type must be text, voice, stage, or category.&quot;, nameof(type))
				? throw new ArgumentException(&quot;Cannot specify parent of a channel category.&quot;, nameof(parent))
				: this.Discord.ApiClient.CreateGuildChannelAsync(this.Id, name, type, parent?.Id, topic, bitrate, userLimit, overwrites, nsfw, perUserRateLimit, qualityMode, defaultAutoArchiveDuration, flags, reason);
	public Task&lt;DiscordThreadResult&gt; GetActiveThreadsAsync()
		=&gt; this.Discord.ApiClient.GetActiveThreadsAsync(this.Id);
	public Task DeleteAllChannelsAsync()
		var tasks = this.Channels.Values.Select(xc =&gt; xc.DeleteAsync());
		return Task.WhenAll(tasks);
	public Task&lt;int&gt; GetPruneCountAsync(int days = 7, IEnumerable&lt;DiscordRole&gt;? includedRoles = null)
			includedRoles = includedRoles.Where(r =&gt; r != null);
				.Where(x =&gt; this.RolesInternal.ContainsKey(x.Id))
				.Select(x =&gt; x.Id);
			return this.Discord.ApiClient.GetGuildPruneCountAsync(this.Id, days, rawRoleIds);
		return this.Discord.ApiClient.GetGuildPruneCountAsync(this.Id, days, null);
	public Task&lt;int?&gt; PruneAsync(int days = 7, bool computePruneCount = true, IEnumerable&lt;DiscordRole&gt;? includedRoles = null, string? reason = null)
			return this.Discord.ApiClient.BeginGuildPruneAsync(this.Id, days, computePruneCount, rawRoleIds, reason);
		return this.Discord.ApiClient.BeginGuildPruneAsync(this.Id, days, computePruneCount, null, reason);
	public Task&lt;IReadOnlyList&lt;DiscordIntegration&gt;&gt; GetIntegrationsAsync()
		=&gt; this.Discord.ApiClient.GetGuildIntegrationsAsync(this.Id);
	public Task&lt;DiscordIntegration&gt; AttachUserIntegrationAsync(DiscordIntegration integration)
		=&gt; this.Discord.ApiClient.CreateGuildIntegrationAsync(this.Id, integration.Type, integration.Id);
	public Task&lt;DiscordIntegration&gt; ModifyIntegrationAsync(DiscordIntegration integration, int expireBehaviour, int expireGracePeriod, bool enableEmoticons)
		=&gt; this.Discord.ApiClient.ModifyGuildIntegrationAsync(this.Id, integration.Id, expireBehaviour, expireGracePeriod, enableEmoticons);
	public Task DeleteIntegrationAsync(DiscordIntegration integration)
		=&gt; this.Discord.ApiClient.DeleteGuildIntegrationAsync(this.Id, integration);
	public Task SyncIntegrationAsync(DiscordIntegration integration)
		=&gt; this.Discord.ApiClient.SyncGuildIntegrationAsync(this.Id, integration.Id);
	public async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
		var vrs = await this.Discord.ApiClient.GetGuildVoiceRegionsAsync(this.Id).ConfigureAwait(false);
			this.Discord.InternalVoiceRegions.TryAdd(xvr.Id, xvr);
	public DiscordInvite? GetInvite(string code)
		=&gt; this.Invites.GetValueOrDefault(code);
	public async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetInvitesAsync()
		var res = await this.Discord.ApiClient.GetGuildInvitesAsync(this.Id).ConfigureAwait(false);
		if (!intents.HasIntent(DiscordIntents.GuildInvites))
	public Task&lt;DiscordInvite&gt; GetVanityInviteAsync()
		=&gt; this.Discord.ApiClient.GetGuildVanityUrlAsync(this.Id);
	public Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetWebhooksAsync()
		=&gt; this.Discord.ApiClient.GetGuildWebhooksAsync(this.Id);
	public string GetWidgetImage(WidgetType bannerType = WidgetType.Shield)
		return $&quot;{Utilities.GetApiBaseUri(this.Discord.Configuration)}{Endpoints.GUILDS}/{this.Id}{Endpoints.WIDGET_PNG}?style={param}&quot;;
	public async Task&lt;DiscordMember&gt; GetMemberAsync(ulong userId, bool fetch = false)
		if (!fetch &amp;&amp; this.MembersInternal.TryGetValue(userId, out var mbr))
		mbr = await this.Discord.ApiClient.GetGuildMemberAsync(this.Id, userId).ConfigureAwait(false);
		if (intents.HasIntent(DiscordIntents.GuildMembers))
	public async Task&lt;DiscordMember?&gt; TryGetMemberAsync(ulong userId, bool fetch = false)
	public bool TryGetMember(ulong userId, [NotNullWhen(true)] out DiscordMember? member)
		member = this.TryGetMemberAsync(userId).Result;
	public async Task&lt;IReadOnlyCollection&lt;DiscordMember&gt;&gt; GetAllMembersAsync()
		var hasIntent = intents.HasIntent(DiscordIntents.GuildMembers);
			var tms = await this.Discord.ApiClient.ListGuildMembersAsync(this.Id, 1000, last == 0 ? null : last).ConfigureAwait(false);
				var usr = new DiscordUser(xtm.User)
				usr = this.Discord.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
				var mbr = new DiscordMember(xtm)
				recmbr.Add(mbr);
			var tm = tms.LastOrDefault();
	public async Task RequestMembersAsync(string? query = null, int limit = 0, bool? presences = null, IEnumerable&lt;ulong&gt;? userIds = null, string? nonce = null)
			throw new InvalidOperationException(&quot;This operation is only valid for regular Discord clients.&quot;);
			throw new ArgumentException(&quot;The query and user IDs cannot both be null.&quot;);
		var grgm = new GatewayRequestGuildMembers(this)
		var payload = new GatewayPayload
		var payloadStr = JsonConvert.SerializeObject(payload, Formatting.None);
		await client.WsSendAsync(payloadStr).ConfigureAwait(false);
	public Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; GetChannelsAsync()
		=&gt; this.Discord.ApiClient.GetGuildChannelsAsync(this.Id);
	public Task&lt;DiscordRole&gt; CreateRoleAsync(string name = null, Permissions? permissions = null, DiscordColor? color = null, bool? hoist = null, bool? mentionable = null, string reason = null)
		=&gt; this.Discord.ApiClient.CreateGuildRoleAsync(this.Id, name, permissions, color?.Value, hoist, mentionable, reason);
	public DiscordRole? GetRole(ulong id)
		=&gt; this.RolesInternal.GetValueOrDefault(id);
	public async Task&lt;DiscordRole&gt; GetRoleAsync(ulong id)
		=&gt; await this.Discord.ApiClient.GetGuildRoleAsync(this.Id, id);
	public DiscordChannel? GetChannel(ulong id)
		=&gt; this.ChannelsInternal.GetValueOrDefault(id);
	public DiscordThreadChannel? GetThread(ulong id)
		=&gt; this.ThreadsInternal.GetValueOrDefault(id);
	public Task&lt;IReadOnlyList&lt;DiscordGuildEmoji&gt;&gt; GetEmojisAsync()
		=&gt; this.Discord.ApiClient.GetGuildEmojisAsync(this.Id);
	public Task&lt;DiscordGuildEmoji&gt; GetEmojiAsync(ulong id)
		=&gt; this.Discord.ApiClient.GetGuildEmojiAsync(this.Id, id);
	public Task&lt;DiscordGuildEmoji&gt; CreateEmojiAsync(string name, Stream image, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
		if (string.IsNullOrWhiteSpace(name))
			throw new ArgumentNullException(nameof(name));
		name = name.Trim();
			throw new ArgumentException(&quot;Emoji name needs to be between 2 and 50 characters long.&quot;);
		ArgumentNullException.ThrowIfNull(image);
		var image64 = MediaTool.Base64FromStream(image);
		return this.Discord.ApiClient.CreateGuildEmojiAsync(this.Id, name, image64, roles?.Select(xr =&gt; xr.Id), reason);
	public Task&lt;DiscordGuildEmoji&gt; ModifyEmojiAsync(DiscordGuildEmoji emoji, string name, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
		ArgumentNullException.ThrowIfNull(emoji);
			throw new ArgumentException(&quot;This emoji does not belong to this guild.&quot;);
			? throw new ArgumentException(&quot;Emoji name needs to be between 2 and 50 characters long.&quot;)
			: this.Discord.ApiClient.ModifyGuildEmojiAsync(this.Id, emoji.Id, name, roles?.Select(xr =&gt; xr.Id), reason);
	public Task DeleteEmojiAsync(DiscordGuildEmoji emoji, string? reason = null)
			? throw new ArgumentNullException(nameof(emoji))
				? throw new ArgumentException(&quot;This emoji does not belong to this guild.&quot;)
				: this.Discord.ApiClient.DeleteGuildEmojiAsync(this.Id, emoji.Id, reason);
	public async Task&lt;IReadOnlyList&lt;DiscordSticker&gt;&gt; GetStickersAsync()
		var stickers = await this.Discord.ApiClient.GetGuildStickersAsync(this.Id).ConfigureAwait(false);
			this.StickersInternal.AddOrUpdate(xstr.Id, xstr, (id, old) =&gt;
	public Task&lt;DiscordSticker&gt; GetStickerAsync(ulong stickerId)
		=&gt; this.Discord.ApiClient.GetGuildStickerAsync(this.Id, stickerId);
	public Task&lt;DiscordSticker&gt; CreateStickerAsync(string name, string description, DiscordEmoji emoji, Stream file, StickerFormat format, string? reason = null)
			_ =&gt; throw new InvalidOperationException(&quot;This format is not supported.&quot;)
			? throw new InvalidOperationException(&quot;Only unicode emoji can be used for stickers.&quot;)
				? throw new ArgumentOutOfRangeException(nameof(name), &quot;Sticker name needs to be between 2 and 30 characters long.&quot;)
					? throw new ArgumentOutOfRangeException(nameof(description), &quot;Sticker description needs to be between 1 and 100 characters long.&quot;)
					: this.Discord.ApiClient.CreateGuildStickerAsync(this.Id, name, description, emoji.GetDiscordName().Replace(&quot;:&quot;, &quot;&quot;), new(&quot;sticker&quot;, file, null, fileExt, contentType), reason);
	public async Task&lt;DiscordSticker&gt; ModifyStickerAsync(ulong sticker, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;DiscordEmoji&gt; emoji, string? reason = null)
		if (!this.StickersInternal.TryGetValue(sticker, out var stickerobj) || stickerobj.Guild.Id != this.Id)
			throw new ArgumentException(&quot;This sticker does not belong to this guild.&quot;);
			throw new ArgumentException(&quot;Sticker name needs to be between 2 and 30 characters long.&quot;);
			throw new ArgumentException(&quot;Sticker description needs to be between 1 and 100 characters long.&quot;);
			throw new ArgumentException(&quot;Only unicode emojis can be used with stickers.&quot;);
			uemoji = emoji.Value.GetDiscordName().Replace(&quot;:&quot;, &quot;&quot;);
		var usticker = await this.Discord.ApiClient.ModifyGuildStickerAsync(this.Id, sticker, name, description, uemoji, reason).ConfigureAwait(false);
		if (this.StickersInternal.TryGetValue(usticker.Id, out var old))
			this.StickersInternal.TryUpdate(usticker.Id, usticker, old);
	public Task&lt;DiscordSticker&gt; ModifyStickerAsync(DiscordSticker sticker, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;DiscordEmoji&gt; emoji, string? reason = null)
		=&gt; this.ModifyStickerAsync(sticker.Id, name, description, emoji, reason);
	public Task DeleteStickerAsync(ulong sticker, string? reason = null) =&gt;
		!this.StickersInternal.TryGetValue(sticker, out var stickerobj)
			? throw new ArgumentNullException(nameof(sticker))
				? throw new ArgumentException(&quot;This sticker does not belong to this guild.&quot;)
				: this.Discord.ApiClient.DeleteGuildStickerAsync(this.Id, sticker, reason);
	public Task DeleteStickerAsync(DiscordSticker sticker, string? reason = null)
		=&gt; this.DeleteStickerAsync(sticker.Id, reason);
	public DiscordChannel? GetDefaultChannel() =&gt;
		this.ChannelsInternal.Values.Where(xc =&gt; xc.Type == ChannelType.Text)
			.OrderBy(xc =&gt; xc.Position)
			.FirstOrDefault(xc =&gt; (xc.PermissionsFor(this.CurrentMember) &amp; Enums.Permissions.AccessChannels) == Enums.Permissions.AccessChannels);
	public Task&lt;DiscordWidget&gt; GetWidgetAsync()
		=&gt; this.Discord.ApiClient.GetGuildWidgetAsync(this.Id);
	public Task&lt;DiscordWidgetSettings&gt; GetWidgetSettingsAsync()
		=&gt; this.Discord.ApiClient.GetGuildWidgetSettingsAsync(this.Id);
	public Task&lt;DiscordWidgetSettings&gt; ModifyWidgetSettingsAsync(bool? isEnabled = null, DiscordChannel? channel = null, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildWidgetSettingsAsync(this.Id, isEnabled, channel?.Id, reason);
	public Task&lt;IReadOnlyList&lt;DiscordGuildTemplate&gt;&gt; GetTemplatesAsync()
		=&gt; this.Discord.ApiClient.GetGuildTemplatesAsync(this.Id);
	public Task&lt;DiscordGuildTemplate&gt; CreateTemplateAsync(string name, string? description = null)
		=&gt; this.Discord.ApiClient.CreateGuildTemplateAsync(this.Id, name, description);
	public Task&lt;DiscordGuildTemplate&gt; SyncTemplateAsync(string code)
		=&gt; this.Discord.ApiClient.SyncGuildTemplateAsync(this.Id, code);
	public Task&lt;DiscordGuildTemplate&gt; ModifyTemplateAsync(string code, string? name = null, string? description = null)
		=&gt; this.Discord.ApiClient.ModifyGuildTemplateAsync(this.Id, code, name, description);
	public Task&lt;DiscordGuildTemplate&gt; DeleteTemplateAsync(string code)
		=&gt; this.Discord.ApiClient.DeleteGuildTemplateAsync(this.Id, code);
	public Task&lt;DiscordGuildMembershipScreening&gt; GetMembershipScreeningFormAsync()
		=&gt; this.Discord.ApiClient.GetGuildMembershipScreeningFormAsync(this.Id);
	public async Task&lt;DiscordGuildMembershipScreening&gt; ModifyMembershipScreeningFormAsync(Action&lt;MembershipScreeningEditModel&gt; action)
		var mdl = new MembershipScreeningEditModel();
		return await this.Discord.ApiClient.ModifyGuildMembershipScreeningFormAsync(this.Id, mdl.Enabled, mdl.Fields, mdl.Description).ConfigureAwait(false);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetApplicationCommandsAsync() =&gt;
		this.Discord.ApiClient.GetGuildApplicationCommandsAsync(this.Discord.CurrentApplication.Id, this.Id);
	public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteApplicationCommandsAsync(IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
		this.Discord.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.Discord.CurrentApplication.Id, this.Id, commands);
	public Task&lt;DiscordApplicationCommand&gt; CreateApplicationCommandAsync(DiscordApplicationCommand command) =&gt;
		this.Discord.ApiClient.CreateGuildApplicationCommandAsync(this.Discord.CurrentApplication.Id, this.Id, command);
	public async Task&lt;DiscordApplicationCommand&gt; EditApplicationCommandAsync(ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
		var mdl = new ApplicationCommandEditModel();
		return await this.Discord.ApiClient.EditGuildApplicationCommandAsync(this.Discord.CurrentApplication.Id, this.Id, commandId, mdl.Name, mdl.Description!, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
	public Task&lt;DiscordGuildWelcomeScreen&gt; GetWelcomeScreenAsync() =&gt;
		this.Discord.ApiClient.GetGuildWelcomeScreenAsync(this.Id);
	public async Task&lt;DiscordGuildWelcomeScreen&gt; ModifyWelcomeScreenAsync(Action&lt;WelcomeScreenEditModel&gt; action)
		var mdl = new WelcomeScreenEditModel();
		return await this.Discord.ApiClient.ModifyGuildWelcomeScreenAsync(this.Id, mdl.Enabled, mdl.WelcomeChannels, mdl.Description).ConfigureAwait(false);
	public async Task&lt;DiscordSoundboardSound&gt; CreateSoundboardSoundAsync(string name, Stream sound, double? volume = null, ulong? emojiId = null, string? emojiName = null, string? reason = null)
		var sound64 = MediaTool.Base64FromStream(sound);
		return await this.Discord.ApiClient.CreateGuildSoundboardSoundAsync(this.Id, name, sound64, volume, emojiId, emojiName, reason);
	public async Task&lt;DiscordSoundboardSound&gt; ModifySoundboardSoundAsync(ulong soundId, Action&lt;SoundboardSoundEditModel&gt; action)
		var mdl = new SoundboardSoundEditModel();
		return await this.Discord.ApiClient.ModifyGuildSoundboardSoundAsync(
		).ConfigureAwait(false);
	public Task DeleteSoundboardSoundAsync(ulong soundId, string? reason = null)
		=&gt; this.Discord.ApiClient.DeleteGuildSoundboardSoundAsync(this.Id, soundId, reason);
	public Task&lt;DiscordSoundboardSound&gt; GetSoundboardSoundAsync(ulong soundId)
		=&gt; this.Discord.ApiClient.GetGuildSoundboardSoundAsync(this.Id, soundId);
	public Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListSoundboardSoundsAsync()
		=&gt; this.Discord.ApiClient.ListGuildSoundboardSoundsAsync(this.Id);
	public async Task&lt;DiscordGuildJoinRequestSearchResult&gt; GetJoinRequestsAsync(int limit = 100, JoinRequestStatusType? statusType = null, ulong? before = null, ulong? after = null)
		=&gt; await this.Discord.ApiClient.GetGuildJoinRequestsAsync(this.Id, limit, statusType, before, after);
	public async Task&lt;DiscordGuildJoinRequest&gt; GetJoinRequestAsync(ulong joinRequestId)
		=&gt; await this.Discord.ApiClient.GetGuildJoinRequestAsync(this.Id, joinRequestId);
	public async Task&lt;DiscordGuildJoinRequest&gt; ModifyJoinRequestsAsync(ulong joinRequestId, bool approve, string? rejectionReason)
		=&gt; await this.Discord.ApiClient.ModifyGuildJoinRequestsAsync(this.Id, joinRequestId, approve ? JoinRequestStatusType.Approved : JoinRequestStatusType.Rejected, rejectionReason);
	public async Task&lt;DiscordClanSettings&gt; GetClanSettingsAsync()
		=&gt; await this.Discord.ApiClient.GetClanSettingsAsync(this.Id);</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.Features.cs">public class GuildFeatures
		if (guild.RawFeatures.Contains(&quot;APPLICATION_COMMAND_PERMISSIONS_V2&quot;)) this.Features.Add(GuildFeaturesEnum.UsesApplicationCommandsPermissionsV2);
		if (guild.RawFeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.RaidAlertsEnabled);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_RESTRICTED&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableRestricted);
		if (guild.RawFeatures.Contains(&quot;VOICE_IN_THREADS&quot;)) this.Features.Add(GuildFeaturesEnum.VoiceInThreadsEnabled);
		if (guild.RawFeatures.Contains(&quot;CHANNEL_HIGHLIGHTS_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.ChannelHighlightsDisabled);
		if (guild.RawFeatures.Contains(&quot;CHANNEL_HIGHLIGHTS&quot;)) this.Features.Add(GuildFeaturesEnum.ChannelHighlights);
		if (guild.RawFeatures.Contains(&quot;GUILD_ONBOARDING_EVER_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HadGuildOnBoardingEverEnabled);
		if (guild.RawFeatures.Contains(&quot;BURST_REACTIONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanUseBurstReactions);
		if (guild.RawFeatures.Contains(&quot;CREATOR_STORE_PAGE&quot;)) this.Features.Add(GuildFeaturesEnum.CanUseCreatorStorePage);
		if (guild.RawFeatures.Contains(&quot;ANIMATED_ICON&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetAnimatedIcon);
		if (guild.RawFeatures.Contains(&quot;ANIMATED_BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetAnimatedBanner);
		if (guild.RawFeatures.Contains(&quot;BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetBanner);
		if (guild.RawFeatures.Contains(&quot;COMMUNITY&quot;)) this.Features.Add(GuildFeaturesEnum.HasCommunityEnabled);
		if (!guild.RawFeatures.Contains(&quot;DISCOVERABLE_DISABLED&quot;) &amp;&amp; guild.RawFeatures.Contains(&quot;DISCOVERABLE&quot;)) this.Features.Add(GuildFeaturesEnum.IsDiscoverable);
		if (guild.RawFeatures.Contains(&quot;FEATUREABLE&quot;)) this.Features.Add(GuildFeaturesEnum.IsFeatureable);
		if (guild.RawFeatures.Contains(&quot;INVITE_SPLASH&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetInviteSplash);
		if (guild.RawFeatures.Contains(&quot;MEMBER_VERIFICATION_GATE_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasMembershipScreeningEnabled);
		if (guild.RawFeatures.Contains(&quot;NEWS&quot;)) this.Features.Add(GuildFeaturesEnum.CanCreateNewsChannels);
		if (guild.RawFeatures.Contains(&quot;PARTNERED&quot;)) this.Features.Add(GuildFeaturesEnum.IsPartnered);
		if (guild.RawFeatures.Contains(&quot;MORE_EMOJI&quot;)) this.Features.Add(GuildFeaturesEnum.CanUploadMoreEmojis);
		if (guild.RawFeatures.Contains(&quot;PREVIEW_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasPreviewEnabled);
		if (guild.RawFeatures.Contains(&quot;VANITY_URL&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetVanityUrl);
		if (guild.RawFeatures.Contains(&quot;VERIFIED&quot;)) this.Features.Add(GuildFeaturesEnum.IsVerified);
		if (guild.RawFeatures.Contains(&quot;VIP_REGIONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanAccessVipRegions);
		if (guild.RawFeatures.Contains(&quot;WELCOME_SCREEN_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasWelcomeScreenEnabled);
		if (guild.RawFeatures.Contains(&quot;TICKETED_EVENTS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasTicketedEventsEnabled);
		if (guild.RawFeatures.Contains(&quot;MONETIZATION_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasMonetizationEnabled);
		if (guild.RawFeatures.Contains(&quot;MORE_STICKERS&quot;)) this.Features.Add(GuildFeaturesEnum.CanUploadMoreStickers);
		if (guild.RawFeatures.Contains(&quot;HUB&quot;)) this.Features.Add(GuildFeaturesEnum.IsHub);
		if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED_TESTING&quot;)) this.Features.Add(GuildFeaturesEnum.HasThreadTestingEnabled);
		if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasThreadsEnabled);
		if (guild.RawFeatures.Contains(&quot;ROLE_ICONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetRoleIcons);
		if (guild.RawFeatures.Contains(&quot;NEW_THREAD_PERMISSIONS&quot;)) this.Features.Add(GuildFeaturesEnum.HasNewThreadPermissions);
		if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasRoleSubscriptionsEnabled);
		if (guild.RawFeatures.Contains(&quot;PREMIUM_TIER_3_OVERRIDE&quot;)) this.Features.Add(GuildFeaturesEnum.PremiumTierThreeOverride);
		if (guild.RawFeatures.Contains(&quot;THREAD_DEFAULT_AUTO_ARCHIVE_DURATION&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetThreadDefaultAutoArchiveDuration);
		if (guild.RawFeatures.Contains(&quot;TEXT_IN_VOICE_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.TextInVoiceEnabled);
		if (guild.RawFeatures.Contains(&quot;HAS_DIRECTORY_ENTRY&quot;)) this.Features.Add(GuildFeaturesEnum.HasDirectoryEntry);
		if (guild.RawFeatures.Contains(&quot;LINKED_TO_HUB&quot;)) this.Features.Add(GuildFeaturesEnum.IsLinkedToHub);
		if (guild.RawFeatures.Contains(&quot;MEMBER_PROFILES&quot;)) this.Features.Add(GuildFeaturesEnum.HasMemberProfiles);
		if (guild.RawFeatures.Contains(&quot;INTERNAL_EMPLOYEE_ONLY&quot;)) this.Features.Add(GuildFeaturesEnum.IsStaffOnly);
		if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE&quot;)) this.Features.Add(GuildFeaturesEnum.RoleSubscriptionsIsAvailableForPurchase);
		if (guild.RawFeatures.Contains(&quot;AUTO_MODERATION&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetupAutoModeration);
		if (guild.RawFeatures.Contains(&quot;GUILD_HOME_TEST&quot;)) this.Features.Add(GuildFeaturesEnum.GuildHomeTest);
		if (guild.RawFeatures.Contains(&quot;INVITES_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.InvitesDisabled);
		if (guild.RawFeatures.Contains(&quot;ACTIVITIES_ALPHA&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesAlpha);
		if (guild.RawFeatures.Contains(&quot;ACTIVITIES_EMPLOYEE&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesEmployee);
		if (guild.RawFeatures.Contains(&quot;ACTIVITIES_INTERNAL_DEV&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesInternalDev);
		if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_KEYWORD_FILTER&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerKeywordFilter);
		if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_ML_SPAM_FILTER&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerMlSpamFilter);
		if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_SPAM_LINK_FILTERGuild&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerSpamLinkFilterGuild);
		if (guild.RawFeatures.Contains(&quot;AUTOMOD_DEFAULT_LIST&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodDefaultList);
		if (guild.RawFeatures.Contains(&quot;BFG&quot;)) this.Features.Add(GuildFeaturesEnum.Bfg);
		if (guild.RawFeatures.Contains(&quot;BOOSTING_TIERS_EXPERIMENT_MEDIUM_GUILD&quot;)) this.Features.Add(GuildFeaturesEnum.BoostingTiersExperimentMediumGuild);
		if (guild.RawFeatures.Contains(&quot;BOOSTING_TIERS_EXPERIMENT_SMALL_GUILD&quot;)) this.Features.Add(GuildFeaturesEnum.BoostingTiersExperimentSmallGuild);
		if (guild.RawFeatures.Contains(&quot;BOT_DEVELOPER_EARLY_ACCESS&quot;)) this.Features.Add(GuildFeaturesEnum.BotDeveloperEarlyAccess);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizable);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableDisabled);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_PROVISIONAL&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableProvisional);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_WHITEGLOVE&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableWhiteGlove);
		if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZATION_APPLICATION_ALLOWLIST&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizationApplicationAllowlist);
		if (guild.RawFeatures.Contains(&quot;DEVELOPER_SUPPORT_SERVER&quot;)) this.Features.Add(GuildFeaturesEnum.DeveloperSupportServer);
		if (guild.RawFeatures.Contains(&quot;EXPOSED_TO_ACTIVITIES_WTP_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.ExposedToActivitiesWtpExperiment);
		if (guild.RawFeatures.Contains(&quot;GUILD_COMMUNICATION_DISABLED_GUILDS&quot;)) this.Features.Add(GuildFeaturesEnum.GuildCommunicationDisabledGuilds);
		if (guild.RawFeatures.Contains(&quot;DISABLE_GUILD_COMMUNICATION&quot;)) this.Features.Add(GuildFeaturesEnum.DisableGuildCommunication);
		if (guild.RawFeatures.Contains(&quot;GUILD_HOME_OVERRIDE&quot;)) this.Features.Add(GuildFeaturesEnum.GuildHomeOverride);
		if (guild.RawFeatures.Contains(&quot;GUILD_AUTOMOD_DEFAULT_LIST&quot;)) this.Features.Add(GuildFeaturesEnum.GuildAutomodDefaultList);
		if (guild.RawFeatures.Contains(&quot;GUILD_MEMBER_VERIFICATION_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.GuildMemberVerificationExperiment);
		if (guild.RawFeatures.Contains(&quot;GUILD_ROLE_SUBSCRIPTION_PURCHASE_FEEDBACK_LOOP&quot;)) this.Features.Add(GuildFeaturesEnum.GuildRoleSubscriptionPurchaseFeedbackLoop);
		if (guild.RawFeatures.Contains(&quot;GUILD_ROLE_SUBSCRIPTION_TRIALS&quot;)) this.Features.Add(GuildFeaturesEnum.GuildRoleSubscriptionTrials);
		if (guild.RawFeatures.Contains(&quot;HAD_EARLY_ACTIVITIES_ACCESS&quot;)) this.Features.Add(GuildFeaturesEnum.HadEarlyActivitiesAccess);
		if (guild.RawFeatures.Contains(&quot;INCREASED_THREAD_LIMIT&quot;)) this.Features.Add(GuildFeaturesEnum.IncreasedThreadLimit);
		if (guild.RawFeatures.Contains(&quot;MOBILE_WEB_ROLE_SUBSCRIPTION_PURCHASE_PAGE&quot;)) this.Features.Add(GuildFeaturesEnum.MobileWebRoleSubscriptionPurchasePage);
		if (guild.RawFeatures.Contains(&quot;RELAY_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.RelayEnabled);
		if (guild.RawFeatures.Contains(&quot;RESTRICT_SPAM_RISK_GUILDS&quot;)) this.Features.Add(GuildFeaturesEnum.RestrictSpamRiskGuilds);
		if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE&quot;)) this.Features.Add(GuildFeaturesEnum.RoleSubscriptionsAvailableForPurchase);
		if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED_TESTING&quot;)) this.Features.Add(GuildFeaturesEnum.ThreadsEnabledTesting);
		if (guild.RawFeatures.Contains(&quot;VOICE_CHANNEL_EFFECTS&quot;)) this.Features.Add(GuildFeaturesEnum.VoiceChannelEffects);
		if (guild.RawFeatures.Contains(&quot;SOUNDBOARD&quot;)) this.Features.Add(GuildFeaturesEnum.Soundboard);
		if (guild.RawFeatures.Contains(&quot;COMMERCE&quot;)) this.Features.Add(GuildFeaturesEnum.Commerce);
		if (guild.RawFeatures.Contains(&quot;EXPOSED_TO_BOOSTING_TIERS_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.ExposedToBoostingTiersExperiment);
		if (guild.RawFeatures.Contains(&quot;PUBLIC_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.PublicDisabled);
		if (guild.RawFeatures.Contains(&quot;PUBLIC&quot;)) this.Features.Add(GuildFeaturesEnum.Public);
		if (guild.RawFeatures.Contains(&quot;SEVEN_DAY_THREAD_ARCHIVE&quot;)) this.Features.Add(GuildFeaturesEnum.SevenDayThreadArchive);
		if (guild.RawFeatures.Contains(&quot;THREE_DAY_THREAD_ARCHIVE&quot;)) this.Features.Add(GuildFeaturesEnum.ThreeDayThreadArchive);
		if (guild.RawFeatures.Contains(&quot;FEATURABLE&quot;)) this.Features.Add(GuildFeaturesEnum.Featurable);
		if (guild.RawFeatures.Contains(&quot;FORCE_RELAY&quot;)) this.Features.Add(GuildFeaturesEnum.ForceRelay);
		if (guild.RawFeatures.Contains(&quot;LURKABLE&quot;)) this.Features.Add(GuildFeaturesEnum.Lurkable);
		if (guild.RawFeatures.Contains(&quot;MEMBER_LIST_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.MemberListDisabled);
		if (guild.RawFeatures.Contains(&quot;CHANNEL_BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetChannelBanner);
		if (guild.RawFeatures.Contains(&quot;PRIVATE_THREADS&quot;)) this.Features.Add(GuildFeaturesEnum.CanCreatePrivateThreads);
	public bool HasFeature(GuildFeaturesEnum flag)
		=&gt; this.Features.Contains(flag);
	public string ToString(string separator, bool humanReadable)
		if (!humanReadable) return string.Join(separator, this.Features);
		var humanReadableFeatures = this.Features.Select(x =&gt; AddSpacesToWord(x.ToString()));
		return string.Join(separator, humanReadableFeatures);
	private static string AddSpacesToWord(string text)
		if (string.IsNullOrWhiteSpace(text))
		var newText = new StringBuilder(text.Length * 2);
		newText.Append(text[0]);
			if (char.IsUpper(text[i]) &amp;&amp; text[i - 1] != &apos; &apos;)
				newText.Append(&apos; &apos;);
			newText.Append(text[i]);
		return newText.ToString();</file><file path="DisCatSharp/Entities/Guild/DiscordGuildEmoji.cs">public sealed class DiscordGuildEmoji : DiscordEmoji
	public Task&lt;DiscordGuildEmoji&gt; ModifyAsync(string name, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
		=&gt; this.Guild.ModifyEmojiAsync(this, name, roles, reason);
	public Task DeleteAsync(string reason = null)
		=&gt; this.Guild.DeleteEmojiAsync(this, reason);</file><file path="DisCatSharp/Entities/Guild/DiscordGuildInventorySettings.cs">public sealed class DiscordGuildInventorySettings</file><file path="DisCatSharp/Entities/Guild/DiscordGuildJoinRequest.cs">public sealed class DiscordGuildJoinRequest : SnowflakeObject
	public async Task&lt;DiscordGuildJoinRequest&gt; ModifyAsync(bool approve, string? rejectionReason)
		=&gt; await this.Discord.ApiClient.ModifyGuildJoinRequestsAsync(this.GuildId, this.RequestId, approve ? JoinRequestStatusType.Approved : JoinRequestStatusType.Rejected, rejectionReason);</file><file path="DisCatSharp/Entities/Guild/DiscordGuildJoinRequestSearchResult.cs">public sealed class DiscordGuildJoinRequestSearchResult : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreening.cs">public class DiscordGuildMembershipScreening : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningField.cs">public class DiscordGuildMembershipScreeningField : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningFieldResponse.cs">public sealed class DiscordGuildMembershipScreeningFieldResponse : DiscordGuildMembershipScreeningField</file><file path="DisCatSharp/Entities/Guild/DiscordGuildPreview.cs">public class DiscordGuildPreview : SnowflakeObject
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{(this.IconHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.png?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.DiscoverySplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_DISCOVERY_SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.DiscoverySplashHash}.png?size=1024&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.HomeHeaderHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_HOME_HEADERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.HomeHeaderHash}.jpg?size=1280&quot; : null;</file><file path="DisCatSharp/Entities/Guild/DiscordGuildTemplate.cs">public class DiscordGuildTemplate : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreen.cs">public class DiscordGuildWelcomeScreen : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreenChannel.cs">public class DiscordGuildWelcomeScreenChannel : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/DiscordMember.cs">public class DiscordMember : DiscordUser, IEquatable&lt;DiscordMember&gt;
		=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHash) ? this.User.AvatarUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHash}.{(this.GuildAvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHash) ? this.User.BannerUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHash}.{(this.GuildBannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; this.RoleIds.Select(id =&gt; this.Guild.GetRole(id)).Where(x =&gt; x is not null).ToList()!;
			var role = this.Roles.OrderByDescending(xr =&gt; xr.Position).FirstOrDefault(xr =&gt; xr.Color.Value is not 0);
		=&gt; this.CommunicationDisabledUntil is not null &amp;&amp; this.CommunicationDisabledUntil.Value.ToUniversalTime() &gt; DateTime.UtcNow;
		=&gt; this.UnusualDmActivityUntil is not null &amp;&amp; this.UnusualDmActivityUntil.Value.ToUniversalTime() &gt; DateTime.UtcNow;
		=&gt; this.Discord.Guilds[this.GuildId].VoiceStates.GetValueOrDefault(this.Id);
				: this.Roles.Max(x =&gt; x.Position);
		=&gt; this.InteractionPermissions ?? this.GetPermissions();
	public bool Equals(DiscordMember e)
	public Task SetMuteAsync(bool mute, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, mute, default, default, default, this.MemberFlags, reason);
	public Task VerifyAsync(string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, default, default, true, this.MemberFlags, reason);
	public Task UnverifyAsync(string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, default, default, false, this.MemberFlags, reason);
	public Task SetDeafAsync(bool deaf, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, deaf, default, default, this.MemberFlags, reason);
	public async Task ModifyAsync(Action&lt;MemberEditModel&gt; action)
		var mdl = new MemberEditModel();
			throw new ArgumentException(&quot;Given channel is not a voice or stage channel.&quot;, nameof(action));
			await this.Discord.ApiClient.ModifyCurrentMemberNicknameAsync(this.Guild.Id, mdl.Nickname.Value,
				mdl.AuditLogReason).ConfigureAwait(false);
			await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, Optional.None,
				mdl.Roles.Map(e =&gt; e.Select(xr =&gt; xr.Id)), mdl.Muted, mdl.Deafened,
				mdl.VoiceChannel.Map(e =&gt; e?.Id), default, this.MemberFlags, mdl.AuditLogReason).ConfigureAwait(false);
			await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, mdl.Nickname,
	public async Task DisconnectFromVoiceAsync()
		=&gt; await this.ModifyAsync(x =&gt; x.VoiceChannel = null!).ConfigureAwait(false);
	public Task TimeoutAsync(DateTimeOffset until, string? reason = null)
		=&gt; until.Subtract(DateTimeOffset.UtcNow).Days &gt; 28 ? throw new ArgumentException(&quot;Timeout can not be longer than 28 days&quot;) : this.Discord.ApiClient.ModifyTimeoutAsync(this.Guild.Id, this.Id, until, reason);
	public Task TimeoutAsync(TimeSpan until, string? reason = null)
		=&gt; this.TimeoutAsync(DateTimeOffset.UtcNow + until, reason);
	public Task TimeoutAsync(DateTime until, string? reason = null)
		=&gt; this.TimeoutAsync(until.ToUniversalTime() - DateTime.UtcNow, reason);
	public Task RemoveTimeoutAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyTimeoutAsync(this.Guild.Id, this.Id, null, reason);
	public Task GrantRoleAsync(DiscordRole role, string? reason = null)
		=&gt; this.Discord.ApiClient.AddGuildMemberRoleAsync(this.Guild.Id, this.Id, role.Id, reason);
	public Task RevokeRoleAsync(DiscordRole role, string? reason = null)
		=&gt; this.Discord.ApiClient.RemoveGuildMemberRoleAsync(this.Guild.Id, this.Id, role.Id, reason);
	public Task ReplaceRolesAsync(IEnumerable&lt;DiscordRole&gt; roles, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, default,
			Optional.Some(roles.Select(xr =&gt; xr.Id)), default, default, default, default, this.MemberFlags, reason);
	public Task BanAsync(int deleteMessageDays = 0, string? reason = null)
		=&gt; this.Guild.BanMemberAsync(this, deleteMessageDays, reason);
	public Task UnbanAsync(string? reason = null)
		=&gt; this.Guild.UnbanMemberAsync(this, reason);
	public Task RemoveAsync(string? reason = null)
		=&gt; this.Discord.ApiClient.RemoveGuildMemberAsync(this.GuildId, this.Id, reason);
	public Task PlaceInAsync(DiscordChannel channel)
		=&gt; channel.PlaceMemberAsync(this);
	public async Task&lt;DiscordVoiceState?&gt; GetVoiceStateAsync()
		=&gt; await this.Discord.ApiClient.GetMemberVoiceStateAsync(this.Guild.Id, this.Id);
	public async Task UpdateVoiceStateAsync(DiscordChannel channel, bool? suppress)
			throw new ArgumentException(&quot;Voice state can only be updated in a stage channel.&quot;);
		await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, channel.Id, suppress).ConfigureAwait(false);
	public async Task MakeSpeakerAsync()
			throw new ArgumentException(&quot;Voice state can only be updated when the user is inside an stage channel.&quot;);
		await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, vs.Channel.Id, false).ConfigureAwait(false);
	public async Task MoveToAudienceAsync()
		await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, vs.Channel.Id, true).ConfigureAwait(false);
	public Permissions PermissionsIn(DiscordChannel channel)
		=&gt; channel.PermissionsFor(this);
	private Permissions GetPermissions()
		perms |= this.Roles.Aggregate(Permissions.None, (c, role) =&gt; c | role.Permissions);
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordMember);
	public override int GetHashCode()
		hash = (hash * 7) + this.Id.GetHashCode();
		hash = (hash * 7) + this.GuildId.GetHashCode();
		=&gt; this.Discord?.UserCache.TryGetValue(this.Id, out var user) ?? false ? user : this.ManualUser;</file><file path="DisCatSharp/Entities/Guild/DiscordRole.cs">public sealed class DiscordRole : SnowflakeObject, IEquatable&lt;DiscordRole&gt;
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ROLE_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=64&quot; : null;
		=&gt; this.UnicodeEmojiString != null ? DiscordEmoji.FromName(this.Discord, $&quot;:{this.UnicodeEmojiString}:&quot;, false) : null;
		=&gt; this.Mention();
		=&gt; this.Guild.Members.Where(x =&gt; x.Value.RoleIds.Any(x =&gt; x == this.Id)).ToList();
	public bool Equals(DiscordRole e)
	public PermissionLevel CheckPermission(Permissions permission)
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordRole);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public Task ModifyPositionAsync(int position, string? reason = null)
		var roles = this.Guild.Roles.Values.OrderByDescending(xr =&gt; xr.Position)
			.Select(x =&gt; new RestGuildRoleReorderPayload
		return this.Discord.ApiClient.ModifyGuildRolePositionAsync(this.GuildId, roles, reason);
	public Task ModifyAsync(string name = null, Permissions? permissions = null, DiscordColor? color = null, bool? hoist = null, bool? mentionable = null, string? reason = null)
		=&gt; this.Discord.ApiClient.ModifyGuildRoleAsync(this.GuildId, this.Id, name, permissions, color?.Value, hoist, mentionable, Optional.None, Optional.None, reason);
	public Task ModifyAsync(Action&lt;RoleEditModel&gt; action)
		var mdl = new RoleEditModel();
			canContinue = this.Guild.Features.HasFeature(GuildFeaturesEnum.CanSetRoleIcons);
			true when mdl.Icon.Value != null =&gt; MediaTool.Base64FromStream(mdl.Icon),
					.MapOrNull(e =&gt; e.Id == 0
						: throw new ArgumentException(&quot;Emoji must be unicode&quot;));
		return canContinue ? this.Discord.ApiClient.ModifyGuildRoleAsync(this.GuildId, this.Id, mdl.Name, mdl.Permissions, mdl.Color?.Value, mdl.Hoist, mdl.Mentionable, iconb64, emoji, mdl.AuditLogReason) : throw new NotSupportedException(&quot;Cannot modify role icon. Guild needs boost tier two.&quot;);
	public Task DeleteAsync(string? reason = null)
		=&gt; this.Discord.ApiClient.DeleteRoleAsync(this.GuildId, this.Id, reason);</file><file path="DisCatSharp/Entities/Guild/DiscordRoleTags.cs">public sealed class DiscordRoleTags : ObservableApiObject
	public RoleType DetermineRoleType()</file><file path="DisCatSharp/Entities/Guild/IncidentsData.cs">public class IncidentsData : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboarding.cs">public sealed class DiscordOnboarding : ObservableApiObject
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPrompt.cs">public sealed class DiscordOnboardingPrompt : SnowflakeObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPromptOption.cs">public sealed class DiscordOnboardingPromptOption : SnowflakeObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordServerGuide.cs">public sealed class DiscordServerGuide : ObservableApiObject
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp/Entities/Guild/Onboarding/NewMemberAction.cs">public sealed class NewMemberAction : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/ResourceChannel.cs">public sealed class ResourceChannel : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/WelcomeMessage.cs">public sealed class WelcomeMessage : ObservableApiObject
		=&gt; this.AuthorIds.First();</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordRecurrenceRuleNWeekday.cs">public sealed class DiscordRecurrenceRuleNWeekday</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEvent.cs">public class DiscordScheduledEvent : SnowflakeObject, IEquatable&lt;DiscordScheduledEvent&gt;
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
		=&gt; this.ChannelId.HasValue ? this.Discord.ApiClient.GetChannelAsync(this.ChannelId.Value).Result : null;
		=&gt; this.Guild.MembersInternal.TryGetValue(this.CreatorId, out var owner)
			: this.Discord.ApiClient.GetGuildMemberAsync(this.GuildId, this.CreatorId).Result;
		=&gt; !string.IsNullOrWhiteSpace(this.CoverImageHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.GUILD_EVENTS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.CoverImageHash}.png&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.ScheduledStartTimeRaw) &amp;&amp; DateTimeOffset.TryParse(this.ScheduledStartTimeRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.ScheduledEndTimeRaw) &amp;&amp; DateTimeOffset.TryParse(this.ScheduledEndTimeRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
	public bool Equals(DiscordScheduledEvent e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordScheduledEvent);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public async Task ModifyAsync(Action&lt;ScheduledEventEditModel&gt; action)
		var mdl = new ScheduledEventEditModel();
					? throw new ArgumentException(&quot;Channel needs to be a voice or stage channel.&quot;)
		var coverb64 = MediaTool.Base64FromStream(mdl.CoverImage);
		await this.Discord.ApiClient.ModifyGuildScheduledEventAsync(this.GuildId, this.Id, channelId, this.EntityType == ScheduledEventEntityType.External ? new DiscordScheduledEventEntityMetadata(mdl.Location.Value) : null, mdl.Name, mdl.ScheduledStartTime, scheduledEndTime, mdl.Description, mdl.EntityType, mdl.Status, coverb64, mdl.RecurrenceRule, mdl.AuditLogReason).ConfigureAwait(false);
	public async Task&lt;DiscordScheduledEvent&gt; StartAsync(string reason = null)
		=&gt; this.Status == ScheduledEventStatus.Scheduled ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Active, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only start scheduled events&quot;);
	public async Task&lt;DiscordScheduledEvent&gt; CancelAsync(string reason = null)
		=&gt; this.Status == ScheduledEventStatus.Scheduled ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Canceled, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only cancel scheduled events&quot;);
	public async Task&lt;DiscordScheduledEvent&gt; EndAsync(string reason = null)
		=&gt; this.Status == ScheduledEventStatus.Active ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Completed, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only stop active events&quot;);
	public async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEventUser&gt;&gt; GetUsersAsync(int? limit = null, ulong? before = null, ulong? after = null, bool? withMember = null)
		=&gt; await this.Discord.ApiClient.GetGuildScheduledEventRspvUsersAsync(this.GuildId, this.Id, limit, before, after, withMember).ConfigureAwait(false);
	public async Task DeleteAsync(string reason = null)
		=&gt; await this.Discord.ApiClient.DeleteGuildScheduledEventAsync(this.GuildId, this.Id, reason).ConfigureAwait(false);</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventEntityMetadata.cs">public class DiscordScheduledEventEntityMetadata : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRule.cs">public sealed class DiscordScheduledEventRecurrenceRule</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRuleValidator.cs">public static class DiscordScheduledEventRecurrenceRuleValidator
	private static List&lt;RecurrenceRuleWeekday&gt; CreateWeekdaySet(params RecurrenceRuleWeekday[] weekdays)
	public static (bool IsValid, string? ErrorMessage) Validate(this DiscordScheduledEventRecurrenceRule rule)
					RecurrenceRuleFrequency.Daily =&gt; rule.ValidateDailyFrequency(),
					RecurrenceRuleFrequency.Weekly =&gt; rule.ValidateWeeklyFrequency(),
					RecurrenceRuleFrequency.Monthly =&gt; rule.ValidateMonthlyFrequency(),
					RecurrenceRuleFrequency.Yearly =&gt; rule.ValidateYearlyFrequency(),
	private static (bool IsValid, string? ErrorMessage) ValidateDailyFrequency(this DiscordScheduledEventRecurrenceRule rule)
		=&gt; rule.ByWeekday is not null &amp;&amp; !rule.ByWeekday.IsValidDailyWeekdaySet()
	private static (bool IsValid, string? ErrorMessage) ValidateWeeklyFrequency(this DiscordScheduledEventRecurrenceRule rule)
	private static (bool IsValid, string? ErrorMessage) ValidateMonthlyFrequency(this DiscordScheduledEventRecurrenceRule rule)
	private static (bool IsValid, string? ErrorMessage) ValidateYearlyFrequency(this DiscordScheduledEventRecurrenceRule rule)
	private static bool IsValidDailyWeekdaySet(this IReadOnlyCollection&lt;RecurrenceRuleWeekday&gt; byWeekday)
		=&gt; s_validDailyWeekdaySets.Any(set =&gt; set.SequenceEqual(byWeekday));</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventUser.cs">public class DiscordScheduledEventUser : ObservableApiObject, IEquatable&lt;DiscordScheduledEventUser&gt;
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) &amp;&amp; guild.ScheduledEvents.TryGetValue(this.EventId, out var scheduledEvent) ? scheduledEvent : null;
	public bool Equals(DiscordScheduledEventUser e)
		=&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || HashCode.Combine(this.User.Id, this.EventId) == HashCode.Combine(e.User.Id, e.EventId));
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordScheduledEventUser);
	public override int GetHashCode()
		=&gt; HashCode.Combine(this.User.Id, this.EventId);
		return (o1 != null || o2 == null) &amp;&amp; (o1 == null || o2 != null) &amp;&amp; ((o1 == null &amp;&amp; o2 == null) || HashCode.Combine(e1.User.Id, e1.EventId) == HashCode.Combine(e2.User.Id, e2.EventId));</file><file path="DisCatSharp/Entities/Guild/Stage/DiscordStageInstance.cs">public class DiscordStageInstance : SnowflakeObject, IEquatable&lt;DiscordStageInstance&gt;
			? this.Guild.ScheduledEvents.GetValueOrDefault(this.ScheduledEventId.Value)
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
	public bool Equals(DiscordStageInstance e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordStageInstance);
	public override int GetHashCode() =&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannel.cs">public class DiscordThreadChannel : DiscordChannel
		=&gt; this.AppliedTagIds?.Select(id =&gt; this.Parent.GetForumPostTag(id)).Where(x =&gt; x != null).ToList();
	public Task ModifyAsync(Action&lt;ThreadEditModel&gt; action)
		var mdl = new ThreadEditModel();
		return this.Parent.Type == ChannelType.Forum &amp;&amp; mdl.AppliedTags.HasValue &amp;&amp; mdl.AppliedTags.Value.Count() &gt; 5
			? throw new NotSupportedException(&quot;Cannot have more than 5 applied tags.&quot;)
			: this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, mdl.Name, mdl.Locked, mdl.Archived, mdl.PerUserRateLimit, mdl.AutoArchiveDuration, mdl.Invitable, mdl.AppliedTags, mdl.Pinned, mdl.AuditLogReason);
	public Task AddTagAsync(ForumPostTag tag, string reason = null)
			: this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, null, null, null, null, new List&lt;ForumPostTag&gt;(this.AppliedTags)
	public async Task RemoveTagAsync(ForumPostTag tag, string reason = null)
		=&gt; await this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, null, null, null, null, new List&lt;ForumPostTag&gt;(this.AppliedTags).Where(x =&gt; x != tag).ToList(), null, reason).ConfigureAwait(false);
	public Task ArchiveAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, true, null, null, null, null, null, reason);
	public Task UnarchiveAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, false, null, null, null, null, null, reason);
	public Task LockAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, true, null, null, null, null, null, null, reason);
	public Task UnlockAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, false, true, null, null, null, null, null, reason);
	public async Task&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt; GetMembersAsync(bool withMember = false, ulong? after = null, int? limit = null)
		=&gt; await this.Discord.ApiClient.GetThreadMembersAsync(this.Id).ConfigureAwait(false);
	public Task AddMemberAsync(ulong memberId)
		=&gt; this.Discord.ApiClient.AddThreadMemberAsync(this.Id, memberId);
	public Task AddMemberAsync(DiscordMember member)
		=&gt; this.AddMemberAsync(member.Id);
	public Task&lt;DiscordThreadChannelMember&gt; GetMemberAsync(ulong memberId, bool withMember = false)
		=&gt; this.Discord.ApiClient.GetThreadMemberAsync(this.Id, memberId, withMember);
	public async Task&lt;DiscordThreadChannelMember?&gt; TryGetMemberAsync(ulong memberId, bool withMember = false)
			return await this.GetMemberAsync(memberId, withMember).ConfigureAwait(false);
	public Task&lt;DiscordThreadChannelMember&gt; GetMemberAsync(DiscordMember member, bool withMember = false)
		=&gt; this.Discord.ApiClient.GetThreadMemberAsync(this.Id, member.Id, withMember);
	public async Task&lt;DiscordThreadChannelMember?&gt; TryGetMemberAsync(DiscordMember member, bool withMember = false)
			return await this.GetMemberAsync(member, withMember).ConfigureAwait(false);
	public Task RemoveMemberAsync(ulong memberId)
		=&gt; this.Discord.ApiClient.RemoveThreadMemberAsync(this.Id, memberId);
	public Task RemoveMemberAsync(DiscordMember member)
		=&gt; this.RemoveMemberAsync(member.Id);
	public async Task AddRoleAsync(ulong roleId)
		var role = this.Guild.GetRole(roleId);
		var members = await this.Guild.GetAllMembersAsync().ConfigureAwait(false);
		var roleMembers = members.Where(m =&gt; m.Roles.Contains(role));
			await this.Discord.ApiClient.AddThreadMemberAsync(this.Id, member.Id).ConfigureAwait(false);
	public Task AddRoleAsync(DiscordRole role)
		=&gt; this.AddRoleAsync(role.Id);
	public async Task RemoveRoleAsync(ulong roleId)
			await this.Discord.ApiClient.RemoveThreadMemberAsync(this.Id, member.Id).ConfigureAwait(false);
	public Task RemoveRoleAsync(DiscordRole role)
		=&gt; this.RemoveRoleAsync(role.Id);
	public Task JoinAsync()
		=&gt; this.Discord.ApiClient.JoinThreadAsync(this.Id);
	public Task LeaveAsync()
		=&gt; this.Discord.ApiClient.LeaveThreadAsync(this.Id);
	public override string ToString()</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMember.cs">public class DiscordThreadChannelMember : SnowflakeObject, IEquatable&lt;DiscordThreadChannelMember&gt;
		=&gt; !string.IsNullOrWhiteSpace(this.JoinTimeStampRaw) &amp;&amp; DateTimeOffset.TryParse(this.JoinTimeStampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; this.Guild != null &amp;&amp; this.Guild.ThreadsInternal.TryGetValue(this.Id, out var thread) ? thread : null;
		=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
	public bool Equals(DiscordThreadChannelMember e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordThreadChannelMember);
	public override int GetHashCode()
		=&gt; HashCode.Combine(this.Id.GetHashCode(), this.UserId.GetHashCode());</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMetadata.cs">public class DiscordThreadChannelMetadata : ObservableApiObject
		=&gt; !string.IsNullOrWhiteSpace(this.ArchiveTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.ArchiveTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.CreateTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.CreateTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadResult.cs">public class DiscordThreadResult : ObservableApiObject
			: this.Threads.Select(t =&gt; new
			}).ToDictionary(t =&gt; t.Id, t =&gt; t.t);</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/ForumPostTag.cs">public class ForumPostTag : NullableSnowflakeObject, IEquatable&lt;ForumPostTag&gt;
	internal DiscordChannel Channel;
		=&gt; this.UnicodeEmojiString != null ? DiscordEmoji.FromName(this.Discord, $&quot;:{this.UnicodeEmojiString}:&quot;, false) : DiscordEmoji.FromGuildEmote(this.Discord, this.EmojiId.Value);
	public bool Equals(ForumPostTag e)
	public async Task&lt;ForumPostTag&gt; ModifyAsync(Action&lt;ForumPostTagEditModel&gt; action)
		var mdl = new ForumPostTagEditModel();
		var res = await this.Discord.ApiClient.ModifyForumChannelAsync(this.ChannelId, null, null, null, null, null, null, this.Channel.InternalAvailableTags.Where(x =&gt; x.Id != this.Id).ToList().Append(new()
		}).ToList(), null, null, null, null, null, null, null, null, mdl.AuditLogReason);
		return res.InternalAvailableTags.First(x =&gt; x.Id == this.Id);
	public Task DeleteAsync(string reason = null)
		=&gt; this.Discord.ApiClient.ModifyForumChannelAsync(this.ChannelId, null, null, Optional.None, Optional.None, null, Optional.None, this.Channel.InternalAvailableTags.Where(x =&gt; x.Id != this.Id).ToList(), Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, null, Optional.None, reason);
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as ForumPostTag);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/ForumReactionEmoji.cs">public class ForumReactionEmoji : ObservableApiObject
	public DiscordEmoji GetEmoji(DiscordClient client)
		=&gt; this.EmojiName != null ? DiscordEmoji.FromName(client, $&quot;:{this.EmojiName}:&quot;, false) : DiscordEmoji.FromGuildEmote(client, this.EmojiId.Value);</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidget.cs">public class DiscordWidget : SnowflakeObject</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidgetMember.cs">public class DiscordWidgetMember : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidgetSettings.cs">public class DiscordWidgetSettings : ObservableApiObject</file><file path="DisCatSharp/Entities/Integration/DiscordIntegration.cs">public class DiscordIntegration : SnowflakeObject</file><file path="DisCatSharp/Entities/Integration/DiscordIntegrationAccount.cs">public class DiscordIntegrationAccount : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/AuthorizingIntegrationOwners.cs">public sealed class AuthorizingIntegrationOwners</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordButtonComponent.cs">public sealed class DiscordButtonComponent : DiscordBaseButtonComponent
			throw new InvalidEnumArgumentException(&quot;Can not use link or premium style on this type of button&quot;);
		this.CustomId = customId ?? Guid.NewGuid().ToString();
			this.Label = label ?? throw new ArgumentException(&quot;Label can only be null if emoji is set.&quot;);
	public DiscordButtonComponent Enable()
		=&gt; this.SetState(false);
	public DiscordButtonComponent Disable()
		=&gt; this.SetState(true);
	public DiscordButtonComponent SetState(bool disabled)
	public DiscordButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordLinkButtonComponent.cs">public class DiscordLinkButtonComponent : DiscordBaseButtonComponent
	public DiscordLinkButtonComponent Enable()
	public DiscordLinkButtonComponent Disable()
	public DiscordLinkButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordPremiumButtonComponent.cs">public class DiscordPremiumButtonComponent : DiscordBaseButtonComponent
	public DiscordPremiumButtonComponent Enable()
	public DiscordPremiumButtonComponent Disable()
	public DiscordPremiumButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponent.cs">public sealed class DiscordActionRowComponent : DiscordComponent
		this.Components = components.ToList().AsReadOnly();
	public DiscordActionRowComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponentResult.cs">public sealed class DiscordActionRowComponentResult : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordComponent.cs">public class DiscordComponent : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordComponentEmoji.cs">public sealed class DiscordComponentEmoji : ObservableApiObject
		if (!DiscordEmoji.IsValidUnicode(name))
			throw new ArgumentException(&quot;Only unicode emojis can be passed.&quot;);</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordComponentResult.cs">public sealed class DiscordComponentResult : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordBaseSelectComponent.cs">public class DiscordBaseSelectComponent : DiscordComponent
		this.CustomId = customId ?? Guid.NewGuid().ToString();
			if (defaultValues.Count() &gt; maxOptions)
				throw new OverflowException(&quot;The amount of default values cannot exceed the maximum amount of selectable options.&quot;);
			if (type == ComponentType.MentionableSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type == &quot;channel&quot;))
				throw new ArgumentException(&quot;The default values for a mentionable select must be of type user or role.&quot;, nameof(defaultValues));
			if (type == ComponentType.ChannelSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;channel&quot;))
				throw new ArgumentException(&quot;The default values for a channel select menus must be of type channel.&quot;, nameof(defaultValues));
			if (type == ComponentType.UserSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;user&quot;))
				throw new ArgumentException(&quot;The default values for a user select menus must be of type user.&quot;, nameof(defaultValues));
			if (type == ComponentType.RoleSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;role&quot;))
				throw new ArgumentException(&quot;The default values for a role select menus must be of type role.&quot;, nameof(defaultValues));</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordChannelSelectComponent.cs">public sealed class DiscordChannelSelectComponent : DiscordBaseSelectComponent
	public DiscordChannelSelectComponent Enable()
	public DiscordChannelSelectComponent Disable()
	public DiscordChannelSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordMentionableSelectComponent.cs">public sealed class DiscordMentionableSelectComponent : DiscordBaseSelectComponent
	public DiscordMentionableSelectComponent Enable()
	public DiscordMentionableSelectComponent Disable()
	public DiscordMentionableSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordRoleSelectComponent.cs">public sealed class DiscordRoleSelectComponent : DiscordBaseSelectComponent
	public DiscordRoleSelectComponent Enable()
	public DiscordRoleSelectComponent Disable()
	public DiscordRoleSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordSelectDefaultValue.cs">public sealed class DiscordSelectDefaultValue</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponent.cs">public sealed class DiscordStringSelectComponent : DiscordBaseSelectComponent
		this.Options = options.ToArray();
	public DiscordStringSelectComponent Enable()
	public DiscordStringSelectComponent Disable()
	public DiscordStringSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponentOption.cs">public sealed class DiscordStringSelectComponentOption : ObservableApiObject
			throw new NotSupportedException(&quot;Select label can&apos;t be longer then 100 chars.&quot;);
			throw new NotSupportedException(&quot;Select value can&apos;t be longer then 100 chars.&quot;);
			throw new NotSupportedException(&quot;Select description can&apos;t be longer then 100 chars.&quot;);</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordUserSelectComponent.cs">public sealed class DiscordUserSelectComponent : DiscordBaseSelectComponent
	public DiscordUserSelectComponent Enable()
	public DiscordUserSelectComponent Disable()
	public DiscordUserSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Text/DiscordTextComponent.cs">public sealed class DiscordTextComponent : DiscordComponent
		this.CustomId = customId ?? Guid.NewGuid().ToString();
	public DiscordTextComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordBaseButtonComponent.cs"></file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordContainerComponent.cs">public sealed class DiscordContainerComponent : DiscordComponent
		var comps = components.ToList();
			throw new ArgumentException(&quot;You can only have up to 10 components in a container.&quot;);
		if (comps.Any(c =&gt; !allowedTypes.Contains(c.Type)))
			throw new ArgumentException(&quot;All components must be of type ActionRow, TextDisplay, Section, MediaGallery, Separator, or File.&quot;);
	public DiscordContainerComponent AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
	public DiscordContainerComponent AddComponent(DiscordComponent component)
		if (!allowedTypes.Contains(component.Type))
	public DiscordContainerComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordFileDisplayComponent.cs">public sealed class DiscordFileDisplayComponent : DiscordComponent
		ArgumentException.ThrowIfNullOrEmpty(url);
		if (!url.StartsWith(&quot;attachment://&quot;, StringComparison.Ordinal))
			throw new ArgumentException(&quot;File URL must start with &apos;attachment://&apos;.&quot;, nameof(url));
	public DiscordFileDisplayComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryComponent.cs">public sealed class DiscordMediaGalleryComponent : DiscordComponent
		var it = items.ToList();
			throw new ArgumentException(&quot;You can only have up to 10 items in a media gallery.&quot;);
	public DiscordMediaGalleryComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryItem.cs">public sealed class DiscordMediaGalleryItem</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionAccessory.cs"></file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionComponent.cs">public sealed class DiscordSectionComponent : DiscordComponent
		var comps = components.ToList();
			throw new ArgumentException(&quot;You can only have up to 3 components in a section.&quot;);
	public DiscordSectionComponent WithThumbnailComponent(string url, string? description = null, bool? spoiler = null)
		this.Accessory = new DiscordThumbnailComponent(url, description, spoiler);
	public DiscordSectionComponent WithButtonComponent(DiscordBaseButtonComponent button)
	public DiscordSectionComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSeparatorComponent.cs">public sealed class DiscordSeparatorComponent : DiscordComponent
	public DiscordSeparatorComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordTextDisplayComponent.cs">public sealed class DiscordTextDisplayComponent : DiscordComponent
	public DiscordTextDisplayComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordThumbnailComponent.cs">public sealed class DiscordThumbnailComponent : DiscordSectionAccessory
	public DiscordThumbnailComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordUnfurledMediaItem.cs">public sealed class DiscordUnfurledMediaItem : DiscordUnfurledMedia</file><file path="DisCatSharp/Entities/Interaction/DiscordActivityInstance.cs">public sealed class DiscordActivityInstance : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/DiscordCallbackHintBuilder.cs">internal sealed class DiscordCallbackHintBuilder
		this.Clear();
		this.CallbackHints.AddRange(other.CallbackHints);
	internal DiscordCallbackHintBuilder AddCallbackHint(InteractionResponseType intendedCallbackType, InteractionCallbackEphemerality intendedCallbackEphemerality = InteractionCallbackEphemerality.Optional, Permissions? intendedRequiredPermissions = null)
		this.CallbackHints.Add(new()
	internal void Clear()
		=&gt; this.CallbackHints.Clear();</file><file path="DisCatSharp/Entities/Interaction/DiscordFollowupMessageBuilder.cs">public sealed class DiscordFollowupMessageBuilder : DisCatSharpBuilder
	public DiscordFollowupMessageBuilder WithV2Components()
	public DiscordFollowupMessageBuilder AddComponents(params DiscordComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
	public DiscordFollowupMessageBuilder AddComponents(params DiscordActionRowComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
	public DiscordFollowupMessageBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
		var ara = components.ToArray();
			throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
			this.ComponentsInternal.Add(ar);
	public DiscordFollowupMessageBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
		var cmpArr = components.ToArray();
					throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
					throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
			this.ComponentsInternal.AddRange(cmpArr);
					throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
			var comp = new DiscordActionRowComponent(cmpArr);
			this.ComponentsInternal.Add(comp);
	public DiscordFollowupMessageBuilder WithPoll(DiscordPollBuilder pollBuilder)
	public DiscordFollowupMessageBuilder WithTts(bool tts)
	public DiscordFollowupMessageBuilder WithContent(string content)
	public DiscordFollowupMessageBuilder AddEmbed(DiscordEmbed embed)
		ArgumentNullException.ThrowIfNull(embed, nameof(embed));
		this.EmbedsInternal.Add(embed);
	public DiscordFollowupMessageBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
		this.EmbedsInternal.AddRange(embeds);
	public DiscordFollowupMessageBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string description = null)
			throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
		if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
			throw new ArgumentException(&quot;A File with that filename already exists&quot;);
			this.FilesInternal.Add(new(filename, data, data.Position, description: description));
			this.FilesInternal.Add(new(filename, data, null, description: description));
	public DiscordFollowupMessageBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string description = null)
		if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
			this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
			this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
	public DiscordFollowupMessageBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
			if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
				this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
				this.FilesInternal.Add(new(file.Key, file.Value, null));
	public DiscordFollowupMessageBuilder WithAllowedMention(IMention mention)
		this.MentionsInternal.Add(mention);
	public DiscordFollowupMessageBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
		this.MentionsInternal.AddRange(mentions);
	public DiscordFollowupMessageBuilder AsEphemeral()
	public DiscordFollowupMessageBuilder SuppressEmbeds()
	internal DiscordFollowupMessageBuilder AsVoiceMessage(bool asVoiceMessage = true)
	public DiscordFollowupMessageBuilder AsSilentMessage()
	public void ClearPoll()
	public override void Clear()
		base.Clear();
	internal override void Validate()
		if (this.Files?.Count == 0 &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; this.EmbedsInternal.Count == 0 &amp;&amp; this.ComponentsInternal.Count == 0 &amp;&amp; this.Poll is null &amp;&amp; this.AttachmentsInternal.Count == 0)
			throw new ArgumentException(&quot;You must specify content, an embed, a component, a poll, or at least one file.&quot;);
		base.Validate();</file><file path="DisCatSharp/Entities/Interaction/DiscordInteraction.cs">public sealed class DiscordInteraction : SnowflakeObject
		=&gt; (this.Discord as DiscordClient).InternalGetCachedChannel(this.ChannelId) ?? (DiscordChannel)(this.Discord as DiscordClient).InternalGetCachedThread(this.ChannelId) ?? (this.Guild == null
			? new DiscordDmChannel
			: new DiscordChannel
	public async Task&lt;DiscordInteractionCallbackResponse&gt; CreateResponseAsync(InteractionResponseType type, DiscordInteractionResponseBuilder? builder = null)
		=&gt; await this.Discord.ApiClient.CreateInteractionResponseAsync(this.Id, this.Token, type, builder);
	public Task CreateInteractionModalResponseAsync(DiscordInteractionModalBuilder builder)
		=&gt; this.Type is not InteractionType.Ping &amp;&amp; this.Type is not InteractionType.ModalSubmit ? this.Discord.ApiClient.CreateInteractionModalResponseAsync(this.Id, this.Token, InteractionResponseType.Modal, builder) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with a modal.&quot;);
	public Task CreateInteractionIframeResponseAsync(string customId, string title, IframeModalSize modalSize = IframeModalSize.Normal, string? iFramePath = null)
		=&gt; this.Type is not InteractionType.Ping ? this.Discord.ApiClient.CreateInteractionIframeResponseAsync(this.Id, this.Token, InteractionResponseType.Iframe, customId, title, modalSize, iFramePath) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with an iframe.&quot;);
	public Task&lt;DiscordMessage&gt; GetOriginalResponseAsync()
		=&gt; this.Discord.ApiClient.GetOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token);
	public async Task&lt;DiscordMessage&gt; EditOriginalResponseAsync(DiscordWebhookBuilder builder)
		builder.Validate(isInteractionResponse: true);
			var attachments = this.Discord.ApiClient.GetOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token).Result.Attachments;
				builder.AttachmentsInternal.AddRange(attachments);
			builder.AttachmentsInternal.Clear();
		return await this.Discord.ApiClient.EditOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token, builder).ConfigureAwait(false);
	public Task DeleteOriginalResponseAsync()
		=&gt; this.Discord.ApiClient.DeleteOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token);
	public async Task&lt;DiscordMessage&gt; CreateFollowupMessageAsync(DiscordFollowupMessageBuilder builder)
		builder.Validate();
		return await this.Discord.ApiClient.CreateFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, builder).ConfigureAwait(false);
	public Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong messageId)
		=&gt; this.Discord.ApiClient.GetFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId);
	public async Task&lt;DiscordMessage&gt; EditFollowupMessageAsync(ulong messageId, DiscordWebhookBuilder builder)
		builder.Validate(isFollowup: true);
			var attachments = this.Discord.ApiClient.GetFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId).Result.Attachments;
		return await this.Discord.ApiClient.EditFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId, builder).ConfigureAwait(false);
	public Task DeleteFollowupMessageAsync(ulong messageId)
		=&gt; this.Discord.ApiClient.DeleteFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId);</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionApplicationCommandCallbackData.cs">internal class DiscordInteractionApplicationCommandCallbackData : ObservableApiObject
internal class DiscordInteractionApplicationCommandModalCallbackData
internal class DiscordInteractionApplicationCommandIframeCallbackData</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionCallback.cs">public sealed class DiscordInteractionCallback : SnowflakeObject</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionCallbackHint.cs">public sealed class DiscordInteractionCallbackHint</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionCallbackResponse.cs">public sealed class DiscordInteractionCallbackResponse : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionData.cs">public sealed class DiscordInteractionData : SnowflakeObject
		=&gt; this.ComponentsInternal.Where(comp =&gt; comp.Components.All(innerComp =&gt; innerComp.Type == ComponentType.InputText)).Select(x =&gt; x.Components[0]).ToList();</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionDataOption.cs">public sealed class DiscordInteractionDataOption : ObservableApiObject
		string.IsNullOrEmpty(this.RawValue)
			: this.Type == ApplicationCommandOptionType.Integer &amp;&amp; int.TryParse(this.RawValue, out var raw)
					? long.Parse(this.RawValue)
						ApplicationCommandOptionType.Boolean =&gt; bool.Parse(this.RawValue),
						ApplicationCommandOptionType.Channel =&gt; ulong.Parse(this.RawValue),
						ApplicationCommandOptionType.User =&gt; ulong.Parse(this.RawValue),
						ApplicationCommandOptionType.Role =&gt; ulong.Parse(this.RawValue),
						ApplicationCommandOptionType.Mentionable =&gt; ulong.Parse(this.RawValue),
						ApplicationCommandOptionType.Number =&gt; double.Parse(this.RawValue),
						ApplicationCommandOptionType.Attachment =&gt; ulong.Parse(this.RawValue),</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionMetadata.cs">public sealed class DiscordInteractionMetadata : SnowflakeObject</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionModalBuilder.cs">public sealed class DiscordInteractionModalBuilder
		this.CustomId = customId ?? Guid.NewGuid().ToString();
				throw new ArgumentException(&quot;Title length cannot exceed 128 characters.&quot;, nameof(value));
	public IReadOnlyList&lt;DiscordActionRowComponent&gt; ModalComponents =&gt; this.Components.Select(c =&gt; c as DiscordActionRowComponent).ToList()!;
	public DiscordInteractionModalBuilder WithTitle(string title)
	public DiscordInteractionModalBuilder WithCustomId(string customId)
	internal DiscordInteractionModalBuilder WithCallbackHints(DiscordCallbackHintBuilder hintBuilder)
			throw new ArgumentNullException(nameof(hintBuilder), &quot;Callback hint builder cannot be null.&quot;);
		this._callbackHints.Clear();
		this._callbackHints.AddRange(hintBuilder.CallbackHints);
	public DiscordInteractionModalBuilder AddTextComponents(params DiscordTextComponent[] components)
		=&gt; this.AddModalComponents(components);
	public DiscordInteractionModalBuilder AddSelectComponents(params DiscordBaseSelectComponent[] components)
	public DiscordInteractionModalBuilder AddTextComponent(DiscordTextComponent component)
		=&gt; this.AddModalComponents(component);
	public DiscordInteractionModalBuilder AddSelectComponent(DiscordBaseSelectComponent component)
	public DiscordInteractionModalBuilder AddModalComponents(params DiscordComponent[] components)
		var ara = components.ToArray();
			throw new ArgumentException(&quot;You can only add 5 components to modals.&quot;);
			throw new ArgumentException($&quot;You try to add too many components. We already have {this.ComponentsInternal.Count}.&quot;);
			this.ComponentsInternal.Add(new DiscordActionRowComponent(
	public DiscordInteractionModalBuilder AddModalComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
			throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
			this.ComponentsInternal.Add(ar);
	internal DiscordInteractionModalBuilder AddModalComponents(DiscordComponent component)
	public void ClearComponents()
		=&gt; this.ComponentsInternal.Clear();
	public void Clear()
		this.ComponentsInternal.Clear();</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResolvedCollection.cs">public sealed class DiscordInteractionResolvedCollection : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResource.cs">public sealed class DiscordInteractionResource : ObservableApiObject</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResponseBuilder.cs">public sealed class DiscordInteractionResponseBuilder : DisCatSharpBuilder
		this.MentionsInternal.AddRange(builder.MentionsInternal);
		this.EmbedsInternal.AddRange(builder.Embeds);
		this.ComponentsInternal.AddRange(builder.Components);
		this.FilesInternal.AddRange(builder.Files);
		this.AttachmentsInternal.AddRange(builder.Attachments);
	internal DiscordInteractionResponseBuilder WithCallbackHints(DiscordCallbackHintBuilder hintBuilder)
			throw new ArgumentNullException(nameof(hintBuilder), &quot;Callback hint builder cannot be null.&quot;);
		this._callbackHints.Clear();
		this._callbackHints.AddRange(hintBuilder.CallbackHints);
	public DiscordInteractionResponseBuilder AddComponents(params DiscordComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
	public DiscordInteractionResponseBuilder AddComponents(params DiscordActionRowComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
	public DiscordInteractionResponseBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
		var ara = components.ToArray();
			throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
			this.ComponentsInternal.Add(ar);
	public DiscordInteractionResponseBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
		var cmpArr = components.ToArray();
					throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
					throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
			this.ComponentsInternal.AddRange(cmpArr);
					throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
			var comp = new DiscordActionRowComponent(cmpArr);
			this.ComponentsInternal.Add(comp);
	public DiscordInteractionResponseBuilder WithPoll(DiscordPollBuilder pollBuilder)
	public DiscordInteractionResponseBuilder WithTts(bool tts)
	public DiscordInteractionResponseBuilder AsEphemeral()
	public DiscordInteractionResponseBuilder WithV2Components()
	public DiscordInteractionResponseBuilder SuppressEmbeds()
	public DiscordInteractionResponseBuilder AsSilentMessage()
	internal DiscordInteractionResponseBuilder AsVoiceMessage(bool asVoiceMessage = true)
	public DiscordInteractionResponseBuilder WithContent(string content)
	public DiscordInteractionResponseBuilder AddEmbed(DiscordEmbed embed)
		ArgumentNullException.ThrowIfNull(embed, nameof(embed));
		this.EmbedsInternal.Add(embed);
	public DiscordInteractionResponseBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
		this.EmbedsInternal.AddRange(embeds);
	public DiscordInteractionResponseBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string description = null)
			throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
		if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
			throw new ArgumentException(&quot;A File with that filename already exists&quot;);
			this.FilesInternal.Add(new(filename, data, data.Position, description: description));
			this.FilesInternal.Add(new(filename, data, null, description: description));
	public DiscordInteractionResponseBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string description = null)
		if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
			this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
			this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
	public DiscordInteractionResponseBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
			if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
				this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
				this.FilesInternal.Add(new(file.Key, file.Value, null));
	public DiscordInteractionResponseBuilder WithAllowedMention(IMention mention)
		this.MentionsInternal.Add(mention);
	public DiscordInteractionResponseBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
		this.MentionsInternal.AddRange(mentions);
	public DiscordInteractionResponseBuilder AddAutoCompleteChoice(DiscordApplicationCommandAutocompleteChoice choice)
		this.ChoicesInternal.Add(choice);
	public DiscordInteractionResponseBuilder AddAutoCompleteChoices(IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt; choices)
		this.ChoicesInternal.AddRange(choices);
	public DiscordInteractionResponseBuilder AddAutoCompleteChoices(params DiscordApplicationCommandAutocompleteChoice[] choices)
		=&gt; this.AddAutoCompleteChoices((IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;)choices);
	public void ClearPoll()
	public override void Clear()
		this.ChoicesInternal.Clear();
		base.Clear();</file><file path="DisCatSharp/Entities/Invite/DiscordInvite.cs">public class DiscordInvite : ObservableApiObject
	public string Url =&gt; DiscordDomain.GetDomain(CoreDomain.DiscordShortlink).Url + &quot;/&quot; + this.Code;
	public Task&lt;DiscordInvite&gt; DeleteAsync(string reason = null)
		=&gt; this.Discord.ApiClient.DeleteInviteAsync(this.Code, reason);
	public override string ToString()
		=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordShortlink).Url}/{this.Code}&quot;;</file><file path="DisCatSharp/Entities/Invite/DiscordInviteChannel.cs">public class DiscordInviteChannel : SnowflakeObject</file><file path="DisCatSharp/Entities/Invite/DiscordInviteGuild.cs">public class DiscordInviteGuild : SnowflakeObject
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.jpg&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.jpg&quot; : null;
		=&gt; !string.IsNullOrWhiteSpace(this.Banner) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.BANNERS}/{this.Id}/{this.Banner}&quot; : null;</file><file path="DisCatSharp/Entities/Invite/DiscordInviteStage.cs">public class DiscordInviteStage : SnowflakeObject</file><file path="DisCatSharp/Entities/Message/DiscordAttachment.cs">public class DiscordAttachment : NullableSnowflakeObject
		=&gt; this.ClipParticipantsInternal?.Select(part =&gt; new DiscordUser(part)).ToList();
		=&gt; !string.IsNullOrWhiteSpace(this.ClipCreatedAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.ClipCreatedAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; this.ApplicationInternal is not null ? new DiscordApplication(this.ApplicationInternal) : null;
	public WaveformVisualizer? VisualizeWaveForm(bool colorful = true)
				? new WaveformVisualizer().WithWaveformByteData(this.WaveForm).CreateColorfulWaveformImage()
				: new WaveformVisualizer().WithWaveformByteData(this.WaveForm).CreateWaveformImage()</file><file path="DisCatSharp/Entities/Message/DiscordForwardedMessage.cs">public sealed class DiscordForwardedMessage : ObservableApiObject
		=&gt; DateTimeOffset.TryParse(this.TimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : throw new ArithmeticException(&quot;Could not convert timestamp to DateTimeOffset&quot;);
		=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.EditedTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw);
	private List&lt;IMention&gt; GetMentions()
				mentions.AddRange(this.MentionedUsersInternal.Select(m =&gt; (IMention)new UserMention(m)));
				mentions.AddRange(this.MentionedRoleIds.Select(r =&gt; (IMention)new RoleMention(r)));
	internal void PopulateMentions()
		var guild = this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var gld) ? gld : null;
		var mentionedUsers = new HashSet&lt;DiscordUser&gt;(new DiscordUserComparer());
				this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
				mentionedUsers.Add(guild.MembersInternal.TryGetValue(usr.Id, out var member) ? member : usr);
		if (!string.IsNullOrWhiteSpace(this.Content))
				this.MentionedRolesInternal = this.MentionedRolesInternal.Union(this.MentionedRoleIds.Select(xid =&gt; guild.GetRole(xid))).ToList();
			this.MentionedChannelsInternal = this.MentionedChannelsInternal.Union(Utilities.GetChannelMentions(this.Content).Select(xid =&gt; guild.GetChannel(xid))).ToList();</file><file path="DisCatSharp/Entities/Message/DiscordMentions.cs">internal class DiscordMentions : ObservableApiObject
		if (!mentions.Any())
					throw new NotSupportedException(&quot;Type not supported in mentions.&quot;);
						users.Add(u.Id.Value);
						parse.Add(PARSE_USERS);
						roles.Add(r.Id.Value);
						parse.Add(PARSE_ROLES);
					parse.Add(PARSE_EVERYONE);
		if (!parse.Contains(PARSE_USERS) &amp;&amp; users.Count &gt; 0)
			this.Users = users.ToArray();
		if (!parse.Contains(PARSE_ROLES) &amp;&amp; roles.Count &gt; 0)
			this.Roles = roles.ToArray();
			this.Parse = parse.ToArray();</file><file path="DisCatSharp/Entities/Message/DiscordMessage.cs">public class DiscordMessage : SnowflakeObject, IEquatable&lt;DiscordMessage&gt;
	private readonly DiscordThreadChannel _startedThread;
	private DiscordChannel _channel;
	private DiscordThreadChannel _thread;
							? this.GuildId.Value.ToString(CultureInfo.InvariantCulture)
			var cid = this.ChannelId.ToString(CultureInfo.InvariantCulture);
			var mid = this.Id.ToString(CultureInfo.InvariantCulture);
				_ =&gt; throw new ArgumentException(&quot;Invalid api channel&quot;)
		=&gt; !string.IsNullOrWhiteSpace(this.TimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.TimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : this.CreationTimestamp;
		=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.EditedTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw);
		=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
			: this.GuildId.HasValue &amp;&amp; this.Guild.ThreadsInternal.TryGetValue(this.Id, out var thread)
	public bool Equals(DiscordMessage e)
	public async Task&lt;DiscordMessage&gt; EndPollAsync()
			? throw new InvalidOperationException(&quot;This message has no poll.&quot;)
				? throw new InvalidOperationException(&quot;Can only end own polls.&quot;)
					? throw new InvalidOperationException(&quot;The poll was already ended.&quot;)
					: await this.Discord.ApiClient.EndPollAsync(this.ChannelId, this.Id);
	public async Task&lt;DiscordMessage&gt; ForwardMessageAsync(DiscordChannel targetChannel, string? content = null)
		=&gt; await this.Discord.ApiClient.ForwardMessageAsync(this, targetChannel.Id, content);
	internal DiscordMessageReference InternalBuildMessageReference()
		ArgumentNullException.ThrowIfNull(this.InternalReference);
		var reference = new DiscordMessageReference
			reference.Guild = client.GuildsInternal.TryGetValue(guildId.Value, out var g)
		var channel = client.InternalGetCachedChannel(channelId.Value);
		if (client.MessageCache != null &amp;&amp; client.MessageCache.TryGet(m =&gt; m.Id == messageId.Value &amp;&amp; m.ChannelId == channelId, out var msg))
	private List&lt;IMention&gt; GetMentions()
			if (this.ReferencedMessage is not null &amp;&amp; this.MentionedUsersInternal.Count is not 0 &amp;&amp; this.MentionedUsersInternal.Contains(this.ReferencedMessage.Author))
				mentions.Add(new RepliedUserMention());
				mentions.AddRange(this.MentionedUsersInternal.Select(m =&gt; (IMention)new UserMention(m)));
				mentions.AddRange(this.MentionedRoleIds.Select(r =&gt; (IMention)new RoleMention(r)));
	internal void PopulateMentions()
		var mentionedUsers = new HashSet&lt;DiscordUser&gt;(new DiscordUserComparer());
				this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
				mentionedUsers.Add(guild.MembersInternal.TryGetValue(usr.Id, out var member) ? member : usr);
		if (!string.IsNullOrWhiteSpace(this.Content))
				this.MentionedRolesInternal = [.. this.MentionedRolesInternal.Union(this.MentionedRoleIds.Select(guild.GetRole))!];
				this.MentionedChannelsInternal = [.. this.MentionedChannelsInternal.Union(Utilities.GetChannelMentions(this.Content).Select(guild.GetChannel))!];
	public Task&lt;DiscordMessage&gt; ModifyAsync(Optional&lt;string&gt; content)
		=&gt; this.Flags?.HasMessageFlag(MessageFlags.IsComponentsV2) ?? false ? throw new InvalidOperationException(&quot;UI Kit messages can not have content.&quot;) : this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, content, default, this.GetMentions(), default, default, [], default);
	public Task&lt;DiscordMessage&gt; ModifyAsync(Optional&lt;DiscordEmbed&gt; embed = default)
		=&gt; this.Flags?.HasMessageFlag(MessageFlags.IsComponentsV2) ?? false ? throw new InvalidOperationException(&quot;UI Kit messages can not have embeds.&quot;) : this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, default, embed.Map(v =&gt; new[] { v }).ValueOr([]), this.GetMentions(), default, default, [], default);
	public Task&lt;DiscordMessage&gt; ModifyAsync(Optional&lt;string&gt; content, Optional&lt;DiscordEmbed&gt; embed = default)
		=&gt; this.Flags?.HasMessageFlag(MessageFlags.IsComponentsV2) ?? false ? throw new InvalidOperationException(&quot;UI Kit messages can not have content or embeds.&quot;) : this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, content, embed.Map(v =&gt; new[] { v }).ValueOr([]), this.GetMentions(), default, default, [], default);
	public Task&lt;DiscordMessage&gt; ModifyAsync(Optional&lt;string&gt; content, Optional&lt;IEnumerable&lt;DiscordEmbed&gt;&gt; embeds = default)
		=&gt; this.Flags?.HasMessageFlag(MessageFlags.IsComponentsV2) ?? false ? throw new InvalidOperationException(&quot;UI Kit messages can not have content or embeds.&quot;) : this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, content, embeds, this.GetMentions(), default, default, [], default);
	public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordMessageBuilder builder)
		builder.Validate(true);
		return await this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, builder.Content, Optional.Some(builder.Embeds.AsEnumerable()), Optional.Some(builder.Mentions.AsEnumerable()), builder.Components, builder.EmbedsSuppressed, builder.Files, builder.Attachments.Count &gt; 0
			? Optional.Some(builder.Attachments.AsEnumerable())
				? builder.KeepAttachmentsInternal.Value &amp;&amp; this.Attachments is not null ? Optional.Some(this.Attachments.AsEnumerable()) : Array.Empty&lt;DiscordAttachment&gt;()
				: Optional.None).ConfigureAwait(false);
	public Task&lt;DiscordMessage&gt; ModifySuppressionAsync(bool suppress = false)
		=&gt; this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, default, default, default, default, suppress, default, default);
	public Task&lt;DiscordMessage&gt; ClearAttachmentsAsync()
		=&gt; this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, default, default, this.GetMentions(), default, default, default, Array.Empty&lt;DiscordAttachment&gt;());
	public async Task&lt;DiscordMessage&gt; ModifyAsync(Action&lt;DiscordMessageBuilder&gt; action)
		var builder = new DiscordMessageBuilder();
	public Task DeleteAsync(string reason = null)
		=&gt; this.Discord.ApiClient.DeleteMessageAsync(this.ChannelId, this.Id, reason);
	public async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(string name, ThreadAutoArchiveDuration autoArchiveDuration = ThreadAutoArchiveDuration.OneHour, int? rateLimitPerUser = null, string? reason = null)
		=&gt; await this.Discord.ApiClient.CreateThreadAsync(this.ChannelId, this.Id, name, autoArchiveDuration, this.Channel.Type == ChannelType.News ? ChannelType.NewsThread : ChannelType.PublicThread, rateLimitPerUser, isForum: false, reason: reason).ConfigureAwait(false);
	public Task PinAsync()
		=&gt; this.Discord.ApiClient.PinMessageAsync(this.ChannelId, this.Id);
	public Task UnpinAsync()
		=&gt; this.Discord.ApiClient.UnpinMessageAsync(this.ChannelId, this.Id);
	public Task&lt;DiscordMessage&gt; RespondAsync(string content)
		=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, content, null, null, this.Id, false, false);
	public Task&lt;DiscordMessage&gt; RespondAsync(DiscordEmbed embed)
		=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, null, embed != null
		Task&lt;DiscordMessage&gt; RespondAsync(string content, DiscordEmbed embed)
		=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, content, embed != null
		Task&lt;DiscordMessage&gt; RespondAsync(DiscordMessageBuilder builder)
		=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, builder.WithReply(this.Id));
	public Task&lt;DiscordMessage&gt; RespondAsync(Action&lt;DiscordMessageBuilder&gt; action)
		return this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, builder.WithReply(this.Id));
	public Task CreateReactionAsync(DiscordEmoji emoji)
		=&gt; this.Discord.ApiClient.CreateReactionAsync(this.ChannelId, this.Id, emoji.ToReactionString());
	public Task DeleteOwnReactionAsync(DiscordEmoji emoji)
		=&gt; this.Discord.ApiClient.DeleteOwnReactionAsync(this.ChannelId, this.Id, emoji.ToReactionString());
	public Task DeleteReactionAsync(DiscordEmoji emoji, DiscordUser user, string reason = null)
		=&gt; this.Discord.ApiClient.DeleteUserReactionAsync(this.ChannelId, this.Id, user.Id, emoji.ToReactionString(), reason);
	public Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsAsync(DiscordEmoji emoji, int limit = 25, ulong? after = null)
		=&gt; this.GetReactionsInternalAsync(emoji, limit, after);
	public Task DeleteAllReactionsAsync(string reason = null)
		=&gt; this.Discord.ApiClient.DeleteAllReactionsAsync(this.ChannelId, this.Id, reason);
	public Task DeleteReactionsEmojiAsync(DiscordEmoji emoji)
		=&gt; this.Discord.ApiClient.DeleteReactionsEmojiAsync(this.ChannelId, this.Id, emoji.ToReactionString());
	private async Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsInternalAsync(DiscordEmoji emoji, int limit = 25, ulong? after = null)
			throw new ArgumentException(&quot;Cannot get a negative number of reactions&apos; users.&quot;);
			var fetch = await this.Discord.ApiClient.GetReactionsAsync(this.Channel.Id, this.Id, emoji.ToReactionString(), last, fetchSize).ConfigureAwait(false);
			users.AddRange(fetch);
			last = fetch.LastOrDefault()?.Id;
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordMessage);
	public override int GetHashCode()
		hash = (hash * 7) + this.Id.GetHashCode();
		hash = (hash * 7) + this.ChannelId.GetHashCode();</file><file path="DisCatSharp/Entities/Message/DiscordMessageActivity.cs">public class DiscordMessageActivity : ObservableApiObject</file><file path="DisCatSharp/Entities/Message/DiscordMessageApplication.cs">public class DiscordMessageApplication : SnowflakeObject</file><file path="DisCatSharp/Entities/Message/DiscordMessageBuilder.cs">public sealed class DiscordMessageBuilder : DisCatSharpBuilder
	public DiscordMessageBuilder WithNonce(string nonce)
	public DiscordMessageBuilder WithEnforceNonce(bool enforceNonce)
	public DiscordMessageBuilder WithContent(string content)
	public DiscordMessageBuilder WithSticker(DiscordSticker sticker)
	public DiscordMessageBuilder WithPoll(DiscordPollBuilder pollBuilder)
	public DiscordMessageBuilder AddComponents(params DiscordComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
	public DiscordMessageBuilder AddComponents(params DiscordActionRowComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
	public DiscordMessageBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
		var ara = components.ToArray();
			throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
			this.ComponentsInternal.Add(ar);
	public DiscordMessageBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
		var cmpArr = components.ToArray();
					throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
					throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
			this.ComponentsInternal.AddRange(cmpArr);
					throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
			var comp = new DiscordActionRowComponent(cmpArr);
			this.ComponentsInternal.Add(comp);
	public DiscordMessageBuilder HasTts(bool isTts)
	public DiscordMessageBuilder SuppressEmbeds(bool suppress = true)
	public DiscordMessageBuilder WithV2Components()
	public DiscordMessageBuilder AsVoiceMessage(bool asVoiceMessage = true)
	public DiscordMessageBuilder AsSilentMessage(bool silent = true)
	public DiscordMessageBuilder AddEmbed(DiscordEmbed embed)
		ArgumentNullException.ThrowIfNull(embed, nameof(embed));
		this.EmbedsInternal.Add(embed);
	public DiscordMessageBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
		this.EmbedsInternal.AddRange(embeds);
	public DiscordMessageBuilder WithAllowedMention(IMention mention)
		this.MentionsInternal.Add(mention);
	public DiscordMessageBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
		this.MentionsInternal.AddRange(mentions);
	public DiscordMessageBuilder WithFile(string fileName, Stream stream, bool resetStreamPosition = false, string description = null)
		=&gt; this.AddFile(fileName, stream, resetStreamPosition, description);
	public DiscordMessageBuilder AddFile(string fileName, Stream stream, bool resetStreamPosition = false, string? description = null)
			throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
		if (this.FilesInternal.Any(x =&gt; x.Filename == fileName))
			throw new ArgumentException(&quot;A File with that filename already exists&quot;);
			this.FilesInternal.Add(new(fileName, stream, stream.Position, description: description));
			this.FilesInternal.Add(new(fileName, stream, null, description: description));
	public DiscordMessageBuilder WithFile(FileStream stream, bool resetStreamPosition = false, string description = null)
		=&gt; this.AddFile(stream, resetStreamPosition, description);
	public DiscordMessageBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string? description = null)
		if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
			this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
			this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
	public DiscordMessageBuilder WithFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
		=&gt; this.AddFiles(files, resetStreamPosition);
	public DiscordMessageBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
			if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
				this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
				this.FilesInternal.Add(new(file.Key, file.Value, null));
	public DiscordMessageBuilder ModifyAttachments(IEnumerable&lt;DiscordAttachment&gt; attachments)
		this.AttachmentsInternal.AddRange(attachments);
	public DiscordMessageBuilder KeepAttachments(bool keep)
	public DiscordMessageBuilder WithReply(ulong messageId, bool mention = false, bool failOnInvalidReply = false)
			this.MentionsInternal.Add(new RepliedUserMention());
	public Task&lt;DiscordMessage&gt; SendAsync(DiscordChannel channel)
		=&gt; channel.SendMessageAsync(this);
	public Task&lt;DiscordMessage&gt; ModifyAsync(DiscordMessage msg)
		=&gt; msg.ModifyAsync(this);
	public void ClearPoll()
	public override void Clear()
		base.Clear();
	internal void Validate(bool isModify = false)
			throw new ArgumentException(&quot;A message can only have up to 10 embeds.&quot;);
			this.AsVoiceMessage(false);
			if (this.Files?.Count == 0 &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; !this.Embeds.Any() &amp;&amp; this.Sticker is null &amp;&amp; (!this.Components?.Any() ?? true) &amp;&amp; this.Poll is null &amp;&amp; this?.Attachments.Count == 0)
				throw new ArgumentException(&quot;You must specify content, an embed, a sticker, a component, a poll or at least one file.&quot;);
			if (this.IsComponentsV2 &amp;&amp; (!string.IsNullOrEmpty(this.Content) || this.Embeds.Any()))
				throw new ArgumentException(&quot;Using UI Kit mode. You cannot specify content or embeds.&quot;);
					throw new InvalidOperationException(&quot;You can only have 10 components per message.&quot;);
					throw new InvalidOperationException(&quot;You can only have 5 action rows per message.&quot;);
			if (this.EnforceNonce &amp;&amp; string.IsNullOrEmpty(this.Nonce))
				throw new InvalidOperationException(&quot;Nonce enforcement is enabled, but no nonce is set.&quot;);
			throw new InvalidOperationException(&quot;Messages with polls can&apos;t be edited.&quot;);
		base.Validate();</file><file path="DisCatSharp/Entities/Message/DiscordMessageFile.cs">public sealed class DiscordMessageFile</file><file path="DisCatSharp/Entities/Message/DiscordMessageInteraction.cs">public class DiscordMessageInteraction : SnowflakeObject</file><file path="DisCatSharp/Entities/Message/DiscordMessageReference.cs">public class DiscordMessageReference
	public override string ToString()</file><file path="DisCatSharp/Entities/Message/DiscordMessageSnapshots.cs">public class DiscordMessageSnapshot : ObservableApiObject</file><file path="DisCatSharp/Entities/Message/DiscordReaction.cs">public class DiscordReaction : ObservableApiObject</file><file path="DisCatSharp/Entities/Message/DiscordUnfurledMedia.cs">public class DiscordUnfurledMedia: ObservableApiObject</file><file path="DisCatSharp/Entities/Message/Mentions.cs">public interface IMention
	public static readonly RepliedUserMention All = new();
	public static readonly EveryoneMention All = new();
	public static readonly UserMention All = new();
	public static readonly RoleMention All = new();
public static class Mentions</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPoll.cs">public sealed class DiscordPoll : ObservableApiObject
		=&gt; !string.IsNullOrWhiteSpace(this.ExpiryRaw) &amp;&amp; DateTimeOffset.TryParse(this.ExpiryRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
	public async Task&lt;ReadOnlyCollection&lt;DiscordUser&gt;&gt; GetAnswerVotersAsync(int answerId, int? limit = null, ulong? after = null)
		=&gt; await this.Discord.ApiClient.GetAnswerVotersAsync(this.ChannelId, this.MessageId, answerId, limit, after);
	public async Task&lt;DiscordMessage&gt; EndAsync()
			? throw new InvalidOperationException(&quot;Can only end own polls.&quot;)
				? throw new InvalidOperationException(&quot;The poll was already ended.&quot;)
				: await this.Discord.ApiClient.EndPollAsync(this.ChannelId, this.MessageId);</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollAnswer.cs">public sealed class DiscordPollAnswer</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollAnswerCount.cs">public sealed class DiscordPollAnswerCount</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollBuilder.cs">public sealed class DiscordPollBuilder
	private DiscordPollMedia _question;
				throw new ArgumentException(&quot;Question cannot exceed 300 characters.&quot;, nameof(value));
	public DiscordPollBuilder SetDuration(int hours)
	public DiscordPollBuilder WithAllowMultiselect(bool allow = true)
	public DiscordPollBuilder WithQuestion(string question)
	public DiscordPollBuilder AddAnswers(params DiscordPollAnswer[] answers)
		=&gt; this.AddAnswers((IEnumerable&lt;DiscordPollAnswer&gt;)answers);
	public DiscordPollBuilder AddAnswers(params string[] answers)
		=&gt; this.AddAnswers(answers.Select(x =&gt; new DiscordPollAnswer(x)));
	public DiscordPollBuilder AddAnswers(IEnumerable&lt;DiscordPollAnswer&gt; answers)
		var cmpArr = answers.ToArray();
				throw new ArgumentOutOfRangeException(nameof(answers), &quot;You must provide at least one answer&quot;);
				throw new ArgumentException(&quot;Cannot add more than 10 answers to a poll!&quot;);
				throw new ArgumentException($&quot;Answers text cannot exceed 55 characters. Thrown in answer {answerId}&quot;);
		this._answers.AddRange(cmpArr);
	public Task&lt;DiscordMessage&gt; SendAsync(DiscordChannel channel)
		=&gt; channel.SendMessageAsync(new DiscordMessageBuilder().WithPoll(this));
	public void ClearAnswers()
		=&gt; this._answers.Clear();
	public void Clear()
		this._answers.Clear();
	internal void Validate()
			throw new ArgumentException(&quot;A poll can only have up to 10 answers.&quot;);
			throw new ArgumentException(&quot;You must specify a question.&quot;);
			throw new ArgumentException(&quot;Polls can only be open for up to 32 days or 768 hours.&quot;);
	internal DiscordPollRequest Build()</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollMedia.cs">public sealed class DiscordPollMedia</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollRequest.cs">internal sealed class DiscordPollRequest</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollResult.cs">public sealed class DiscordPollResult : ObservableApiObject</file><file path="DisCatSharp/Entities/NullableSnowflakeObject.cs">public abstract class NullableSnowflakeObject : ObservableApiObject
		=&gt; this.Id.GetSnowflakeTime();</file><file path="DisCatSharp/Entities/OAuth2/DiscordAccessToken.cs">public sealed class DiscordAccessToken : ObservableApiObject
	public static DiscordAccessToken FromJson(string json)</file><file path="DisCatSharp/Entities/OAuth2/DiscordApplicationRoleConnection.cs">public sealed class DiscordApplicationRoleConnection : ObservableApiObject
public sealed class ApplicationRoleConnectionMetadata
	public ApplicationRoleConnectionMetadata AddMetadata(string key, string value)
		this.Metadata.Add(key, value);
	public ApplicationRoleConnectionMetadata RemoveMetadata(string key)
		this.Metadata.Remove(key);
	public Dictionary&lt;string, string&gt; GetKeyValuePairs()</file><file path="DisCatSharp/Entities/OAuth2/DiscordAuthorizationInformation.cs">public sealed class DiscordAuthorizationInformation : ObservableApiObject
		=&gt; DateTimeOffset.TryParse(this.ExpiresRaw, out var expires)
			: throw new InvalidCastException(&quot;Something went wrong&quot;);</file><file path="DisCatSharp/Entities/ObservableApiObject.cs">public abstract class ObservableApiObject
				this.IgnoredJsonKeys.Add(ignoredKey);</file><file path="DisCatSharp/Entities/Optional.cs">public static class Optional
	public static readonly None None = new();
	public static Optional&lt;T&gt; Some&lt;T&gt;(T value)
	public static Optional&lt;T?&gt; FromNullable&lt;T&gt;([AllowNull] T? value)
public interface IOptional
	public T Value =&gt; this.HasValue ? this._val : throw new InvalidOperationException(&quot;Value is not set.&quot;);
	private readonly T _val;
	public Optional&lt;TOut&gt; Map&lt;TOut&gt;(Func&lt;T, TOut&gt; mapper)
	public Optional&lt;TOut&gt; MapOrNull&lt;TOut&gt;(Func&lt;T, TOut&gt; mapper)
	public T ValueOr(T other)
	public T ValueOrDefault()
		=&gt; this.ValueOr(default);
	public T Expect(Exception err)
	public T Expect(string str) =&gt; this.Expect(new InvalidOperationException(str));
	public bool HasValueAnd(Predicate&lt;T&gt; predicate)
	public override string ToString() =&gt; $&quot;Optional&lt;{typeof(T)}&gt; ({this.Map(x =&gt; x.ToString()).ValueOr(&quot;&lt;no value&gt;&quot;)})&quot;;
	public override bool Equals(object obj) =&gt;
			T t =&gt; this.Equals(t),
			Optional&lt;T&gt; opt =&gt; this.Equals(opt),
	public bool Equals(Optional&lt;T&gt; e) =&gt; (!this.HasValue &amp;&amp; !e.HasValue) || (this.HasValue == e.HasValue &amp;&amp; this.Value.Equals(e.Value));
	public bool Equals(T e)
	public override int GetHashCode()
		=&gt; this.Map(x =&gt; x.GetHashCode()).ValueOrDefault();
		=&gt; opt1.Equals(opt2);
		=&gt; !opt1.Equals(opt2);
		=&gt; opt.Equals(t);
		=&gt; !opt.Equals(t);
internal sealed class OptionalJsonContractResolver : DefaultContractResolver
	protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
		var property = base.CreateProperty(member, memberSerialization);
		if (!type.GetTypeInfo().ImplementedInterfaces.Contains(typeof(IOptional)))
		var declaringMember = property.DeclaringType.GetTypeInfo().DeclaredMembers
			.FirstOrDefault(e =&gt; e.Name == property.UnderlyingName);
					var optionalValue = declaringProp.GetValue(instance);
					var optionalValue = declaringField.GetValue(instance);
				throw new InvalidOperationException(
internal sealed class OptionalJsonConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
			writer.WriteToken(JsonToken.Null);
			JToken.FromObject(val).WriteTo(writer);
	public override object ReadJson(
		var constructor = objectType.GetTypeInfo().DeclaredConstructors
			.FirstOrDefault(e =&gt; e.GetParameters()[0].ParameterType == genericType);
		return constructor.Invoke([serializer.Deserialize(reader, genericType)]);
	public override bool CanConvert(Type objectType) =&gt; objectType.GetTypeInfo().ImplementedInterfaces.Contains(typeof(IOptional));</file><file path="DisCatSharp/Entities/SnowflakeObject.cs">public abstract class SnowflakeObject : ObservableApiObject
		=&gt; this.Id.GetSnowflakeTime();</file><file path="DisCatSharp/Entities/Sticker/DiscordSticker.cs">public class DiscordSticker : SnowflakeObject, IEquatable&lt;DiscordSticker&gt;
	public DiscordGuild Guild =&gt; (this.Discord as DiscordClient).InternalGetCachedGuild(this.GuildId);
		=&gt; this.InternalTags != null ? this.InternalTags.Split(&apos;,&apos;) : [];
	public string Url =&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.STICKERS}/{this.Id}.{(this.FormatType == StickerFormat.Lottie ? &quot;json&quot; : &quot;png&quot;)}&quot;;
	public bool Equals(DiscordSticker other)
	public override int GetHashCode()
		=&gt; this.PackId != null ? HashCode.Combine(this.Id.GetHashCode(), this.PackId.GetHashCode()) : HashCode.Combine(this.Id.GetHashCode(), this.GuildId.GetHashCode());
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as ForumPostTag);
	public override string ToString() =&gt; $&quot;Sticker {this.Id}; {this.Name}; {this.FormatType}&quot;;
	public Task&lt;DiscordSticker&gt; ModifyAsync(Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;string&gt; tags, string reason = null) =&gt;
			? throw new ArgumentException(&quot;This sticker does not belong to a guild.&quot;)
				? throw new ArgumentException(&quot;Sticker name needs to be between 2 and 30 characters long.&quot;)
					? throw new ArgumentException(&quot;Sticker description needs to be between 1 and 100 characters long.&quot;)
					: tags.HasValue &amp;&amp; !DiscordEmoji.TryFromUnicode(this.Discord, tags.Value, out var emoji)
						? throw new ArgumentException(&quot;Sticker tags needs to be a unicode emoji.&quot;)
						: this.Discord.ApiClient.ModifyGuildStickerAsync(this.GuildId.Value, this.Id, name, description, tags, reason);
	public Task DeleteAsync(string reason = null)
		=&gt; this.GuildId.HasValue ? this.Discord.ApiClient.DeleteGuildStickerAsync(this.GuildId.Value, this.Id, reason) : throw new ArgumentException(&quot;The requested sticker is no guild sticker.&quot;);</file><file path="DisCatSharp/Entities/Sticker/DiscordStickerPack.cs">public sealed class DiscordStickerPack : SnowflakeObject
	public Task&lt;DiscordSticker&gt; CoverSticker =&gt; this.Discord.ApiClient.GetStickerAsync(this.CoverStickerId);
	public string BannerUrl =&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ASSETS}{Endpoints.STICKER_APPLICATION}{Endpoints.STORE}/{this.BannerAssetId}.png?size=4096&quot;;</file><file path="DisCatSharp/Entities/Store/DiscordEntitlement.cs">public sealed class DiscordEntitlement : SnowflakeObject
		=&gt; this.Discord.GetCachedOrEmptyUserInternal(this.UserId);
		=&gt; !string.IsNullOrWhiteSpace(this.StartsAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.StartsAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.EndsAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.EndsAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
	public async Task DeleteTestEntitlementsAsync()
		=&gt; await (this.Discord as DiscordClient)!.DeleteTestEntitlementAsync(this.Id);
	public async Task&lt;bool&gt; ConsumeAsync()
			? throw new InvalidOperationException(&quot;You can only consume consumable entitlements.&quot;)
			: (this.Consumed.HasValue &amp;&amp; this.Consumed.Value) || await (this.Discord as DiscordClient)!.ConsumeEntitlementAsync(this.Id);</file><file path="DisCatSharp/Entities/Store/DiscordSku.cs">public sealed class DiscordSku : SnowflakeObject, IEquatable&lt;DiscordSku&gt;
	public bool Equals(DiscordSku? e)
	public override bool Equals(object? obj)
		=&gt; this.Equals(obj as DiscordSku);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSubscriptionsAsync(ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
		=&gt; await (this.Discord as DiscordClient)!.GetSkuSubscriptionsAsync(this.Id, userId, before, after, limit);
	public async Task&lt;DiscordSubscription?&gt; GetSubscriptionAsync(ulong subscriptionId)
		=&gt; await (this.Discord as DiscordClient)!.GetSkuSubscriptionAsync(this.Id, subscriptionId);
	public async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong ownerId, EntitlementOwnerType ownerType)
		=&gt; await (this.Discord as DiscordClient)!.CreateTestEntitlementAsync(this.Id, ownerId, ownerType);
public sealed class SkuPrice</file><file path="DisCatSharp/Entities/Store/DiscordStoreSku.cs">public class DiscordStoreSku : SnowflakeObject, IEquatable&lt;DiscordStoreSku&gt;
	public bool Equals(DiscordStoreSku e)
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordStoreSku);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Store/DiscordSubscription.cs">public sealed class DiscordSubscription : SnowflakeObject
		=&gt; this.Discord.UserCache.GetValueOrDefault(this.UserId);
		=&gt; !string.IsNullOrWhiteSpace(this.CurrentPeriodStartRaw) &amp;&amp; DateTimeOffset.TryParse(this.CurrentPeriodStartRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.CurrentPeriodEndRaw) &amp;&amp; DateTimeOffset.TryParse(this.CurrentPeriodEndRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
		=&gt; !string.IsNullOrWhiteSpace(this.CanceledAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.CanceledAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;</file><file path="DisCatSharp/Entities/User/DiscordActivity.cs">internal sealed class UserStatusConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
					writer.WriteValue(&quot;online&quot;);
					writer.WriteValue(&quot;idle&quot;);
					writer.WriteValue(&quot;dnd&quot;);
					writer.WriteValue(&quot;invisible&quot;);
					writer.WriteValue(&quot;streaming&quot;);
					writer.WriteValue(&quot;offline&quot;);
	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) =&gt;
		reader.Value?.ToString().ToLowerInvariant() switch // reader.Value can be a string, DateTime or DateTimeOffset (yes, it&apos;s weird)
	public override bool CanConvert(Type objectType) =&gt; objectType == typeof(UserStatus);
public sealed class DiscordActivity
		this.UpdateWith(rawActivity);
	internal void UpdateWith(TransportActivity rawActivity)
			this.RichPresence.UpdateWith(rawActivity);
		else this.RichPresence = rawActivity?.IsRichPresence() == true ? new DiscordRichPresence(rawActivity) : null;
			this.CustomStatus.UpdateWith(rawActivity.State, rawActivity.Emoji);
				? new DiscordCustomStatus
public sealed class DiscordCustomStatus
	internal void UpdateWith(string? state, DiscordEmoji? emoji)
public sealed class DiscordRichPresence
		this.UpdateWith(rawGame);
	internal void UpdateWith(TransportActivity rawGame)
			? new DiscordApplication
		if (rawGame?.Party != null &amp;&amp; ulong.TryParse(rawGame.Party.Id, NumberStyles.Number, CultureInfo.InvariantCulture, out var partyId))
			if (lid.StartsWith(&quot;spotify:&quot;, StringComparison.Ordinal))
				this.LargeImage = new DiscordSpotifyAsset
			else if (ulong.TryParse(lid, NumberStyles.Number, CultureInfo.InvariantCulture, out var ulid))
				this.LargeImage = new DiscordApplicationAsset
			if (sid.StartsWith(&quot;spotify:&quot;, StringComparison.Ordinal))
				this.SmallImage = new DiscordSpotifyAsset
			else if (ulong.TryParse(sid, NumberStyles.Number, CultureInfo.InvariantCulture, out var usid))
				this.SmallImage = new DiscordApplicationAsset</file><file path="DisCatSharp/Entities/User/DiscordClan.cs">public sealed class DiscordClan
		=&gt; string.IsNullOrWhiteSpace(this.BadgeHash) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CLAN_BADGES}/{this.IdentityGuildId?.ToString(CultureInfo.InvariantCulture)}/{this.BadgeHash}.{(this.BadgeHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;</file><file path="DisCatSharp/Entities/User/DiscordConnection.cs">public class DiscordConnection : ObservableApiObject</file><file path="DisCatSharp/Entities/User/DiscordPresence.cs">public sealed class DiscordPresence : ObservableApiObject
		=&gt; this.Discord.GetCachedOrEmptyUserInternal(this.InternalUser.Id);
public sealed class UserWithIdOnly : ObservableApiObject
public sealed class DiscordClientStatus : ObservableApiObject</file><file path="DisCatSharp/Entities/User/DiscordTeam.cs">public sealed class DiscordTeam : SnowflakeObject, IEquatable&lt;DiscordTeam&gt;
		=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.TEAM_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=1024&quot; : null!;
	public bool Equals(DiscordTeam other)
	public override bool Equals(object obj)
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
	public override string ToString()
public sealed class DiscordTeamMember : IEquatable&lt;DiscordTeamMember&gt;
	public bool Equals(DiscordTeamMember other)
	public override int GetHashCode() =&gt; HashCode.Combine(this.User, this.TeamId);</file><file path="DisCatSharp/Entities/User/DiscordUser.cs">public class DiscordUser : SnowflakeObject, IEquatable&lt;DiscordUser&gt;
		=&gt; int.Parse(this.Discriminator, NumberStyles.Integer, CultureInfo.InvariantCulture);
		=&gt; !this.BannerColorInternal.HasValue ? null : new DiscordColor(this.BannerColorInternal.Value);
	public virtual IReadOnlyList&lt;DiscordColor&gt;? ThemeColors =&gt; !(this.ThemeColorsInternal is not null &amp;&amp; this.ThemeColorsInternal.Count != 0) ? null : this.ThemeColorsInternal.Select(x =&gt; new DiscordColor(x)).ToList();
		=&gt; string.IsNullOrWhiteSpace(this.BannerHash) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=4096&quot;;
		=&gt; new($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.USERS}/{this.Id}&quot;);
		=&gt; string.IsNullOrWhiteSpace(this.AvatarHash) ? this.DefaultAvatarUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHash}.{(this.AvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMBED}{Endpoints.AVATARS}/{(this.IsMigrated ? (this.Id &gt;&gt; 22) % 6 : Convert.ToUInt64(this.DiscriminatorInt) % 5).ToString(CultureInfo.InvariantCulture)}.png?size=1024&quot;;
		=&gt; this.Mention(this is DiscordMember);
		=&gt; this.Discord is DiscordClient dc &amp;&amp; dc.Presences.TryGetValue(this.Id, out var presence) ? presence : null;
	public bool Equals(DiscordUser e)
	public async Task&lt;DiscordUser&gt; GetFromApiAsync()
		=&gt; await this.Discord.ApiClient.GetUserAsync(this.Id).ConfigureAwait(false);
	public async Task&lt;DiscordRpcApplication?&gt; GetRpcInfoAsync()
		=&gt; this.IsBot ? await this.Discord.ApiClient.GetApplicationRpcInfoAsync(this.Id).ConfigureAwait(false) : await Task.FromResult&lt;DiscordRpcApplication?&gt;(null).ConfigureAwait(false);
	public async Task&lt;bool&gt; IsInGuild(DiscordGuild guild)
			var member = await guild.GetMemberAsync(this.Id).ConfigureAwait(false);
	public async Task&lt;bool&gt; IsNotInGuild(DiscordGuild guild)
		=&gt; !await this.IsInGuild(guild).ConfigureAwait(false);
	public async Task&lt;DiscordMember&gt; ConvertToMember(DiscordGuild guild)
		=&gt; await guild.GetMemberAsync(this.Id).ConfigureAwait(false);
	public Task UnbanAsync(DiscordGuild guild, string? reason = null)
		=&gt; guild.UnbanMemberAsync(this, reason);
	public string GetAvatarUrl(MediaFormat fmt, ushort size = 1024)
			throw new ArgumentException(&quot;You must specify valid image format.&quot;, nameof(fmt));
			throw new ArgumentOutOfRangeException(nameof(size));
		var log = Math.Log(size, 2);
			MediaFormat.Auto =&gt; !string.IsNullOrWhiteSpace(this.AvatarHash) ? this.AvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot; : &quot;png&quot;,
			_ =&gt; throw new ArgumentOutOfRangeException(nameof(fmt))
		var ssize = size.ToString(CultureInfo.InvariantCulture);
		if (!string.IsNullOrWhiteSpace(this.AvatarHash))
			var id = this.Id.ToString(CultureInfo.InvariantCulture);
			return $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{id}/{this.AvatarHash}.{sfmt}?size={ssize}&quot;;
		var type = (this.DiscriminatorInt % 5).ToString(CultureInfo.InvariantCulture);
		return $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMBED}{Endpoints.AVATARS}/{type}.{sfmt}?size={ssize}&quot;;
	public Task&lt;DiscordDmChannel&gt; CreateDmChannelAsync()
		=&gt; this.Discord.ApiClient.CreateDmAsync(this.Id);
	public async Task&lt;DiscordMessage&gt; SendMessageAsync(string content)
			throw new ArgumentException(&quot;Bots cannot DM each other.&quot;);
		var chn = await this.CreateDmChannelAsync().ConfigureAwait(false);
		return await chn.SendMessageAsync(content).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordEmbed embed)
		return await chn.SendMessageAsync(embed).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; SendMessageAsync(string content, DiscordEmbed embed)
		return await chn.SendMessageAsync(content, embed).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordMessageBuilder message)
		return await chn.SendMessageAsync(message).ConfigureAwait(false);
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as DiscordUser);
	public override int GetHashCode()
		=&gt; this.Id.GetHashCode();
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.CertifiedModerator);
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.Partner);
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.VerifiedBot);
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.VerifiedDeveloper);
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.ActiveDeveloper);
		=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.Staff);
	public async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; OAuth2GetConnectionsAsync(DiscordOAuth2Client oauth2Client)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserConnectionsAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; OAuth2GetGuildAsync(DiscordOAuth2Client oauth2Client)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildsAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordMember&gt; OAuth2GetGuildMemberAsync(DiscordOAuth2Client oauth2Client, DiscordGuild guild)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildMemberAsync(this.AccessToken, guild.Id) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordMember&gt; OAuth2GetGuildMemberAsync(DiscordOAuth2Client oauth2Client, ulong guildId)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildMemberAsync(this.AccessToken, guildId) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordMember&gt; OAuth2AddToGuildAsync(DiscordOAuth2Client oauth2Client, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
		=&gt; this.AccessToken is not null ? await oauth2Client.AddCurrentUserToGuildAsync(this.AccessToken, this.Id, guildId, nickname, roles, muted, deafened) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordMember&gt; OAuth2AddToGuildAsync(DiscordOAuth2Client oauth2Client, DiscordGuild guild, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
		=&gt; this.AccessToken is not null ? await oauth2Client.AddCurrentUserToGuildAsync(this.AccessToken, this.Id, guild.Id, nickname, roles, muted, deafened) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordUser&gt; OAuth2GetAsync(DiscordOAuth2Client oauth2Client)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordAuthorizationInformation&gt; OAuth2GetAuthorizationInfoAsync(DiscordOAuth2Client oauth2Client)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentAuthorizationInformationAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordApplicationRoleConnection&gt; OAuth2GetApplicationRoleConnectionAsync(DiscordOAuth2Client oauth2Client)
		=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserApplicationRoleConnectionAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
	public async Task&lt;DiscordApplicationRoleConnection&gt; OAuth2UpdateApplicationRoleConnectionAsync(DiscordOAuth2Client oauth2Client, string platformName, string platformUsername, ApplicationRoleConnectionMetadata metadata)
		=&gt; this.AccessToken is not null ? await oauth2Client.UpdateCurrentUserApplicationRoleConnectionAsync(this.AccessToken, platformName, platformUsername, metadata) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
public class AvatarDecorationData
	public string? AssetUrl =&gt; string.IsNullOrWhiteSpace(this.Asset) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS_DECORATION_PRESETS}/{this.Asset}.png?size=1024&quot;;
internal sealed class DiscordUserComparer : IEqualityComparer&lt;DiscordUser&gt;
	public bool Equals(DiscordUser x, DiscordUser y)
		=&gt; x.Equals(y);
	public int GetHashCode(DiscordUser obj)
		=&gt; obj.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Voice/DiscordSoundboardSound.cs">public sealed class DiscordSoundboardSound : SnowflakeObject
		=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
		=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SOUNDBOARD_SOUNDS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.mp3&quot;;
	public async Task&lt;DiscordSoundboardSound&gt; ModifyAsync(Action&lt;SoundboardSoundEditModel&gt; action)
			throw new InvalidOperationException(&quot;You can only edit guild soundboard sounds.&quot;);
		var mdl = new SoundboardSoundEditModel();
		return await this.Discord.ApiClient.ModifyGuildSoundboardSoundAsync(
		).ConfigureAwait(false);
	public Task DeleteSoundboardSoundAsync(string? reason = null)
		=&gt; this.GuildId.HasValue ? this.Discord.ApiClient.DeleteGuildSoundboardSoundAsync(this.GuildId.Value, this.Id, reason) : throw new InvalidOperationException(&quot;You can only delete guild soundboard sounds.&quot;);</file><file path="DisCatSharp/Entities/Voice/DiscordVoiceRegion.cs">public class DiscordVoiceRegion : ObservableApiObject
	public bool Equals(DiscordVoiceRegion region)
	public override bool Equals(object obj) =&gt; this.Equals(obj as DiscordVoiceRegion);
	public override int GetHashCode() =&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Voice/DiscordVoiceState.cs">public class DiscordVoiceState : ObservableApiObject
		=&gt; this.ChannelId is not null &amp;&amp; this.ChannelId.Value != 0 ? this.Discord.InternalGetCachedChannel(this.ChannelId.Value) : null;
				usr = this.Guild.MembersInternal.GetValueOrDefault(this.UserId);
			usr ??= this.Discord.GetCachedOrEmptyUserInternal(this.UserId);
		=&gt; this.Guild!.Members.TryGetValue(this.TransportMember.User!.Id, out var member)
	public override string ToString() =&gt; $&quot;{this.UserId.ToString(CultureInfo.InvariantCulture)} in {(this.GuildId ?? this.Channel.GuildId.Value).ToString(CultureInfo.InvariantCulture)}&quot;;</file><file path="DisCatSharp/Entities/Webhook/DiscordWebhook.cs">public class DiscordWebhook : SnowflakeObject, IEquatable&lt;DiscordWebhook&gt;
		=&gt; !string.IsNullOrWhiteSpace(this.AvatarHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id}/{this.AvatarHash}.png?size=1024&quot; : null;
	public bool Equals(DiscordWebhook e) =&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || this.Id == e.Id);
	public Task&lt;DiscordWebhook&gt; ModifyAsync(string name = null, Optional&lt;Stream&gt; avatar = default, ulong? channelId = null, string reason = null)
		var avatarb64 = MediaTool.Base64FromStream(avatar);
		return this.Discord.ApiClient.ModifyWebhookAsync(this.Id, newChannelId, name, avatarb64, reason);
	public Task&lt;DiscordMessage&gt; GetMessageAsync(ulong messageId)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).GetWebhookMessageAsync(this.Id, this.Token, messageId);
	public async Task&lt;DiscordMessage?&gt; TryGetMessageAsync(ulong messageId)
			return await this.GetMessageAsync(messageId).ConfigureAwait(false);
	public Task&lt;DiscordMessage&gt; GetMessageAsync(ulong messageId, ulong threadId)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).GetWebhookMessageAsync(this.Id, this.Token, messageId, threadId);
	public async Task&lt;DiscordMessage&gt; TryGetMessageAsync(ulong messageId, ulong threadId)
			return await this.GetMessageAsync(messageId, threadId).ConfigureAwait(false);
	public Task DeleteAsync()
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookAsync(this.Id, this.Token);
	public Task&lt;DiscordMessage&gt; ExecuteAsync(DiscordWebhookBuilder builder, string threadId = null)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookAsync(this.Id, this.Token, builder, threadId);
	public Task ExecuteSlackAsync(string json, string threadId = null)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookSlackAsync(this.Id, this.Token, json, threadId);
	public Task ExecuteGithubAsync(string json, string threadId = null)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookGithubAsync(this.Id, this.Token, json, threadId);
	public async Task&lt;DiscordMessage&gt; EditMessageAsync(ulong messageId, DiscordWebhookBuilder builder, string threadId = null)
		builder.Validate(true);
			builder.AttachmentsInternal.AddRange(this.ApiClient.GetWebhookMessageAsync(this.Id, this.Token, messageId.ToString(), threadId).Result.Attachments);
			builder.AttachmentsInternal.Clear();
		return await (this.Discord?.ApiClient ?? this.ApiClient).EditWebhookMessageAsync(this.Id, this.Token, messageId.ToString(), builder, threadId).ConfigureAwait(false);
	public Task DeleteMessageAsync(ulong messageId)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookMessageAsync(this.Id, this.Token, messageId);
	public Task DeleteMessageAsync(ulong messageId, ulong threadId)
		=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookMessageAsync(this.Id, this.Token, messageId, threadId);
	public override bool Equals(object obj) =&gt; this.Equals(obj as DiscordWebhook);
	public override int GetHashCode() =&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Webhook/DiscordWebhookBuilder.cs">public sealed class DiscordWebhookBuilder : DisCatSharpBuilder
	public DiscordWebhookBuilder SuppressEmbeds()
	public DiscordWebhookBuilder AsSilentMessage()
	public DiscordWebhookBuilder SendWithComponents()
	public DiscordWebhookBuilder AsVoiceMessage()
	public DiscordWebhookBuilder AddComponents(params DiscordComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
	public DiscordWebhookBuilder AddComponents(params DiscordActionRowComponent[] components)
		=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
	public DiscordWebhookBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
		var ara = components.ToArray();
			throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
			this.ComponentsInternal.Add(ar);
	public DiscordWebhookBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
		var cmpArr = components.ToArray();
					throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
					throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
			this.ComponentsInternal.AddRange(cmpArr);
					throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
			var comp = new DiscordActionRowComponent(cmpArr);
			this.ComponentsInternal.Add(comp);
	public DiscordWebhookBuilder WithV2Components()
	public DiscordWebhookBuilder WithPoll(DiscordPollBuilder pollBuilder)
	public DiscordWebhookBuilder WithUsername(string username)
	public DiscordWebhookBuilder WithAvatarUrl(string avatarUrl)
	public DiscordWebhookBuilder WithTts(bool tts)
	public DiscordWebhookBuilder WithContent(string content)
	public DiscordWebhookBuilder WithThreadName(string name)
	public DiscordWebhookBuilder AddEmbed(DiscordEmbed embed)
		ArgumentNullException.ThrowIfNull(embed, nameof(embed));
		this.EmbedsInternal.Add(embed);
	public DiscordWebhookBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
		this.EmbedsInternal.AddRange(embeds);
	public DiscordWebhookBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string description = null)
			throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
		if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
			throw new ArgumentException(&quot;A File with that filename already exists&quot;);
			this.FilesInternal.Add(new(filename, data, data.Position, description: description));
			this.FilesInternal.Add(new(filename, data, null, description: description));
	public DiscordWebhookBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string description = null)
		if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
			this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
			this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
	public DiscordWebhookBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
			if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
				this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
				this.FilesInternal.Add(new(file.Key, file.Value, null));
	public DiscordWebhookBuilder ModifyAttachments(IEnumerable&lt;DiscordAttachment&gt; attachments)
		this.AttachmentsInternal.AddRange(attachments);
	public DiscordWebhookBuilder KeepAttachments(bool keep)
	public DiscordWebhookBuilder WithAllowedMention(IMention mention)
		this.MentionsInternal.Add(mention);
	public DiscordWebhookBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
		this.MentionsInternal.AddRange(mentions);
	public DiscordWebhookBuilder WithAppliedTags(IEnumerable&lt;ulong&gt; tags)
		this._appliedTags.AddRange(tags);
	public async Task&lt;DiscordMessage&gt; SendAsync(DiscordWebhook webhook)
		=&gt; await webhook.ExecuteAsync(this).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; SendAsync(DiscordWebhook webhook, ulong threadId)
		=&gt; await webhook.ExecuteAsync(this, threadId.ToString()).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, DiscordMessage message)
		=&gt; await this.ModifyAsync(webhook, message.Id).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, ulong messageId)
		=&gt; await webhook.EditMessageAsync(messageId, this).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, DiscordMessage message, DiscordThreadChannel thread)
		=&gt; await this.ModifyAsync(webhook, message.Id, thread.Id).ConfigureAwait(false);
	public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, ulong messageId, ulong threadId)
		=&gt; await webhook.EditMessageAsync(messageId, this, threadId.ToString()).ConfigureAwait(false);
	public void ClearPoll()
	public override void Clear()
		base.Clear();
	internal void Validate(bool isModify = false, bool isFollowup = false, bool isInteractionResponse = false)
				throw new ArgumentException(&quot;You cannot change the username of a message.&quot;);
				throw new ArgumentException(&quot;You cannot change the avatar of a message.&quot;);
				throw new InvalidOperationException(&quot;You cannnot edit a poll.&quot;);
				throw new ArgumentException(&quot;You cannot change the username of a follow up message.&quot;);
				throw new ArgumentException(&quot;You cannot change the avatar of a follow up message.&quot;);
				throw new ArgumentException(&quot;You cannot change the username of an interaction response.&quot;);
				throw new ArgumentException(&quot;You cannot change the avatar of an interaction response.&quot;);
		if (this.Files?.Count == 0 &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; !this.Embeds.Any() &amp;&amp; !this.Components.Any() &amp;&amp; this.Poll is null &amp;&amp; this?.Attachments.Count == 0)
			throw new ArgumentException(&quot;You must specify content, an embed, a component, a poll, or at least one file.&quot;);
		base.Validate();</file><file path="DisCatSharp/Enums/Application/ApplicationCommandHandlerType.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationCommandIntegrationTypes.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationCommandOptionType.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationCommandPermissionType.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationCommandType.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationDiscoverabilityState.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationDiscoveryEligibilityFlags.cs">public static class ApplicationDiscoveryEligibilityFlagExtensions
	public static bool HasApplicationDiscoveryFlag(this ApplicationDiscoveryEligibilityFlags baseFlags, ApplicationDiscoveryEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Application/ApplicationExplicitContentFilter.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationFlags.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationInteractionsVersion.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationMonetizationEligibilityFlags.cs">public static class ApplicationMonetizationEligibilityFlagExtensions
	public static bool HasApplicationMonetizationEligibilityFlag(this ApplicationMonetizationEligibilityFlags baseFlags, ApplicationMonetizationEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Application/ApplicationMonetizationState.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationRoleConnectionMetadataType.cs"></file><file path="DisCatSharp/Enums/Application/ApplicationVerificationEligibilityFlags.cs">public static class ApplicationVerificationEligibilityFlagExtensions
	public static bool HasVerificationEligibilityFlag(this ApplicationVerificationEligibilityFlags baseFlags, ApplicationVerificationEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Application/ApplicationVerificationState.cs"></file><file path="DisCatSharp/Enums/Application/RpcApplicationState.cs"></file><file path="DisCatSharp/Enums/Application/StoreApplicationState.cs"></file><file path="DisCatSharp/Enums/Channel/ChannelFlags.cs">public static class ChannelFlagExtensions
	public static bool HasChannelFlag(this ChannelFlags baseFlags, ChannelFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Channel/ChannelType.cs"></file><file path="DisCatSharp/Enums/Channel/DirectoryCategory.cs"></file><file path="DisCatSharp/Enums/Channel/OverwriteType.cs"></file><file path="DisCatSharp/Enums/Channel/VideoQualityMode.cs"></file><file path="DisCatSharp/Enums/Core/CooldownBucketType.cs"></file><file path="DisCatSharp/Enums/Core/DisCatSharpCommandType.cs"></file><file path="DisCatSharp/Enums/Core/DisCatSharpStatisticType.cs"></file><file path="DisCatSharp/Enums/Discord/ApiChannel.cs"></file><file path="DisCatSharp/Enums/Discord/DiscordDomain.cs">public static class DiscordDomain
	public static DomainHelpAttribute GetDomain(Enum domainEnum)
			throw new NotSupportedException($&quot;Invalid type. Found: {domainEnum.GetType()} Expected: CoreDomain or OtherDomain or UnusedDomain&quot;);
			throw new UnauthorizedAccessException(&quot;You don&apos;t have access to this domains&quot;);
		var memberInfo = domainEnum.GetType().GetMember(domainEnum.ToString()).FirstOrDefault();
			var attribute = (DomainHelpAttribute)memberInfo.GetCustomAttributes(typeof(DomainHelpAttribute), false).FirstOrDefault();
public class DomainHelpAttribute : Attribute</file><file path="DisCatSharp/Enums/Discord/DiscordEvent.cs">public class EventAttribute : Attribute
		this.EventName = evtn.ToString();
public class EventHandlerAttribute : Attribute</file><file path="DisCatSharp/Enums/Discord/DiscordIntents.cs">public static class DiscordIntentExtensions
	public static bool HasIntent(this DiscordIntents intents, DiscordIntents search)
	public static DiscordIntents AddIntent(this DiscordIntents intents, DiscordIntents toAdd)
	public static DiscordIntents RemoveIntent(this DiscordIntents intents, DiscordIntents toRemove)
	internal static bool HasAllPrivilegedIntents(this DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.GuildMembers | DiscordIntents.GuildPresences | DiscordIntents.MessageContent);
	internal static bool HasAllV9PrivilegedIntents(this DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.GuildMembers | DiscordIntents.GuildPresences);</file><file path="DisCatSharp/Enums/Discord/DiscordShortlink.cs">public static class DiscordShortlink
	public static readonly string Support = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/support&quot;;
	public static readonly string TrustAndSafety = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/request&quot;;
	public static readonly string Contact = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/contact&quot;;
	public static readonly string BugReport = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/bugreport&quot;;
	public static readonly string TranslationError = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/lang-feedback&quot;;
	public static readonly string Status = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/status&quot;;
	public static readonly string Terms = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/terms&quot;;
	public static readonly string Guidelines = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/guidelines&quot;;
	public static readonly string Moderation = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/moderation&quot;;</file><file path="DisCatSharp/Enums/Discord/GatewayCompressionLevel.cs"></file><file path="DisCatSharp/Enums/Discord/OAuth.cs">public static class OAuth
	public static string ResolveScopes(OAuthScopes scope) =&gt;</file><file path="DisCatSharp/Enums/Discord/TokenType.cs"></file><file path="DisCatSharp/Enums/Guild/AuditLogActionCategory.cs"></file><file path="DisCatSharp/Enums/Guild/AuditLogActionType.cs"></file><file path="DisCatSharp/Enums/Guild/Automod/AutomodActionType.cs"></file><file path="DisCatSharp/Enums/Guild/Automod/AutomodEventType.cs"></file><file path="DisCatSharp/Enums/Guild/Automod/AutomodKeywordPresetType.cs"></file><file path="DisCatSharp/Enums/Guild/Automod/AutomodTriggerType.cs"></file><file path="DisCatSharp/Enums/Guild/BadgeType.cs"></file><file path="DisCatSharp/Enums/Guild/BannerType.cs"></file><file path="DisCatSharp/Enums/Guild/DefaultMessageNotifications.cs"></file><file path="DisCatSharp/Enums/Guild/ExplicitContentFilter.cs"></file><file path="DisCatSharp/Enums/Guild/HubType.cs"></file><file path="DisCatSharp/Enums/Guild/JoinRequestStatusType.cs"></file><file path="DisCatSharp/Enums/Guild/MemberFlags.cs">public static class MemberFlagExtensions
	public static bool HasMemberFlag(this MemberFlags baseFlags, MemberFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Guild/MembershipScreeningFieldType.cs"></file><file path="DisCatSharp/Enums/Guild/MfaLevel.cs"></file><file path="DisCatSharp/Enums/Guild/NsfwLevel.cs"></file><file path="DisCatSharp/Enums/Guild/Onboarding/NewMemberActionType.cs"></file><file path="DisCatSharp/Enums/Guild/Onboarding/OnboardingMode.cs"></file><file path="DisCatSharp/Enums/Guild/Onboarding/PromptType.cs"></file><file path="DisCatSharp/Enums/Guild/Permission.cs">public static class PermissionMethods
	public static bool HasPermission(this Permissions p, Permissions permission)
		=&gt; p.HasFlag(Permissions.Administrator) || (p &amp; permission) == permission;
	public static Permissions Grant(this Permissions p, Permissions grant) =&gt; p | grant;
	public static Permissions Revoke(this Permissions p, Permissions revoke) =&gt; p &amp; ~revoke;
public sealed class PermissionStringAttribute : Attribute</file><file path="DisCatSharp/Enums/Guild/PlayStyle.cs"></file><file path="DisCatSharp/Enums/Guild/PremiumTier.cs"></file><file path="DisCatSharp/Enums/Guild/PriceTierType.cs"></file><file path="DisCatSharp/Enums/Guild/RoleFlags.cs"></file><file path="DisCatSharp/Enums/Guild/RoleType.cs"></file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleFrequency.cs"></file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleWeekday.cs"></file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventEntityType.cs"></file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventStatus.cs"></file><file path="DisCatSharp/Enums/Guild/SystemChannelFlags.cs">public static class SystemChannelFlagsExtension
	public static bool HasSystemChannelFlag(this SystemChannelFlags baseFlags, SystemChannelFlags flag)
	public static bool HasSystemChannelFlag(this SystemChannelFlags? baseFlags, SystemChannelFlags flag)</file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ForumLayout.cs"></file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ForumPostSortOrder.cs"></file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ThreadAutoArchiveDuration.cs"></file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ThreadMemberFlags.cs"></file><file path="DisCatSharp/Enums/Guild/VerificationLevel.cs"></file><file path="DisCatSharp/Enums/Guild/WidgetType.cs"></file><file path="DisCatSharp/Enums/Integration/IntegrationExpireBehavior.cs"></file><file path="DisCatSharp/Enums/Interaction/ButtonStyle.cs"></file><file path="DisCatSharp/Enums/Interaction/ComponentType.cs"></file><file path="DisCatSharp/Enums/Interaction/IFrameModalSize.cs"></file><file path="DisCatSharp/Enums/Interaction/InteractionCallbackEphemerality.cs"></file><file path="DisCatSharp/Enums/Interaction/InteractionContextType.cs"></file><file path="DisCatSharp/Enums/Interaction/InteractionResponseType.cs"></file><file path="DisCatSharp/Enums/Interaction/InteractionType.cs"></file><file path="DisCatSharp/Enums/Interaction/SeparatorSpacingSize.cs"></file><file path="DisCatSharp/Enums/Interaction/TextComponentStyle.cs"></file><file path="DisCatSharp/Enums/Invite/InviteFlags.cs">public static class InviteFlagExtensions
	public static bool HasInviteFlag(this InviteFlags baseFlags, InviteFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Invite/InviteType.cs"></file><file path="DisCatSharp/Enums/Invite/TargetType.cs"></file><file path="DisCatSharp/Enums/Message/AttachmentFlags.cs">public static class AttachmentFlagExtensions
	public static bool HasAttachmentFlag(this AttachmentFlags baseFlags, AttachmentFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Message/EmbedFlags.cs">public static class EmbedFlagExtensions
	public static bool HasEmbedFlag(this EmbedFlags baseFlags, EmbedFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Message/LoadingState.cs"></file><file path="DisCatSharp/Enums/Message/MentionType.cs"></file><file path="DisCatSharp/Enums/Message/MessageActivityType.cs"></file><file path="DisCatSharp/Enums/Message/MessageFlags.cs">public static class MessageFlagExtensions
	public static bool HasMessageFlag(this MessageFlags baseFlags, MessageFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Message/MessageType.cs"></file><file path="DisCatSharp/Enums/Message/PollLayoutType.cs"></file><file path="DisCatSharp/Enums/Message/ReferenceType.cs"></file><file path="DisCatSharp/Enums/Message/TimestampFormat.cs"></file><file path="DisCatSharp/Enums/Message/UnfurledMediaFlags.cs">public static class UnfurledMediaFlagExtensions
	public static bool HasUnfurledMediaFlag(this UnfurledMediaFlags baseFlags, UnfurledMediaFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Store/EntitlementOwnerType.cs"></file><file path="DisCatSharp/Enums/Store/EntitlementType.cs"></file><file path="DisCatSharp/Enums/Store/ProductLine.cs"></file><file path="DisCatSharp/Enums/Store/SkuAccessType.cs"></file><file path="DisCatSharp/Enums/Store/SkuFlags.cs">public static class SkuFlagExtensions
	public static bool HasSkuFlag(this SkuFlags baseFlags, SkuFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/Enums/Store/SkuType.cs"></file><file path="DisCatSharp/Enums/Store/SubscriptionStatus.cs"></file><file path="DisCatSharp/Enums/User/ConnectionMetadataVisibilityType.cs"></file><file path="DisCatSharp/Enums/User/ConnectionVisibilityType.cs"></file><file path="DisCatSharp/Enums/User/PremiumType.cs"></file><file path="DisCatSharp/Enums/User/UserFlags.cs"></file><file path="DisCatSharp/Enums/VersionCheckMode.cs"></file><file path="DisCatSharp/Enums/Voice/AnimationType.cs"></file><file path="DisCatSharp/Enums/Voice/SpeakingFlags.cs">public static class SpeakingFlagExtensions
	public static bool HasSpeakingFlag(this SpeakingFlags baseFlags, SpeakingFlags flag) =&gt; (baseFlags &amp; flag) == flag;</file><file path="DisCatSharp/EventArgs/Application/ApplicationCommandEventArgs.cs">public sealed class ApplicationCommandEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Application/ApplicationCommandPermissionsUpdateEventArgs.cs">public sealed class ApplicationCommandPermissionsUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Application/GuildApplicationCommandCountEventArgs.cs">public sealed class GuildApplicationCommandCountEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/ChannelCreateEventArgs.cs">public class ChannelCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/ChannelDeleteEventArgs.cs">public class ChannelDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/ChannelPinsUpdateEventArgs.cs">public class ChannelPinsUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/ChannelUpdateEventArgs.cs">public class ChannelUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/DMChannelDeleteEventArgs.cs">public class DmChannelDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Channel/VoiceChannelStatusUpdateEventArgs.cs">public class VoiceChannelStatusUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/ClientErrorEventArgs.cs">public class ClientErrorEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/DiscordEventArgs.cs">public abstract class DiscordEventArgs : AsyncEventArgs
			this.ServiceProvider = provider.CreateScope().ServiceProvider;
	public IServiceProvider ServiceProvider { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);</file><file path="DisCatSharp/EventArgs/EmbeddedActivityUpdateEventArgs.cs">public class EmbeddedActivityUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodActionExecutedEventArgs.cs">public class AutomodActionExecutedEventArgs : DiscordEventArgs
		=&gt; this.Guild.Members.TryGetValue(this.UserId, out var member) ? member : this.Guild.GetMemberAsync(this.UserId, true).Result;
	public DiscordChannel? Channel =&gt; this.ChannelId.HasValue ? this.Guild.GetChannel(this.ChannelId.Value) : null;</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodCreateRuleEventArgs.cs">public class AutomodRuleCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodDeleteRuleEventArgs.cs">public class AutomodRuleDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodUpdateRuleEventArgs.cs">public class AutomodRuleUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Ban/GuildBanAddEventArgs.cs">public class GuildBanAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Ban/GuildBanRemoveEventArgs.cs">public class GuildBanRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildAuditLogEntryCreateEventArgs.cs">public class GuildAuditLogEntryCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildCreateEventArgs.cs">public class GuildCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildDeleteEventArgs.cs">public class GuildDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildDownloadCompletedEventArgs.cs">public class GuildDownloadCompletedEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildEmojisUpdateEventArgs.cs">public class GuildEmojisUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildIntegrationsUpdateEventArgs.cs">public class GuildIntegrationsUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildStickersUpdateEventArgs.cs">public class GuildStickersUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/GuildUpdateEventArgs.cs">public class GuildUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationCreateEventArgs.cs">public class GuildIntegrationCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationDeleteEventArgs.cs">public class GuildIntegrationDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationUpdateEventArgs.cs">public class GuildIntegrationUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberAddEventArgs.cs">public class GuildMemberAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberRemoveEventArgs.cs">public class GuildMemberRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMembersChunkEventArgs.cs">public class GuildMembersChunkEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberUpdateEventArgs.cs">public class GuildMemberUpdateEventArgs : DiscordEventArgs
		=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHashBefore}.{(this.GuildAvatarHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHashAfter}.{(this.GuildAvatarHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.AvatarHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHashBefore}.{(this.AvatarHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.AvatarHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHashAfter}.{(this.AvatarHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHashBefore}.{(this.GuildBannerHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
		=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHashAfter}.{(this.GuildBannerHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestCreateEventArgs.cs">public class GuildJoinRequestCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestDeleteEventArgs.cs">public class GuildJoinRequestDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestUpdateEventArgs.cs">public class GuildJoinRequestUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleCreateEventArgs.cs">public class GuildRoleCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleDeleteEventArgs.cs">public class GuildRoleDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleUpdateEventArgs.cs">public class GuildRoleUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventCreateEventArgs.cs">public class GuildScheduledEventCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventDeleteEventArgs.cs">public class GuildScheduledEventDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUpdateEventArgs.cs">public class GuildScheduledEventUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserAddEventArgs.cs">public class GuildScheduledEventUserAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserRemoveEventArgs.cs">public class GuildScheduledEventUserRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundCreateEventArgs.cs">public class GuildSoundboardSoundCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundDeleteEventArgs.cs">public class GuildSoundboardSoundDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundsUpdateEventArgs.cs">public class GuildSoundboardSoundsUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundUpdateEventArgs.cs">public class GuildSoundboardSoundUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/SoundboardSoundsEventArgs.cs">public class SoundboardSoundsEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadCreateEventArgs.cs">public class ThreadCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadDeleteEventArgs.cs">public class ThreadDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadListSyncEventArgs.cs">public class ThreadListSyncEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadMembersUpdateEventArgs.cs">public class ThreadMembersUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadMemberUpdateEventArgs.cs">public class ThreadMemberUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadUpdateEventArgs.cs">public class ThreadUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutAddEventArgs.cs">public class GuildMemberTimeoutAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutRemoveEventArgs.cs">public class GuildMemberTimeoutRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutUpdateEventArgs.cs">public class GuildMemberTimeoutUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/HeartBeatEventArgs.cs">public class HeartbeatEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Interaction/ComponentInteractionCreateEventArgs.cs">public class ComponentInteractionCreateEventArgs : InteractionCreateEventArgs</file><file path="DisCatSharp/EventArgs/Interaction/ContextMenuInteractionCreateEventArgs.cs">public sealed class ContextMenuInteractionCreateEventArgs : InteractionCreateEventArgs</file><file path="DisCatSharp/EventArgs/Interaction/InteractionCreateEventArgs.cs">public class InteractionCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Invite/InviteCreateEventArgs.cs">public sealed class InviteCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Invite/InviteDeleteEventArgs.cs">public sealed class InviteDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/MessageAcknowledgeEventArgs.cs">public sealed class MessageAcknowledgeEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/MessageBulkDeleteEventArgs.cs">public class MessageBulkDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/MessageCreateEventArgs.cs">public class MessageCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/MessageDeleteEventArgs.cs">public class MessageDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/MessageUpdateEventArgs.cs">public class MessageUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Polls/MessagePollVoteAddEventArgs.cs">public sealed class MessagePollVoteAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Polls/MessagePollVoteRemoveEventArgs.cs">public sealed class MessagePollVoteRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionAddEventArgs.cs">public class MessageReactionAddEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEmojiEventArgs.cs">public sealed class MessageReactionRemoveEmojiEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEventArgs.cs">public class MessageReactionRemoveEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionsClearEventArgs.cs">public class MessageReactionsClearEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/PayloadReceivedEventArgs.cs">public class PayloadReceivedEventArgs : DiscordEventArgs
			if (string.IsNullOrWhiteSpace(this._json))
				this._json = this.PayloadObject.ToString();</file><file path="DisCatSharp/EventArgs/RateLimitExceptionEventArgs.cs">public class RateLimitExceptionEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/ReadyEventArgs.cs">public sealed class ReadyEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Socket/SocketDisconnectEventArgs.cs">public class SocketCloseEventArgs : DiscordEventArgs
public class SocketErrorEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Socket/SocketEventArgs.cs">public class SocketEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Socket/WebSocketMessageEventArgs.cs">public abstract class SocketMessageEventArgs : AsyncEventArgs
public sealed class SocketTextMessageEventArgs : SocketMessageEventArgs
public sealed class SocketBinaryMessageEventArgs : SocketMessageEventArgs</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceCreateEventArgs.cs">public class StageInstanceCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceDeleteEventArgs.cs">public class StageInstanceDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceUpdateEventArgs.cs">public class StageInstanceUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Store/EntitlementCreateEventArgs.cs">public class EntitlementCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Store/EntitlementDeleteEventArgs.cs">public class EntitlementDeleteEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Store/EntitlementUpdateEventArgs.cs">public class EntitlementUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Store/SubscriptionCreateEventArgs.cs">public class SubscriptionCreateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Store/SubscriptionUpdateEventArgs.cs">public class SubscriptionUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/TypingStartEventArgs.cs">public class TypingStartEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/UnknownEventArgs.cs">public class UnknownEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/User/PresenceUpdateEventArgs.cs">public class PresenceUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/User/UserSettingsUpdateEventArgs.cs">public class UserSettingsUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/User/UserSpeakingEventArgs.cs">public class UserSpeakingEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/User/UserUpdateEventArgs.cs">public class UserUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Voice/VoiceChannelEffectSendEventArgs.cs">public class VoiceChannelEffectSendEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Voice/VoiceServerUpdateEventArgs.cs">public class VoiceServerUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/Voice/VoiceStateUpdateEventArgs.cs">public class VoiceStateUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/WebhooksUpdateEventArgs.cs">public class WebhooksUpdateEventArgs : DiscordEventArgs</file><file path="DisCatSharp/EventArgs/ZombiedEventArgs.cs">public class ZombiedEventArgs : DiscordEventArgs</file><file path="DisCatSharp/Exceptions/BadRequestException.cs">public class BadRequestException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();
				this.Errors = j[&quot;errors&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/DisCatSharpException.cs">public class DisCatSharpException : Exception</file><file path="DisCatSharp/Exceptions/DisCatSharpUserException.cs">public class DisCatSharpUserException : Exception</file><file path="DisCatSharp/Exceptions/DiscordJsonException.cs">public sealed class DiscordJsonException : DisCatSharpException</file><file path="DisCatSharp/Exceptions/ExceptionFilter.cs">public class DisCatSharpExceptionFilter : IExceptionFilter
	public bool Filter(Exception ex)
		=&gt; !this.Config.TrackExceptions.Contains(ex.GetType());</file><file path="DisCatSharp/Exceptions/NotFoundException.cs">public class NotFoundException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/NotIndexedException.cs">public sealed class NotIndexedException : Exception
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/RateLimitException.cs">public class RateLimitException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/RequestSizeException.cs">public class RequestSizeException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/ServerErrorException.cs">public class ServerErrorException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/UnauthorizedException.cs">public class UnauthorizedException : DisCatSharpException
			var j = JObject.Parse(response.Response);
				this.JsonMessage = j[&quot;message&quot;]!.ToString();</file><file path="DisCatSharp/Exceptions/ValidationException.cs">public sealed class ValidationException : DisCatSharpUserException</file><file path="DisCatSharp/Formatter.cs">public static class Formatter
	public static string BlockCode(this string content, string language = &quot;&quot;)
	public static string InlineCode(this string content)
	public static string Timestamp(this TimeSpan time, TimestampFormat format = TimestampFormat.RelativeTime)
	public static string Timestamp(this DateTimeOffset time, TimestampFormat format = TimestampFormat.RelativeTime)
		=&gt; $&quot;&lt;t:{time.ToUnixTimeSeconds()}:{(char)format}&gt;&quot;;
	public static string Timestamp(this DateTime time, TimestampFormat format = TimestampFormat.RelativeTime)
		=&gt; Timestamp(time.ToUniversalTime() - DateTime.UtcNow, format);
	public static string Subtext(this string content)
	public static string Bold(this string content)
	public static string Italic(this string content)
	public static string Spoiler(this string content)
	public static string Underline(this string content)
	public static string Strike(this string content)
	public static string Header1(this string content)
	public static string Header2(this string content)
	public static string Header3(this string content)
	public static string SingleQuote(this string content)
	public static string MultiQuote(this string content)
	public static string SimpleList(this string[] content)
		=&gt; string.Join(&quot;\n&quot;, content.Select(x =&gt; $&quot;- {x}&quot;));
	public static string EmbedlessUrl(this Uri url)
	public static string MaskedUrl(this string text, Uri url, string? altText = null, bool embedless = false)
		=&gt; $&quot;[{text}]({(embedless ? EmbedlessUrl(url) : url)}{(!string.IsNullOrWhiteSpace(altText) ? $&quot; \&quot;{altText}\&quot;&quot; : string.Empty)})&quot;;
	public static string Sanitize(this string text)
		=&gt; CommonRegEx.MdSanitizeRegex().Replace(text, m =&gt; $&quot;\\{m.Groups[1].Value}&quot;);
	public static string Strip(this string text)
		=&gt; CommonRegEx.MdStripRegex().Replace(text, m =&gt; string.Empty);
	public static string Mention(this DiscordUser user, bool nickname = false)
			? $&quot;&lt;@!{user.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
			: $&quot;&lt;@{user.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
	public static string Mention(this DiscordChannel channel)
		=&gt; $&quot;&lt;#{channel.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
	public static string Mention(this DiscordRole role)
		=&gt; $&quot;&lt;@&amp;{role.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
	public static string Emoji(this DiscordEmoji emoji)
		=&gt; $&quot;&lt;:{emoji.Name}:{emoji.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
	public static string AttachedImageUrl(this string filename)</file><file path="DisCatSharp/GlobalSuppressions.cs"></file><file path="DisCatSharp/Internals.cs">public static class Internals
	internal static bool IsVoiceJoinable(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage;
	internal static bool IsThreadHolder(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Text || channel.Type == ChannelType.News || channel.Type == ChannelType.Forum;
	internal static bool IsThread(this DiscordChannel channel) =&gt; channel.Type == ChannelType.PublicThread || channel.Type == ChannelType.PrivateThread || channel.Type == ChannelType.NewsThread;
	internal static bool IsWritable(this DiscordChannel channel) =&gt; channel.Type is
	internal static bool IsMovableInParent(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage || channel.Type == ChannelType.Text || channel.Type == ChannelType.Forum || channel.Type == ChannelType.News;
	internal static bool IsMovable(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage || channel.Type == ChannelType.Text || channel.Type == ChannelType.Category || channel.Type == ChannelType.Forum || channel.Type == ChannelType.News;</file><file path="DisCatSharp/Logging/CompositeDefaultLogger.cs">internal class CompositeDefaultLogger : ILogger&lt;BaseDiscordClient&gt;
		this._loggers = providers.Select(x =&gt; x.CreateLogger(typeof(BaseDiscordClient).FullName!))
			.ToList();
	public bool IsEnabled(LogLevel logLevel)
	public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
			logger.Log(logLevel, eventId, state, exception, formatter);
	public IDisposable BeginScope&lt;TState&gt;(TState state) where TState : notnull
		=&gt; throw new NotImplementedException();</file><file path="DisCatSharp/Logging/DefaultLogger.cs">public class DefaultLogger : ILogger&lt;BaseDiscordClient&gt;
	private static readonly Lock s_lock = new();
	private readonly LogLevel _minimumLevel;
	public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
		if (!this.IsEnabled(logLevel))
			Console.Write($&quot;[{DateTimeOffset.Now.ToString(this._timestampFormat)}] [{eventId.Id,-4}/{ename,-12}] &quot;);
					throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null);
			Console.Write(logLevel switch
				_ =&gt; throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null)
			Console.ResetColor();
				Console.Write(&quot; &quot;);
			Console.WriteLine(message);
				Console.WriteLine(exception);
	public bool IsEnabled(LogLevel logLevel)
	public IDisposable BeginScope&lt;TState&gt;(TState state) where TState : notnull
		=&gt; throw new NotImplementedException();</file><file path="DisCatSharp/Logging/DefaultLoggerFactory.cs">internal class DefaultLoggerFactory : ILoggerFactory
	public void AddProvider(ILoggerProvider provider)
		=&gt; this._providers.Add(provider);
	public ILogger CreateLogger(string categoryName)
			? throw new ObjectDisposedException(nameof(DefaultLoggerFactory), &quot;This logger factory is already disposed.&quot;)
				? throw new ArgumentException($&quot;This factory can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, {typeof(DiscordWebhookClient).FullName} or {typeof(DiscordOAuth2Client).FullName}, not {categoryName}.&quot;, nameof(categoryName))
				: new CompositeDefaultLogger(this._providers);
	public void Dispose()
		ObjectDisposedException.ThrowIf(this._isDisposed, this);
			provider.Dispose();
		this._providers.Clear();</file><file path="DisCatSharp/Logging/DefaultLoggerProvider.cs">internal class DefaultLoggerProvider : ILoggerProvider
	private readonly LogLevel _minimumLevel;
	public ILogger CreateLogger(string categoryName) =&gt;
			? throw new ObjectDisposedException(nameof(DefaultLoggerProvider), &quot;This logger provider is already disposed.&quot;)
				? throw new ArgumentException($&quot;This provider can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, {typeof(DiscordWebhookClient).FullName} or {typeof(DiscordOAuth2Client).FullName}.&quot;, nameof(categoryName))
				: new DefaultLogger(this._minimumLevel, this._timestampFormat);
	public void Dispose()</file><file path="DisCatSharp/Logging/LoggerEvents.cs">public static class LoggerEvents</file><file path="DisCatSharp/Logging/ShardedLoggerFactory.cs">internal class ShardedLoggerFactory : ILoggerFactory
	public void AddProvider(ILoggerProvider provider)
		=&gt; throw new InvalidOperationException(&quot;This is a passthrough logger container, it cannot register new providers.&quot;);
	public ILogger CreateLogger(string categoryName) =&gt;
			? throw new ArgumentException($&quot;This factory can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, not for {categoryName}&quot;, nameof(categoryName))
	public void Dispose()</file><file path="DisCatSharp/MediaTool.cs">public sealed class MediaTool : IDisposable
	private MediaFormat _mfCache = MediaFormat.Unknown;
		ArgumentNullException.ThrowIfNull(stream);
			throw new ArgumentException(&quot;The stream needs to be both readable and seekable.&quot;, nameof(stream));
		this.SourceStream.Seek(0, SeekOrigin.Begin);
	public void Dispose()
	public MediaFormat GetFormat()
		using var br = new BinaryReader(this.SourceStream, Utilities.UTF8, true);
		var bgn64 = br.ReadUInt64();
		if (bgn32 is WEBP_MAGIC_1 &amp;&amp; br.ReadUInt32() is WEBP_MAGIC_2)
			this.SourceStream.Seek(-2, SeekOrigin.End);
			if (br.ReadUInt16() is JPEG_MAGIC_2)
		throw new InvalidDataException(&quot;The data within the stream was not valid media data.&quot;);
	public string GetBase64()
		var fmt = this.GetFormat();
		var sb = new StringBuilder();
		sb.Append(&quot;data:&quot;)
			.Append(fmt.ToMimeType())
			.Append(&quot;;base64,&quot;);
			br += this.SourceStream.Read(buff, br, (int)this.SourceStream.Length - br);
		sb.Append(Convert.ToBase64String(buff));
		return this._b64Cache = sb.ToString();
	public static string Base64FromStream(Stream stream)
		using var mediatool = new MediaTool(stream);
		return mediatool.GetBase64();
	public static Optional&lt;string?&gt; Base64FromStream(Optional&lt;Stream?&gt; stream)
public static class MediaFormattExtensions
	public static string ToMimeType(this MediaFormat format)
			_ =&gt; throw new InvalidOperationException(&quot;Unknown media format.&quot;)</file><file path="DisCatSharp/Net/Abstractions/AuditLogAbstractions.cs">internal sealed class AuditLogUser
internal sealed class AuditLogWebhook
internal sealed class AuditLogThreadMetadata
internal sealed class AuditLogThread
internal sealed class AuditLogGuildScheduledEvent
internal sealed class AuditLogGuildScheduledEventEntityMetadata
internal sealed class AuditLogIntegrationAccount
internal sealed class AuditLogIntegration
internal sealed class AuditLogActionChange
internal sealed class AuditLogActionOptions
internal sealed class AuditLogAction
internal sealed class AuditLog : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/ClientProperties.cs">internal sealed class ClientProperties : ObservableApiObject
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
			if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
			var plat = RuntimeInformation.OSDescription.ToLowerInvariant();
			if (plat.Contains(&quot;freebsd&quot;))
			if (plat.Contains(&quot;openbsd&quot;))
			if (plat.Contains(&quot;netbsd&quot;))
			if (plat.Contains(&quot;dragonfly&quot;))
			if (plat.Contains(&quot;miros bsd&quot;) || plat.Contains(&quot;mirbsd&quot;))
			if (plat.Contains(&quot;desktopbsd&quot;))
			return plat.Contains(&quot;darwin&quot;)
				: plat.Contains(&quot;unix&quot;)
			var a = typeof(DiscordClient).GetTypeInfo().Assembly;
			var an = a.GetName();
			return $&quot;DisCatSharp {an.Version.ToString(4)}&quot;;</file><file path="DisCatSharp/Net/Abstractions/FollowedChannelAddPayload.cs">internal sealed class FollowedChannelAddPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Gateway/DiscordDispatchPayload.cs">internal sealed class DiscordDispatchPayload</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayHello.cs">internal sealed class GatewayHello</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayIdentifyResume.cs">internal sealed class GatewayIdentify
internal sealed class GatewayResume</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayInfo.cs">public sealed class GatewayInfo</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayOpCode.cs"></file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayPayload.cs">internal sealed class GatewayPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayRequestGuildMembers.cs">internal sealed class GatewayRequestGuildMembers : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Gateway/SoundboardSoundsPayloads.cs">internal sealed class RequestSoundboardSoundsPayload : ObservableApiObject
internal sealed class SoundboardSoundsEventPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Gateway/VoiceStateUpdatePayload.cs">internal sealed class VoiceStateUpdatePayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/IOAuth2Payload.cs">internal interface IOAuth2Payload</file><file path="DisCatSharp/Net/Abstractions/ReadyPayload.cs">internal sealed class ReadyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestApplicationCommandPayloads.cs">internal sealed class RestApplicationCommandCreatePayload : ObservableApiObject
internal sealed class RestApplicationCommandEditPayload : ObservableApiObject
internal sealed class RestInteractionResponsePayload : ObservableApiObject
internal sealed class RestInteractionModalResponsePayload : ObservableApiObject
internal sealed class RestInteractionIframeResponsePayload : ObservableApiObject
internal sealed class RestFollowupMessageCreatePayload : ObservableApiObject
internal sealed class RestApplicationRoleConnectionMetadataPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestApplicationPayloads.cs">internal sealed class RestApplicationModifyPayload : ObservableApiObject
internal class RestApplicationEmojiModifyPayload : ObservableApiObject
internal sealed class RestApplicationEmojiCreatePayload : RestApplicationEmojiModifyPayload</file><file path="DisCatSharp/Net/Abstractions/Rest/RestAutomodRuleModifyPayload.cs">internal sealed class RestAutomodRuleModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestChannelPayloads.cs">internal sealed class RestChannelCreatePayload : ObservableApiObject
internal sealed class RestChannelModifyPayload : ObservableApiObject
internal class RestChannelMessageEditPayload : ObservableApiObject
	public bool ShouldSerializeContent()
	public bool ShouldSerializeEmbed()
internal sealed class RestChannelMessageCreatePayload : RestChannelMessageEditPayload
internal sealed class RestChannelMessageCreateMultipartPayload : ObservableApiObject
internal sealed class RestChannelMessageBulkDeletePayload : ObservableApiObject
internal sealed class RestChannelInviteCreatePayload : ObservableApiObject
internal sealed class RestChannelPermissionEditPayload : ObservableApiObject
internal sealed class RestChannelGroupDmRecipientAddPayload : IOAuth2Payload
internal sealed class AcknowledgePayload : ObservableApiObject
internal sealed class RestThreadChannelCreatePayload : ObservableApiObject
internal sealed class RestThreadChannelModifyPayload : ObservableApiObject
internal sealed class RestVoiceChannelStatusModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestForumPostTagPayloads.cs">internal sealed class RestForumPostTagPayloads : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildPayloads.cs">internal interface IReasonAction
internal sealed class RestGuildCreatePayload : ObservableApiObject
internal sealed class RestGuildCreateFromTemplatePayload : ObservableApiObject
internal sealed class RestGuildModifyPayload : ObservableApiObject
internal sealed class RestGuildMfaLevelModifyPayload : ObservableApiObject
internal sealed class RestGuildFeatureModifyPayload : ObservableApiObject
internal sealed class RestGuildSafetyModifyPayload : ObservableApiObject
internal sealed class RestGuildCommunityModifyPayload : ObservableApiObject
internal sealed class RestGuildInventoryModifyPayload : ObservableApiObject
internal sealed class RestGuildIncidentActionsModifyPayload : ObservableApiObject
internal sealed class RestGuildOnboardingModifyPayload : ObservableApiObject
internal sealed class RestGuildServerGuideModifyPayload : ObservableApiObject
internal sealed class RestGuildMemberAddPayload : IOAuth2Payload
internal sealed class RestGuildChannelReorderPayload : ObservableApiObject
internal sealed class RestGuildChannelNewParentPayload : ObservableApiObject
internal sealed class RestGuildChannelNoParentPayload : ObservableApiObject
internal sealed class RestGuildRoleReorderPayload
internal sealed class RestGuildMemberModifyPayload : ObservableApiObject
internal sealed class RestGuildMemberTimeoutModifyPayload : ObservableApiObject
internal sealed class RestGuildRolePayload : ObservableApiObject
internal sealed class RestGuildPruneResultPayload : ObservableApiObject
internal sealed class RestGuildIntegrationAttachPayload : ObservableApiObject
internal sealed class RestGuildJoinRequestUpdatePayload : ObservableApiObject
internal sealed class RestGuildIntegrationModifyPayload : ObservableApiObject
internal class RestGuildEmojiModifyPayload : ObservableApiObject
internal class RestGuildEmojiCreatePayload : RestGuildEmojiModifyPayload
internal class RestGuildWidgetSettingsPayload : ObservableApiObject
internal class RestGuildTemplateCreateOrModifyPayload : ObservableApiObject
internal class RestGuildMembershipScreeningFormModifyPayload : ObservableApiObject
internal class RestGuildWelcomeScreenModifyPayload : ObservableApiObject
internal class RestGuildUpdateCurrentUserVoiceStatePayload : ObservableApiObject
internal class RestGuildUpdateUserVoiceStatePayload : ObservableApiObject
internal sealed class RestGuildBanPayload : ObservableApiObject
internal sealed class RestGuildBulkBanPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildScheduledEventPayloads.cs">internal sealed class RestGuildScheduledEventCreatePayload : ObservableApiObject
internal sealed class RestGuildScheduledEventModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildSoundboardSoundPayloads.cs">internal sealed class RestSoundboardSoundCreatePayload : ObservableApiObject
internal sealed class RestSoundboardSoundModifyPayload : ObservableApiObject
internal sealed class RestSendSoundboardSoundPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestOAuth2ApplicationRoleConnectionPayload.cs">internal sealed class RestOAuth2ApplicationRoleConnectionPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStageInstancePayloads.cs">internal sealed class RestStageInstanceCreatePayload : ObservableApiObject
internal sealed class RestStageInstanceModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStickerPayloads.cs">internal sealed class RestStickerModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStorePayloads.cs">internal sealed class TestEntitlementCreatePayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestUserPayloads.cs">internal sealed class RestUserDmCreatePayload : ObservableApiObject
internal sealed class RestUserGroupDmCreatePayload : ObservableApiObject
internal sealed class RestUserUpdateCurrentPayload : ObservableApiObject
	public bool ShouldSerializeAvatarBase64()
	public bool ShouldSerializeBannerBase64()
internal sealed class RestUserGuild : ObservableApiObject
internal sealed class RestUserGuildListPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestWebhookPayloads.cs">internal sealed class RestWebhookPayload : ObservableApiObject
	public bool ShouldSerializeAvatarBase64()
internal sealed class RestWebhookExecutePayload : ObservableApiObject
internal sealed class RestWebhookMessageEditPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/ShardInfo.cs">internal sealed class ShardInfo
internal sealed class ShardInfoConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		serializer.Serialize(writer, obj);
	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		var arr = this.ReadArrayObject(reader, serializer);
		return new ShardInfo
	private JArray ReadArrayObject(JsonReader reader, JsonSerializer serializer) =&gt;
			? throw new JsonSerializationException(&quot;Expected array of length 2&quot;)
	public override bool CanConvert(Type objectType) =&gt; objectType == typeof(ShardInfo);</file><file path="DisCatSharp/Net/Abstractions/StatusUpdate.cs">internal sealed class StatusUpdate : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportActivity.cs">internal sealed class TransportActivity : ObservableApiObject
		get =&gt; this.ApplicationIdStr != null ? ulong.Parse(this.ApplicationIdStr, CultureInfo.InvariantCulture) : null;
	public bool IsRichPresence()
	public bool IsCustomStatus()
	public class PresenceAssets
	public class GameParty
		public class GamePartySize
	public class GameTimestamps
			=&gt; this.StartInternal != null ? Utilities.GetDateTimeOffsetFromMilliseconds(this.StartInternal.Value, false) : null;
			=&gt; this.EndInternal != null ? Utilities.GetDateTimeOffsetFromMilliseconds(this.EndInternal.Value, false) : null;
	public class GameSecrets
internal sealed class GamePartySizeConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		serializer.Serialize(writer, obj);
	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		var arr = this.ReadArrayObject(reader, serializer);
	private JArray ReadArrayObject(JsonReader reader, JsonSerializer serializer) =&gt;
			? throw new JsonSerializationException(&quot;Expected array of length 2&quot;)
	public override bool CanConvert(Type objectType) =&gt; objectType == typeof(TransportActivity.GameParty.GamePartySize);</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportApplication.cs">internal sealed class TransportApplication : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportMember.cs">internal class TransportMember : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportTeam.cs">internal sealed class TransportTeam : ObservableApiObject
internal sealed class TransportTeamMember</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportUser.cs">internal class TransportUser : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/VoiceStateUpdate.cs">internal sealed class VoiceStateUpdate : ObservableApiObject</file><file path="DisCatSharp/Net/ConnectionEndpoint.cs">	public readonly override int GetHashCode()
		=&gt; 13 + (7 * this.Hostname.GetHashCode()) + (7 * this.Port);
	public readonly override string ToString()
	internal readonly string ToHttpString()
	internal readonly string ToWebSocketString()</file><file path="DisCatSharp/Net/Models/ApplicationCommandEditModel.cs">public class ApplicationCommandEditModel : ObservableApiObject
				throw new ArgumentException(&quot;Application command name cannot exceed 32 characters.&quot;, nameof(value));
				throw new ArgumentException(&quot;Application command description cannot exceed 100 characters.&quot;, nameof(value));</file><file path="DisCatSharp/Net/Models/AutomodRuleEditModel.cs">public class AutomodRuleEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/BaseEditModel.cs">public class BaseEditModel</file><file path="DisCatSharp/Net/Models/ChannelEditModel.cs">public class ChannelEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/ForumChannelEditModel.cs">public class ForumChannelEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/ForumPostTagEditModel.cs">public class ForumPostTagEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/GuildEditModel.cs">public class GuildEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/MemberEditModel.cs">public class MemberEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/MembershipScreeningEditModel.cs">public class MembershipScreeningEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/RoleEditModel.cs">public class RoleEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/ScheduledEventEditModel.cs">public class ScheduledEventEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/SoundboardSoundEditModel.cs">public sealed class SoundboardSoundEditModel : ObservableApiObject
				throw new ArgumentException(&quot;Soundboard sound name cannot exceed 100 characters.&quot;, nameof(value));
				throw new ArgumentException(&quot;Soundboard sound volume must be between 0.0 and 1.0.&quot;, nameof(value));</file><file path="DisCatSharp/Net/Models/ThreadEditModel.cs">public class ThreadEditModel : BaseEditModel</file><file path="DisCatSharp/Net/Models/WelcomeScreenEditModel.cs">public class WelcomeScreenEditModel</file><file path="DisCatSharp/Net/Rest/BaseRestRequest.cs">public abstract class BaseRestRequest
		headers = headers.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Uri.EscapeDataString(x.Value)))
			.ToDictionary(x =&gt; x.Key, x =&gt; x.Value);
	public Task&lt;RestResponse&gt; WaitForCompletionAsync()
	protected internal void SetCompleted(RestResponse response)
		=&gt; this.RequestTaskSource.SetResult(response);
	protected internal void SetFaulted(Exception ex)
		=&gt; this.RequestTaskSource.SetException(ex);
	protected internal bool TrySetFaulted(Exception ex)
		=&gt; this.RequestTaskSource.TrySetException(ex);</file><file path="DisCatSharp/Net/Rest/CommonHeaders.cs">public static class CommonHeaders</file><file path="DisCatSharp/Net/Rest/DiscordApiClient.cs">public sealed class DiscordApiClient
	private static string BuildQueryString(Dictionary&lt;string, string&gt; values, bool post = false)
		var valsCollection = values.Select(xkvp =&gt;
			$&quot;{WebUtility.UrlEncode(xkvp.Key)}={WebUtility.UrlEncode(xkvp.Value)}&quot;);
		var vals = string.Join(&quot;&amp;&quot;, valsCollection);
	private DiscordMessage PrepareMessage(JToken msgRaw)
		this.PopulateMessage(author, ret);
		if (ret is { InternalReference.Type: ReferenceType.Default, MessageType: MessageType.Reply } &amp;&amp; !string.IsNullOrWhiteSpace(referencedMsg?.ToString()))
			this.PopulateMessage(author, ret.ReferencedMessage);
			? new DiscordDmChannel
			: new DiscordChannel
	private void PopulateMessage(TransportUser author, DiscordMessage ret)
		if (author.IsBot &amp;&amp; int.Parse(author.Discriminator) == 0)
			if (!this.Discord.UserCache.TryGetValue(author.Id, out var usr))
				if (!guild.Members.TryGetValue(author.Id, out var mbr))
		ret.PopulateMentions();
				x.Message.MentionedUsersInternal.ForEach(u =&gt; u.Discord = this.Discord);
				x.Message.AttachmentsInternal.ForEach(a =&gt; a.Discord = this.Discord);
				x.Message.EmbedsInternal.ForEach(a =&gt; a.Discord = this.Discord);
				x.Message.MentionedChannelsInternal.ForEach(u =&gt; u.Discord = this.Discord);
				x.Message.MentionedRolesInternal.ForEach(u =&gt; u.Discord = this.Discord);
			x.Message.PopulateMentions();
	internal Task&lt;RestResponse&gt; DoRequestAsync(BaseDiscordClient client, RateLimitBucket bucket, Uri url, RestRequestMethod method, string route, IReadOnlyDictionary&lt;string, string&gt;? headers = null, string? payload = null, double? ratelimitWaitOverride = null, bool targetDebug = false)
		var req = new RestRequest(client, bucket, url, method, route, headers, payload, ratelimitWaitOverride);
			this.Rest.ExecuteRequestAsync(req, targetDebug).LogTaskFault(this.Discord.Logger, LogLevel.Error, LoggerEvents.RestError, $&quot;Error while executing request. Url: {url.AbsoluteUri}&quot;);
			_ = this.Rest.ExecuteRequestAsync(req, targetDebug);
		return req.WaitForCompletionAsync();
	internal Task&lt;RestResponse&gt; DoFormRequestAsync(DiscordOAuth2Client client, RateLimitBucket bucket, Uri url, RestRequestMethod method, string route, Dictionary&lt;string, string&gt; formData, Dictionary&lt;string, string&gt;? headers = null, double? ratelimitWaitOverride = null, bool targetDebug = false)
		var req = new RestFormRequest(client, bucket, url, method, route, formData, headers, ratelimitWaitOverride);
		this.Rest.ExecuteFormRequestAsync(req, targetDebug).LogTaskFault(this.OAuth2Client.Logger, LogLevel.Error, LoggerEvents.RestError, $&quot;Error while executing request. Url: {url.AbsoluteUri}&quot;);
	private Task&lt;RestResponse&gt; DoStickerMultipartAsync(
		var req = new MultipartStickerWebRequest(client, bucket, url, method, route, name, tags, description, headers, file, ratelimitWaitOverride);
			this.Rest.ExecuteRequestAsync(req, targetDebug).LogTaskFault(this.Discord.Logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while executing request&quot;);
	private Task&lt;RestResponse&gt; DoMultipartAsync(
		var req = new MultipartWebRequest(client, bucket, url, method, route, headers, values, files, ratelimitWaitOverride);
	internal async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
		var bucket = this.Rest.GetBucket(RestRequestMethod.GET, route, new
		var url = Utilities.GetApiUriFor(path, this.Discord.Configuration);
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route).ConfigureAwait(false);
	internal async Task&lt;DiscordGuild&gt; GetGuildAsync(ulong guildId, bool? withCounts)
			urlParams[&quot;with_counts&quot;] = withCounts.Value.ToString();
		var url = Utilities.GetApiUriFor(path, urlParams.Count != 0 ? BuildQueryString(urlParams) : &quot;&quot;, this.Discord.Configuration);
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route, urlParams).ConfigureAwait(false);
		var json = JObject.Parse(res.Response);
			await dc.OnGuildUpdateEventAsync(guildRest, rawMembers).ConfigureAwait(false);
	internal async Task&lt;IReadOnlyList&lt;DiscordMember&gt;&gt; SearchGuildMembersAsync(ulong guildId, string name, int? limit)
			[&quot;limit&quot;] = limit.ToString()
		var url = Utilities.GetApiUriFor(path, BuildQueryString(querydict), this.Discord.Configuration);
		var json = JArray.Parse(res.Response);
			var usr = new DiscordUser(xtm.User)
			this.Discord.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
			mbrs.Add(new(xtm)
	internal async Task&lt;DiscordBan&gt; GetGuildBanAsync(ulong guildId, ulong userId)
		var uri = Utilities.GetApiUriFor(path, this.Discord.Configuration);
		var res = await this.DoRequestAsync(this.Discord, bucket, uri, RestRequestMethod.GET, route).ConfigureAwait(false);
	internal async Task&lt;DiscordGuild&gt; CreateGuildAsync(
		var pld = new RestGuildCreatePayload
		var bucket = this.Rest.GetBucket(RestRequestMethod.POST, route, new
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
			await dc.OnGuildCreateEventAsync(guild, rawMembers, null).ConfigureAwait(false);
	internal async Task&lt;DiscordGuild&gt; CreateGuildFromTemplateAsync(string templateCode, string name, Optional&lt;string&gt; iconb64)
		var pld = new RestGuildCreateFromTemplatePayload
	internal async Task DeleteGuildAsync(ulong guildId)
		var bucket = this.Rest.GetBucket(RestRequestMethod.DELETE, route, new
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route).ConfigureAwait(false);
			await dc.OnGuildDeleteEventAsync(gld).ConfigureAwait(false);
	internal async Task&lt;DiscordGuild&gt; ModifyGuildAsync(
		var pld = new RestGuildModifyPayload
		var headers = Utilities.GetBaseHeaders();
		if (!string.IsNullOrWhiteSpace(reason))
			headers.Add(REASON_HEADER_NAME, reason);
		var bucket = this.Rest.GetBucket(RestRequestMethod.PATCH, route, new
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
			await dc.OnGuildUpdateEventAsync(guild, rawMembers).ConfigureAwait(false);
	internal async Task&lt;DiscordGuild&gt; ModifyGuildCommunitySettingsAsync(ulong guildId, List&lt;string&gt; features, Optional&lt;ulong?&gt; rulesChannelId, Optional&lt;ulong?&gt; publicUpdatesChannelId, string preferredLocale, string description, DefaultMessageNotifications defaultMessageNotifications, ExplicitContentFilter explicitContentFilter, Optional&lt;VerificationLevel&gt; verificationLevel, string? reason)
		var pld = new RestGuildCommunityModifyPayload
			Description = Optional.FromNullable(description),
	internal async Task&lt;DiscordGuild&gt; ModifyGuildInventorySettingsAsync(ulong guildId, bool isEmojiPackCollectible, string? reason)
		var pld = new RestGuildInventoryModifyPayload
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;IncidentsData&gt; ModifyGuildIncidentActionsAsync(ulong guildId, DateTimeOffset? invitesDisabledUntil, DateTimeOffset? dmsDisabledUntil)
		var pld = new RestGuildIncidentActionsModifyPayload
		var bucket = this.Rest.GetBucket(RestRequestMethod.PUT, route, new
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordOnboarding&gt; GetGuildOnboardingAsync(ulong guildId)
	internal async Task&lt;DiscordOnboarding&gt; ModifyGuildOnboardingAsync(ulong guildId, Optional&lt;List&lt;DiscordOnboardingPrompt&gt;&gt; prompts, Optional&lt;List&lt;ulong&gt;&gt; defaultChannelIds, Optional&lt;bool&gt; enabled, Optional&lt;OnboardingMode&gt; mode, string? reason = null)
		var pld = new RestGuildOnboardingModifyPayload
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordServerGuide&gt; GetGuildServerGuideAsync(ulong guildId)
	internal async Task&lt;DiscordServerGuide&gt; ModifyGuildServerGuideAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;WelcomeMessage&gt; welcomeMessage, Optional&lt;List&lt;NewMemberAction&gt;&gt; newMemberActions, Optional&lt;List&lt;ResourceChannel&gt;&gt; resourceChannels, string? reason = null)
		var pld = new RestGuildServerGuideModifyPayload
	internal async Task&lt;DiscordGuild&gt; ModifyGuildSafetyAlertsSettingsAsync(ulong guildId, List&lt;string&gt; features, Optional&lt;ulong?&gt; safetyAlertsChannelId, string? reason)
		var pld = new RestGuildSafetyModifyPayload
	internal async Task&lt;DiscordGuild&gt; ModifyGuildFeaturesAsync(ulong guildId, List&lt;string&gt; features, string? reason)
		var pld = new RestGuildFeatureModifyPayload
	internal async Task EnableGuildMfaAsync(ulong guildId, string? reason)
		var pld = new RestGuildMfaLevelModifyPayload
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task DisableGuildMfaAsync(ulong guildId, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordBan&gt;&gt; GetGuildBansAsync(ulong guildId, int? limit, ulong? before, ulong? after)
			urlParams[&quot;limit&quot;] = limit.Value.ToString(CultureInfo.InvariantCulture);
			urlParams[&quot;before&quot;] = before.Value.ToString(CultureInfo.InvariantCulture);
			urlParams[&quot;after&quot;] = after.Value.ToString(CultureInfo.InvariantCulture);
		var url = Utilities.GetApiUriFor(path, BuildQueryString(urlParams), this.Discord.Configuration);
		var bansRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordBan&gt;&gt;(res.Response).Select(xb =&gt;
			if (!this.Discord.TryGetCachedUserInternal(xb.RawUser.Id, out var usr))
				usr = this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
	internal Task CreateGuildBanAsync(ulong guildId, ulong userId, int deleteMessageSeconds, string? reason)
			throw new ArgumentException(&quot;Delete message seconds must be a number between 0 and 604800.&quot;, nameof(deleteMessageSeconds));
		var pld = new RestGuildBanPayload
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld));
	internal async Task&lt;DiscordBulkBanResponse&gt; CreateGuildBulkBanAsync(ulong guildId, List&lt;ulong&gt; userIds, int deleteMessageSeconds, string? reason)
			throw new ArgumentException(&quot;Can only bulk-ban up to 200 users.&quot;, nameof(userIds));
		var pld = new RestGuildBulkBanPayload
		var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal Task RemoveGuildBanAsync(ulong guildId, ulong userId, string? reason)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers);
	internal Task LeaveGuildAsync(ulong guildId)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route);
	internal async Task&lt;DiscordMember?&gt; AddGuildMemberAsync(ulong guildId, ulong userId, string accessToken, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
		var pld = new RestGuildMemberAddPayload
			this.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, $&quot;{CommonHeaders.AUTHORIZATION_BOT} {this.OAuth2Client.DiscordConfiguration.Token}&quot;);
		var url = Utilities.GetApiUriFor(path, this.Discord is not null ? this.Discord.Configuration : this.OAuth2Client.DiscordConfiguration);
			this.Rest.HttpClient.DefaultRequestHeaders.Remove(CommonHeaders.AUTHORIZATION);
		DiscordMember dm = new(tm);
	internal async Task&lt;IReadOnlyList&lt;TransportMember&gt;&gt; ListGuildMembersAsync(ulong guildId, int? limit, ulong? after)
	internal Task AddGuildMemberRoleAsync(ulong guildId, ulong userId, ulong roleId, string? reason)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers);
	internal Task RemoveGuildMemberRoleAsync(ulong guildId, ulong userId, ulong roleId, string? reason)
	internal Task ModifyGuildChannelPositionAsync(ulong guildId, IEnumerable&lt;RestGuildChannelReorderPayload&gt; pld, string? reason)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld));
	internal Task ModifyGuildChannelParentAsync(ulong guildId, IEnumerable&lt;RestGuildChannelNewParentPayload&gt; pld, string? reason)
	internal Task DetachGuildChannelParentAsync(ulong guildId, IEnumerable&lt;RestGuildChannelNoParentPayload&gt; pld, string? reason)
	internal Task ModifyGuildRolePositionAsync(ulong guildId, IEnumerable&lt;RestGuildRoleReorderPayload&gt; pld, string? reason)
	internal async Task&lt;AuditLog&gt; GetAuditLogsAsync(ulong guildId, int limit, ulong? after, ulong? before, ulong? responsible, int? actionType)
			[&quot;limit&quot;] = limit.ToString(CultureInfo.InvariantCulture)
	internal async Task&lt;DiscordInvite&gt; GetGuildVanityUrlAsync(ulong guildId)
	internal async Task&lt;DiscordWidget&gt; GetGuildWidgetAsync(ulong guildId)
		ret.Guild = this.Discord.Guilds.ContainsKey(guildId) ? this.Discord.Guilds[guildId] : null;
				.. rawChannels.Select(r =&gt; new DiscordChannel
					Name = r[&quot;name&quot;].ToString(),
				.. rawChannels.Select(r =&gt;
					var c = ret.Guild.GetChannel((ulong)r[&quot;id&quot;]);
	internal async Task&lt;DiscordWidgetSettings&gt; GetGuildWidgetSettingsAsync(ulong guildId)
	internal async Task&lt;DiscordWidgetSettings&gt; ModifyGuildWidgetSettingsAsync(ulong guildId, bool? isEnabled, ulong? channelId, string? reason)
		var pld = new RestGuildWidgetSettingsPayload
	internal async Task&lt;IReadOnlyList&lt;DiscordGuildTemplate&gt;&gt; GetGuildTemplatesAsync(ulong guildId)
	internal async Task&lt;DiscordGuildTemplate&gt; CreateGuildTemplateAsync(ulong guildId, string name, string? description)
		var pld = new RestGuildTemplateCreateOrModifyPayload
	internal async Task&lt;DiscordGuildTemplate&gt; SyncGuildTemplateAsync(ulong guildId, string templateCode)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route).ConfigureAwait(false);
	internal async Task&lt;DiscordGuildTemplate&gt; ModifyGuildTemplateAsync(ulong guildId, string templateCode, string? name, string? description)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordGuildTemplate&gt; DeleteGuildTemplateAsync(ulong guildId, string templateCode)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route).ConfigureAwait(false);
	internal async Task&lt;DiscordGuildMembershipScreening&gt; GetGuildMembershipScreeningFormAsync(ulong guildId)
	internal async Task&lt;DiscordGuildMembershipScreening&gt; ModifyGuildMembershipScreeningFormAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;DiscordGuildMembershipScreeningField[]&gt; fields, Optional&lt;string&gt; description)
		var pld = new RestGuildMembershipScreeningFormModifyPayload
	internal async Task&lt;DiscordGuildWelcomeScreen&gt; GetGuildWelcomeScreenAsync(ulong guildId)
	internal async Task&lt;DiscordGuildWelcomeScreen&gt; ModifyGuildWelcomeScreenAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;IEnumerable&lt;DiscordGuildWelcomeScreenChannel&gt;&gt; welcomeChannels, Optional&lt;string&gt; description)
		var pld = new RestGuildWelcomeScreenModifyPayload
	internal async Task&lt;DiscordVoiceState?&gt; GetCurrentUserVoiceStateAsync(ulong guildId)
	internal async Task&lt;DiscordVoiceState?&gt; GetMemberVoiceStateAsync(ulong guildId, ulong memberId)
	internal async Task UpdateCurrentUserVoiceStateAsync(ulong guildId, ulong channelId, bool? suppress, DateTimeOffset? requestToSpeakTimestamp)
		var pld = new RestGuildUpdateCurrentUserVoiceStatePayload
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task UpdateUserVoiceStateAsync(ulong guildId, ulong userId, ulong channelId, bool? suppress)
		var pld = new RestGuildUpdateUserVoiceStatePayload
	internal async Task&lt;ReadOnlyCollection&lt;AutomodRule&gt;&gt; GetAutomodRulesAsync(ulong guildId)
		return ret.AsReadOnly();
	internal async Task&lt;AutomodRule&gt; GetAutomodRuleAsync(ulong guildId, ulong ruleId)
	internal async Task&lt;AutomodRule&gt; CreateAutomodRuleAsync(
		RestAutomodRuleModifyPayload pld = new()
			Actions = actions.ToArray(),
			pld.ExemptChannels = exemptChannels.ToArray();
			pld.ExemptRoles = exemptRoles.ToArray();
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
			await dc.OnAutomodRuleCreated(ret).ConfigureAwait(false);
	internal async Task&lt;AutomodRule&gt; ModifyAutomodRuleAsync(
		var pld = new RestAutomodRuleModifyPayload
			await dc.OnAutomodRuleUpdated(ret).ConfigureAwait(false);
	internal async Task&lt;AutomodRule&gt; DeleteAutomodRuleAsync(ulong guildId, ulong ruleId, string? reason = null)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers).ConfigureAwait(false);
			await dc.OnAutomodRuleDeleted(ret).ConfigureAwait(false);
	public async Task&lt;DiscordSoundboardSound&gt; CreateGuildSoundboardSoundAsync(ulong guildId, string name, string sound, double? volume = null, ulong? emojiId = null, string? emojiName = null, string? reason = null)
		var pld = new RestSoundboardSoundCreatePayload
	public async Task&lt;DiscordSoundboardSound&gt; ModifyGuildSoundboardSoundAsync(ulong guildId, ulong soundId, Optional&lt;string&gt; name, Optional&lt;double?&gt; volume, Optional&lt;ulong?&gt; emojiId, Optional&lt;string?&gt; emojiName, string? reason = null)
		var pld = new RestSoundboardSoundModifyPayload
	public async Task DeleteGuildSoundboardSoundAsync(ulong guildId, ulong soundId, string? reason = null)
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers).ConfigureAwait(false);
	public async Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListGuildSoundboardSoundsAsync(ulong guildId)
	public async Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListDefaultSoundboardSoundsAsync()
	public async Task&lt;DiscordSoundboardSound&gt; GetGuildSoundboardSoundAsync(ulong guildId, ulong soundId)
	public async Task SendSoundboardSoundAsync(ulong channelId, ulong soundId, ulong? sourceGuildId = null)
		var pld = new RestSendSoundboardSoundPayload
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordScheduledEvent&gt; CreateGuildScheduledEventAsync(ulong guildId, ulong? channelId, DiscordScheduledEventEntityMetadata metadata, string name, DateTimeOffset scheduledStartTime, DateTimeOffset? scheduledEndTime, string description, ScheduledEventEntityType type, Optional&lt;string&gt; coverb64, DiscordScheduledEventRecurrenceRule? recurrenceRule, string? reason = null)
			var (IsValid, ErrorMessage) = recurrenceRule.Validate();
				throw new ValidationException(
		var pld = new RestGuildScheduledEventCreatePayload
			await dc.OnGuildScheduledEventCreateEventAsync(scheduledEvent, guild).ConfigureAwait(false);
	internal async Task&lt;DiscordScheduledEvent&gt; ModifyGuildScheduledEventAsync(
			var (IsValid, ErrorMessage) = recurrenceRule.Value.Validate();
		var pld = new RestGuildScheduledEventModifyPayload
			this.Discord.UserCache.AddOrUpdate(scheduledEvent.Creator.Id, scheduledEvent.Creator, (id, old) =&gt;
			await dc.OnGuildScheduledEventUpdateEventAsync(scheduledEvent, guild).ConfigureAwait(false);
	internal async Task&lt;DiscordScheduledEvent&gt; ModifyGuildScheduledEventStatusAsync(ulong guildId, ulong scheduledEventId, ScheduledEventStatus status, string? reason = null)
	internal async Task&lt;DiscordScheduledEvent&gt; GetGuildScheduledEventAsync(ulong guildId, ulong scheduledEventId, bool? withUserCount)
	internal async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEvent&gt;&gt; ListGuildScheduledEventsAsync(ulong guildId, bool? withUserCount)
				this.Discord.UserCache.AddOrUpdate(ev.Creator.Id, ev.Creator, (id, old) =&gt;
			events.Add(ev.Id, ev);
	internal Task DeleteGuildScheduledEventAsync(ulong guildId, ulong scheduledEventId, string? reason)
	internal async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEventUser&gt;&gt; GetGuildScheduledEventRspvUsersAsync(ulong guildId, ulong scheduledEventId, int? limit, ulong? before, ulong? after, bool? withMember)
			urlParams[&quot;with_member&quot;] = withMember.Value.ToString(CultureInfo.InvariantCulture);
			rspvUser.User = this.Discord.UserCache.AddOrUpdate(rspvUser.User.Id, rspvUser.User, (id, old) =&gt;
			rspv.Add(rspvUser.User.Id, rspvUser);
	internal async Task&lt;DiscordChannel&gt; CreateGuildChannelAsync(ulong guildId, string name, ChannelType type, ulong? parent, Optional&lt;string&gt; topic, int? bitrate, int? userLimit, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites, bool? nsfw, Optional&lt;int?&gt; perUserRateLimit, VideoQualityMode? qualityMode, ThreadAutoArchiveDuration? defaultAutoArchiveDuration, Optional&lt;ChannelFlags?&gt; flags, string? reason)
			restOverwrites.AddRange(overwrites.Select(ow =&gt; ow.Build()));
		var pld = new RestChannelCreatePayload
		ret.Initialize(this.Discord);
	internal async Task&lt;DiscordChannel&gt; CreateGuildForumChannelAsync(
			restoverwrites.AddRange(permissionOverwrites.Select(ow =&gt; ow.Build()));
	internal Task ModifyChannelAsync(
		var pld = new RestChannelModifyPayload
	internal async Task&lt;DiscordChannel&gt; ModifyForumChannelAsync(
	internal async Task&lt;DiscordChannel&gt; GetChannelAsync(ulong channelId)
	internal Task DeleteChannelAsync(ulong channelId, string? reason)
	internal async Task&lt;DiscordMessage&gt; GetMessageAsync(ulong channelId, ulong messageId)
		var ret = this.PrepareMessage(JObject.Parse(res.Response));
	internal async Task&lt;DiscordMessage&gt; CreateMessageAsync(ulong channelId, string content, IEnumerable&lt;DiscordEmbed&gt; embeds, DiscordSticker sticker, ulong? replyMessageId, bool mentionReply, bool failOnInvalidReply, ReadOnlyCollection&lt;DiscordComponent&gt;? components = null)
			throw new ArgumentException(&quot;Message content length cannot exceed 2000 characters.&quot;);
				throw new ArgumentException(&quot;You must specify message content, a sticker, components or embeds.&quot;);
				throw new ArgumentException(&quot;Message content must not be empty.&quot;);
					embed.Timestamp = embed.Timestamp.Value.ToUniversalTime();
		var pld = new RestChannelMessageCreatePayload
			pld.MessageReference = new InternalDiscordMessageReference
	internal async Task&lt;DiscordMessage&gt; CreateMessageAsync(ulong channelId, DiscordMessageBuilder builder)
		builder.Validate();
		pld.Mentions = new(builder.Mentions.Count == 0 ? Mentions.All : builder.Mentions, builder.Mentions.Any(), builder.MentionOnReply);
			if (builder.Attachments.Any())
					attachments.Add(att);
				DiscordAttachment att = new()
				[&quot;payload_json&quot;] = DiscordJson.SerializeObject(pld)
			var res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
			foreach (var file in builder.FilesInternal.Where(x =&gt; x.ResetPositionTo.HasValue))
	public async Task&lt;DiscordMessage&gt; ForwardMessageAsync(DiscordMessage forwardMessage, ulong targetChannelId, string? content)
			MessageReference = new InternalDiscordMessageReference
	internal async Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; GetGuildChannelsAsync(ulong guildId)
		var channelsRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordChannel&gt;&gt;(res.Response).Select(xc =&gt;
	internal Task ModifyVoiceChannelStatusAsync(ulong channelId, string? status)
		var pld = new RestVoiceChannelStatusModifyPayload
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, payload: DiscordJson.SerializeObject(pld));
	internal async Task&lt;DiscordStageInstance&gt; CreateStageInstanceAsync(ulong channelId, string topic, bool sendStartNotification, ulong? scheduledEventId = null, string? reason = null)
		var pld = new RestStageInstanceCreatePayload
	internal async Task&lt;DiscordStageInstance&gt; GetStageInstanceAsync(ulong channelId)
	internal Task ModifyStageInstanceAsync(ulong channelId, Optional&lt;string&gt; topic, string? reason)
		var pld = new RestStageInstanceModifyPayload
	internal Task DeleteStageInstanceAsync(ulong channelId, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetChannelMessagesAsync(ulong channelId, int limit, ulong? before, ulong? after, ulong? around)
			urlParams[&quot;limit&quot;] = limit.ToString(CultureInfo.InvariantCulture);
		var msgsRaw = JArray.Parse(res.Response);
			msgs.Add(this.PrepareMessage(xj));
	internal async Task&lt;DiscordMessage&gt; GetChannelMessageAsync(ulong channelId, ulong messageId)
	internal async Task&lt;DiscordMessage&gt; EditMessageAsync(ulong channelId, ulong messageId, Optional&lt;string&gt; content, Optional&lt;IEnumerable&lt;DiscordEmbed&gt;&gt; embeds, Optional&lt;IEnumerable&lt;IMention&gt;&gt; mentions, IReadOnlyList&lt;DiscordComponent&gt; components, Optional&lt;bool&gt; suppressEmbed, IReadOnlyCollection&lt;DiscordMessageFile&gt; files, Optional&lt;IEnumerable&lt;DiscordAttachment&gt;&gt; attachments)
		var pld = new RestChannelMessageEditPayload
			Content = content.ValueOrDefault(),
				.Map(m =&gt; new DiscordMentions(m ?? Mentions.None, false, mentions.Value?.OfType&lt;RepliedUserMention&gt;().Any() ?? false))
				.ValueOrDefault()
				attachmentsNew.Add(att);
			if (attachments.HasValue &amp;&amp; attachments.Value.Any())
				attachmentsNew.AddRange(attachments.Value);
			var res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, values: values, files: files).ConfigureAwait(false);
			foreach (var file in files.Where(x =&gt; x.ResetPositionTo.HasValue))
				List&lt;DiscordAttachment&gt; attachmentsNew = new(attachments.Value.Count());
	internal Task DeleteMessageAsync(ulong channelId, ulong messageId, string? reason)
	internal Task DeleteMessagesAsync(ulong channelId, IEnumerable&lt;ulong&gt; messageIds, string? reason)
		var pld = new RestChannelMessageBulkDeletePayload
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld));
	internal async Task&lt;ReadOnlyCollection&lt;DiscordUser&gt;&gt; GetAnswerVotersAsync(ulong channelId, ulong messageId, int answerId, int? limit, ulong? after)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route);
		var votersRaw = JObject.Parse(res.Response);
			var usr = new DiscordUser(xr)
			usr = this.Discord.UserCache.AddOrUpdate(xr.Id, usr, (id, old) =&gt;
			voters.Add(usr);
	internal async Task&lt;DiscordMessage&gt; EndPollAsync(ulong channelId, ulong messageId)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route);
	internal async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetChannelInvitesAsync(ulong channelId)
		var invitesRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordInvite&gt;&gt;(res.Response).Select(xi =&gt;
	internal async Task&lt;DiscordInvite&gt; CreateChannelInviteAsync(ulong channelId, int maxAge, int maxUses, TargetType? targetType, ulong? targetApplicationId, ulong? targetUser, bool temporary, bool unique, string? reason)
		var pld = new RestChannelInviteCreatePayload
	internal Task DeleteChannelPermissionAsync(ulong channelId, ulong overwriteId, string? reason)
	internal Task EditChannelPermissionsAsync(ulong channelId, ulong overwriteId, Permissions allow, Permissions deny, string type, string? reason)
		var pld = new RestChannelPermissionEditPayload
	internal Task TriggerTypingAsync(ulong channelId)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route);
	internal async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetPinnedMessagesAsync(ulong channelId)
	internal Task PinMessageAsync(ulong channelId, ulong messageId)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route);
	internal Task UnpinMessageAsync(ulong channelId, ulong messageId)
	internal Task AddGroupDmRecipientAsync(ulong channelId, ulong userId, string accessToken, string nickname)
		var pld = new RestChannelGroupDmRecipientAddPayload
	internal Task RemoveGroupDmRecipientAsync(ulong channelId, ulong userId)
	internal async Task&lt;DiscordDmChannel&gt; CreateGroupDmAsync(IEnumerable&lt;string&gt; accessTokens, IDictionary&lt;ulong, string&gt; nicks)
		var pld = new RestUserGroupDmCreatePayload
	internal async Task&lt;DiscordDmChannel&gt; CreateDmAsync(ulong recipientId)
		var pld = new RestUserDmCreatePayload
	internal async Task&lt;DiscordFollowedChannel&gt; FollowChannelAsync(ulong channelId, ulong webhookChannelId)
		var pld = new FollowedChannelAddPayload
		var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordMessage&gt; CrosspostMessageAsync(ulong channelId, ulong messageId)
		var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route).ConfigureAwait(false);
	internal Task&lt;DiscordUser&gt; GetCurrentUserAsync()
		=&gt; this.GetUserAsync(Endpoints.ME);
	internal Task&lt;DiscordUser&gt; GetUserAsync(ulong userId)
		=&gt; this.GetUserAsync(userId.ToString(CultureInfo.InvariantCulture));
	internal async Task&lt;DiscordUser&gt; GetUserAsync(string userId)
		var url = Utilities.GetApiUriFor(path.Replace(&quot;//&quot;, &quot;/&quot;), this.Discord.Configuration);
		if (this.Discord.Configuration.Intents.HasIntent(DiscordIntents.GuildPresences) &amp;&amp; duser.Presence == null &amp;&amp; this.Discord is DiscordClient dc)
	internal async Task&lt;DiscordMember&gt; GetGuildMemberAsync(ulong guildId, ulong userId)
		var usr = new DiscordUser(tm.User)
		usr = this.Discord.UserCache.AddOrUpdate(tm.User.Id, usr, (id, old) =&gt;
		if (this.Discord.Configuration.Intents.HasIntent(DiscordIntents.GuildPresences) &amp;&amp; usr.Presence == null &amp;&amp; this.Discord is DiscordClient dc)
	internal Task RemoveGuildMemberAsync(ulong guildId, ulong userId, string? reason)
	internal async Task&lt;DiscordUser&gt; ModifyCurrentUserAsync(string username, Optional&lt;string?&gt; base64Avatar, Optional&lt;string?&gt; base64Banner)
		var pld = new RestUserUpdateCurrentPayload
	internal async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(int limit = 100, ulong? before = null, ulong? after = null)
		var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration)
			.AddParameter(&quot;limit&quot;, limit.ToString(CultureInfo.InvariantCulture));
			url.AddParameter(&quot;before&quot;, before.Value.ToString(CultureInfo.InvariantCulture));
			url.AddParameter(&quot;after&quot;, after.Value.ToString(CultureInfo.InvariantCulture));
		var res = await this.DoRequestAsync(this.Discord, bucket, url.Build(), RestRequestMethod.GET, route).ConfigureAwait(false);
			var glds = guildsRaw.Select(xug =&gt; (this.Discord as DiscordClient)?.GuildsInternal[xug.Id]);
	internal Task ModifyGuildMemberAsync(
		var pld = new RestGuildMemberModifyPayload
	internal Task ModifyTimeoutAsync(ulong guildId, ulong userId, DateTimeOffset? until, string? reason)
		var pld = new RestGuildMemberTimeoutModifyPayload
	internal Task ModifyCurrentMemberNicknameAsync(ulong guildId, string nick, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordRole&gt;&gt; GetGuildRolesAsync(ulong guildId)
		var roles = DiscordJson.DeserializeIEnumerableObject&lt;IEnumerable&lt;DiscordRole&gt;&gt;(res.Response, this.Discord).Select(xr =&gt;
		}).ToList();
	internal async Task&lt;DiscordRole&gt; GetGuildRoleAsync(ulong guildId, ulong roleId)
	internal async Task&lt;DiscordRole&gt; ModifyGuildRoleAsync(ulong guildId, ulong roleId, string name, Permissions? permissions, int? color, bool? hoist, bool? mentionable, Optional&lt;string&gt; iconb64, Optional&lt;string&gt; emoji, string? reason)
		var pld = new RestGuildRolePayload
	internal Task DeleteRoleAsync(ulong guildId, ulong roleId, string? reason)
	internal async Task&lt;DiscordRole&gt; CreateGuildRoleAsync(ulong guildId, string name, Permissions? permissions, int? color, bool? hoist, bool? mentionable, string? reason)
	internal async Task&lt;DiscordGuildJoinRequestSearchResult&gt; GetGuildJoinRequestsAsync(ulong guildId, int limit = 100, JoinRequestStatusType? statusType = null, ulong? before = null, ulong? after = null)
				JoinRequestStatusType.Submitted or JoinRequestStatusType.Approved or JoinRequestStatusType.Rejected =&gt; statusType.Value.ToString().ToUpperInvariant(),
				_ =&gt; throw new ArgumentOutOfRangeException(nameof(statusType), $&quot;Status type {statusType.Value} is not supported&quot;)
	internal async Task&lt;DiscordGuildJoinRequest&gt; GetGuildJoinRequestAsync(ulong guildId, ulong joinRequestId)
	internal async Task&lt;DiscordGuildJoinRequest&gt; ModifyGuildJoinRequestsAsync(ulong guildId, ulong joinRequestId, JoinRequestStatusType statusType, string? rejectionReason)
		var pld = new RestGuildJoinRequestUpdatePayload
			Action = statusType is JoinRequestStatusType.Approved or JoinRequestStatusType.Rejected ? statusType.ToString().ToUpperInvariant() : throw new InvalidOperationException($&quot;Can not {statusType} as action for join request {joinRequestId}&quot;),
	internal async Task&lt;DiscordClanSettings&gt; GetClanSettingsAsync(ulong clanId)
	internal async Task&lt;int&gt; GetGuildPruneCountAsync(ulong guildId, int days, IEnumerable&lt;ulong&gt; includeRoles)
			throw new ArgumentException(&quot;Prune inactivity days must be a number between 0 and 30.&quot;, nameof(days));
			[&quot;days&quot;] = days.ToString(CultureInfo.InvariantCulture)
		var sb = includeRoles?.Aggregate(new StringBuilder(),
			         (sb, id) =&gt; sb.Append($&quot;&amp;include_roles={id}&quot;))
		         ?? new StringBuilder();
		var url = Utilities.GetApiUriFor(path, $&quot;{BuildQueryString(urlParams)}{sb}&quot;, this.Discord.Configuration);
	internal async Task&lt;int?&gt; BeginGuildPruneAsync(ulong guildId, int days, bool computePruneCount, IEnumerable&lt;ulong&gt; includeRoles, string? reason)
			[&quot;days&quot;] = days.ToString(CultureInfo.InvariantCulture),
			[&quot;compute_prune_count&quot;] = computePruneCount.ToString()
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers).ConfigureAwait(false);
	internal async Task&lt;DiscordGuildTemplate&gt; GetTemplateAsync(string code)
	internal async Task&lt;IReadOnlyList&lt;DiscordIntegration&gt;&gt; GetGuildIntegrationsAsync(ulong guildId)
	internal async Task&lt;DiscordGuildPreview&gt; GetGuildPreviewAsync(ulong guildId)
	internal async Task&lt;DiscordIntegration&gt; CreateGuildIntegrationAsync(ulong guildId, string type, ulong id)
		var pld = new RestGuildIntegrationAttachPayload
	internal async Task&lt;DiscordIntegration&gt; ModifyGuildIntegrationAsync(ulong guildId, ulong integrationId, int expireBehaviour, int expireGracePeriod, bool enableEmoticons)
		var pld = new RestGuildIntegrationModifyPayload
	internal Task DeleteGuildIntegrationAsync(ulong guildId, DiscordIntegration integration)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, payload: DiscordJson.SerializeObject(integration));
	internal Task SyncGuildIntegrationAsync(ulong guildId, ulong integrationId)
	internal async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; GetGuildVoiceRegionsAsync(ulong guildId)
	internal async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetGuildInvitesAsync(ulong guildId)
	internal async Task&lt;DiscordInvite&gt; GetInviteAsync(string inviteCode, bool? withCounts, bool? withExpiration, ulong? guildScheduledEventId)
	internal async Task&lt;DiscordInvite&gt; DeleteInviteAsync(string inviteCode, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetUserConnectionsAsync()
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; GetRoleConnectionMetadataRecords(ulong id)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; UpdateRoleConnectionMetadataRecords(ulong id, IEnumerable&lt;DiscordApplicationRoleConnectionMetadata&gt; metadataObjects)
			pld.Add(new()
	internal async Task&lt;DiscordWebhook&gt; CreateWebhookAsync(ulong channelId, string name, Optional&lt;string&gt; base64Avatar, string? reason)
		var pld = new RestWebhookPayload
			AvatarBase64 = base64Avatar.ValueOrDefault(),
	internal async Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetChannelWebhooksAsync(ulong channelId)
		var webhooksRaw = DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordWebhook&gt;&gt;(res.Response, this.Discord).Select(xw =&gt;
	internal async Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetGuildWebhooksAsync(ulong guildId)
	internal async Task&lt;DiscordWebhook&gt; GetWebhookAsync(ulong webhookId)
		var url = Utilities.GetApiUriFor(path, this.Discord?.Configuration);
	internal async Task&lt;DiscordWebhook&gt; GetWebhookWithTokenAsync(ulong webhookId, string webhookToken)
	internal async Task&lt;DiscordWebhook&gt; ModifyWebhookAsync(ulong webhookId, ulong channelId, string name, Optional&lt;string&gt; base64Avatar, string? reason)
	internal async Task&lt;DiscordWebhook&gt; ModifyWebhookAsync(ulong webhookId, string name, string base64Avatar, string webhookToken, string? reason)
	internal Task DeleteWebhookAsync(ulong webhookId, string? reason)
	internal Task DeleteWebhookAsync(ulong webhookId, string webhookToken, string? reason)
	internal async Task&lt;DiscordMessage&gt; ExecuteWebhookAsync(ulong webhookId, string webhookToken, DiscordWebhookBuilder builder, string threadId)
		var pld = new RestWebhookExecutePayload
			Username = builder.Username.ValueOrDefault(),
			AvatarUrl = builder.AvatarUrl.ValueOrDefault(),
			AppliedTags = builder.AppliedTags.Any() ? builder.AppliedTags : null,
		if (builder.Mentions.Any())
		if (!string.IsNullOrEmpty(builder.Content) || builder.Embeds?.Count &gt; 0 || builder.Files?.Count &gt; 0 || builder.IsTts || builder.Mentions.Any())
			values[&quot;payload_json&quot;] = DiscordJson.SerializeObject(pld);
		var qub = Utilities.GetApiUriBuilderFor(path, this.Discord?.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;);
			qub.AddParameter(&quot;thread_id&quot;, threadId);
			qub.AddParameter(&quot;with_components&quot;, builder.WithComponents.Value.ToString().ToLower());
		var url = qub.Build();
		foreach (var file in builder.Files.Where(x =&gt; x.ResetPositionTo.HasValue))
	internal async Task&lt;DiscordMessage&gt; ExecuteWebhookSlackAsync(ulong webhookId, string webhookToken, string jsonPayload, string threadId)
		var qub = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;);
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: jsonPayload).ConfigureAwait(false);
	internal async Task&lt;DiscordMessage&gt; ExecuteWebhookGithubAsync(ulong webhookId, string webhookToken, string jsonPayload, string threadId)
	internal async Task&lt;DiscordMessage&gt; EditWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, DiscordWebhookBuilder builder, string threadId)
		builder.Validate(true);
		var pld = new RestWebhookMessageEditPayload
				attachments.AddRange(builder.Attachments);
			var qub = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration);
			var res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, values: values, files: builder.Files).ConfigureAwait(false);
	internal Task&lt;DiscordMessage&gt; EditWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, DiscordWebhookBuilder builder, ulong threadId) =&gt;
		this.EditWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), builder, threadId.ToString());
	internal async Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, string threadId)
	internal Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId) =&gt;
		this.GetWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), null);
	internal Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, ulong threadId) =&gt;
		this.GetWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), threadId.ToString());
	internal async Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, string threadId)
	internal Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId) =&gt;
		this.DeleteWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), null);
	internal Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, ulong threadId) =&gt;
		this.DeleteWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), threadId.ToString());
	internal Task CreateReactionAsync(ulong channelId, ulong messageId, string emoji)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
	internal Task DeleteOwnReactionAsync(ulong channelId, ulong messageId, string emoji)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
	internal Task DeleteUserReactionAsync(ulong channelId, ulong messageId, ulong userId, string emoji, string? reason)
		return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
	internal async Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsAsync(ulong channelId, ulong messageId, string emoji, ulong? afterId = null, int limit = 25)
			urlParams[&quot;after&quot;] = afterId.Value.ToString(CultureInfo.InvariantCulture);
			reacters.Add(usr);
	internal Task DeleteAllReactionsAsync(ulong channelId, ulong messageId, string? reason)
	internal Task DeleteReactionsEmojiAsync(ulong channelId, ulong messageId, string emoji)
	internal async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(
		var pld = new RestThreadChannelCreatePayload
			if (appliedTags != null &amp;&amp; appliedTags.Any())
					tags.Add(b.Id.Value);
		var bucket = this.Rest.GetBucket(RestRequestMethod.POST, route, param, out var path);
	internal async Task&lt;DiscordThreadChannel&gt; GetThreadAsync(ulong threadId)
	internal async Task JoinThreadAsync(ulong channelId)
		await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route).ConfigureAwait(false);
	internal async Task LeaveThreadAsync(ulong channelId)
	internal async Task AddThreadMemberAsync(ulong channelId, ulong userId)
	internal async Task&lt;DiscordThreadChannelMember&gt; GetThreadMemberAsync(ulong channelId, ulong userId, bool withMember = false)
			[&quot;with_member&quot;] = withMember.ToString(CultureInfo.InvariantCulture)
	internal async Task RemoveThreadMemberAsync(ulong channelId, ulong userId)
	internal async Task&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt; GetThreadMembersAsync(ulong threadId, bool withMember = false, ulong? after = null, int? limit = null)
	internal async Task&lt;DiscordThreadResult&gt; GetActiveThreadsAsync(ulong guildId)
		threadReturn.Threads.ForEach(x =&gt; x.Discord = this.Discord);
	internal async Task&lt;DiscordThreadResult&gt; GetJoinedPrivateArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
	internal async Task&lt;DiscordThreadResult&gt; GetPublicArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
	internal async Task&lt;DiscordThreadResult&gt; GetPrivateArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
	internal Task ModifyThreadAsync(ulong threadId, ChannelType parentType, string name, Optional&lt;bool?&gt; locked, Optional&lt;bool?&gt; archived, Optional&lt;int?&gt; perUserRateLimit, Optional&lt;ThreadAutoArchiveDuration?&gt; autoArchiveDuration, Optional&lt;bool?&gt; invitable, Optional&lt;IEnumerable&lt;ForumPostTag&gt;&gt; appliedTags, Optional&lt;bool?&gt; pinned, string? reason)
		var pld = new RestThreadChannelModifyPayload
				List&lt;ulong&gt; tags = new(appliedTags.Value.Count());
	internal async Task&lt;IReadOnlyList&lt;DiscordGuildEmoji&gt;&gt; GetGuildEmojisAsync(ulong guildId)
		this.Discord.Guilds.TryGetValue(guildId, out var gld);
				if (!users.ContainsKey(xtu.Id))
					var user = gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu);
			emojis.Add(xge);
	internal async Task&lt;DiscordGuildEmoji&gt; GetGuildEmojiAsync(ulong guildId, ulong emojiId)
		var emojiRaw = JObject.Parse(res.Response);
			emoji.User = gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu);
	internal async Task&lt;DiscordGuildEmoji&gt; CreateGuildEmojiAsync(ulong guildId, string name, string imageb64, IEnumerable&lt;ulong&gt; roles, string? reason)
		var pld = new RestGuildEmojiCreatePayload
			? gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu)
	internal async Task&lt;DiscordGuildEmoji&gt; ModifyGuildEmojiAsync(ulong guildId, ulong emojiId, string name, IEnumerable&lt;ulong&gt; roles, string? reason)
		var pld = new RestGuildEmojiModifyPayload
	internal Task DeleteGuildEmojiAsync(ulong guildId, ulong emojiId, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationEmoji&gt;&gt; GetApplicationEmojisAsync(ulong applicationId)
		return [.. this.Discord.UpdateCachedApplicationEmojis(emojisRaw?.Value&lt;JArray&gt;(&quot;items&quot;)).Select(x =&gt; x.Value)];
	internal async Task&lt;DiscordApplicationEmoji&gt; GetApplicationEmojiAsync(ulong applicationId, ulong emojiId)
		return this.Discord.UpdateCachedApplicationEmoji(emoji);
	internal async Task&lt;DiscordApplicationEmoji&gt; CreateApplicationEmojiAsync(ulong applicationId, string name, string imageb64)
		var pld = new RestApplicationEmojiCreatePayload
	internal async Task&lt;DiscordApplicationEmoji&gt; ModifyApplicationEmojiAsync(ulong applicationId, ulong emojiId, string name)
		var pld = new RestApplicationEmojiModifyPayload
	internal Task DeleteApplicationEmojiAsync(ulong applicationId, ulong emojiId)
	internal async Task&lt;DiscordSticker&gt; GetStickerAsync(ulong stickerId)
	internal async Task&lt;DiscordStickerPack&gt; GetStickerPackAsync(ulong id)
	internal async Task&lt;IReadOnlyList&lt;DiscordStickerPack&gt;&gt; GetStickerPacksAsync()
		var json = JObject.Parse(res.Response)[&quot;sticker_packs&quot;] as JArray;
	internal async Task&lt;IReadOnlyList&lt;DiscordSticker&gt;&gt; GetGuildStickersAsync(ulong guildId)
	internal async Task&lt;DiscordSticker&gt; GetGuildStickerAsync(ulong guildId, ulong stickerId)
	internal async Task&lt;DiscordSticker&gt; CreateGuildStickerAsync(ulong guildId, string name, string description, string tags, DiscordMessageFile file, string? reason)
		var res = await this.DoStickerMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, name, tags, description, headers, file).ConfigureAwait(false);
	internal async Task&lt;DiscordSticker&gt; ModifyGuildStickerAsync(ulong guildId, ulong stickerId, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;string&gt; tags, string? reason)
		var pld = new RestStickerModifyPayload
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route).ConfigureAwait(false);
	internal async Task DeleteGuildStickerAsync(ulong guildId, ulong stickerId, string? reason)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGlobalApplicationCommandsAsync(ulong applicationId, bool withLocalizations = false)
			[&quot;with_localizations&quot;] = withLocalizations.ToString().ToLower()
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGlobalApplicationCommandsAsync(ulong applicationId, IEnumerable&lt;DiscordApplicationCommand&gt; commands)
		if (commands.Any())
			pld.AddRange(commands.Select(command =&gt; new RestApplicationCommandCreatePayload
	internal async Task&lt;DiscordApplicationCommand&gt; CreateGlobalApplicationCommandAsync(ulong applicationId, DiscordApplicationCommand command)
		var pld = new RestApplicationCommandCreatePayload
	internal async Task&lt;DiscordApplicationCommand&gt; GetGlobalApplicationCommandAsync(ulong applicationId, ulong commandId)
	internal async Task&lt;DiscordApplicationCommand&gt; EditGlobalApplicationCommandAsync(
		var pld = new RestApplicationCommandEditPayload
			NameLocalizations = nameLocalization.ValueOrDefault()?.GetKeyValuePairs(),
			DescriptionLocalizations = descriptionLocalization.ValueOrDefault()?.GetKeyValuePairs(),
	internal async Task DeleteGlobalApplicationCommandAsync(ulong applicationId, ulong commandId)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGuildApplicationCommandsAsync(ulong applicationId, ulong guildId, bool withLocalizations = false)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGuildApplicationCommandsAsync(ulong applicationId, ulong guildId, IEnumerable&lt;DiscordApplicationCommand&gt; commands)
	internal async Task&lt;DiscordApplicationCommand&gt; CreateGuildApplicationCommandAsync(ulong applicationId, ulong guildId, DiscordApplicationCommand command)
	internal async Task&lt;DiscordApplicationCommand&gt; GetGuildApplicationCommandAsync(ulong applicationId, ulong guildId, ulong commandId)
	internal async Task&lt;DiscordApplicationCommand&gt; EditGuildApplicationCommandAsync(
	internal async Task DeleteGuildApplicationCommandAsync(ulong applicationId, ulong guildId, ulong commandId)
	internal async Task&lt;DiscordInteractionCallbackResponse&gt; CreateInteractionResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, DiscordInteractionResponseBuilder? builder)
		RestInteractionResponsePayload pld;
				? new DiscordInteractionApplicationCommandCallbackData
					Mentions = builder.Mentions.Any() ? new(builder.Mentions, builder.Mentions.Count is not 0) : null,
			if (!string.IsNullOrEmpty(builder.Content) || builder.Embeds?.Count &gt; 0 || builder.IsTts || builder.Mentions.Any() || builder.Files?.Count &gt; 0 || builder.Components?.Count &gt; 0)
		RestResponse response;
		var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;false&quot;).AddParameter(&quot;with_response&quot;, &quot;true&quot;).Build();
			response = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
			response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
		return response.ResponseCode is not HttpStatusCode.NoContent &amp;&amp; !string.IsNullOrEmpty(response.Response)
	internal async Task CreateInteractionModalResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, DiscordInteractionModalBuilder builder)
		if (builder.ModalComponents.Any(mc =&gt; mc.Components.Any(c =&gt; c.Type != ComponentType.InputText)))
			throw new NotSupportedException(&quot;Can&apos;t send any other type then Input Text as Modal Component.&quot;);
		var pld = new RestInteractionModalResponsePayload
		var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;).Build();
	internal async Task CreateInteractionIframeResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, string customId, string title, IframeModalSize modalSize, string? iFramePath = null)
		var pld = new RestInteractionIframeResponsePayload
	internal Task&lt;DiscordMessage&gt; GetOriginalInteractionResponseAsync(ulong applicationId, string interactionToken) =&gt;
		this.GetWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, null);
	internal Task&lt;DiscordMessage&gt; EditOriginalInteractionResponseAsync(ulong applicationId, string interactionToken, DiscordWebhookBuilder builder) =&gt;
		this.EditWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, builder, null);
	internal Task DeleteOriginalInteractionResponseAsync(ulong applicationId, string interactionToken) =&gt;
		this.DeleteWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, null);
	internal async Task&lt;DiscordMessage&gt; CreateFollowupMessageAsync(ulong applicationId, string interactionToken, DiscordFollowupMessageBuilder builder)
		ArgumentNullException.ThrowIfNull(builder, nameof(builder));
		var pld = new RestFollowupMessageCreatePayload
		RestResponse res;
			res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
			res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId) =&gt;
		this.GetWebhookMessageAsync(applicationId, interactionToken, messageId);
	internal Task&lt;DiscordMessage&gt; EditFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId, DiscordWebhookBuilder builder) =&gt;
		this.EditWebhookMessageAsync(applicationId, interactionToken, messageId.ToString(), builder, null);
	internal Task DeleteFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId) =&gt;
		this.DeleteWebhookMessageAsync(applicationId, interactionToken, messageId);
	internal async Task&lt;IReadOnlyList&lt;DiscordStoreSku&gt;&gt; GetPublishedListingsAsync(ulong applicationId)
			[&quot;application_id&quot;] = applicationId.ToString()
	internal async Task&lt;IReadOnlyList&lt;DiscordSku&gt;&gt; GetSkusAsync(ulong applicationId)
	internal async Task&lt;IReadOnlyList&lt;DiscordEntitlement&gt;&gt; GetEntitlementsAsync(ulong applicationId, ulong? guildId, ulong? userId, List&lt;ulong&gt;? skuIds = null, ulong? before = null, ulong? after = null, int limit = 100, bool? excludeEnded = null, bool? excludeDeleted = null)
		urlParams[&quot;limit&quot;] = limit.ToString();
			urlParams[&quot;guild_id&quot;] = guildId.Value.ToString();
			urlParams[&quot;user_id&quot;] = userId.Value.ToString();
			urlParams[&quot;sku_ids&quot;] = string.Join(&quot;,&quot;, skuIds);
			urlParams[&quot;before&quot;] = before.Value.ToString();
			urlParams[&quot;after&quot;] = after.Value.ToString();
			urlParams[&quot;exclude_ended&quot;] = excludeEnded.Value.ToString().ToLower();
			urlParams[&quot;exclude_deleted&quot;] = excludeDeleted.Value.ToString().ToLower();
	internal async Task&lt;DiscordEntitlement?&gt; GetEntitlementAsync(ulong applicationId, ulong entitlementId)
	internal async Task&lt;bool&gt; ConsumeEntitlementAsync(ulong applicationId, ulong entitlementId)
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route).ConfigureAwait(false);
	internal async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSkuSubscriptionsAsync(ulong skuId, ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
		urlParams[&quot;userId&quot;] = userId.ToString();
	internal async Task&lt;DiscordSubscription?&gt; GetSkuSubscriptionAsync(ulong skuId, ulong subscriptionId)
	internal async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong applicationId, ulong skuId, ulong ownerId, EntitlementOwnerType ownerType)
		TestEntitlementCreatePayload pld = new()
	internal async Task DeleteTestEntitlementAsync(ulong applicationId, ulong entitlementId)
	internal Task&lt;TransportApplication&gt; GetCurrentApplicationOauth2InfoAsync()
		=&gt; this.GetApplicationOauth2InfoAsync(Endpoints.ME);
	internal Task&lt;DiscordRpcApplication&gt; GetApplicationRpcInfoAsync(ulong applicationId)
		=&gt; this.GetApplicationRpcInfoAsync(applicationId.ToString(CultureInfo.InvariantCulture));
	private async Task&lt;TransportApplication&gt; GetApplicationOauth2InfoAsync(string applicationId)
	internal async Task&lt;TransportApplication&gt; GetCurrentApplicationInfoAsync()
	internal async Task&lt;TransportApplication&gt; ModifyCurrentApplicationInfoAsync(
		var pld = new RestApplicationModifyPayload
	private async Task&lt;DiscordRpcApplication&gt; GetApplicationRpcInfoAsync(string applicationId)
	internal async Task&lt;IReadOnlyList&lt;DiscordApplicationAsset&gt;&gt; GetApplicationAssetsAsync(DiscordApplication application)
	internal async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync()
		var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route, headers).ConfigureAwait(false);
		var info = JObject.Parse(res.Response).ToObject&lt;GatewayInfo&gt;();
		info.SessionBucket.ResetAfter = DateTimeOffset.UtcNow + TimeSpan.FromMilliseconds(info.SessionBucket.ResetAfterInternal);
	internal async Task&lt;DiscordAuthorizationInformation&gt; GetCurrentOAuth2AuthorizationInformationAsync(string accessToken)
			throw new InvalidOperationException(&quot;Cannot use oauth2 endpoints with discord client&quot;);
		headers.Add(&quot;Bearer&quot;, accessToken);
		var url = Utilities.GetApiUriFor(path, this.OAuth2Client.DiscordConfiguration);
		var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.GET, route, headers).ConfigureAwait(false);
	internal async Task&lt;DiscordUser&gt; GetCurrentUserAsync(string accessToken)
		var bucket = this.Rest.GetBucket(RestRequestMethod.GET, route,
				application_id = this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture)
		var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.GET, route, headers)
			.ConfigureAwait(false);
	internal async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetCurrentUserConnectionsAsync(string accessToken)
	internal async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(string accessToken)
	internal async Task&lt;DiscordMember&gt; GetCurrentUserGuildMemberAsync(string accessToken, ulong guildId)
			guild_id = guildId.ToString(CultureInfo.InvariantCulture)
	internal async Task&lt;DiscordApplicationRoleConnection&gt; GetCurrentUserApplicationRoleConnectionAsync(string accessToken)
	internal async Task&lt;DiscordApplicationRoleConnection&gt; ModifyCurrentUserApplicationRoleConnectionAsync(string accessToken, Optional&lt;string&gt; platformName, Optional&lt;string&gt; platformUsername, Optional&lt;ApplicationRoleConnectionMetadata&gt; metadata)
		RestOAuth2ApplicationRoleConnectionPayload pld = new()
			Metadata = metadata.HasValue ? metadata.Value.GetKeyValuePairs() : Optional&lt;Dictionary&lt;string, string&gt;&gt;.None
		var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
	internal async Task&lt;DiscordAccessToken&gt; ExchangeOAuth2AccessTokenAsync(string code)
			{ &quot;client_id&quot;, this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture) },
		var res = await this.DoFormRequestAsync(this.OAuth2Client, bucket, url, RestRequestMethod.POST, route, formData).ConfigureAwait(false);
	internal async Task&lt;DiscordAccessToken&gt; RefreshOAuth2AccessTokenAsync(string refreshToken)
	internal async Task RevokeOAuth2TokenAsync(string token, string type)
		var authorizationString = Encoding.UTF8.GetBytes($&quot;{this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture)}:{this.OAuth2Client.ClientSecret}&quot;);
		var base64EncodedAuthorizationString = Convert.ToBase64String(authorizationString);
		headers.Add(&quot;Basic&quot;, base64EncodedAuthorizationString);
		await this.DoFormRequestAsync(this.OAuth2Client, bucket, url, RestRequestMethod.POST, route, formData, headers).ConfigureAwait(false);</file><file path="DisCatSharp/Net/Rest/Endpoints.cs">public static class Endpoints</file><file path="DisCatSharp/Net/Rest/IpEndpoint.cs"></file><file path="DisCatSharp/Net/Rest/MultipartWebRequest.cs">internal sealed class MultipartWebRequest : BaseRestRequest
internal sealed class MultipartStickerWebRequest : BaseRestRequest</file><file path="DisCatSharp/Net/Rest/RateLimitBucket.cs">internal sealed class RateLimitBucket : IEquatable&lt;RateLimitBucket&gt;
		get =&gt; Volatile.Read(ref this.HashInternal);
			this.IsUnlimited = value.Contains(s_unlimitedHash);
			if (this.BucketId is not null &amp;&amp; !this.BucketId.StartsWith(value, StringComparison.Ordinal))
				this.RouteHashes.Add(id);
			Volatile.Write(ref this.HashInternal, value);
	public bool Equals(RateLimitBucket e) =&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || this.BucketId == e.BucketId);
	public static string GenerateBucketId(string hash, string guildId, string channelId, string webhookId)
	public static string GenerateHashKey(RestRequestMethod method, string route)
	public static string GenerateUnlimitedHash(RestRequestMethod method, string route)
	public override string ToString()
	public override bool Equals(object obj)
		=&gt; this.Equals(obj as RateLimitBucket);
	public override int GetHashCode()
	internal async Task TryResetLimitAsync(DateTimeOffset now)
		while (Interlocked.CompareExchange(ref this.LimitResetting, 1, 0) != 0)
			await Task.Yield();
	internal void SetInitialValues(int max, int usesLeft, DateTimeOffset newReset)</file><file path="DisCatSharp/Net/Rest/RestClient.cs">internal sealed class RestClient : IDisposable
	private readonly TimeSpan _bucketCleanupDelay = TimeSpan.FromSeconds(60);
	private readonly AsyncManualResetEvent _globalRateLimitEvent;
	private readonly ILogger _logger;
		this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, Utilities.GetFormattedToken(client));
		this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, client.Configuration.Locale);
		if (!string.IsNullOrWhiteSpace(client.Configuration.Timezone))
			this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, client.Configuration.Timezone);
		if (!string.IsNullOrWhiteSpace(client.Configuration.Override))
			this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, client.Configuration.Override);
		var httphandler = new HttpClientHandler
			BaseAddress = new(Utilities.GetApiBaseUri(configuration)),
		this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
			this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, configuration.Locale);
			if (!string.IsNullOrWhiteSpace(configuration.Timezone))
				this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, configuration.Timezone);
			if (!string.IsNullOrWhiteSpace(configuration.Override))
				this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, configuration.Override);
	public void Dispose()
		this._globalRateLimitEvent.Reset();
			this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Bucket cleaner task stopped.&quot;);
		this._routesToHashes.Clear();
		this._hashesToBuckets.Clear();
		this._requestQueue.Clear();
		GC.SuppressFinalize(this);
	public RateLimitBucket GetBucket(RestRequestMethod method, string route, object routeParams, out string url)
		var rparamsProps = routeParams.GetType()
			.GetTypeInfo()
			var val = xp.GetValue(routeParams);
				DateTime dt =&gt; dt.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture),
				DateTimeOffset dto =&gt; dto.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture),
				IFormattable xf =&gt; xf.ToString(null, CultureInfo.InvariantCulture),
				_ =&gt; val.ToString()
		var guildId = rparams.GetValueOrDefault(&quot;guild_id&quot;, &quot;&quot;);
		var channelId = rparams.GetValueOrDefault(&quot;channel_id&quot;, &quot;&quot;);
		var webhookId = rparams.GetValueOrDefault(&quot;webhook_id&quot;, &quot;&quot;);
		var hashKey = RateLimitBucket.GenerateHashKey(method, route);
		var hash = this._routesToHashes.GetOrAdd(hashKey, RateLimitBucket.GenerateUnlimitedHash(method, route));
		var bucketId = RateLimitBucket.GenerateBucketId(hash, guildId, channelId, webhookId);
		var bucket = this._hashesToBuckets.GetOrAdd(bucketId, new RateLimitBucket(hash, guildId, channelId, webhookId));
		if (!bucket.RouteHashes.Contains(bucketId))
			bucket.RouteHashes.Add(bucketId);
		_ = this._requestQueue.TryGetValue(bucketId, out var count);
		this._requestQueue[bucketId] = Interlocked.Increment(ref count);
			this._cleanerTask = Task.Run(this.CleanupBucketsAsync, this._bucketCleanerTokenSource.Token);
			this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Bucket cleaner task started.&quot;);
		url = CommonRegEx.HttpRouteRegex().Replace(route, xm =&gt; rparams[xm.Groups[1].Value]);
	public Task ExecuteRequestAsync(BaseRestRequest request, bool targetDebug = false)
		=&gt; request is null ? throw new ArgumentNullException(nameof(request)) : this.ExecuteRequestAsync(request, null, null, targetDebug);
	public Task ExecuteFormRequestAsync(BaseRestRequest request, bool targetDebug = false)
		=&gt; request is null ? throw new ArgumentNullException(nameof(request)) : this.ExecuteFormRequestAsync(request, null, null, targetDebug);
	private async Task ExecuteFormRequestAsync(BaseRestRequest request, RateLimitBucket? bucket, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool targetDebug = false)
		ObjectDisposedException.ThrowIf(this._disposed, this);
			Console.WriteLine(&quot;Meow&quot;);
			await this._globalRateLimitEvent.WaitAsync().ConfigureAwait(false);
			ratelimitTcs ??= await this.WaitForInitialRateLimit(bucket).ConfigureAwait(false);
				await bucket.TryResetLimitAsync(now).ConfigureAwait(false);
				if (Interlocked.Decrement(ref bucket.RemainingInternal) &lt; 0)
					this._logger.LogWarning(LoggerEvents.RatelimitDiag, &quot;Request for {bucket} is blocked. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
					if (delay &lt; new TimeSpan(-TimeSpan.TicksPerMinute))
						this._logger.LogError(LoggerEvents.RatelimitDiag, &quot;Failed to retrieve ratelimits - giving up and allowing next request for bucket&quot;);
						delay = TimeSpan.FromMilliseconds(100);
					this._logger.LogWarning(LoggerEvents.RatelimitPreemptive, &quot;Preemptive ratelimit triggered - waiting until {ResetDate:yyyy-MM-dd HH:mm:ss zzz} ({Delay:c})&quot;, resetDate, delay);
					Task.Delay(delay)
						.ContinueWith(_ =&gt; this.ExecuteFormRequestAsync(request, null, null))
						.LogTaskFault(this._logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while executing request&quot;);
				this._logger.LogDebug(LoggerEvents.RatelimitDiag, &quot;Request for {bucket} is allowed. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
				this._logger.LogDebug(LoggerEvents.RatelimitDiag, &quot;Initial request for {bucket} is allowed. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
			var req = this.BuildFormRequest(request);
				this._logger.Log(LogLevel.Trace, LoggerEvents.RestTx, &quot;Rest Form Request Content:\n{Content}&quot;, await req.Content.ReadAsStringAsync()!);
			var response = new RestResponse();
				res = await this.HttpClient.SendAsync(req, HttpCompletionOption.ResponseContentRead, CancellationToken.None).ConfigureAwait(false);
				var bts = await res.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
				var txt = Utilities.UTF8.GetString(bts, 0, bts.Length);
					this._logger.Log(LogLevel.Trace, LoggerEvents.RestRx, &quot;Rest Form Response Content: {Content}&quot;, txt);
				response.Headers = res.Headers?.ToDictionary(xh =&gt; xh.Key, xh =&gt; string.Join(&quot;\n&quot;, xh.Value), StringComparer.OrdinalIgnoreCase);
				this._logger.LogError(LoggerEvents.RestError, httpex, &quot;Request to {Url} triggered an HttpException&quot;, request.Url.AbsoluteUri);
				request.SetFaulted(httpex);
				this.FailInitialRateLimitTest(request, ratelimitTcs);
			this.UpdateBucket(request, response, ratelimitTcs);
					ex = new BadRequestException(request, response);
					ex = new UnauthorizedException(request, response);
					ex = new NotFoundException(request, response);
					ex = new RequestSizeException(request, response);
					ex = new RateLimitException(request, response);
					this.Handle429(response, out var wait, out var global);
							this._logger.LogError(LoggerEvents.RatelimitHit, &quot;Global ratelimit hit, cooling down for {uri}&quot;, request.Url.AbsoluteUri);
								await wait.ConfigureAwait(false);
								_ = this._globalRateLimitEvent.SetAsync();
							this.ExecuteRequestAsync(request, bucket, ratelimitTcs)
								.LogTaskFault(this._logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while retrying request&quot;);
							this._logger.LogError(LoggerEvents.RatelimitHit, &quot;Ratelimit hit, requeuing request to {url}&quot;, request.Url.AbsoluteUri);
					ex = new ServerErrorException(request, response);
				request.SetFaulted(ex);
				request.SetCompleted(response);
			this._logger.LogError(LoggerEvents.RestError, ex, &quot;Request to {Url} triggered an exception&quot;, request.Url.AbsoluteUri);
			if (!request.TrySetFaulted(ex))
				_ = this._requestQueue.TryGetValue(bucket.BucketId, out var count);
				this._requestQueue[bucket.BucketId] = Interlocked.Decrement(ref count);
						if (this._requestQueue.ContainsKey(r))
							_ = this._requestQueue.TryRemove(r, out _);
	private async Task ExecuteRequestAsync(BaseRestRequest request, RateLimitBucket? bucket, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool targetDebug = false)
					this._logger.LogWarning(LoggerEvents.RatelimitPreemptive, &quot;Preemptive ratelimit triggered - waiting until {0:yyyy-MM-dd HH:mm:ss zzz} ({1:c}).&quot;, resetDate, delay);
						.ContinueWith(_ =&gt; this.ExecuteRequestAsync(request, null, null))
			var req = this.BuildRequest(request);
				this._logger.Log(LogLevel.Trace, LoggerEvents.RestTx, &quot;Rest Request Content:\n{Content}&quot;, await req.Content.ReadAsStringAsync());
					var x = await req.Content!.ReadAsStringAsync();
					Console.WriteLine(x);
					Console.WriteLine(txt);
					this._logger.Log(LogLevel.Trace, LoggerEvents.RestRx, &quot;Rest Response Content: {Content}&quot;, txt);
				this._logger.LogError(LoggerEvents.RestError, httpex, &quot;Request to {0} triggered an HttpException&quot;, request.Url.AbsoluteUri);
								await client.RateLimitHitInternal.InvokeAsync(client, new(client.ServiceProvider)
						senex.AddSentryContext(&quot;Request&quot;, debugInfo);
						this._discord.Sentry.CaptureException(senex);
						_ = Task.Run(this._discord.Sentry.FlushAsync);
			this._logger.LogError(LoggerEvents.RestError, ex, &quot;Request to {0} triggered an exception&quot;, request.Url.AbsoluteUri);
	private void FailInitialRateLimitTest(BaseRestRequest request, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool resetToInitial = false)
			this.UpdateHashCaches(request, bucket);
		_ = Task.Run(() =&gt; ratelimitTcs?.TrySetResult(false));
	private async Task&lt;TaskCompletionSource&lt;bool&gt;?&gt; WaitForInitialRateLimit(RateLimitBucket bucket)
				if (Interlocked.CompareExchange(ref bucket.LimitTesting, 1, 0) is 0)
				await Task.Yield();
				await waitTask.ConfigureAwait(false);
	private HttpRequestMessage BuildFormRequest(BaseRestRequest request)
		var req = new HttpRequestMessage(new(request.Method.ToString()), request.Url);
		if (request.Headers is not null &amp;&amp; request.Headers.Any())
						req.Headers.Add(kvp.Key, kvp.Value);
			throw new InvalidOperationException();
		req.Content = new FormUrlEncodedContent(formRequest.FormData);
	private HttpRequestMessage BuildRequest(BaseRestRequest request)
			case RestRequest nmprequest when !string.IsNullOrWhiteSpace(nmprequest.Payload):
				this._logger.LogTrace(LoggerEvents.RestTx, nmprequest.Payload);
				req.Content = new StringContent(nmprequest.Payload);
				this._logger.LogTrace(LoggerEvents.RestTx, &quot;&lt;multipart request&gt;&quot;);
				var boundary = &quot;---------------------------&quot; + DateTime.Now.Ticks.ToString(&quot;x&quot;);
				req.Headers.Add(CommonHeaders.CONNECTION, CommonHeaders.CONNECTION_KEEP_ALIVE);
				req.Headers.Add(CommonHeaders.KEEP_ALIVE, &quot;600&quot;);
				var content = new MultipartFormDataContent(boundary);
				if (mprequest.Values is not null &amp;&amp; mprequest.Values.Any())
						content.Add(new StringContent(kvp.Value), kvp.Key);
				if (mprequest.Files is not null &amp;&amp; mprequest.Files.Any())
						var name = $&quot;files[{fileId.ToString(CultureInfo.InvariantCulture)}]&quot;;
						content.Add(new StreamContent(f.Value), name, f.Key);
				var sc = new StreamContent(mpsrequest.File.Stream);
				var content = new MultipartFormDataContent(boundary)
					{ new StringContent(mpsrequest.Name), &quot;name&quot; },
					{ new StringContent(mpsrequest.Tags), &quot;tags&quot; }
				if (!string.IsNullOrEmpty(mpsrequest.Description))
					content.Add(new StringContent(mpsrequest.Description), &quot;description&quot;);
				content.Add(sc, &quot;file&quot;, fileName);
	private void Handle429(RestResponse response, out Task? waitTask, out bool global)
		if (hs.TryGetValue(CommonHeaders.RETRY_AFTER, out var retryAfterRaw))
			var retryAfter = TimeSpan.FromSeconds(int.Parse(retryAfterRaw, CultureInfo.InvariantCulture));
			waitTask = Task.Delay(retryAfter);
		if (hs.TryGetValue(CommonHeaders.RATELIMIT_GLOBAL, out var isGlobal) &amp;&amp; isGlobal.ToLowerInvariant() is &quot;true&quot;)
	private void UpdateBucket(BaseRestRequest request, RestResponse response, TaskCompletionSource&lt;bool&gt;? ratelimitTcs)
		if (hs.TryGetValue(CommonHeaders.RATELIMIT_SCOPE, out var scope))
		var r1 = hs.TryGetValue(CommonHeaders.RATELIMIT_LIMIT, out var usesMax);
		var r2 = hs.TryGetValue(CommonHeaders.RATELIMIT_REMAINING, out var usesLeft);
		var r3 = hs.TryGetValue(CommonHeaders.RATELIMIT_RESET, out var reset);
		var r4 = hs.TryGetValue(CommonHeaders.RATELIMIT_RESET_AFTER, out var resetAfter);
		var r5 = hs.TryGetValue(CommonHeaders.RATELIMIT_BUCKET, out var hash);
				this.FailInitialRateLimitTest(request, ratelimitTcs, ratelimitTcs is null);
		var resetTime = new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero).AddSeconds(double.Parse(reset, CultureInfo.InvariantCulture));
		if (hs.TryGetValue(&quot;Date&quot;, out var rawDate))
			serverTime = DateTimeOffset.Parse(rawDate, CultureInfo.InvariantCulture).ToUniversalTime();
			resetDelta = TimeSpan.FromSeconds(request.RateLimitWaitOverride.Value);
			bucket.ResetAfter = TimeSpan.FromSeconds(double.Parse(resetAfter!, CultureInfo.InvariantCulture));
		var maximum = int.Parse(usesMax!, CultureInfo.InvariantCulture);
		var remaining = int.Parse(usesLeft!, CultureInfo.InvariantCulture);
			bucket.SetInitialValues(maximum, remaining, newReset);
			_ = Task.Run(() =&gt; ratelimitTcs.TrySetResult(true));
		this.UpdateHashCaches(request, bucket, hash);
	private void UpdateHashCaches(BaseRestRequest request, RateLimitBucket bucket, string? newHash = null)
		var hashKey = RateLimitBucket.GenerateHashKey(request.Method, request.Route);
		if (!this._routesToHashes.TryGetValue(hashKey, out var oldHash))
			_ = this._routesToHashes.TryRemove(hashKey, out _);
				_ = this._hashesToBuckets.TryRemove(bucket.BucketId, out _);
		this._logger.LogDebug(LoggerEvents.RestHashMover, &quot;Updating hash in {0}: \&quot;{1}\&quot; -&gt; \&quot;{2}\&quot;&quot;, hashKey, oldHash, newHash);
		var bucketId = RateLimitBucket.GenerateBucketId(newHash, bucket.GuildId, bucket.ChannelId, bucket.WebhookId);
		_ = this._routesToHashes.AddOrUpdate(hashKey, newHash, (key, previousHash) =&gt;
			var oldBucketId = RateLimitBucket.GenerateBucketId(oldHash!, bucket.GuildId, bucket.ChannelId, bucket.WebhookId);
			_ = this._hashesToBuckets.TryRemove(oldBucketId, out _);
			_ = this._hashesToBuckets.AddOrUpdate(bucketId, bucket, (_, _) =&gt; bucket);
	private async Task CleanupBucketsAsync()
				await Task.Delay(this._bucketCleanupDelay, this._bucketCleanerTokenSource.Token).ConfigureAwait(false);
				var bucket = this._hashesToBuckets.Values.FirstOrDefault(x =&gt; x.RouteHashes.Contains(key));
				if (bucket is null || bucket.LastAttemptAt.AddSeconds(5) &lt; DateTimeOffset.UtcNow)
					_ = this._requestQueue.TryRemove(key, out _);
				if (string.IsNullOrEmpty(value.BucketId) || (this._requestQueue.ContainsKey(value.BucketId) &amp;&amp; !value.IsUnlimited))
				_ = this._hashesToBuckets.TryRemove(key, out _);
				bucketIdStrBuilder.Append(value.BucketId + &quot;, &quot;);
				this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Removed {0} unused bucket{1}: [{2}]&quot;, removedBuckets, removedBuckets &gt; 1 ? &quot;s&quot; : string.Empty, bucketIdStrBuilder.ToString().TrimEnd(&apos;,&apos;, &apos; &apos;));
		this.Dispose();</file><file path="DisCatSharp/Net/Rest/RestFormRequest.cs">internal sealed class RestFormRequest : BaseRestRequest</file><file path="DisCatSharp/Net/Rest/RestRequest.cs">internal sealed class RestRequest : BaseRestRequest</file><file path="DisCatSharp/Net/Rest/RestRequestMethod.cs"></file><file path="DisCatSharp/Net/Rest/RestResponse.cs">public sealed class RestResponse</file><file path="DisCatSharp/Net/Rest/SessionBucket.cs">public sealed class SessionBucket : ObservableApiObject
	public override string ToString()</file><file path="DisCatSharp/Net/Serialization/DiscordComponentJsonConverter.cs">internal sealed class DiscordComponentJsonConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		=&gt; throw new NotImplementedException();
	public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		var job = JObject.Load(reader);
		var type = job[&quot;type&quot;]?.ToObject&lt;ComponentType&gt;() ?? throw new ArgumentException($&quot;Value {reader} does not have a component type specifier&quot;);
		DiscordComponent cmp = type switch
			ComponentType.ActionRow =&gt; new DiscordActionRowComponent(),
			ComponentType.Button when (string?)job[&quot;url&quot;] is not null =&gt; new DiscordLinkButtonComponent(),
			ComponentType.Button when (string?)job[&quot;sku_id&quot;] is not null =&gt; new DiscordPremiumButtonComponent(),
			ComponentType.Button =&gt; new DiscordButtonComponent(),
			ComponentType.StringSelect =&gt; new DiscordStringSelectComponent(),
			ComponentType.InputText =&gt; new DiscordTextComponent(),
			ComponentType.UserSelect =&gt; new DiscordUserSelectComponent(),
			ComponentType.RoleSelect =&gt; new DiscordRoleSelectComponent(),
			ComponentType.MentionableSelect =&gt; new DiscordMentionableSelectComponent(),
			ComponentType.ChannelSelect =&gt; new DiscordChannelSelectComponent(),
			ComponentType.Section =&gt; new DiscordSectionComponent(),
			ComponentType.TextDisplay =&gt; new DiscordTextDisplayComponent(),
			ComponentType.Thumbnail =&gt; new DiscordThumbnailComponent(),
			ComponentType.MediaGallery =&gt; new DiscordMediaGalleryComponent(),
			ComponentType.File =&gt; new DiscordFileDisplayComponent(),
			ComponentType.Separator =&gt; new DiscordSeparatorComponent(),
		using var jreader = job.CreateReader();
		serializer.Populate(jreader, cmp);
	public override bool CanConvert(Type objectType)
		=&gt; typeof(DiscordComponent).IsAssignableFrom(objectType);</file><file path="DisCatSharp/Net/Serialization/DiscordJson.cs">public static class DiscordJson
	private static readonly JsonSerializer s_serializer = JsonSerializer.CreateDefault(new()
		ContractResolver = new OptionalJsonContractResolver()
	public static string SerializeObject(object value)
	public static T DeserializeObject&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : ObservableApiObject
	public static T DeserializeIEnumerableObject&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : IEnumerable&lt;ObservableApiObject&gt;
	public static void PopulateObject(JToken value, object target)
		using var reader = value.CreateReader();
		s_serializer.Populate(reader, target);
	public static T ToDiscordObject&lt;T&gt;(this JToken token)
	private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
		var stringWriter = new StringWriter(new(), CultureInfo.InvariantCulture);
		using (var jsonTextWriter = new JsonTextWriter(stringWriter))
			jsonSerializer.Serialize(jsonTextWriter, value, type);
		return stringWriter.ToString();
	private static void DiscordJsonErrorHandler(object? sender, ErrorEventArgs e, BaseDiscordClient? discord)
		SentryEvent sentryEvent = new(new DiscordJsonException(jre))
			Message = Utilities.StripTokensAndOptIds(sentryMessage, discord.Configuration.EnableDiscordIdScrubber)
		sentryEvent.SetFingerprint(BaseDiscordClient.GenerateSentryFingerPrint(sentryEvent));
				Id = discord.CurrentUser.Id.ToString(),
		var sid = discord.Sentry.CaptureEvent(sentryEvent);
		_ = Task.Run(discord.Sentry.FlushAsync);
			discord.Logger.LogInformation(&quot;DiscordJson exception reported to sentry with id {sid}&quot;, sid.ToString());
	private static T DeserializeObjectInternal&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : ObservableApiObject
		ArgumentNullException.ThrowIfNull(json, nameof(json));
		var obj = JsonConvert.DeserializeObject&lt;T&gt;(json, new JsonSerializerSettings
			ContractResolver = new OptionalJsonContractResolver(),
		if (!discord.Configuration.ReportMissingFields || !obj.AdditionalProperties.Any())
		var sentryMessage = &quot;Found missing properties in api response for &quot; + obj.GetType().Name;
			if (obj.IgnoredJsonKeys.Count is not 0 &amp;&amp; obj.IgnoredJsonKeys.Any(x =&gt; x == ap.Key))
					discord.Logger.LogInformation(&quot;{sentry}&quot;, sentryMessage);
					discord.Logger.LogDebug(&quot;{json}&quot;, json);
			sentryFields.Add(ap.Key);
				discord.Logger.LogInformation(&quot;Found field {field} on {object}&quot;, ap.Key, obj.GetType().Name);
		var sentryJson = JsonConvert.SerializeObject(sentryFields);
		SentryEvent sentryEvent = new()
		sentryEvent.SetExtra(&quot;Found Fields&quot;, sentryJson);
			discord.Logger.LogInformation(&quot;Missing fields reported to sentry with id {sid}&quot;, sid.ToString());
	private static T DeserializeIEnumerableObjectInternal&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : IEnumerable&lt;ObservableApiObject&gt;
		if (!discord.Configuration.ReportMissingFields || !obj.Any(x =&gt; x.AdditionalProperties.Any()))
		var first = obj.First();
		var sentryMessage = &quot;Found missing properties in api response for &quot; + first.GetType().Name;
			if (first.IgnoredJsonKeys.Count is not 0 &amp;&amp; first.IgnoredJsonKeys.Any(x =&gt; x == ap.Key))
				discord.Logger.LogInformation(&quot;Found field {field} on {object}&quot;, ap.Key, first.GetType().Name);</file><file path="DisCatSharp/Net/Serialization/SnowflakeArrayAsDictionaryJsonConverter.cs">internal class SnowflakeArrayAsDictionaryJsonConverter : JsonConverter
	public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
			writer.WriteNull();
			var type = value.GetType().GetTypeInfo();
			JToken.FromObject(type.GetDeclaredProperty(&quot;Values&quot;)!.GetValue(value)!).WriteTo(writer);
	public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		var constructor = objectType.GetTypeInfo().DeclaredConstructors
			.FirstOrDefault(e =&gt; !e.IsStatic &amp;&amp; e.GetParameters().Length == 0);
		var properties = objectType.GetTypeInfo().GetDeclaredProperty(&quot;Item&quot;);
		var entries = (IEnumerable?)serializer.Deserialize(reader, objectType.GenericTypeArguments[1].MakeArrayType());
			properties.SetValue(dict, entry, [
				?? throw new InvalidOperationException($&quot;Type {entry?.GetType()} is not deserializable&quot;)
	public override bool CanConvert(Type objectType)
		var genericTypedef = objectType.GetGenericTypeDefinition();
		return typeof(SnowflakeObject).GetTypeInfo().IsAssignableFrom(valueParam.GetTypeInfo()) ||</file><file path="DisCatSharp/Net/Udp/BaseUdpClient.cs">public abstract class BaseUdpClient
	public abstract void Setup(ConnectionEndpoint endpoint);
	public abstract Task SendAsync(byte[] data, int dataLength);
	public abstract Task&lt;byte[]&gt; ReceiveAsync();
	public abstract void Close();</file><file path="DisCatSharp/Net/Udp/DCSUdpClient.cs">internal class DcsUdpClient : BaseUdpClient
	private readonly CancellationTokenSource _tokenSource;
	private UdpClient _client;
	private ConnectionEndpoint _endPoint;
	private Task _receiverTask;
	public override void Setup(ConnectionEndpoint endpoint)
		this._receiverTask = Task.Run(this.ReceiverLoopAsync, this.TOKEN);
	public override Task SendAsync(byte[] data, int dataLength)
		=&gt; this._client.SendAsync(data, dataLength, this._endPoint.Hostname, this._endPoint.Port);
	public override Task&lt;byte[]&gt; ReceiveAsync() =&gt; Task.FromResult(this._packetQueue.Take(this.TOKEN));
	public override void Close()
		this._tokenSource.Cancel();
			this._client.Close();
		this._packetQueue.Dispose();
	private async Task ReceiverLoopAsync()
				var packet = await this._client.ReceiveAsync(this.TOKEN).ConfigureAwait(false);
				this._packetQueue.Add(packet.Buffer, this.TOKEN);
	public static BaseUdpClient CreateNew()
		=&gt; new DcsUdpClient();</file><file path="DisCatSharp/Net/WebSocket/IWebSocketClient.cs">public interface IWebSocketClient : IDisposable
	Task ConnectAsync(Uri uri);
	Task DisconnectAsync(int code = 1000, string message = &quot;&quot;);
	Task SendMessageAsync(string message);
	bool AddDefaultHeader(string name, string value);
	bool RemoveDefaultHeader(string name);</file><file path="DisCatSharp/Net/WebSocket/PayloadDecompressor.cs">internal sealed class PayloadDecompressor : IDisposable
	private readonly MemoryStream _compressedStream;
	private readonly DeflateStream _decompressorStream;
			throw new InvalidOperationException(&quot;Decompressor requires a valid compression mode.&quot;);
	public void Dispose()
		this._compressedStream.Dispose();
	public bool TryDecompress(ArraySegment&lt;byte&gt; compressed, MemoryStream decompressed)
			this._compressedStream.Write(compressed.Array, compressed.Offset + 2, compressed.Count - 2);
			this._compressedStream.Write(compressed.Array, compressed.Offset, compressed.Count);
		this._compressedStream.Flush();
		var cspan = compressed.AsSpan();
		var suffix = BinaryPrimitives.ReadUInt32BigEndian(cspan[^4..]);
				zlib.Dispose();
			zlib.CopyTo(decompressed);
			this._compressedStream.SetLength(0);</file><file path="DisCatSharp/Net/WebSocket/SocketLock.cs">internal sealed class SocketLock : IDisposable
	private readonly SemaphoreSlim _lockSemaphore;
	private Task _unlockTask;
	public void Dispose()
	public async Task LockAsync()
		await this._lockSemaphore.WaitAsync(CancellationToken.None).ConfigureAwait(false);
		this._unlockTask = Task.Delay(TimeSpan.FromSeconds(30), this._timeoutCancel.Value);
		_ = this._unlockTask.ContinueWith(this.InternalUnlock, TaskContinuationOptions.NotOnCanceled);
	public void UnlockAfter(TimeSpan unlockDelay)
			this._timeoutCancelSource.Cancel();
			this._timeoutCancelSource.Dispose();
		this._unlockTask = Task.Delay(unlockDelay, CancellationToken.None);
		_ = this._unlockTask.ContinueWith(this.InternalUnlock);
	public Task WaitAsync()
		=&gt; this._lockSemaphore.WaitAsync();
	private void InternalUnlock(Task t)
		=&gt; this._lockSemaphore.Release(this._maxConcurrency);</file><file path="DisCatSharp/Net/WebSocket/WebSocketClient.cs">public class WebSocketClient : IWebSocketClient
	private readonly SemaphoreSlim _senderLock;
	private CancellationToken _receiverToken;
	private CancellationToken _socketToken;
	public async Task ConnectAsync(Uri uri)
			await this.DisconnectAsync().ConfigureAwait(false);
		await this._senderLock.WaitAsync(CancellationToken.None).ConfigureAwait(false);
					this._ws.Options.SetRequestHeader(k, v);
			await this._ws.ConnectAsync(uri, this._socketToken).ConfigureAwait(false);
			this._receiverTask = Task.Run(this.ReceiverLoopAsync, this._receiverToken);
			this._senderLock.Release();
	public async Task DisconnectAsync(int code = 1000, string? message = null)
				await this._ws.CloseOutputAsync((WebSocketCloseStatus)code, message, CancellationToken.None).ConfigureAwait(false);
				await this._receiverTask.ConfigureAwait(false); // Ensure that receiving completed
					this._socketTokenSource.Cancel();
					this._receiverTokenSource.Cancel();
	public async Task SendMessageAsync(string message)
		var bytes = Utilities.UTF8.GetBytes(message);
				var segLen = Math.Min(OUTGOING_CHUNK_SIZE, len - segStart);
				await this._ws.SendAsync(new(bytes, segStart, segLen), WebSocketMessageType.Text, i == segCount - 1, CancellationToken.None).ConfigureAwait(false);
	public bool AddDefaultHeader(string name, string value)
	public bool RemoveDefaultHeader(string name)
		=&gt; this._defaultHeaders.Remove(name);
	public void Dispose()
		this.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
		GC.SuppressFinalize(this);
	internal async Task ReceiverLoopAsync()
		await Task.Yield();
			using var bs = new MemoryStream();
				WebSocketReceiveResult result;
					throw new NullReferenceException();
					result = await this._ws.ReceiveAsync(buffer, CancellationToken.None).ConfigureAwait(false);
					await bs.WriteAsync(buffer.Array!, 0, result.Count, this._receiverToken);
				_ = await bs.ReadAsync(resultBytes, 0, resultBytes.Length, this._receiverToken);
				bs.SetLength(0);
					await this._connected.InvokeAsync(this, new(this._serviceProvider)).ConfigureAwait(false);
					await this._messageReceived.InvokeAsync(this, new SocketBinaryMessageEventArgs(resultBytes)).ConfigureAwait(false);
					await this._messageReceived.InvokeAsync(this, new SocketTextMessageEventArgs(Utilities.UTF8.GetString(resultBytes))).ConfigureAwait(false);
						await this._ws.CloseOutputAsync(code, result.CloseStatusDescription, CancellationToken.None).ConfigureAwait(false);
					await this._disconnected.InvokeAsync(this, new(this._serviceProvider)
					}).ConfigureAwait(false);
			await this._exceptionThrown.InvokeAsync(this, new(this._serviceProvider)
		_ = this.DisconnectAsync().ConfigureAwait(false);
	public static IWebSocketClient CreateNew(IWebProxy proxy, IServiceProvider provider)
		=&gt; new WebSocketClient(proxy, provider);
		add =&gt; this._connected.Register(value);
		remove =&gt; this._connected.Unregister(value);
		add =&gt; this._disconnected.Register(value);
		remove =&gt; this._disconnected.Unregister(value);
		add =&gt; this._messageReceived.Register(value);
		remove =&gt; this._messageReceived.Unregister(value);
		add =&gt; this._exceptionThrown.Register(value);
		remove =&gt; this._exceptionThrown.Unregister(value);
	private IServiceProvider _serviceProvider;
	private void EventErrorHandler&lt;TArgs&gt;(AsyncEvent&lt;WebSocketClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;WebSocketClient, TArgs&gt; handler, WebSocketClient sender, TArgs eventArgs)
		where TArgs : AsyncEventArgs
		=&gt; this._exceptionThrown.InvokeAsync(this, new(this._serviceProvider)
		}).ConfigureAwait(false).GetAwaiter().GetResult();</file><file path="DisCatSharp/QueryUriBuilder.cs">internal class QueryUriBuilder
		ArgumentNullException.ThrowIfNull(uri);
	public QueryUriBuilder AddParameter(string key, string value)
		this._queryParams.Add(new(key, value));
	public Uri Build() =&gt;
		new UriBuilder(this.SourceUri)
			Query = this._queryParams.Count is not 0 ? string.Join(&quot;&amp;&quot;, this._queryParams.Select(e =&gt; Uri.EscapeDataString(e.Key) + &apos;=&apos; + Uri.EscapeDataString(e.Value))) : string.Empty
	public override string ToString() =&gt; this.Build().ToString();</file><file path="DisCatSharp/ReadOnlyConcurrentDictionary.cs">	public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator() =&gt; this._underlyingDict.GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator() =&gt; ((IEnumerable)this._underlyingDict).GetEnumerator();
	public bool ContainsKey(TKey key) =&gt; this._underlyingDict.ContainsKey(key);
	public bool TryGetValue(TKey key, out TValue value) =&gt; this._underlyingDict.TryGetValue(key, out value);</file><file path="DisCatSharp/ReadOnlySet.cs">	public IEnumerator&lt;T&gt; GetEnumerator()
		=&gt; this._underlyingSet.GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator()
		=&gt; (this._underlyingSet as IEnumerable).GetEnumerator();</file><file path="DisCatSharp/RingBuffer.cs">public class RingBuffer&lt;T&gt; : ICollection&lt;T&gt;
			throw new ArgumentOutOfRangeException(nameof(size), &quot;Size must be positive.&quot;);
		if (elements == null || !elements.Any())
			throw new ArgumentException(&quot;The collection cannot be null or empty.&quot;, nameof(elements));
		this.InternalBuffer = elements.ToArray();
			throw new ArgumentOutOfRangeException(nameof(index), &quot;Index must be less than buffer capacity, and greater than zero.&quot;);
	public void Add(T item)
	public void Clear()
		this.InternalBuffer.Populate(default);
	public bool Contains(T item) =&gt; throw new NotImplementedException(&quot;This method is not implemented. Use .Contains(predicate) instead.&quot;);
	public void CopyTo(T[] array, int index)
			throw new ArgumentException(&quot;Target array is too small to contain the elements from this buffer.&quot;, nameof(array));
	public bool Remove(T item) =&gt; throw new NotImplementedException(&quot;This method is not implemented. Use .Remove(predicate) instead.&quot;);
	public IEnumerator&lt;T&gt; GetEnumerator() =&gt;
			? this.InternalBuffer.AsEnumerable().GetEnumerator()
			: this.InternalBuffer.Skip(this.CurrentIndex)
				.Concat(this.InternalBuffer.Take(this.CurrentIndex))
				.GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator() =&gt; this.GetEnumerator();
	public bool TryGet(Func&lt;T, bool&gt; predicate, out T item)
	public bool Contains(Func&lt;T, bool&gt; predicate) =&gt; this.InternalBuffer.Any(predicate);
	public bool Remove(Func&lt;T, bool&gt; predicate)</file><file path="DisCatSharp/Utilities.cs">public static class Utilities
		var ti = t.GetTypeInfo();
		var vals = Enum.GetValues(t).Cast&lt;Permissions&gt;();
			var xsv = xv.ToString();
			var xmv = ti.DeclaredMembers.FirstOrDefault(xm =&gt; xm.Name == xsv);
		var a = typeof(DiscordClient).GetTypeInfo().Assembly;
			var v = a.GetName().Version;
	public static string? StripTokensAndOptIds(string? str, bool stripIds)
	public static string? StripTokens(string? str)
		if (string.IsNullOrWhiteSpace(str))
		str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
		str = Regex.Replace(str, @&quot;(mfa\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);
	public static string? StripIds(string? str, bool strip)
		if (string.IsNullOrWhiteSpace(str) || !strip)
		str = DiscordRegEx.IdRegex().Replace(str, &quot;{DISCORD_ID}&quot;);
	public static Uri AddParameter(this Uri url, string paramName, string paramValue)
		var uriBuilder = new UriBuilder(url);
		var query = HttpUtility.ParseQueryString(uriBuilder.Query);
		uriBuilder.Query = query.ToString();
	internal static string GetApiBaseUri(DiscordConfiguration? config = null)
	internal static Uri GetApiUriFor(string path, DiscordConfiguration? config = null)
	internal static Uri GetApiUriFor(string path, string queryString, DiscordConfiguration? config = null)
	internal static QueryUriBuilder GetApiUriBuilderFor(string path, DiscordConfiguration? config = null)
	internal static string GetFormattedToken(BaseDiscordClient client)
	internal static string GetFormattedToken(DiscordConfiguration config)
			_ =&gt; throw new ArgumentException(&quot;Invalid token type specified.&quot;, nameof(config))
	internal static Dictionary&lt;string, string&gt; GetBaseHeaders()
	internal static string GetUserAgent()
	internal static bool ContainsUserMentions(string message)
		=&gt; DiscordRegEx.UserWithoutNicknameRegex().IsMatch(message);
	internal static bool ContainsNicknameMentions(string message)
		=&gt; DiscordRegEx.UserWithNicknameRegex().IsMatch(message);
	internal static bool ContainsChannelMentions(string message)
		=&gt; DiscordRegEx.ChannelRegex().IsMatch(message);
	internal static bool ContainsRoleMentions(string message)
		=&gt; DiscordRegEx.RoleRegex().IsMatch(message);
	internal static bool ContainsEmojis(string message)
		=&gt; DiscordRegEx.EmojiRegex().IsMatch(message);
	internal static IEnumerable&lt;ulong&gt; GetUserMentions(string message)
		var matches = DiscordRegEx.UserWithOptionalNicknameRegex().Matches(message);
		       select ulong.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture);
	internal static IEnumerable&lt;ulong&gt; GetRoleMentions(string message)
		var matches = DiscordRegEx.RoleRegex().Matches(message);
	internal static IEnumerable&lt;ulong&gt; GetChannelMentions(string message)
		var matches = DiscordRegEx.ChannelRegex().Matches(message);
	internal static IEnumerable&lt;ulong&gt; GetEmojis(string message)
		var matches = DiscordRegEx.EmojiRegex().Matches(message);
		       select ulong.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture);
	internal static bool IsValidSlashCommandName(string name)
		=&gt; DiscordRegEx.ApplicationCommandNameRegex().IsMatch(name);
	internal static bool HasMessageIntents(DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.GuildMessages) || intents.HasIntent(DiscordIntents.DirectMessages);
	internal static bool HasMessageContentIntents(DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.MessageContent);
	internal static bool HasReactionIntents(DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.GuildMessageReactions) || intents.HasIntent(DiscordIntents.DirectMessageReactions);
	internal static bool HasTypingIntents(DiscordIntents intents)
		=&gt; intents.HasIntent(DiscordIntents.GuildMessageTyping) || intents.HasIntent(DiscordIntents.DirectMessageTyping);
	public static int GetShardId(ulong guildId, int shardCount)
	public static DateTimeOffset GetDateTimeOffset(long unixTime, bool shouldThrow = true)
			return DateTimeOffset.FromUnixTimeSeconds(unixTime);
	public static DateTimeOffset GetDateTimeOffsetFromMilliseconds(long unixTime, bool shouldThrow = true)
			return DateTimeOffset.FromUnixTimeMilliseconds(unixTime);
	public static long GetUnixTime(DateTimeOffset dto)
		=&gt; dto.ToUnixTimeMilliseconds();
	public static DateTimeOffset GetSnowflakeTime(this ulong snowflake)
		=&gt; DiscordClient.DiscordEpoch.AddMilliseconds(snowflake &gt;&gt; 22);
	public static DateTimeOffset? GetSnowflakeTime(this ulong? snowflake)
		=&gt; snowflake is not null ? DiscordClient.DiscordEpoch.AddMilliseconds(snowflake.Value &gt;&gt; 22) : null;
	public static string ToPermissionString(this Permissions perm, bool useNewline = false, bool sortAscending = true, bool includeValue = false, bool shortIfAll = false)
		if (shortIfAll &amp;&amp; perm.HasPermission(Permissions.All))
			.Where(xkvp =&gt; xkvp.Key != Permissions.None &amp;&amp; xkvp.Key != Permissions.All &amp;&amp; (perm &amp; xkvp.Key) == xkvp.Key)
			.Select(xkvp =&gt; includeValue ? $&quot;{xkvp.Value} ({(long)xkvp.Key})&quot; : xkvp.Value);
		return string.Join(useNewline ? &quot;\n&quot; : &quot;, &quot;, sortAscending ? strs.OrderBy(xs =&gt; xs) : strs);
	public static bool Contains(this string str, params char[] characters)
		=&gt; str.Any(characters.Contains);
	internal static void LogTaskFault(this Task task, ILogger? logger, LogLevel level, EventId eventId, string? message, params object?[] args)
		ArgumentNullException.ThrowIfNull(task);
		task.ContinueWith(t =&gt; logger.Log(level, eventId, t.Exception, message, args), TaskContinuationOptions.OnlyOnFaulted);
	internal static void Deconstruct&lt;TKey, TValue&gt;(this KeyValuePair&lt;TKey, TValue&gt; kvp, out TKey key, out TValue value)
	public static Task CheckGitHubVersionAsync(DiscordClient client, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productName = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null, string? githubToken = null)
	public static Task CheckNuGetVersionAsync(DiscordClient client, string packageId = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null)
	internal static Task CheckVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productNameOrPackageId = &quot;DisCatSharp&quot;, string? manualVersion = null, string? githubToken = null, bool includePrerelease = true, VersionCheckMode checkMode = VersionCheckMode.NuGet)
	private static async Task CheckGitHubVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productName = &quot;DisCatSharp&quot;, string? manualVersion = null, string? githubToken = null, bool includePrerelease = true)
		if (startupCheck &amp;&amp; s_gitHubVersionCheckFinishedFor.TryGetValue(productName, out var val) &amp;&amp; val)
			var currentVersion = version.Split(&apos;-&apos;)[0]!.Split(&apos;+&apos;)[0]!;
			var splitVersion = currentVersion.Split(&apos;.&apos;);
			var api = Convert.ToInt32(splitVersion[0]);
			var major = Convert.ToInt32(splitVersion[1]);
			var minor = Convert.ToInt32(splitVersion[2]);
			ApiConnection apiConnection = githubToken is not null ? new(new Connection(new($&quot;{client.BotLibrary}&quot;, client.VersionString), new InMemoryCredentialStore(new(githubToken)))) : new(new Connection(new($&quot;{client.BotLibrary}&quot;, client.VersionString)));
			ReleasesClient releaseClient = new(apiConnection);
				? (await releaseClient.GetAll(owner, repository, new()
				})).ToList().FirstOrDefault()
				: await releaseClient.GetLatest(owner, repository);
				client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates. Could not determine remote version&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;);
				var assetUrl = latest.Assets.FirstOrDefault(x =&gt; x.Name is &quot;RELEASENOTES.md&quot;)?.BrowserDownloadUrl;
						GitHubClient gitHubClient = new(apiConnection.Connection);
						var response = await gitHubClient.Connection.GetRawStream(new(assetUrl), new Dictionary&lt;string, string&gt;
						releaseNotes = await response.Body.GenerateStringFromStream();
			var lastGitHubRelease = latest.TagName.Replace(&quot;v&quot;, string.Empty, StringComparison.InvariantCultureIgnoreCase);
			var githubSplitVersion = lastGitHubRelease.Split(&apos;.&apos;);
			var githubApi = Convert.ToInt32(githubSplitVersion[0]);
			var githubMajor = Convert.ToInt32(githubSplitVersion[1]);
			var githubMinor = Convert.ToInt32(githubSplitVersion[2]);
				client.Logger.LogCritical(&quot;[{Type}] Your version of {Product} is outdated!\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version, lastGitHubRelease);
				client.Logger.LogWarning(&quot;[{Type}] Your version of {Product} is newer than the latest release!\n\tPre-releases are not recommended for production.\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version, lastGitHubRelease);
				client.Logger.LogInformation(&quot;[{Type}] Your version of {Product} is up to date!\n\tCurrent version: v{CurrentVersion}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version);
				if (!string.IsNullOrEmpty(releaseNotes))
					client.Logger.LogInformation(&quot;Release Notes:\n{ReleaseNotes}&quot;, releaseNotes);
					client.Logger.LogWarning(&quot;Could not find any release notes&quot;);
				client.Logger.LogInformation(&quot;Release notes disabled by config&quot;);
			client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates for {Product}. Error: {Exception}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, ex);
				if (!s_gitHubVersionCheckFinishedFor.TryAdd(productName, true) &amp;&amp; s_gitHubVersionCheckFinishedFor.TryGetValue(productName, out _))
	private static async Task CheckNuGetVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string packageId = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null)
		if (startupCheck &amp;&amp; s_nuGetVersionCheckFinishedFor.TryGetValue(packageId, out var val) &amp;&amp; val)
			var repository = Repository.Factory.GetCoreV3(&quot;https://api.nuget.org/v3/index.json&quot;);
			var sourceCache = new SourceCacheContext
			var latestVersions = (await resource.GetLatestVersions(new List&lt;string&gt;
				packageId.ToLowerInvariant()
			}, includePrerelease, false, sourceCache, new NullLogger(), CancellationToken.None))?.ToList();
			var latestPackageVersion = latestVersions.First(x =&gt; string.Equals(x.Key, packageId, StringComparison.InvariantCultureIgnoreCase)).Value;
				await using var packageStream = new MemoryStream();
				await dResource.CopyNupkgToStreamAsync(
					new NullLogger(),
				using var packageReader = new PackageArchiveReader(packageStream);
				var nuspecReader = await packageReader.GetNuspecReaderAsync(CancellationToken.None);
				releaseNotes = nuspecReader.GetReleaseNotes();
			var gitLessVersion = version.Split(&apos;+&apos;)[0];
			NuGetVersion currentPackageVersion = new(gitLessVersion);
				client.Logger.LogCritical(&quot;[{Type}] Your version of {Product} is outdated!\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion, latestPackageVersion.OriginalVersion);
				client.Logger.LogWarning(&quot;[{Type}] Your version of {Product} is newer than the latest release!\n\tPre-releases are not recommended for production.\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion, latestPackageVersion.OriginalVersion);
				client.Logger.LogInformation(&quot;[{Type}] Your version of {Product} is up to date!\n\tCurrent version: v{CurrentVersion}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion);
			client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates for {Product}. Error: {Exception}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, ex);
				if (!s_nuGetVersionCheckFinishedFor.TryAdd(packageId, true) &amp;&amp; s_nuGetVersionCheckFinishedFor.TryGetValue(packageId, out _))</file><file path="LICENSE.md">The MIT License (MIT)

Copyright (c) 2021-2025 AITSYS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

# Package licenses for DisCatSharp
Parts of this package are not provided under DisCatSharp&apos;s license. Said
licenses are listed here.


## Package base
[Original license reading](https://github.com/DSharpPlus/DSharpPlus/blob/master/LICENSE)
```
The MIT License (MIT)

Copyright (c) 2015 Mike Santiago

Copyright (c) 2016-2021 DSharpPlus Development Team


Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Opus
[Original license reading](https://github.com/xiph/opus/blob/master/COPYING)

```
Copyright 2001-2011 Xiph.Org, Skype Limited, Octasic,
                    Jean-Marc Valin, Timothy B. Terriberry,
                    CSIRO, Gregory Maxwell, Mark Borgerding,
                    Erik de Castro Lopo

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Opus is subject to the royalty-free patent licenses which are
specified at:

Xiph.Org Foundation:
https://datatracker.ietf.org/ipr/1524/

Microsoft Corporation:
https://datatracker.ietf.org/ipr/1914/

Broadcom Corporation:
https://datatracker.ietf.org/ipr/1526/
```

## Libsodium
[Original license reading](https://github.com/jedisct1/libsodium/blob/master/LICENSE)

```
/*
 * ISC License
 *
 * Copyright (c) 2013-2020
 * Frank Denis &lt;j at pureftpd dot org&gt;
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
```


## DisCatSharp.Common
```
Copyright 2021-2025 AITSYS

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

## DisCatSharp.Common Source
[Original license reading](https://github.com/Emzi0767/Common/blob/master/LICENSE.TXT)

```
Copyright 2020-2021 Emzi0767

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-

Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/


TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

    &quot;License&quot; shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    &quot;Legal Entity&quot; shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    &quot;control&quot; means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    &quot;Source&quot; form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    &quot;Object&quot; form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    &quot;Work&quot; shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    &quot;Contribution&quot; shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, &quot;submitted&quot;
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as &quot;Not a Contribution.&quot;

    &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS
```</file><file path="README.md">[![Build](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/build.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/build.yml) [![Documentation](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/documentation.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/documentation.yml) [![CodeQL](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/codeql-analysis.yml) [![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=shield)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_shield)

[![GitHub last commit](https://img.shields.io/github/last-commit/Aiko-IT-Systems/DisCatSharp?label=Last%20Commit&amp;style=flat-square&amp;logo=github)](https://aitsys.dev/source/DisCatSharp/history/) [![GitHub commit activity](https://img.shields.io/github/commit-activity/w/Aiko-IT-Systems/DisCatSharp?label=Commit%20Activity&amp;style=flat-square&amp;logo=github)](https://github.com/Aiko-IT-Systems/DisCatSharp/commits/main)
[![GitHub pull requests](https://img.shields.io/github/issues-pr/Aiko-IT-Systems/DisCatSharp?label=PRs&amp;style=flat-square&amp;logo=github&amp;logo=gitub)](https://github.com/Aiko-IT-Systems/DisCatSharp/pulls) ![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/Aiko-IT-Systems/DisCatSharp?label=Size&amp;style=flat-square&amp;logo=github)

![Stable](https://img.shields.io/nuget/v/DisCatSharp?color=1F8B4C&amp;label=Stable&amp;style=flat-square&amp;logo=Nuget) ![Nightly](https://img.shields.io/nuget/vpre/DisCatSharp?color=AD1457&amp;label=Nightly&amp;style=flat-square&amp;logo=Nuget)

----

# DisCatSharp
## A Discord App Library written in C# for .NET

----

# News

## New

- Full support for role subscriptions
- Full support for burst reactions
- Full support for subscriptions and entitlements
- New queue system for Lavalink
- Support for join request (create, update &amp; delete) events for clans
- Support for message forwarding
- Support for application emojis

## Breaking

- Small breaking change in `AttachmentFlags`: The flag values are now prefixed with `Is` to be in line with other flag names.
- `AddMention(IMention mention)` =&gt; `WithAllowedMention(IMention allowedMention)`
- `AddMentions(IEnumerable&lt;IMention&gt; mentions)` =&gt; `WithAllowedMentions(IEnumerable&lt;IMention&gt; allowedMentions)`
- Breaking change for `DiscordTextComponent`: `string customId = null, string label = null` was switched to `string label, string customId = null`.
- `Url` fields on DiscordXY objects are now of type `DiscordUri`. You can still use it as `Uri` arg since we added an implicit operator.
- Fixed the naming for create and delete test entitlement methods

----

# About

## Why DisCatSharp?

If you:
- want a library where you get kind and efficient help
- would like to have and use the most recent features of the Discord API
- are ready to build great things

Then this is the right place for you!

## What Happened With The History

We&apos;ve squashed the history of DisCatSharp due to it&apos;s clone size and cluttered history.
The original history can be seen in the releases / tags and at https://github.com/Aiko-IT-Systems/DisCatSharp.Backup (Archived version *before* the squash).

## Installing

You can install the library from the following sources:
- [NuGet](https://www.nuget.org/profiles/DisCatSharp)
- [GitHub](https://github.com/orgs/Aiko-IT-Systems/packages?tab=packages&amp;q=DisCatSharp)

## Documentation

The documentation is available at [docs.dcs.aitsys.dev](https://docs.dcs.aitsys.dev).

Alternative hosts for our docs are:
- Backup Host [backup-docs.dcs.aitsys.dev](https://backup-docs.dcs.aitsys.dev)


## Bugs or Feature requests?

Either join our official support guild at https://discord.gg/RXA6u3jxdU, open an [issue](https://github.com/Aiko-IT-Systems/DisCatSharp/issues/new/choose) or write us an email at [bugs@aitsys.dev](mailto:bugs@aitsys.dev).

&lt;!-- All requests are tracked at [aitsys.dev](https://aitsys.dev/proje&lt;ct/view/1/). We currently don&apos;t do that for reasons --&gt;

## Tutorials / Examples

* [Howto](https://docs.dcs.aitsys.dev/articles/getting_started/bot_account.html)
* [Examples](https://github.com/Aiko-IT-Systems/DisCatSharp.Examples)
* [Template App(:warning:Outdated)](https://github.com/Aiko-IT-Systems/DisCatSharp.TemplateApp)
* [Public Support App for DisCatSharp Server](https://github.com/Aiko-IT-Systems/DisCatSharp.Support)

## Visual Studio Tools
* [DisCatSharp Analyzer Docs](https://docs.dcs.aitsys.dev/vs/index)
* [Snippets for Visual Studio](https://github.com/Aiko-IT-Systems/DisCatSharp.Snippets)

----

## NuGet Packages

### Main

| Package                         | Stable                                                                                                           | Nightly                                                                                                                             |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp                     | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.svg?label=&amp;logo=nuget&amp;style=flat-square)                     | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)                     |
| DisCatSharp.ApplicationCommands | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.ApplicationCommands.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.ApplicationCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |
| DisCatSharp.CommandsNext        | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.CommandsNext.svg?label=&amp;logo=nuget&amp;style=flat-square)        | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.CommandsNext.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)        |
| DisCatSharp.Interactivity       | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Interactivity.svg?label=&amp;logo=nuget&amp;style=flat-square)       | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Interactivity.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)       |

### Voice

| Package                       | Stable                                                                                                         | Nightly                                                                                                                           |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Lavalink          | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Lavalink.svg?label=&amp;logo=nuget&amp;style=flat-square)          | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Lavalink.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)          |
| DisCatSharp.VoiceNext         | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.VoiceNext.svg?label=&amp;logo=nuget&amp;style=flat-square)         | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.VoiceNext.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)         |
| DisCatSharp.VoiceNext.Natives | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.VoiceNext.Natives.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.VoiceNext.Natives.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |

### Hosting

| Package                                 | Stable                                                                                                                   | Nightly                                                                                                                                     |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Configuration               | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Configuration.svg?label=&amp;logo=nuget&amp;style=flat-square)               | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Configuration.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square)               |
| DisCatSharp.Hosting                     | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Hosting.svg?label=&amp;logo=nuget&amp;style=flat-square)                     | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Hosting.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square)                     |
| DisCatSharp.Hosting.DependencyInjection | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Hosting.DependencyInjection.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Hosting.DependencyInjection.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square) |

### Templates

| Package                                                                                         | Stable                                                                                                        | Nightly                                                                                                                          |
| ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| [DisCatSharp.ProjectTemplates](https://github.com/Aiko-IT-Systems/DisCatSharp.ProjectTemplates) | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.ProjectTemplates.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.ProjectTemplates.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square) |

### Development / Commons

| Package                      | Stable                                                                                                        | Nightly                                                                                                                          |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Attributes       | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Attributes.svg?label=&amp;logo=nuget&amp;style=flat-square)       | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Attributes.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)       |
| DisCatSharp.Common           | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Common.svg?label=&amp;logo=nuget&amp;style=flat-square)           | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Common.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)           |
| DisCatSharp.Analyzer.Roselyn | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Analyzer.Roselyn.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Analyzer.Roselyn.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |

### [Extensions](https://github.com/Aiko-IT-Systems/DisCatSharp.Extensions)

| Package                                    | Stable                                                                                                                      | Nightly                                                                                                                                        |
| ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Extensions.TwoFactorCommands   | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.TwoFactorCommands.svg?label=&amp;logo=nuget&amp;style=flat-square)   | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.TwoFactorCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)   |
| DisCatSharp.Extensions.OAuth2Web           | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.OAuth2Web.svg?label=&amp;logo=nuget&amp;style=flat-square)           | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.OAuth2Web.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)           |
| DisCatSharp.Extensions.SimpleMusicCommands | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.SimpleMusicCommands.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.SimpleMusicCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |


----

## Sponsors

- [Dei](https://github.com/DeividasKaza)
- [Will](https://github.com/villChurch)
- [SavageVictor](https://github.com/SavageVictor)
- [Schattenclown](https://github.com/Schattenclown)
- [FabiChan99](https://github.com/FabiChan99)

## Thanks

Big thanks goes to the following people who helped us without being part of the core team ♥️
- [Auros Nexus](https://github.com/Auros)
- [Lunar Starstrum](https://github.com/OoLunar)
- [Geferon](https://github.com/geferon)
- [Alice](https://github.com/QuantuChi)
- [Will](https://github.com/villChurch)
- [InFTord](https://github.com/InFTord)

## Special Thanks

The special thanks goes to Nagisa. Make sure to check out her [Instagram](https://www.instagram.com/nagisaarts_/) ♥️♥️

The second special thanks goes to [Sentry](https://sentry.io) ([GitHub](https://github.com/getsentry/)) for sponsering us a business account on sentry for error tracking.
You guys are the best 💕⭐

## Open Source License Status

[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=large)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_large)</file><file path="RELEASENOTES.md">DisCatSharp Release Notes

	- Full support for role subscriptions
	- Full support for burst reactions
	- Full support for subscriptions and entitlements
	- Support for join request (create, update &amp; delete) events for clans
	- Support for message forwarding
	- Support for application emojis
	- Fix for gateway close code handling

    Breaking

    - Small breaking change in `AttachmentFlags`: The flag values are now prefixed with `Is` to be in line with other flag names.
    - `AddMention(IMention mention)` =&gt; `WithAllowedMention(IMention allowedMention)`
    - `AddMentions(IEnumerable&lt;IMention&gt; mentions)` =&gt; `WithAllowedMentions(IEnumerable&lt;IMention&gt; allowedMentions)`
	- Breaking change for `DiscordTextComponent`: `string customId = null, string label = null` was switched to `string label, string customId = null`.
	- `Url` fields on DiscordXY objects are now of type `DiscordUri`. You can still use it as `Uri` arg since we added an implicit operator.
	- Fixed the naming for create and delete test entitlement methods


DisCatSharp.Attributes Release Notes

    - None


DisCatSharp.ApplicationCommands Release Notes

    - Some optimizations


DisCatSharp.CommandsNext Release Notes

    - None

DisCatSharp.Interactivity Release Notes

    - None

DisCatSharp.Common Release Notes

    - None


DisCatSharp.Lavalink Release Notes

    - New queue system. See https://docs.dcs.aitsys.dev/articles/modules/audio/lavalink_v4/queue
    - Support for LavaLyrics plugin


DisCatSharp.VoiceNext Release Notes

    - Will be deprecated 2025 and replaced by DisCatSharp.Voice


DisCatSharp.Experimental Release Notes

    - GCP Attachments
    - Guild Member Search powered by elasticsearch


DisCatSharp.Configuration Release Notes

    - None


DisCatSharp.Hosting Release Notes

    - None


DisCatSharp.Hosting.DependencyInjection Release Notes

    - None</file></files></repomix>