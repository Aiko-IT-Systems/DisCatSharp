<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where line numbers have been added, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.hintrc
.repomixignore
ARTICLES.md
BUILDING.md
CHANGELOG.md
CONTRIBUTING.md
DisCatSharp.ApplicationCommands/ApplicationCommandsConfiguration.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsExtension.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsModule.cs
DisCatSharp.ApplicationCommands/ApplicationCommandsUtilities.cs
DisCatSharp.ApplicationCommands/Attributes/ApplicationCommandModuleLifespanAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/CheckBaseAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuCooldownAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/DontInjectAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireAnyPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireBotPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireDirectMessageAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireGuildAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireGuildOwnerAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireNsfwAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequirePermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireSkuEntitlementAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamAdmin.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamDeveloper.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamMember.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamOwner.cs
DisCatSharp.ApplicationCommands/Attributes/RequireTeamReadOnly.cs
DisCatSharp.ApplicationCommands/Attributes/RequireUserPermissionsAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/AutocompleteAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChannelTypesAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceNameAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProviderAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IAutocompleteProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IChoiceProvider.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/MinimumMaximumAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/OptionAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandCooldownAttribute.cs
DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandGroupAttribute.cs
DisCatSharp.ApplicationCommands/Checks/ApplicationCommandEqualityChecks.cs
DisCatSharp.ApplicationCommands/Context/ApplicationCommandsTranslationContext.cs
DisCatSharp.ApplicationCommands/Context/AutocompleteContext.cs
DisCatSharp.ApplicationCommands/Context/BaseContext.cs
DisCatSharp.ApplicationCommands/Context/ContextMenuContext.cs
DisCatSharp.ApplicationCommands/Context/InteractionContext.cs
DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj
DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj.DotSettings
DisCatSharp.ApplicationCommands/Entities/ChoiceTranslator.cs
DisCatSharp.ApplicationCommands/Entities/CommandTranslator.cs
DisCatSharp.ApplicationCommands/Entities/FakeApplicationCommandObjects.cs
DisCatSharp.ApplicationCommands/Entities/GroupTranslator.cs
DisCatSharp.ApplicationCommands/Entities/ICooldownResponder.cs
DisCatSharp.ApplicationCommands/Entities/OptionTranslator.cs
DisCatSharp.ApplicationCommands/Entities/RegisteredDiscordApplicationCommand.cs
DisCatSharp.ApplicationCommands/Entities/SubGroupTranslator.cs
DisCatSharp.ApplicationCommands/Enums/ApplicationCommandFinalType.cs
DisCatSharp.ApplicationCommands/Enums/ApplicationCommandModuleLifespan.cs
DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuErrorEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuExecutedEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleReadyEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleStartupFinishedEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/GlobalApplicationCommandsRegisteredEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/Module/GuildApplicationCommandsRegisteredEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandErrorEventArgs.cs
DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandExecutedEventArgs.cs
DisCatSharp.ApplicationCommands/Exceptions/ContextMenu/ContextMenuExecutionChecksFailedException.cs
DisCatSharp.ApplicationCommands/Exceptions/SlashCommand/SlashExecutionChecksFailedException.cs
DisCatSharp.ApplicationCommands/ExtensionMethods.cs
DisCatSharp.ApplicationCommands/GlobalSuppressions.cs
DisCatSharp.ApplicationCommands/Workers/ApplicationCommandWorker.cs
DisCatSharp.ApplicationCommands/Workers/RegistrationWorker.cs
DisCatSharp.Attributes/DeprecatedAttribute.cs
DisCatSharp.Attributes/DisCatSharp.Attributes.csproj
DisCatSharp.Attributes/DisCatSharp.Attributes.csproj.DotSettings
DisCatSharp.Attributes/DiscordDeprecatedAttribute.cs
DisCatSharp.Attributes/DiscordInExperimentAttribute.cs
DisCatSharp.Attributes/DiscordUnreleasedAttribute.cs
DisCatSharp.Attributes/ExperimentalAttribute.cs
DisCatSharp.Attributes/Features.cs
DisCatSharp.Attributes/GlobalSuppressions.cs
DisCatSharp.Attributes/Properties/AssemblyProperties.cs
DisCatSharp.Attributes/RequiresFeatureAttribute.cs
DisCatSharp.Attributes/RequiresOverrideAttribute.cs
DisCatSharp.CommandsNext/Attributes/AliasesAttribute.cs
DisCatSharp.CommandsNext/Attributes/CheckBaseAttribute.cs
DisCatSharp.CommandsNext/Attributes/CommandAttribute.cs
DisCatSharp.CommandsNext/Attributes/CooldownAttribute.cs
DisCatSharp.CommandsNext/Attributes/DescriptionAttribute.cs
DisCatSharp.CommandsNext/Attributes/DontInjectAttribute.cs
DisCatSharp.CommandsNext/Attributes/GroupAttribute.cs
DisCatSharp.CommandsNext/Attributes/HiddenAttribute.cs
DisCatSharp.CommandsNext/Attributes/ModuleLifespanAttribute.cs
DisCatSharp.CommandsNext/Attributes/PriorityAttribute.cs
DisCatSharp.CommandsNext/Attributes/RemainingTextAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireBoostingAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireBotPermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireCertifiedModeratorAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireCommunityAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireDirectMessageAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireGuildAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireGuildOwnerAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireMemberVerificationGateAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireNsfwAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireOwnerAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireOwnerOrIdAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequirePermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequirePrefixesAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireReferencedMessageAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireRolesAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireStaffAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireUserPermissionsAttribute.cs
DisCatSharp.CommandsNext/Attributes/RequireWelcomeScreenAttribute.cs
DisCatSharp.CommandsNext/BaseCommandModule.cs
DisCatSharp.CommandsNext/CommandsNextConfiguration.cs
DisCatSharp.CommandsNext/CommandsNextEvents.cs
DisCatSharp.CommandsNext/CommandsNextExtension.cs
DisCatSharp.CommandsNext/CommandsNextUtilities.cs
DisCatSharp.CommandsNext/Converters/ArgumentBindingResult.cs
DisCatSharp.CommandsNext/Converters/BaseHelpFormatter.cs
DisCatSharp.CommandsNext/Converters/DefaultHelpFormatter.cs
DisCatSharp.CommandsNext/Converters/EntityConverters.cs
DisCatSharp.CommandsNext/Converters/EnumConverter.cs
DisCatSharp.CommandsNext/Converters/HelpFormatterFactory.cs
DisCatSharp.CommandsNext/Converters/IArgumentConverter.cs
DisCatSharp.CommandsNext/Converters/NullableConverter.cs
DisCatSharp.CommandsNext/Converters/NumericConverters.cs
DisCatSharp.CommandsNext/Converters/StringConverter.cs
DisCatSharp.CommandsNext/Converters/TimeConverters.cs
DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj
DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj.DotSettings
DisCatSharp.CommandsNext/Entities/Builders/CommandBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandGroupBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandModuleBuilder.cs
DisCatSharp.CommandsNext/Entities/Builders/CommandOverloadBuilder.cs
DisCatSharp.CommandsNext/Entities/Command.cs
DisCatSharp.CommandsNext/Entities/CommandArgument.cs
DisCatSharp.CommandsNext/Entities/CommandGroup.cs
DisCatSharp.CommandsNext/Entities/CommandHelpMessage.cs
DisCatSharp.CommandsNext/Entities/CommandModule.cs
DisCatSharp.CommandsNext/Entities/CommandOverload.cs
DisCatSharp.CommandsNext/Entities/CommandResult.cs
DisCatSharp.CommandsNext/Entities/ICooldownResponder.cs
DisCatSharp.CommandsNext/EventArgs/CommandContext.cs
DisCatSharp.CommandsNext/EventArgs/CommandErrorEventArgs.cs
DisCatSharp.CommandsNext/EventArgs/CommandEventArgs.cs
DisCatSharp.CommandsNext/EventArgs/CommandExecutionEventArgs.cs
DisCatSharp.CommandsNext/Exceptions/ChecksFailedException.cs
DisCatSharp.CommandsNext/Exceptions/CommandNotFoundException.cs
DisCatSharp.CommandsNext/Exceptions/DuplicateCommandException.cs
DisCatSharp.CommandsNext/Exceptions/DuplicateOverloadException.cs
DisCatSharp.CommandsNext/Exceptions/InvalidOverloadException.cs
DisCatSharp.CommandsNext/ExtensionMethods.cs
DisCatSharp.CommandsNext/GlobalSuppressions.cs
DisCatSharp.Common/DisCatSharp.Common.csproj
DisCatSharp.Common/DisCatSharp.Common.csproj.DotSettings
DisCatSharp.Common/GlobalSuppressions.cs
DisCatSharp.Common/RegularExpressions/CommonRegEx.cs
DisCatSharp.Common/RegularExpressions/DiscordRegEx.cs
DisCatSharp.Common/Serialization/DateTimeFormatAttribute.cs
DisCatSharp.Common/Serialization/DecomposerAttribute.cs
DisCatSharp.Common/Serialization/EnumAttributes.cs
DisCatSharp.Common/Serialization/Int53Attribute.cs
DisCatSharp.Common/Serialization/SerializationAttribute.cs
DisCatSharp.Common/Serialization/TimeSpanAttributes.cs
DisCatSharp.Common/Serialization/TimeSpanFormatAttribute.cs
DisCatSharp.Common/Serialization/UnixTimestampAttributes.cs
DisCatSharp.Common/Types/CharSpanLookupDictionary.cs
DisCatSharp.Common/Types/CharSpanLookupReadOnlyDictionary.cs
DisCatSharp.Common/Types/ContinuousMemoryBuffer.cs
DisCatSharp.Common/Types/IMemoryBuffer.cs
DisCatSharp.Common/Types/LinqMethods.cs
DisCatSharp.Common/Types/MemoryBuffer.cs
DisCatSharp.Common/Types/SecureRandom.cs
DisCatSharp.Common/Types/Serialization/ComplexDecomposer.cs
DisCatSharp.Common/Types/Serialization/IDecomposer.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEvent.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventArgs.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionHandler.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionMode.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventHandler.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventTimeoutException.cs
DisCatSharp.Common/Utilities/AsyncEvent/AsyncManualResetEvent.cs
DisCatSharp.Common/Utilities/AsyncExecutor.cs
DisCatSharp.Common/Utilities/AsyncManualResetEvent.cs
DisCatSharp.Common/Utilities/EnsureObjectStates.cs
DisCatSharp.Common/Utilities/Extensions.cs
DisCatSharp.Common/Utilities/ReflectionUtilities.cs
DisCatSharp.Common/Utilities/RuntimeInformation.cs
DisCatSharp.Common/Utilities/WaveformConverter.cs
DisCatSharp.Common/Utilities/WaveformVisualizer.cs
DisCatSharp.Configuration/ConfigurationExtensions.cs
DisCatSharp.Configuration/DisCatSharp.Configuration.csproj
DisCatSharp.Configuration/GlobalSuppressions.cs
DisCatSharp.Configuration/Models/ConfigSection.cs
DisCatSharp.Docs/404.md
DisCatSharp.Docs/articles/experimental/gcp_attachments.md
DisCatSharp.Docs/articles/experimental/index.md
DisCatSharp.Docs/articles/experimental/search_guild_members.md
DisCatSharp.Docs/articles/faq.md
DisCatSharp.Docs/articles/getting_started/bot_account.md
DisCatSharp.Docs/articles/getting_started/first_bot.md
DisCatSharp.Docs/articles/getting_started/templates.md
DisCatSharp.Docs/articles/getting_started/web_app.md
DisCatSharp.Docs/articles/index.md
DisCatSharp.Docs/articles/misc/hosting.md
DisCatSharp.Docs/articles/misc/nightly_builds.md
DisCatSharp.Docs/articles/misc/reporting_issues.md
DisCatSharp.Docs/articles/misc/sentry.md
DisCatSharp.Docs/articles/misc/voice_activities.md
DisCatSharp.Docs/articles/modules/application_commands/cooldowns.md
DisCatSharp.Docs/articles/modules/application_commands/events.md
DisCatSharp.Docs/articles/modules/application_commands/intro.md
DisCatSharp.Docs/articles/modules/application_commands/modals.md
DisCatSharp.Docs/articles/modules/application_commands/options.md
DisCatSharp.Docs/articles/modules/application_commands/paginated_modals.md
DisCatSharp.Docs/articles/modules/application_commands/translations/reference.md
DisCatSharp.Docs/articles/modules/application_commands/translations/using.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/advanced.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/commands.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/configuration.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/docker.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/intro.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/queue.md
DisCatSharp.Docs/articles/modules/audio/lavalink_v4/setup.md
DisCatSharp.Docs/articles/modules/audio/voicenext/prerequisites.md
DisCatSharp.Docs/articles/modules/audio/voicenext/receive.md
DisCatSharp.Docs/articles/modules/audio/voicenext/transmit.md
DisCatSharp.Docs/articles/modules/commandsnext/command_attributes.md
DisCatSharp.Docs/articles/modules/commandsnext/cooldowns.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/argument_converters.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/command_handler.md
DisCatSharp.Docs/articles/modules/commandsnext/customization/help_formatter.md
DisCatSharp.Docs/articles/modules/commandsnext/dependency_injection.md
DisCatSharp.Docs/articles/modules/commandsnext/intro.md
DisCatSharp.Docs/articles/modules/interactivity/interactivity.md
DisCatSharp.Docs/articles/modules/oauth2/oauth2_client.md
DisCatSharp.Docs/articles/sec_comp/sentry.md
DisCatSharp.Docs/articles/topics/components/buttons.md
DisCatSharp.Docs/articles/topics/components/select_menus.md
DisCatSharp.Docs/articles/topics/events.md
DisCatSharp.Docs/articles/topics/intents.md
DisCatSharp.Docs/articles/topics/logging/default.md
DisCatSharp.Docs/articles/topics/logging/di.md
DisCatSharp.Docs/articles/topics/logging/third_party.md
DisCatSharp.Docs/articles/topics/messagebuilder.md
DisCatSharp.Docs/articles/topics/sharding.md
DisCatSharp.Docs/articles/topics/workarounds.md
DisCatSharp.Docs/changelogs/index.md
DisCatSharp.Docs/changelogs/v10/10_0_0.md
DisCatSharp.Docs/changelogs/v10/10_1_0.md
DisCatSharp.Docs/changelogs/v10/10_2_0.md
DisCatSharp.Docs/changelogs/v10/10_3_0.md
DisCatSharp.Docs/changelogs/v10/10_4_0.md
DisCatSharp.Docs/changelogs/v10/10_6_0.md
DisCatSharp.Docs/changelogs/v10/10_6_2.md
DisCatSharp.Docs/changelogs/v10/10_6_4.md
DisCatSharp.Docs/changelogs/v10/10_6_6.md
DisCatSharp.Docs/changelogs/v10/10_7_0.md
DisCatSharp.Docs/index.md
DisCatSharp.Docs/natives/index.md
DisCatSharp.Docs/snippets/global_name.cs
DisCatSharp.Docs/vs/analyzer/dcs/0001.md
DisCatSharp.Docs/vs/analyzer/dcs/0002.md
DisCatSharp.Docs/vs/analyzer/dcs/0101.md
DisCatSharp.Docs/vs/analyzer/dcs/0102.md
DisCatSharp.Docs/vs/analyzer/dcs/0103.md
DisCatSharp.Docs/vs/analyzer/dcs/0200.md
DisCatSharp.Docs/vs/analyzer/dcs/0201.md
DisCatSharp.Docs/vs/index.md
DisCatSharp.Experimental/AudioHelper.cs
DisCatSharp.Experimental/DisCatSharp.Experimental.csproj
DisCatSharp.Experimental/DisCatSharpExtensions.cs
DisCatSharp.Experimental/DiscordApiClientHook.cs
DisCatSharp.Experimental/Entities/Channel/DiscordChannelMethodHooks.cs
DisCatSharp.Experimental/Entities/Channel/GcpAttachment.cs
DisCatSharp.Experimental/Entities/Channel/GcpAttachmentsResponse.cs
DisCatSharp.Experimental/Entities/Channel/GcpAttachmentUploadInformation.cs
DisCatSharp.Experimental/Entities/Clyde/ClydeProfile.cs
DisCatSharp.Experimental/Entities/Clyde/ClydeSettings.cs
DisCatSharp.Experimental/Entities/DisCatSharpBuilderMethodHooks.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchParams.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchValidator.cs
DisCatSharp.Experimental/Entities/Guild/DiscordGuildMethodsHook.cs
DisCatSharp.Experimental/Entities/Guild/DiscordMemberFilter.cs
DisCatSharp.Experimental/Entities/Guild/DiscordMemberPaginationFilter.cs
DisCatSharp.Experimental/Entities/Guild/DiscordQueries.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSafetySignals.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSearchGuildMembersResponse.cs
DisCatSharp.Experimental/Entities/Guild/DiscordSupplementalGuildMember.cs
DisCatSharp.Experimental/Enums/Guild/JoinSourceType.cs
DisCatSharp.Experimental/Enums/Guild/MemberSortType.cs
DisCatSharp.Experimental/GlobalSuppressions.cs
DisCatSharp.Experimental/Payloads/ClydeSettingsPayloads.cs
DisCatSharp.Experimental/Payloads/RestGcpAttachmentsPayload.cs
DisCatSharp.Hosting.DependencyInjection/DisCatSharp.Hosting.DependencyInjection.csproj
DisCatSharp.Hosting.DependencyInjection/ServiceCollectionExtensions.cs
DisCatSharp.Hosting/BaseHostedService.cs
DisCatSharp.Hosting/ConfigurationExtensions.cs
DisCatSharp.Hosting/Constants.cs
DisCatSharp.Hosting/DisCatSharp.Hosting.csproj
DisCatSharp.Hosting/DiscordHostedService.cs
DisCatSharp.Hosting/DiscordSharedHostedService.cs
DisCatSharp.Hosting/GlobalSuppressions.cs
DisCatSharp.Hosting/IDiscordHostedService.cs
DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj
DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj.DotSettings
DisCatSharp.Interactivity/Entities/ModalPage.cs
DisCatSharp.Interactivity/Entities/Page.cs
DisCatSharp.Interactivity/Entities/PaginatedModalResponse.cs
DisCatSharp.Interactivity/Entities/PaginationEmojis.cs
DisCatSharp.Interactivity/Enums/ButtonPaginationBehavior.cs
DisCatSharp.Interactivity/Enums/InteractionResponseBehavior.cs
DisCatSharp.Interactivity/Enums/PaginationBehaviour.cs
DisCatSharp.Interactivity/Enums/PaginationDeletion.cs
DisCatSharp.Interactivity/Enums/PollBehaviour.cs
DisCatSharp.Interactivity/Enums/SplitType.cs
DisCatSharp.Interactivity/EventHandling/Components/ComponentEventWaiter.cs
DisCatSharp.Interactivity/EventHandling/Components/ComponentPaginator.cs
DisCatSharp.Interactivity/EventHandling/Components/ModalEventWaiter.cs
DisCatSharp.Interactivity/EventHandling/Components/PaginationButtons.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ButtonPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentCollectRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentMatchRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/InteractionPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Components/Requests/ModalMatchRequest.cs
DisCatSharp.Interactivity/EventHandling/EventWaiter.cs
DisCatSharp.Interactivity/EventHandling/IPaginator.cs
DisCatSharp.Interactivity/EventHandling/Paginator.cs
DisCatSharp.Interactivity/EventHandling/Poller.cs
DisCatSharp.Interactivity/EventHandling/ReactionCollector.cs
DisCatSharp.Interactivity/EventHandling/Requests/CollectRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/IPaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/MatchRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/PaginationRequest.cs
DisCatSharp.Interactivity/EventHandling/Requests/PollRequest.cs
DisCatSharp.Interactivity/Extensions/ChannelExtensions.cs
DisCatSharp.Interactivity/Extensions/ClientExtensions.cs
DisCatSharp.Interactivity/Extensions/InteractionExtensions.cs
DisCatSharp.Interactivity/Extensions/MessageExtensions.cs
DisCatSharp.Interactivity/GlobalSuppressions.cs
DisCatSharp.Interactivity/Helpers/InteractivityHelpers.cs
DisCatSharp.Interactivity/InteractivityConfiguration.cs
DisCatSharp.Interactivity/InteractivityEvents.cs
DisCatSharp.Interactivity/InteractivityExtension.cs
DisCatSharp.Interactivity/InteractivityResult.cs
DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj
DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj.DotSettings
DisCatSharp.Lavalink/Entities/DefaultQueueEntry.cs
DisCatSharp.Lavalink/Entities/Filters/IPluginFilter.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkChannelMix.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkDisortion.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkEqualizer.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkFilters.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkKaraoke.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkLowPass.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkRotation.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkTimescale.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkTremolo.cs
DisCatSharp.Lavalink/Entities/Filters/LavalinkVibrato.cs
DisCatSharp.Lavalink/Entities/IQueueEntry.cs
DisCatSharp.Lavalink/Entities/LavalinkException.cs
DisCatSharp.Lavalink/Entities/LavalinkInfo.cs
DisCatSharp.Lavalink/Entities/LavalinkLyricsResult.cs
DisCatSharp.Lavalink/Entities/LavalinkPlayer.cs
DisCatSharp.Lavalink/Entities/LavalinkPlayerState.cs
DisCatSharp.Lavalink/Entities/LavalinkPlaylist.cs
DisCatSharp.Lavalink/Entities/LavalinkPlaylistInfo.cs
DisCatSharp.Lavalink/Entities/LavalinkRestResponse.cs
DisCatSharp.Lavalink/Entities/LavalinkSessionConfiguration.cs
DisCatSharp.Lavalink/Entities/LavalinkStats.cs
DisCatSharp.Lavalink/Entities/LavalinkTrack.cs
DisCatSharp.Lavalink/Entities/LavalinkTrackLoadingResult.cs
DisCatSharp.Lavalink/Entities/LavalinkVoiceState.cs
DisCatSharp.Lavalink/Entities/LyricsLine.cs
DisCatSharp.Lavalink/Entities/Websocket/EventOP.cs
DisCatSharp.Lavalink/Entities/Websocket/LavalinkOp.cs
DisCatSharp.Lavalink/Entities/Websocket/PlayerUpdateOp.cs
DisCatSharp.Lavalink/Entities/Websocket/ReadyOp.cs
DisCatSharp.Lavalink/Entities/Websocket/StatsOp.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackEndEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackException.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackExceptionEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackStartEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/TrackStuckEvent.cs
DisCatSharp.Lavalink/Entities/Websocket/WebSocketClosedEvent.cs
DisCatSharp.Lavalink/Enums/Filters/LavalinkFilterBand.cs
DisCatSharp.Lavalink/Enums/LavalinkEvents.cs
DisCatSharp.Lavalink/Enums/LavalinkLoadResultType.cs
DisCatSharp.Lavalink/Enums/LavalinkRestEndpoints.cs
DisCatSharp.Lavalink/Enums/LavalinkSearchType.cs
DisCatSharp.Lavalink/Enums/LavalinkTrackEndReason.cs
DisCatSharp.Lavalink/Enums/RepeatMode.cs
DisCatSharp.Lavalink/Enums/Severity.cs
DisCatSharp.Lavalink/Enums/Websocket/EventOpType.cs
DisCatSharp.Lavalink/Enums/Websocket/OpType.cs
DisCatSharp.Lavalink/EventArgs/GuildPlayerDestroyedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkPlayerStateUpdateEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkSessionConnectedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkSessionDisconnectedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkStatsReceivedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackEndedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackExceptionEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackStartedEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkTrackStuckEventArgs.cs
DisCatSharp.Lavalink/EventArgs/LavalinkWebsocketClosedEventArgs.cs
DisCatSharp.Lavalink/Exceptions/LavalinkRestException.cs
DisCatSharp.Lavalink/ExtensionMethods.cs
DisCatSharp.Lavalink/GlobalSuppressions.cs
DisCatSharp.Lavalink/LavalinkConfiguration.cs
DisCatSharp.Lavalink/LavalinkExtension.cs
DisCatSharp.Lavalink/LavalinkGuildPlayer.cs
DisCatSharp.Lavalink/LavalinkJson.cs
DisCatSharp.Lavalink/LavalinkQueue.cs
DisCatSharp.Lavalink/LavalinkRestClient.cs
DisCatSharp.Lavalink/LavalinkSession.cs
DisCatSharp.Lavalink/Models/LavalinkPlayerUpdateModel.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerCreatePayload.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerUpdatePayload.cs
DisCatSharp.Lavalink/Payloads/LavalinkRestVoiceStateUpdatePayload.cs
DisCatSharp.Logos/browserconfig.xml
DisCatSharp.slnx
DisCatSharp.Targets/DisCatSharp.targets
DisCatSharp.Targets/InternalsVisibleTo.targets
DisCatSharp.Targets/Library.targets
DisCatSharp.Targets/NuGet.targets
DisCatSharp.Targets/Package.targets
DisCatSharp.Targets/TestProject.targets
DisCatSharp.Targets/Version.targets
DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/DisCatSharp.Analyzer.Tests.csproj
DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/Program.cs
DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/Tests/Dcs0201.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/AppCommandSplitPartialTests.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/DisCatSharp.ApplicationCommands.Tests.csproj
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part0.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part1.cs
DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part2.cs
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/ConfigurationExtensionTests.cs
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/DisCatSharp.Configuration.Tests.csproj
DisCatSharp.Tests/DisCatSharp.Configuration.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.CopilotTests/DisCatSharp.CopilotTests.csproj
DisCatSharp.Tests/DisCatSharp.CopilotTests/NullValueHandlingTests.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/BasicEventHandlerTests.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/DisCatSharp.EventHandlers.Tests.csproj
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/EventsEnumIntegrityTests.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/ServiceProviderTests.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/DisCatSharp.Hosting.Tests.csproj
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/ExtensionTests.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/GlobalSuppressions.cs
DisCatSharp.Tests/DisCatSharp.Hosting.Tests/HostTests.cs
DisCatSharp.Tests/DisCatSharp.SafetyTests/DisCatSharp.SafetyTests.csproj
DisCatSharp.Tests/DisCatSharp.SafetyTests/HttpTest.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/CodeFixResources.Designer.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/CodeFixResources.resx
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/DisCatSharp.Analyzer.CodeFixes.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/DisCatSharpRequiresOverrideCodeFix.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Vsix/DisCatSharp.Analyzer.Vsix.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Vsix/source.extension.vsixmanifest
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharpAnalyzer.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.Designer.cs
DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.resx
DisCatSharp.Tools/DisCatSharp.Tools.slnx
DisCatSharp.VoiceNext/AudioFormat.cs
DisCatSharp.VoiceNext/Codec/Helpers.cs
DisCatSharp.VoiceNext/Codec/Interop.cs
DisCatSharp.VoiceNext/Codec/Opus.cs
DisCatSharp.VoiceNext/Codec/Rtp.cs
DisCatSharp.VoiceNext/Codec/Sodium.cs
DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj
DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj.DotSettings
DisCatSharp.VoiceNext/Entities/AudioSender.cs
DisCatSharp.VoiceNext/Entities/VoiceDispatch.cs
DisCatSharp.VoiceNext/Entities/VoiceIdentifyPayload.cs
DisCatSharp.VoiceNext/Entities/VoicePacket.cs
DisCatSharp.VoiceNext/Entities/VoiceReadyPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayloadData.cs
DisCatSharp.VoiceNext/Entities/VoiceServerUpdatePayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSessionDescriptionPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceSpeakingPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceStateUpdatePayload.cs
DisCatSharp.VoiceNext/Entities/VoiceUserJoinPayload.cs
DisCatSharp.VoiceNext/Entities/VoiceUserLeavePayload.cs
DisCatSharp.VoiceNext/EventArgs/VoiceReceiveEventArgs.cs
DisCatSharp.VoiceNext/EventArgs/VoiceUserJoinEventArgs.cs
DisCatSharp.VoiceNext/EventArgs/VoiceUserLeaveEventArgs.cs
DisCatSharp.VoiceNext/ExtensionMethods.cs
DisCatSharp.VoiceNext/GlobalSuppressions.cs
DisCatSharp.VoiceNext/Interop/Bindings.cs
DisCatSharp.VoiceNext/Interop/OpusControl.cs
DisCatSharp.VoiceNext/Interop/OpusError.cs
DisCatSharp.VoiceNext/Interop/OpusPacketMetrics.cs
DisCatSharp.VoiceNext/Interop/OpusSignal.cs
DisCatSharp.VoiceNext/IVoiceFilter.cs
DisCatSharp.VoiceNext/RawVoicePacket.cs
DisCatSharp.VoiceNext/StreamExtensions.cs
DisCatSharp.VoiceNext/VoiceApplication.cs
DisCatSharp.VoiceNext/VoiceNextConfiguration.cs
DisCatSharp.VoiceNext/VoiceNextConnection.cs
DisCatSharp.VoiceNext/VoiceNextEvents.cs
DisCatSharp.VoiceNext/VoiceNextExtension.cs
DisCatSharp.VoiceNext/VoiceTransmitSink.cs
DisCatSharp/BaseExtension.cs
DisCatSharp/Clients/BaseDiscordClient.cs
DisCatSharp/Clients/DiscordClient.cs
DisCatSharp/Clients/DiscordClient.Dispatch.cs
DisCatSharp/Clients/DiscordClient.EventHandlers.cs
DisCatSharp/Clients/DiscordClient.Events.cs
DisCatSharp/Clients/DiscordClient.WebSocket.cs
DisCatSharp/Clients/DiscordOAuth2Client.cs
DisCatSharp/Clients/DiscordShardedClient.cs
DisCatSharp/Clients/DiscordShardedClient.Events.cs
DisCatSharp/Clients/DiscordWebhookClient.cs
DisCatSharp/DisCatSharp.csproj
DisCatSharp/DisCatSharp.csproj.DotSettings
DisCatSharp/DiscordConfiguration.cs
DisCatSharp/Entities/Application/DiscordApplication.cs
DisCatSharp/Entities/Application/DiscordApplicationCommand.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandAutocompleteChoice.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandLocalization.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandOption.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandOptionChoice.cs
DisCatSharp/Entities/Application/DiscordApplicationCommandPermission.cs
DisCatSharp/Entities/Application/DiscordApplicationEmoji.cs
DisCatSharp/Entities/Application/DiscordApplicationInstallParams.cs
DisCatSharp/Entities/Application/DiscordApplicationIntegrationTypeConfiguration.cs
DisCatSharp/Entities/Application/DiscordApplicationRoleConnectionMetadata.cs
DisCatSharp/Entities/Application/DiscordGuildApplicationCommandPermission.cs
DisCatSharp/Entities/Application/DiscordIntegrationTypesConfig.cs
DisCatSharp/Entities/Application/DiscordOAuth2InstallParams.cs
DisCatSharp/Entities/Application/DiscordRpcApplication.cs
DisCatSharp/Entities/Channel/ChannelTypeExtensions.cs
DisCatSharp/Entities/Channel/DiscordChannel.cs
DisCatSharp/Entities/Channel/DiscordChannelMention.cs
DisCatSharp/Entities/Channel/DiscordDmChannel.cs
DisCatSharp/Entities/Channel/DiscordFollowedChannel.cs
DisCatSharp/Entities/Channel/DiscordGuildDirectoryChannel.cs
DisCatSharp/Entities/Channel/DiscordGuildDirectoryEntry.cs
DisCatSharp/Entities/Channel/Overwrite/DiscordOverwrite.cs
DisCatSharp/Entities/Channel/Overwrite/DiscordOverwriteBuilder.cs
DisCatSharp/Entities/Color/DiscordColor.Colors.cs
DisCatSharp/Entities/Color/DiscordColor.cs
DisCatSharp/Entities/Core/CooldownBucket.cs
DisCatSharp/Entities/Core/DisCatSharpBuilder.cs
DisCatSharp/Entities/Core/DisCatSharpCommandContext.cs
DisCatSharp/Entities/Core/IBucket.cs
DisCatSharp/Entities/Core/ICooldown.cs
DisCatSharp/Entities/DiscordLocales.cs
DisCatSharp/Entities/DiscordProtocol.cs
DisCatSharp/Entities/DiscordSignedLink.cs
DisCatSharp/Entities/DiscordUri.cs
DisCatSharp/Entities/Embed/DiscordEmbed.cs
DisCatSharp/Entities/Embed/DiscordEmbedAuthor.cs
DisCatSharp/Entities/Embed/DiscordEmbedBuilder.cs
DisCatSharp/Entities/Embed/DiscordEmbedField.cs
DisCatSharp/Entities/Embed/DiscordEmbedFooter.cs
DisCatSharp/Entities/Embed/DiscordEmbedImage.cs
DisCatSharp/Entities/Embed/DiscordEmbedProvider.cs
DisCatSharp/Entities/Embed/DiscordEmbedThumbnail.cs
DisCatSharp/Entities/Embed/DiscordEmbedVideo.cs
DisCatSharp/Entities/Emoji/DiscordEmoji.cs
DisCatSharp/Entities/Emoji/DiscordEmoji.Mapping.cs
DisCatSharp/Entities/Emoji/DiscordUnicodeEmoji.cs
DisCatSharp/Entities/Emoji/PartialEmoji.cs
DisCatSharp/Entities/Guild/Automod/AutomodAction.cs
DisCatSharp/Entities/Guild/Automod/AutomodActionMetadata.cs
DisCatSharp/Entities/Guild/Automod/AutomodRule.cs
DisCatSharp/Entities/Guild/Automod/AutomodTriggerMetadata.cs
DisCatSharp/Entities/Guild/DiscordAuditLogObjects.cs
DisCatSharp/Entities/Guild/DiscordBan.cs
DisCatSharp/Entities/Guild/DiscordBulkBanResponse.cs
DisCatSharp/Entities/Guild/DiscordGameActivity.cs
DisCatSharp/Entities/Guild/DiscordGuild.AuditLog.cs
DisCatSharp/Entities/Guild/DiscordGuild.cs
DisCatSharp/Entities/Guild/DiscordGuild.Features.cs
DisCatSharp/Entities/Guild/DiscordGuildEmoji.cs
DisCatSharp/Entities/Guild/DiscordGuildInventorySettings.cs
DisCatSharp/Entities/Guild/DiscordGuildJoinRequest.cs
DisCatSharp/Entities/Guild/DiscordGuildJoinRequestSearchResult.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreening.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningField.cs
DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningFieldResponse.cs
DisCatSharp/Entities/Guild/DiscordGuildPreview.cs
DisCatSharp/Entities/Guild/DiscordGuildProfile.cs
DisCatSharp/Entities/Guild/DiscordGuildTemplate.cs
DisCatSharp/Entities/Guild/DiscordGuildTrait.cs
DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreen.cs
DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreenChannel.cs
DisCatSharp/Entities/Guild/DiscordMember.cs
DisCatSharp/Entities/Guild/DiscordRole.cs
DisCatSharp/Entities/Guild/DiscordRoleTags.cs
DisCatSharp/Entities/Guild/IncidentsData.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboarding.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPrompt.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPromptOption.cs
DisCatSharp/Entities/Guild/Onboarding/DiscordServerGuide.cs
DisCatSharp/Entities/Guild/Onboarding/NewMemberAction.cs
DisCatSharp/Entities/Guild/Onboarding/ResourceChannel.cs
DisCatSharp/Entities/Guild/Onboarding/WelcomeMessage.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordRecurrenceRuleNWeekday.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEvent.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventEntityMetadata.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRule.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRuleValidator.cs
DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventUser.cs
DisCatSharp/Entities/Guild/Stage/DiscordStageInstance.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannel.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMember.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMetadata.cs
DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadResult.cs
DisCatSharp/Entities/Guild/ThreadAndForum/ForumPostTag.cs
DisCatSharp/Entities/Guild/ThreadAndForum/ForumReactionEmoji.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidget.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidgetMember.cs
DisCatSharp/Entities/Guild/Widget/DiscordWidgetSettings.cs
DisCatSharp/Entities/Integration/DiscordIntegration.cs
DisCatSharp/Entities/Integration/DiscordIntegrationAccount.cs
DisCatSharp/Entities/Interaction/AuthorizingIntegrationOwners.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordLinkButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/Button/DiscordPremiumButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordComponent.cs
DisCatSharp/Entities/Interaction/Components/DiscordComponentEmoji.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordBaseSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordChannelSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordMentionableSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordRoleSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordSelectDefaultValue.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponentOption.cs
DisCatSharp/Entities/Interaction/Components/Select/DiscordUserSelectComponent.cs
DisCatSharp/Entities/Interaction/Components/Text/DiscordTextInputComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordBaseButtonComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordContainerComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordFileDisplayComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordLabelComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryItem.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionAccessory.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSeparatorComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordTextDisplayComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordThumbnailComponent.cs
DisCatSharp/Entities/Interaction/Components/V2Components/DiscordUnfurledMediaItem.cs
DisCatSharp/Entities/Interaction/Components/V2Components/ILabelComponent.cs
DisCatSharp/Entities/Interaction/DiscordActivityInstance.cs
DisCatSharp/Entities/Interaction/DiscordFollowupMessageBuilder.cs
DisCatSharp/Entities/Interaction/DiscordInteraction.cs
DisCatSharp/Entities/Interaction/DiscordInteractionApplicationCommandCallbackData.cs
DisCatSharp/Entities/Interaction/DiscordInteractionCallback.cs
DisCatSharp/Entities/Interaction/DiscordInteractionCallbackResponse.cs
DisCatSharp/Entities/Interaction/DiscordInteractionData.cs
DisCatSharp/Entities/Interaction/DiscordInteractionDataOption.cs
DisCatSharp/Entities/Interaction/DiscordInteractionMetadata.cs
DisCatSharp/Entities/Interaction/DiscordInteractionModalBuilder.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResolvedCollection.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResource.cs
DisCatSharp/Entities/Interaction/DiscordInteractionResponseBuilder.cs
DisCatSharp/Entities/Invite/DiscordInvite.cs
DisCatSharp/Entities/Invite/DiscordInviteChannel.cs
DisCatSharp/Entities/Invite/DiscordInviteGuild.cs
DisCatSharp/Entities/Message/DiscordAttachment.cs
DisCatSharp/Entities/Message/DiscordForwardedMessage.cs
DisCatSharp/Entities/Message/DiscordMentions.cs
DisCatSharp/Entities/Message/DiscordMessage.cs
DisCatSharp/Entities/Message/DiscordMessageActivity.cs
DisCatSharp/Entities/Message/DiscordMessageApplication.cs
DisCatSharp/Entities/Message/DiscordMessageBuilder.cs
DisCatSharp/Entities/Message/DiscordMessageFile.cs
DisCatSharp/Entities/Message/DiscordMessageInteraction.cs
DisCatSharp/Entities/Message/DiscordMessageReference.cs
DisCatSharp/Entities/Message/DiscordMessageSnapshots.cs
DisCatSharp/Entities/Message/DiscordReaction.cs
DisCatSharp/Entities/Message/DiscordUnfurledMedia.cs
DisCatSharp/Entities/Message/Mentions.cs
DisCatSharp/Entities/Message/Polls/DiscordPoll.cs
DisCatSharp/Entities/Message/Polls/DiscordPollAnswer.cs
DisCatSharp/Entities/Message/Polls/DiscordPollAnswerCount.cs
DisCatSharp/Entities/Message/Polls/DiscordPollBuilder.cs
DisCatSharp/Entities/Message/Polls/DiscordPollMedia.cs
DisCatSharp/Entities/Message/Polls/DiscordPollRequest.cs
DisCatSharp/Entities/Message/Polls/DiscordPollResult.cs
DisCatSharp/Entities/NullableSnowflakeObject.cs
DisCatSharp/Entities/OAuth2/DiscordAccessToken.cs
DisCatSharp/Entities/OAuth2/DiscordApplicationRoleConnection.cs
DisCatSharp/Entities/OAuth2/DiscordAuthorizationInformation.cs
DisCatSharp/Entities/ObservableApiObject.cs
DisCatSharp/Entities/Optional.cs
DisCatSharp/Entities/SnowflakeObject.cs
DisCatSharp/Entities/Sticker/DiscordSticker.cs
DisCatSharp/Entities/Sticker/DiscordStickerPack.cs
DisCatSharp/Entities/Store/DiscordEntitlement.cs
DisCatSharp/Entities/Store/DiscordSku.cs
DisCatSharp/Entities/Store/DiscordStoreSku.cs
DisCatSharp/Entities/Store/DiscordSubscription.cs
DisCatSharp/Entities/User/AvatarDecorationData.cs
DisCatSharp/Entities/User/DiscordActivity.cs
DisCatSharp/Entities/User/DiscordCollectibles.cs
DisCatSharp/Entities/User/DiscordConnection.cs
DisCatSharp/Entities/User/DiscordNameplate.cs
DisCatSharp/Entities/User/DiscordPresence.cs
DisCatSharp/Entities/User/DiscordPrimaryGuild.cs
DisCatSharp/Entities/User/DiscordTeam.cs
DisCatSharp/Entities/User/DiscordUser.cs
DisCatSharp/Entities/User/DisplayNameStyles.cs
DisCatSharp/Entities/Voice/DiscordSoundboardSound.cs
DisCatSharp/Entities/Voice/DiscordVoiceRegion.cs
DisCatSharp/Entities/Voice/DiscordVoiceState.cs
DisCatSharp/Entities/Webhook/DiscordWebhook.cs
DisCatSharp/Entities/Webhook/DiscordWebhookBuilder.cs
DisCatSharp/Enums/Application/ApplicationCommandHandlerType.cs
DisCatSharp/Enums/Application/ApplicationCommandIntegrationTypes.cs
DisCatSharp/Enums/Application/ApplicationCommandOptionType.cs
DisCatSharp/Enums/Application/ApplicationCommandPermissionType.cs
DisCatSharp/Enums/Application/ApplicationCommandType.cs
DisCatSharp/Enums/Application/ApplicationDiscoverabilityState.cs
DisCatSharp/Enums/Application/ApplicationDiscoveryEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationExplicitContentFilter.cs
DisCatSharp/Enums/Application/ApplicationFlags.cs
DisCatSharp/Enums/Application/ApplicationInteractionsVersion.cs
DisCatSharp/Enums/Application/ApplicationMonetizationEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationMonetizationState.cs
DisCatSharp/Enums/Application/ApplicationRoleConnectionMetadataType.cs
DisCatSharp/Enums/Application/ApplicationVerificationEligibilityFlags.cs
DisCatSharp/Enums/Application/ApplicationVerificationState.cs
DisCatSharp/Enums/Application/RpcApplicationState.cs
DisCatSharp/Enums/Application/StoreApplicationState.cs
DisCatSharp/Enums/Channel/ChannelFlags.cs
DisCatSharp/Enums/Channel/ChannelType.cs
DisCatSharp/Enums/Channel/DirectoryCategory.cs
DisCatSharp/Enums/Channel/OverwriteType.cs
DisCatSharp/Enums/Channel/TagMatching.cs
DisCatSharp/Enums/Channel/VideoQualityMode.cs
DisCatSharp/Enums/Core/CooldownBucketType.cs
DisCatSharp/Enums/Core/DisCatSharpCommandType.cs
DisCatSharp/Enums/Core/DisCatSharpStatisticType.cs
DisCatSharp/Enums/Core/ModifyMode.cs
DisCatSharp/Enums/Discord/ApiChannel.cs
DisCatSharp/Enums/Discord/DiscordDomain.cs
DisCatSharp/Enums/Discord/DiscordEvent.cs
DisCatSharp/Enums/Discord/DiscordIntents.cs
DisCatSharp/Enums/Discord/DiscordShortlink.cs
DisCatSharp/Enums/Discord/GatewayCompressionLevel.cs
DisCatSharp/Enums/Discord/OAuth.cs
DisCatSharp/Enums/Discord/TokenType.cs
DisCatSharp/Enums/Guild/AuditLogActionCategory.cs
DisCatSharp/Enums/Guild/AuditLogActionType.cs
DisCatSharp/Enums/Guild/Automod/AutomodActionType.cs
DisCatSharp/Enums/Guild/Automod/AutomodEventType.cs
DisCatSharp/Enums/Guild/Automod/AutomodKeywordPresetType.cs
DisCatSharp/Enums/Guild/Automod/AutomodTriggerType.cs
DisCatSharp/Enums/Guild/BadgeType.cs
DisCatSharp/Enums/Guild/BannerType.cs
DisCatSharp/Enums/Guild/DefaultMessageNotifications.cs
DisCatSharp/Enums/Guild/ExplicitContentFilter.cs
DisCatSharp/Enums/Guild/GuildProfileVisibility.cs
DisCatSharp/Enums/Guild/HubType.cs
DisCatSharp/Enums/Guild/JoinRequestStatusType.cs
DisCatSharp/Enums/Guild/MemberFlags.cs
DisCatSharp/Enums/Guild/MembershipScreeningFieldType.cs
DisCatSharp/Enums/Guild/MfaLevel.cs
DisCatSharp/Enums/Guild/NsfwLevel.cs
DisCatSharp/Enums/Guild/Onboarding/NewMemberActionType.cs
DisCatSharp/Enums/Guild/Onboarding/OnboardingMode.cs
DisCatSharp/Enums/Guild/Onboarding/PromptType.cs
DisCatSharp/Enums/Guild/Permission.cs
DisCatSharp/Enums/Guild/PlayStyle.cs
DisCatSharp/Enums/Guild/PremiumTier.cs
DisCatSharp/Enums/Guild/PriceTierType.cs
DisCatSharp/Enums/Guild/RoleFlags.cs
DisCatSharp/Enums/Guild/RoleType.cs
DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleFrequency.cs
DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleWeekday.cs
DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventEntityType.cs
DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventStatus.cs
DisCatSharp/Enums/Guild/SystemChannelFlags.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ForumLayout.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ForumPostSortOrder.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ThreadAutoArchiveDuration.cs
DisCatSharp/Enums/Guild/ThreadAndForum/ThreadMemberFlags.cs
DisCatSharp/Enums/Guild/VerificationLevel.cs
DisCatSharp/Enums/Guild/WidgetType.cs
DisCatSharp/Enums/Integration/IntegrationExpireBehavior.cs
DisCatSharp/Enums/Interaction/ButtonStyle.cs
DisCatSharp/Enums/Interaction/ComponentType.cs
DisCatSharp/Enums/Interaction/IFrameModalSize.cs
DisCatSharp/Enums/Interaction/InteractionCallbackEphemerality.cs
DisCatSharp/Enums/Interaction/InteractionContextType.cs
DisCatSharp/Enums/Interaction/InteractionResponseType.cs
DisCatSharp/Enums/Interaction/InteractionType.cs
DisCatSharp/Enums/Interaction/SeparatorSpacingSize.cs
DisCatSharp/Enums/Interaction/TextComponentStyle.cs
DisCatSharp/Enums/Invite/InviteFlags.cs
DisCatSharp/Enums/Invite/InviteType.cs
DisCatSharp/Enums/Invite/TargetType.cs
DisCatSharp/Enums/Message/AttachmentFlags.cs
DisCatSharp/Enums/Message/DiscordMediaType.cs
DisCatSharp/Enums/Message/EmbedFlags.cs
DisCatSharp/Enums/Message/LoadingState.cs
DisCatSharp/Enums/Message/MediaType.cs
DisCatSharp/Enums/Message/MentionType.cs
DisCatSharp/Enums/Message/MessageActivityType.cs
DisCatSharp/Enums/Message/MessageFlags.cs
DisCatSharp/Enums/Message/MessageType.cs
DisCatSharp/Enums/Message/PollLayoutType.cs
DisCatSharp/Enums/Message/ReferenceType.cs
DisCatSharp/Enums/Message/TimestampFormat.cs
DisCatSharp/Enums/Message/UnfurledMediaFlags.cs
DisCatSharp/Enums/Store/EntitlementOwnerType.cs
DisCatSharp/Enums/Store/EntitlementType.cs
DisCatSharp/Enums/Store/ProductLine.cs
DisCatSharp/Enums/Store/SkuAccessType.cs
DisCatSharp/Enums/Store/SkuFlags.cs
DisCatSharp/Enums/Store/SkuType.cs
DisCatSharp/Enums/Store/SubscriptionStatus.cs
DisCatSharp/Enums/User/ConnectionMetadataVisibilityType.cs
DisCatSharp/Enums/User/ConnectionVisibilityType.cs
DisCatSharp/Enums/User/DisplayNameEffect.cs
DisCatSharp/Enums/User/DisplayNameFont.cs
DisCatSharp/Enums/User/PremiumType.cs
DisCatSharp/Enums/User/UserFlags.cs
DisCatSharp/Enums/VersionCheckMode.cs
DisCatSharp/Enums/Voice/AnimationType.cs
DisCatSharp/Enums/Voice/SpeakingFlags.cs
DisCatSharp/EventArgs/Application/ApplicationCommandEventArgs.cs
DisCatSharp/EventArgs/Application/ApplicationCommandPermissionsUpdateEventArgs.cs
DisCatSharp/EventArgs/Application/GuildApplicationCommandCountEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelCreateEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelDeleteEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelPinsUpdateEventArgs.cs
DisCatSharp/EventArgs/Channel/ChannelUpdateEventArgs.cs
DisCatSharp/EventArgs/Channel/DMChannelDeleteEventArgs.cs
DisCatSharp/EventArgs/Channel/VoiceChannelStatusUpdateEventArgs.cs
DisCatSharp/EventArgs/ClientErrorEventArgs.cs
DisCatSharp/EventArgs/DiscordEventArgs.cs
DisCatSharp/EventArgs/EmbeddedActivityUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodActionExecutedEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodCreateRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodDeleteRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Automod/AutomodUpdateRuleEventArgs.cs
DisCatSharp/EventArgs/Guild/Ban/GuildBanAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Ban/GuildBanRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildAuditLogEntryCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildDownloadCompletedEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildEmojisUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildIntegrationsUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildStickersUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/GuildUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMembersChunkEventArgs.cs
DisCatSharp/EventArgs/Guild/Member/GuildMemberUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Role/GuildRoleUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserAddEventArgs.cs
DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundsUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Sounboard/SoundboardSoundsEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadCreateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadDeleteEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadListSyncEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadMembersUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadMemberUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Thread/ThreadUpdateEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutAddEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutRemoveEventArgs.cs
DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutUpdateEventArgs.cs
DisCatSharp/EventArgs/HeartBeatEventArgs.cs
DisCatSharp/EventArgs/Interaction/ComponentInteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Interaction/ContextMenuInteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Interaction/InteractionCreateEventArgs.cs
DisCatSharp/EventArgs/Invite/InviteCreateEventArgs.cs
DisCatSharp/EventArgs/Invite/InviteDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageAcknowledgeEventArgs.cs
DisCatSharp/EventArgs/Message/MessageBulkDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageCreateEventArgs.cs
DisCatSharp/EventArgs/Message/MessageDeleteEventArgs.cs
DisCatSharp/EventArgs/Message/MessageUpdateEventArgs.cs
DisCatSharp/EventArgs/Message/Polls/MessagePollVoteAddEventArgs.cs
DisCatSharp/EventArgs/Message/Polls/MessagePollVoteRemoveEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionAddEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEmojiEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEventArgs.cs
DisCatSharp/EventArgs/Message/Reaction/MessageReactionsClearEventArgs.cs
DisCatSharp/EventArgs/PayloadReceivedEventArgs.cs
DisCatSharp/EventArgs/RateLimitExceptionEventArgs.cs
DisCatSharp/EventArgs/ReadyEventArgs.cs
DisCatSharp/EventArgs/Socket/SocketDisconnectEventArgs.cs
DisCatSharp/EventArgs/Socket/SocketEventArgs.cs
DisCatSharp/EventArgs/Socket/WebSocketMessageEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceCreateEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceDeleteEventArgs.cs
DisCatSharp/EventArgs/Stage/StageInstanceUpdateEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementCreateEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementDeleteEventArgs.cs
DisCatSharp/EventArgs/Store/EntitlementUpdateEventArgs.cs
DisCatSharp/EventArgs/Store/SubscriptionCreateEventArgs.cs
DisCatSharp/EventArgs/Store/SubscriptionUpdateEventArgs.cs
DisCatSharp/EventArgs/TypingStartEventArgs.cs
DisCatSharp/EventArgs/UnknownEventArgs.cs
DisCatSharp/EventArgs/User/PresenceUpdateEventArgs.cs
DisCatSharp/EventArgs/User/UserSettingsUpdateEventArgs.cs
DisCatSharp/EventArgs/User/UserSpeakingEventArgs.cs
DisCatSharp/EventArgs/User/UserUpdateEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceChannelEffectSendEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceServerUpdateEventArgs.cs
DisCatSharp/EventArgs/Voice/VoiceStateUpdateEventArgs.cs
DisCatSharp/EventArgs/WebhooksUpdateEventArgs.cs
DisCatSharp/EventArgs/ZombiedEventArgs.cs
DisCatSharp/Exceptions/BadRequestException.cs
DisCatSharp/Exceptions/DisCatSharpException.cs
DisCatSharp/Exceptions/DisCatSharpUserException.cs
DisCatSharp/Exceptions/DiscordJsonException.cs
DisCatSharp/Exceptions/ExceptionFilter.cs
DisCatSharp/Exceptions/NotFoundException.cs
DisCatSharp/Exceptions/NotIndexedException.cs
DisCatSharp/Exceptions/RateLimitException.cs
DisCatSharp/Exceptions/RequestSizeException.cs
DisCatSharp/Exceptions/ServerErrorException.cs
DisCatSharp/Exceptions/UnauthorizedException.cs
DisCatSharp/Exceptions/ValidationException.cs
DisCatSharp/Formatter.cs
DisCatSharp/GlobalSuppressions.cs
DisCatSharp/Internals.cs
DisCatSharp/Logging/CompositeDefaultLogger.cs
DisCatSharp/Logging/DefaultLogger.cs
DisCatSharp/Logging/DefaultLoggerFactory.cs
DisCatSharp/Logging/DefaultLoggerProvider.cs
DisCatSharp/Logging/LoggerEvents.cs
DisCatSharp/Logging/ShardedLoggerFactory.cs
DisCatSharp/MediaTool.cs
DisCatSharp/Net/Abstractions/AuditLogAbstractions.cs
DisCatSharp/Net/Abstractions/ClientProperties.cs
DisCatSharp/Net/Abstractions/FollowedChannelAddPayload.cs
DisCatSharp/Net/Abstractions/Gateway/DiscordDispatchPayload.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayHello.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayIdentifyResume.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayInfo.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayOpCode.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayPayload.cs
DisCatSharp/Net/Abstractions/Gateway/GatewayRequestGuildMembers.cs
DisCatSharp/Net/Abstractions/Gateway/SoundboardSoundsPayloads.cs
DisCatSharp/Net/Abstractions/Gateway/VoiceStateUpdatePayload.cs
DisCatSharp/Net/Abstractions/IOAuth2Payload.cs
DisCatSharp/Net/Abstractions/ReadyPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestApplicationCommandPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestApplicationPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestAutomodRuleModifyPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestChannelPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestForumPostTagPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildScheduledEventPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestGuildSoundboardSoundPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestOAuth2ApplicationRoleConnectionPayload.cs
DisCatSharp/Net/Abstractions/Rest/RestStageInstancePayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestStickerPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestStorePayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestUserPayloads.cs
DisCatSharp/Net/Abstractions/Rest/RestWebhookPayloads.cs
DisCatSharp/Net/Abstractions/ShardInfo.cs
DisCatSharp/Net/Abstractions/StatusUpdate.cs
DisCatSharp/Net/Abstractions/Transport/TransportActivity.cs
DisCatSharp/Net/Abstractions/Transport/TransportApplication.cs
DisCatSharp/Net/Abstractions/Transport/TransportMember.cs
DisCatSharp/Net/Abstractions/Transport/TransportTeam.cs
DisCatSharp/Net/Abstractions/Transport/TransportUser.cs
DisCatSharp/Net/Abstractions/VoiceStateUpdate.cs
DisCatSharp/Net/ConnectionEndpoint.cs
DisCatSharp/Net/Models/ApplicationCommandEditModel.cs
DisCatSharp/Net/Models/AutomodRuleEditModel.cs
DisCatSharp/Net/Models/BaseEditModel.cs
DisCatSharp/Net/Models/ChannelEditModel.cs
DisCatSharp/Net/Models/ForumChannelEditModel.cs
DisCatSharp/Net/Models/ForumPostTagEditModel.cs
DisCatSharp/Net/Models/GuildEditModel.cs
DisCatSharp/Net/Models/MemberEditModel.cs
DisCatSharp/Net/Models/MembershipScreeningEditModel.cs
DisCatSharp/Net/Models/RoleEditModel.cs
DisCatSharp/Net/Models/ScheduledEventEditModel.cs
DisCatSharp/Net/Models/SoundboardSoundEditModel.cs
DisCatSharp/Net/Models/ThreadEditModel.cs
DisCatSharp/Net/Models/WelcomeScreenEditModel.cs
DisCatSharp/Net/Rest/BaseRestRequest.cs
DisCatSharp/Net/Rest/CommonHeaders.cs
DisCatSharp/Net/Rest/DiscordApiClient.cs
DisCatSharp/Net/Rest/Endpoints.cs
DisCatSharp/Net/Rest/IpEndpoint.cs
DisCatSharp/Net/Rest/MultipartWebRequest.cs
DisCatSharp/Net/Rest/RateLimitBucket.cs
DisCatSharp/Net/Rest/RestClient.cs
DisCatSharp/Net/Rest/RestFormRequest.cs
DisCatSharp/Net/Rest/RestRequest.cs
DisCatSharp/Net/Rest/RestRequestMethod.cs
DisCatSharp/Net/Rest/RestResponse.cs
DisCatSharp/Net/Rest/SessionBucket.cs
DisCatSharp/Net/Serialization/DisCatSharpContractResolver.cs
DisCatSharp/Net/Serialization/DiscordComponentJsonConverter.cs
DisCatSharp/Net/Serialization/DiscordJson.cs
DisCatSharp/Net/Serialization/ILabelComponentJsonConverter.cs
DisCatSharp/Net/Serialization/SnowflakeArrayAsDictionaryJsonConverter.cs
DisCatSharp/Net/Udp/BaseUdpClient.cs
DisCatSharp/Net/Udp/DCSUdpClient.cs
DisCatSharp/Net/WebSocket/IWebSocketClient.cs
DisCatSharp/Net/WebSocket/PayloadDecompressor.cs
DisCatSharp/Net/WebSocket/SocketLock.cs
DisCatSharp/Net/WebSocket/WebSocketClient.cs
DisCatSharp/QueryUriBuilder.cs
DisCatSharp/ReadOnlyConcurrentDictionary.cs
DisCatSharp/ReadOnlySet.cs
DisCatSharp/RingBuffer.cs
DisCatSharp/Utilities.cs
LICENSE.md
NOTICE.md
old_solutions/DisCatSharp.sln
old_solutions/DisCatSharp.Tools/DisCatSharp.Tools.sln
README.md
RELEASENOTES.md</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".hintrc">{
  &quot;extends&quot;: [
    &quot;development&quot;
  ],
  &quot;hints&quot;: {
    &quot;axe/aria&quot;: &quot;off&quot;,
    &quot;compat-api/html&quot;: [
      &quot;default&quot;,
      {
        &quot;ignore&quot;: [
          &quot;meta[name=theme-color]&quot;
        ]
      }
    ],
    &quot;manifest-file-extension&quot;: &quot;off&quot;
  }
}</file><file path=".repomixignore">.devcontainer/
.github/
.nuget/
DisCatSharp.Archive/
DisCatSharp.VoiceNext.Natives/
*.ruleset
*.ps1
.editorconfig
*.json
Directory.Build.props
DisCatSharp.code-workspace
.gitignore
.gitattributes
DisCatSharp.Docs/api/
DisCatSharp.Docs/pdf/
DisCatSharp.Docs/dcs/
*.yml
*.bat
*.dll
*.min
discatsharp-ai-test.xml
discatsharp-ai.xml
DisCatSharp.Experimental/openapi_preview.json
*.png
*.jpg
*.jpeg
*.svg
*.js
*.ts
*.css
*.mp4</file><file path="ARTICLES.md"># Writing articles for DisCatSharp

## Markdown header

```md
---
uid: article_name
title: Article Title
description: Short article description
author: DisCatSharp Team
---

Your article content
```

## Available yml header options

| Key         | Description        | Example          |
| ----------- | ------------------ | ---------------- |
| uid         | uid for cross ref  | cats             |
| title       | site title         | Cats             |
| description | short summarize    | Meow             |
| author      | your name          | DisCatSharp Team |

## Markdown docs for docfx

https://dotnet.github.io/docfx/docs/markdown.html</file><file path="BUILDING.md"># Building DisCatSharp
These are detailed instructions on how to build the DisCatSharp library under various environmnets.

It is recommended you have prior experience with multi-target .NET Core/Standard projects, as well as the `dotnet` CLI utility, and MSBuild.

## Requirements
In order to build the library, you will first need to install some software.

### Windows
On Windows, we only officially support Visual Studio 2022 17.0 or newer. Visual Studio Code and other IDEs might work, but are generally not supported or even guaranteed to work properly.

* **Windows 10** - while we support running the library on Windows 7 and above, we only support building on Windows 10 and better.
* [**Git for Windows**](https://git-scm.com/download/win) - required to clone the repository.
* [**Visual Studio 2022**](https://www.visualstudio.com/downloads/) - community edition or better. We do not support Visual Studio 2021 and older.
* **Windows PowerShell** - required to run the build scripts. You need to make sure your script execution policy allows execution of unsigned scripts.
* [**.NET SDK 8.0 or newer**](https://www.microsoft.com/net/download) - required to build the project.

### GNU/Linux
On GNU/Linux, we support building via Visual Studio Code and .NET Core SDK. Other IDEs might work, but are not supported or guaranteed to work properly.

While these should apply to any modern distribution, we only test against Ubuntu 24.04. Your mileage may vary.

When installing the below, make sure you install all the dependencies properly. We might ship a build environment as a docker container in the future.

* **Any modern GNU/Linux distribution** - like Ubuntu 24.04.
* **Git** - to clone the repository.
* [**Visual Studio Code**](https://code.visualstudio.com/Download) - a recent version is required.
   * **C# for Visual Studio Code (powered by OmniSharp)** - required for syntax highlighting and basic Intellisense
* [**.NET SDK 8.0 or newer**](https://www.microsoft.com/net/download) - required to build the project.
* [**PowerShell Core**](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7.5) - required to execute the build scripts.

## Instructions
Once you install all the necessary prerequisites, you can proceed to building. These instructions assume you have already cloned the repository.

### Windows
Building on Windows is relatively easy. There&apos;s 2 ways to build the project:

#### Building through Visual Studio
Building through Visual Studio yields just binaries you can use in your projects.

1. Open the solution in Visual Studio.
2. Set the configuration to Release.
3. Select Build &gt; Build Solution to build the project.
4. Select Build &gt; Publish DisCatSharp to publish the binaries.

#### Building with the build script
Building this way outputs NuGet packages, and a documentation package. Ensure you have an internet connection available, as the script will install programs necessary to build the documentation.

1. Open PowerShell and navigate to the directory which you cloned DisCatSharp to.
2. Execute `.\DisCatSharp.Tools\rebuild-lib.ps1 -ArtifactLocation .\dcs-artifacts -Configuration Release` and wait for the script to finish execution.
3. Once it&apos;s done, the artifacts will be available in *dcs-artifacts* directory, next to the directory to which the repository is cloned.

### GNU/Linux
When all necessary prerequisites are installed, you can proceed to building. There are technically 2 ways to build the library, though both of them perform the same steps, they are just invoked slightly differently.

#### Through Visual Studio Code
1. Open Visual Studio Code and open the folder to which you cloned DisCatSharp as your workspace.
2. Select Build &gt; Run Task...
3. Select `buildRelease` task and wait for it to finish.
4. The artifacts will be placed in *dcs-artifacts* directory, next to where the repository is cloned.

#### Through PowerShell
1. Open PowerShell (`pwsh`) and navigate to the directory which you cloned DisCatSharp to.
2. Execute `./DisCatSharp.Tools/rebuild-lib.ps1 -ArtifactLocation ./dcs-artifacts -Configuration Release` and wait for the script to finish execution.
3. Once it&apos;s done, the artifacts will be available in *dcs-artifacts* directory, next to the directory to which the repository is cloned.</file><file path="CHANGELOG.md"># Changelogs

Please visit our [documentation](https://docs.dcs.aitsys.dev/changelogs) for more information.</file><file path="CONTRIBUTING.md"># Contributing to DisCatSharp
We&apos;re really happy to accept contributions. However we also ask that you follow several rules when doing so.

# Proper base
When opening a PR, please make sure your branch targets the latest release branch, in this case it would be `main`. Also make sure your branch is even with the target branch, to avoid unnecessary surprises.

# Versioning
We follow custom [SemVer](https://semver.org/) versioning when it comes to pushing stable releases. Ideally, this means you should only be creating PRs for `PATCH` and `MINOR` changes. If you wish to introduce a `major` (breaking) change, please discuss it beforehand so we can determine how to integrate it into our next major version. If this involves removing a public facing property/method, mark it with the `Deprecated` attribute instead on the latest release branch.

Warning: We use a slightly different method for SemVer. {DISCORD_API_VERSION}.{MAJOR}.{MINOR}-{PATCH}

# Proper titles
When opening issues, make sure the title reflects the purpose of the issue or the pull request. Prefer past tense, and
be brief. Further description belongs inside the issue or PR.

# Descriptive changes
We require the commits describe the change made. It can be a short description. If you fixed or resolved an open issue,
please reference it by using the # notation.

Examples of good commit messages:

* `Fixed a potential memory leak with cache entities. Fixes #142.`
* `Implemented new command extension. Resolves #169.`
* `Changed message cache behaviour. It&apos;s now global instead of per-channel.`
* `Fixed a potential NRE.`
* ```
  Changed message cache behaviour:

  - Messages are now stored globally.
  - Cache now deletes messages when they are deleted from discord.
  - Cache itself is now a ring buffer.
  ```

# Code style
We use [Microsoft C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)
throughout the repository, with several exceptions:

* Preference of `this`. While this one is not required, it&apos;s ill-advised to remove the existing instances thereof.
* When working with async code, and your method consists of a single `await` statement not in any `if`, `while`, etc.
  blocks, pass the task through instead of awaiting it. For example:

  ```cs
  public Task DoSomethingAsync()
    =&gt; this.DoAnotherThingAsync();

  public Task DoAnotherThingAsync()
  {
      Console.WriteLine(&quot;42&quot;);
      return this.DoYetAnotherThingAsync(42);
  }

  public async Task DoYetAnotherThingAsync(int num)
  {
      if (num == 42)
          await SuperAwesomeMethodAsync();
  }
  ```

In addition to these, we also have several preferences:

* Use initializer syntax when possible:

  ```cs
  var a = new Class
  {
      StringNumber = &quot;forty-two&quot;,
      Number = 42
  };

  var b = new Dictionary&lt;string, int&gt;()
  {
      [&quot;forty-two&quot;] = 42,
      [&quot;sixty-nine&quot;] = 69
  };

  var c = new List&lt;int&gt;() { 42, 69 };

  var d = new[] { 42, 69 };
  ```
* Inline `out` declarations when possible: `SomeOutMethod(42, out var stringified);`
* Members in classes should be ordered as follows (with few exceptions):
   * Public `const` fields.
   * Non-public `const` fields.
   * Public static properties.
   * Public static fields.
   * Non-public static properties.
   * Non-public static fields.
   * Public properties.
   * Public fields.
   * Private properties.
   * Private fields.
   * Static constructor.
   * Public constructors.
   * Non-public constructors.
   * Public methods (with the exception of methods overridden from `System.Object`).
   * Non-public methods.
   * Methods overridden from `System.Object`.
   * Public static methods.
   * Non-public static methods.
   * Operator overloads.
   * Public events.
   * Non-public events.

# Code changes
One of our requirements is that all code change commits must build successfully. This is verified by our CI. When you
open a pull request, AppVeyor will start a build. You can view its summary by visiting it from the checks section on
the PR overview page.

PRs that do not build will not be accepted.

Furthermore we require that methods you implement on Discord entities have a reflection in the Discord API.

# Developer Certificate of Origin (DCO)
```
Version 1.1

Copyright (C) 2004, 2006 The Linux Foundation and its contributors.

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.


Developer&apos;s Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
```</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsConfiguration.cs">/// &lt;summary&gt;
///     A configuration for a &lt;see cref=&quot;ApplicationCommandsExtension&quot; /&gt;
/// &lt;/summary&gt;
public sealed class ApplicationCommandsConfiguration
⋮----
///     Creates a new configuration with default values.
⋮----
///     Utilized via dependency injection pipeline.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The service provider.&lt;/param&gt;
⋮----
///     Creates a new instance of &lt;see cref=&quot;ApplicationCommandsConfiguration&quot; /&gt;, copying the properties of another
///     configuration.
⋮----
/// &lt;param name=&quot;acc&quot;&gt;Configuration the properties of which are to be copied.&lt;/param&gt;
⋮----
///     &lt;para&gt;Sets the service provider.&lt;/para&gt;
///     &lt;para&gt;Objects in this provider are used when instantiating application command modules.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/para&gt;
⋮----
public IServiceProvider ServiceProvider { internal get; set; } = new ServiceCollection().BuildServiceProvider(true);
⋮----
///     &lt;para&gt;This option enables the default help command.&lt;/para&gt;
///     &lt;para&gt;Disabling this will allow you to make your own help command.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;This option enables the default help command with user apps capability.&lt;/para&gt;
///     &lt;para&gt;Mutually exclusive with &lt;see cref=&quot;EnableDefaultHelp&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/para&gt;
⋮----
///     This option enables the localization feature.
⋮----
// TODO: Check if it interferes with callback hints
⋮----
///     &lt;para&gt;Automatically defer all responses.&lt;/para&gt;
///     &lt;note type=&quot;note&quot;&gt;If you enable this, you can&apos;t use CreateResponse. Use EditResponse instead.&lt;/note&gt;
⋮----
///     &lt;para&gt;
///         This option informs the module to check through all guilds whether the
///         &lt;see target=&quot;_blank&quot; alt=&quot;Application Commands Scope&quot;
///             href=&quot;https://discord.com/developers/docs/topics/oauth2#shared-resources-oauth2-scopes&quot;&gt;
///             application.commands
///         &lt;/see&gt;
///         scope is set.
///     &lt;/para&gt;
///     &lt;note type=&quot;warning&quot;&gt;This will take quite a while, when the bot is on more than 1k guilds.&lt;/note&gt;
⋮----
///     &lt;para&gt;This option increases the debug output of the module.&lt;/para&gt;
///     &lt;note type=&quot;warning&quot;&gt;
///         &lt;para&gt;This is not recommended for production use.&lt;/para&gt;
///         &lt;para&gt;Enable this option only if DisCatSharp support advises you to do so.&lt;/para&gt;
///     &lt;/note&gt;
⋮----
///     &lt;para&gt;Whether to only generate translations files and abort after that.&lt;/para&gt;
⋮----
///     Whether to enable unit test mode.</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsModule.cs">/// &lt;summary&gt;
///     Represents a base class for application command modules
/// &lt;/summary&gt;
public abstract class ApplicationCommandsModule
⋮----
///     Called before the execution of a slash command in the module.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The context.&lt;/param&gt;
/// &lt;returns&gt; Whether or not to execute the slash command.&lt;/returns&gt;
public virtual Task&lt;bool&gt; BeforeSlashExecutionAsync(InteractionContext ctx)
=&gt; Task.FromResult(true);
⋮----
///     Called after the execution of a slash command in the module.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public virtual Task AfterSlashExecutionAsync(InteractionContext ctx)
⋮----
///     Called before the execution of a context menu in the module.
⋮----
/// &lt;returns&gt; Whether or not to execute the slash command. &lt;/returns&gt;
public virtual Task&lt;bool&gt; BeforeContextMenuExecutionAsync(ContextMenuContext ctx)
⋮----
///     Called after the execution of a context menu in the module.
⋮----
public virtual Task AfterContextMenuExecutionAsync(ContextMenuContext ctx)</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsUtilities.cs">/// &lt;summary&gt;
///     Provides a set of utility methods for application commands.
/// &lt;/summary&gt;
public static class ApplicationCommandsUtilities
⋮----
///     Whether this module is a candidate type.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
internal static bool IsModuleCandidateType(this Type type)
=&gt; type.GetTypeInfo().IsModuleCandidateType();
⋮----
/// &lt;param name=&quot;ti&quot;&gt;The type info.&lt;/param&gt;
internal static bool IsModuleCandidateType(this TypeInfo ti)
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking type {name}&quot;, ti.FullName);
// check if compiler-generated
⋮----
// check if derives from the required base class
⋮----
var timodule = tmodule.GetTypeInfo();
if (!timodule.IsAssignableFrom(ti))
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Not assignable from type&quot;);
⋮----
// check if anonymous
if (ti.IsGenericType &amp;&amp; ti.Name.Contains(&quot;AnonymousType&quot;) &amp;&amp; (ti.Name.StartsWith(&quot;&lt;&gt;&quot;, StringComparison.Ordinal) || ti.Name.StartsWith(&quot;VB$&quot;, StringComparison.Ordinal)) &amp;&amp; (ti.Attributes &amp; TypeAttributes.NotPublic) == TypeAttributes.NotPublic)
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Anonymous&quot;);
⋮----
// check if abstract, or not a class
⋮----
// check if delegate type
var tdelegate = typeof(Delegate).GetTypeInfo();
if (tdelegate.IsAssignableFrom(ti))
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Delegated&quot;);
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking qualifying methods&quot;);
// qualifies if any method or type qualifies
return ti.DeclaredMethods.Any(xmi =&gt; xmi.IsCommandCandidate(out _)) || ti.DeclaredNestedTypes.Any(xti =&gt; xti.IsModuleCandidateType());
⋮----
///     Whether this is a command candidate.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;parameters&quot;&gt;The parameters.&lt;/param&gt;
internal static bool IsCommandCandidate(this MethodInfo method, out ParameterInfo[] parameters)
⋮----
// check if exists
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Not existent&quot;);
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Checking method {name}&quot;, method.Name);
⋮----
// check if non-public, abstract, a constructor, or a special name
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;abstract, constructor or special name&quot;);
⋮----
// check if appropriate return and arguments
parameters = method.GetParameters();
if (parameters.Length == 0 || (parameters.First().ParameterType != typeof(ContextMenuContext) &amp;&amp; parameters.First().ParameterType != typeof(InteractionContext)) || method.ReturnType != typeof(Task))
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Missing first parameter with type ContextMenuContext or InteractionContext&quot;);
⋮----
ApplicationCommandsExtension.Logger.LogDebug(&quot;Qualifies&quot;);
// qualifies</file><file path="DisCatSharp.ApplicationCommands/Attributes/ApplicationCommandModuleLifespanAttribute.cs">/// &lt;summary&gt;
///     Defines this application command module&apos;s lifespan. Module lifespans are transient by default.
/// &lt;/summary&gt;
⋮----
public class ApplicationCommandModuleLifespanAttribute : Attribute
⋮----
///     Defines this application command module&apos;s lifespan.
⋮----
/// &lt;param name=&quot;lifespan&quot;&gt;The lifespan of the module. Module lifespans are transient by default.&lt;/param&gt;
⋮----
///     Gets the lifespan.</file><file path="DisCatSharp.ApplicationCommands/Attributes/CheckBaseAttribute.cs">/// &lt;summary&gt;
///     The base class for a pre-execution check for a application command.
/// &lt;/summary&gt;
public abstract class ApplicationCommandCheckBaseAttribute : Attribute
⋮----
///     Checks whether this command can be executed within the current context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The context.&lt;/param&gt;
/// &lt;returns&gt;Whether the checks passed.&lt;/returns&gt;
public abstract Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx);</file><file path="DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuAttribute.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationCommand&quot; /&gt; with the type of
///     &lt;see cref=&quot;ApplicationCommandType.User&quot; /&gt; or &lt;see cref=&quot;ApplicationCommandType.Message&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
public sealed class ContextMenuAttribute : Attribute
⋮----
///     Marks this method as a context menu.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type of the context menu.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the context menu.&lt;/param&gt;
/// &lt;param name=&quot;isNsfw&quot;&gt;Whether the context menu is marked as NSFW.&lt;/param&gt;
/// &lt;param name=&quot;allowedContexts&quot;&gt;The allowed contexts of the context menu.&lt;/param&gt;
/// &lt;param name=&quot;integrationTypes&quot;&gt;The allowed integration types of the context menu.&lt;/param&gt;
⋮----
throw new ArgumentException(&quot;Context menus cannot be of type ChatInput (Slash).&quot;);
⋮----
/// &lt;param name=&quot;defaultMemberPermissions&quot;&gt;The default member permissions of the context menu.&lt;/param&gt;
⋮----
///     Gets the name of this context menu.
⋮----
///     Gets the type of this context menu.
⋮----
///     Gets this context menu&apos;s needed permissions.
⋮----
///     Gets the allowed contexts of this context menu.
⋮----
///     Gets the allowed integration types of this context menu.
⋮----
///     Gets whether this context menu is marked as NSFW.</file><file path="DisCatSharp.ApplicationCommands/Attributes/ContextMenu/ContextMenuCooldownAttribute.cs">/// &lt;summary&gt;
///     Defines a cooldown for this command. This allows you to define how many times can users execute a specific command
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     Defines a cooldown for this command. This means that users will be able to use the command a specific number of
///     times before they have to wait to use it again.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;maxUses&quot;&gt;Number of times the command can be used before triggering a cooldown.&lt;/param&gt;
/// &lt;param name=&quot;resetAfter&quot;&gt;Number of seconds after which the cooldown is reset.&lt;/param&gt;
/// &lt;param name=&quot;bucketType&quot;&gt;
///     Type of cooldown bucket. This allows controlling whether the bucket will be cooled down per
///     user, guild, member, channel, and/or globally.
/// &lt;/param&gt;
/// &lt;param name=&quot;cooldownResponderType&quot;&gt;The responder type used to respond to cooldown ratelimit hits.&lt;/param&gt;
⋮----
public sealed class ContextMenuCooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : ApplicationCommandCheckBaseAttribute, ICooldown&lt;BaseContext, CooldownBucket&gt;
⋮----
///     Gets the responder type.
⋮----
///     Gets the maximum number of uses before this command triggers a cooldown for its bucket.
⋮----
///     Gets the time after which the cooldown is reset.
⋮----
public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
⋮----
///     Gets the type of the cooldown bucket. This determines how cooldowns are applied.
⋮----
///     Gets a cooldown bucket for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Command context to get cooldown bucket for.&lt;/param&gt;
/// &lt;returns&gt;Requested cooldown bucket, or null if one wasn&apos;t present.&lt;/returns&gt;
public CooldownBucket GetBucket(BaseContext ctx)
⋮----
var bid = this.GetBucketId(ctx, out _, out _, out _, out _);
ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
⋮----
///     Calculates the cooldown remaining for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate the cooldown.&lt;/param&gt;
/// &lt;returns&gt;Remaining cooldown, or zero if no cooldown is active.&lt;/returns&gt;
public TimeSpan GetRemainingCooldown(BaseContext ctx)
⋮----
var bucket = this.GetBucket(ctx);
⋮----
/// &lt;inheritdoc /&gt;
public async Task&lt;bool&gt; RespondRatelimitHitAsync(BaseContext ctx, bool noHit, CooldownBucket bucket)
⋮----
await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;));
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;).AsEphemeral());
⋮----
var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
var providerInstance = Activator.CreateInstance(this.ResponderType);
await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
⋮----
///     Calculates bucket ID for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate bucket ID for.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;ID of the user with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;ID of the channel with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;ID of the guild with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;memberId&quot;&gt;ID of the member with which this bucket is associated.&lt;/param&gt;
/// &lt;returns&gt;Calculated bucket ID.&lt;/returns&gt;
private string GetBucketId(BaseContext ctx, out ulong userId, out ulong channelId, out ulong guildId, out ulong memberId)
⋮----
var bid = CooldownBucket.MakeId(ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), userId, channelId, guildId, memberId);
⋮----
///     Executes a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld, out var mem);
if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
⋮----
bucket = new(this.MaxUses, this.Reset, ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), usr, chn, gld, mem);
ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.ApplicationCommands/Attributes/DontInjectAttribute.cs">/// &lt;summary&gt;
///     Prevents this field or property from having its value injected by dependency injection.
/// &lt;/summary&gt;
⋮----
public class DontInjectAttribute : Attribute</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireAnyPermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this application command is restricted to members with any of the specified permissions. This
///     check also verifies that the bot has the same permissions.
/// &lt;/summary&gt;
⋮----
public sealed class RequireAnyPermissionsAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that usage of this command is restricted to members with any of the specified permissions. This check also
///     verifies that the bot has the same permissions.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Runs checks.
⋮----
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
throw new InvalidOperationException(&quot;This check cannot be used in a DM.&quot;);
⋮----
var pusr = ctx.Channel.PermissionsFor(usr);
⋮----
var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
var pbot = ctx.Channel.PermissionsFor(bot);
⋮----
var usrok = ctx.Guild.OwnerId == usr.Id || pusr.HasPermission(Permissions.Administrator);
var botok = ctx.Guild.OwnerId == bot.Id || pusr.HasPermission(Permissions.Administrator);
⋮----
usrok = this.AnyPermissions.Any(x =&gt; (pusr &amp; x) != 0);
⋮----
botok = this.AnyPermissions.Any(x =&gt; (pbot &amp; x) != 0);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireBotPermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this application command is only possible when the bot is granted a specific permission.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireBotPermissionsAttribute : ApplicationCommandCheckBaseAttribute
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Runs checks.
⋮----
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
var pbot = ctx.Channel.PermissionsFor(bot);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireDirectMessageAttribute.cs">/// &lt;summary&gt;
///     Defines that this application command is only usable within a direct message channel.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireDirectMessageAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that this command is only usable within a direct message channel.
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
=&gt; Task.FromResult(ctx.Channel is DiscordDmChannel);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireGuildAttribute.cs">/// &lt;summary&gt;
///     Defines that this application command is only usable within a guild.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireGuildAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that this command is only usable within a guild.
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
=&gt; Task.FromResult(ctx.Guild != null);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireGuildOwnerAttribute.cs">/// &lt;summary&gt;
///     Defines that this application command is only usable within a guild by its owner.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireGuildOwnerAttributeAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that this command is only usable within a guild by its owner.
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
=&gt; Task.FromResult(ctx.Guild is not null &amp;&amp; ctx.Guild.OwnerId == ctx.User.Id);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireNsfwAttribute.cs">/// &lt;summary&gt;
///     Defines that this application command is only usable within a guild.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireNsfwAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that this command is only usable within a guild.
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
=&gt; Task.FromResult(ctx.Guild == null || ctx.Channel.IsNsfw);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequirePermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this application command is restricted to members with specified permissions. This check also
///     verifies that the bot has the same permissions.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequirePermissionsAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that usage of this command is restricted to members with specified permissions. This check also verifies
///     that the bot has the same permissions.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Runs checks.
⋮----
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
var pusr = ctx.Channel.PermissionsFor(usr);
⋮----
var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
var pbot = ctx.Channel.PermissionsFor(bot);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireSkuEntitlementAttribute.cs">// TODO: Add method to respond with button
/// &lt;summary&gt;
///     Defines that usage of this application command is restricted to users with a specified entitlement.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     Defines that usage of this command is restricted to users with a specified entitlement.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;skuId&quot;&gt;Sku id for which an entitlement is required to execute this command.&lt;/param&gt;
⋮----
public sealed class ApplicationCommandRequireSkuEntitlementAttribute(ulong skuId) : ApplicationCommandCheckBaseAttribute
⋮----
///     Gets the sku id requiring an entitlement.
⋮----
///     Runs checks.
⋮----
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
if (ctx.Interaction.Entitlements.Any(x =&gt; x.SkuId == this.SkuId))
return await Task.FromResult(true).ConfigureAwait(false);
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AddComponents(new DiscordPremiumButtonComponent(this.SkuId))).ConfigureAwait(false);
return await Task.FromResult(false).ConfigureAwait(false);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamAdmin.cs">/// &lt;summary&gt;
///     Defines that this application command is restricted to team members of the bot with admin role or higher.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireTeamAdminAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return Task.FromResult(app.Owner.Id == ctx.User.Id);
⋮----
var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamDeveloper.cs">/// &lt;summary&gt;
///     Defines that this application command is restricted to team members of the bot with developer role or higher.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireTeamDeveloperAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return Task.FromResult(app.Owner.Id == ctx.User.Id);
⋮----
var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;developer&quot; or &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamMember.cs">/// &lt;summary&gt;
///     Defines that this application command is restricted to the team members of the bot.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireTeamMemberAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return app.Team is null ? Task.FromResult(app.Owner.Id == ctx.User.Id) : Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id));</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamOwner.cs">/// &lt;summary&gt;
///     Defines that this application command is restricted to team members of the bot with owner role.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireTeamOwnerAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return Task.FromResult(app.Owner.Id == ctx.User.Id);
⋮----
var teamMember = app.Team.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireTeamReadOnly.cs">/// &lt;summary&gt;
///     Defines that this application command is restricted to team members of the bot with read-only role or higher.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireTeamReadOnlyAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return Task.FromResult(app.Owner.Id == ctx.User.Id);
⋮----
var teamMember = app.Team?.Members.FirstOrDefault(x =&gt; x.User.Id == ctx.User.Id);
return teamMember == null ? Task.FromResult(false) : Task.FromResult(teamMember.Role is &quot;read-only&quot; or &quot;developer&quot; or &quot;admin&quot; or &quot;owner&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/RequireUserPermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this application command is restricted to members with specified permissions.
/// &lt;/summary&gt;
⋮----
public sealed class ApplicationCommandRequireUserPermissionsAttribute : ApplicationCommandCheckBaseAttribute
⋮----
///     Defines that usage of this command is restricted to members with specified permissions.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Runs checks.
⋮----
public override Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
return Task.FromResult(this.IgnoreDms);
⋮----
return Task.FromResult(false);
⋮----
return Task.FromResult(true);
⋮----
var pusr = ctx.Channel.PermissionsFor(usr);
⋮----
? Task.FromResult(true)
⋮----
: Task.FromResult(false);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/AutocompleteAttribute.cs">/// &lt;summary&gt;
///     The autocomplete attribute.
/// &lt;/summary&gt;
⋮----
public class AutocompleteAttribute : Attribute
⋮----
///     Adds an autocomplete provider to this command option.
⋮----
/// &lt;param name=&quot;providerType&quot;&gt;The type of the provider.&lt;/param&gt;
⋮----
///     The type of the provider.</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChannelTypesAttribute.cs">/// &lt;summary&gt;
///     Defines allowed channel types for a channel parameter.
/// &lt;/summary&gt;
⋮----
public class ChannelTypesAttribute : Attribute
⋮----
/// &lt;param name=&quot;channelTypes&quot;&gt;The channel types to allow.&lt;/param&gt;
⋮----
///     Allowed channel types.</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceAttribute.cs">/// &lt;summary&gt;
///     Adds a choice for this slash command option
/// &lt;/summary&gt;
⋮----
public class ChoiceAttribute : Attribute
⋮----
///     Adds a choice to the slash command option
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the choice.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value of the choice.&lt;/param&gt;
⋮----
///     Gets the name of the choice
⋮----
///     Gets the value of the choice</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceNameAttribute.cs">/// &lt;summary&gt;
///     Sets the name for this enum choice.
/// &lt;/summary&gt;
⋮----
public class ChoiceNameAttribute : Attribute
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name for this enum choice.&lt;/param&gt;
⋮----
///     The name.</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProvider.cs">/// &lt;summary&gt;
///     Implementation of &lt;see cref=&quot;IChoiceProvider&quot; /&gt; with access to service collection.
/// &lt;/summary&gt;
public abstract class ChoiceProvider : IChoiceProvider
⋮----
///     Sets the service provider.
⋮----
///     The optional ID of the Guild the command got registered for.
⋮----
///     Sets the choices for the slash command.
⋮----
public abstract Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/ChoiceProviderAttribute.cs">/// &lt;summary&gt;
///     Sets a IChoiceProvider for a command options. ChoiceProviders can be used to provide
///     DiscordApplicationCommandOptionChoice from external sources such as a database.
/// &lt;/summary&gt;
⋮----
public class ChoiceProviderAttribute : Attribute
⋮----
///     Adds a choice provider to this command.
⋮----
/// &lt;param name=&quot;providerType&quot;&gt;The type of the provider.&lt;/param&gt;
⋮----
///     The type of the provider.</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IAutocompleteProvider.cs">/// &lt;summary&gt;
///     The autocomplete provider.
/// &lt;/summary&gt;
public interface IAutocompleteProvider
⋮----
///     Provider the autocompletion.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt;
Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext context);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/IChoiceProvider.cs">/// &lt;summary&gt;
///     All choice providers must inherit from this interface
/// &lt;/summary&gt;
public interface IChoiceProvider
⋮----
///     Sets the choices for the slash command
⋮----
Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/MinimumMaximumAttribute.cs">/// &lt;summary&gt;
///     Sets a minimum value for this slash command option. Only valid for &lt;see cref=&quot;int&quot; /&gt;, &lt;see cref=&quot;long&quot; /&gt; or
///     &lt;see cref=&quot;double&quot; /&gt; parameters.
/// &lt;/summary&gt;
⋮----
public class MinimumValueAttribute : Attribute
⋮----
///     The value.
⋮----
///     Sets a maximum value for this slash command option. Only valid for &lt;see cref=&quot;int&quot; /&gt;, &lt;see cref=&quot;long&quot; /&gt; or
⋮----
public class MaximumValueAttribute : Attribute
⋮----
///     Sets a minimum value for this slash command option. Only valid for &lt;see cref=&quot;string&quot; /&gt; parameters.
⋮----
public class MinimumLengthAttribute : Attribute
⋮----
throw new ArgumentException(&quot;Minimum cannot be more than 6000.&quot;);
⋮----
///     Sets a maximum value for this slash command option.  Only valid for &lt;see cref=&quot;string&quot; /&gt; parameters.
⋮----
public class MaximumLengthAttribute : Attribute
⋮----
///     Sets a maximum value for this slash command option. Only valid for &lt;see cref=&quot;string&quot; /&gt; parameters.
⋮----
throw new ArgumentException(&quot;Maximum length cannot be less than 1 and cannot be more than 6000.&quot;);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/OptionAttribute.cs">/// &lt;summary&gt;
///     Marks this parameter as an option for a slash command
/// &lt;/summary&gt;
⋮----
public class OptionAttribute : Attribute
⋮----
///     Whether to autocomplete this option.
⋮----
///     Gets the description of this option.
⋮----
///     Gets the name of this option.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;OptionAttribute&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;autocomplete&quot;&gt;If true, autocomplete.&lt;/param&gt;
⋮----
throw new ArgumentException(&quot;Slash command option names cannot go over 32 characters.&quot;);
⋮----
throw new ArgumentException(&quot;Slash command option descriptions cannot go over 100 characters.&quot;);
⋮----
this.Name = name.ToLower();</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandAttribute.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationCommand&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
public class SlashCommandAttribute : Attribute
⋮----
///     Marks this method as a slash command.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of this slash command.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of this slash command.&lt;/param&gt;
/// &lt;param name=&quot;isNsfw&quot;&gt;Whether this command is marked as NSFW.&lt;/param&gt;
/// &lt;param name=&quot;allowedContexts&quot;&gt;The allowed contexts of this slash command.&lt;/param&gt;
/// &lt;param name=&quot;integrationTypes&quot;&gt;The allowed integration types.&lt;/param&gt;
⋮----
this.Name = name.ToLower();
⋮----
/// &lt;param name=&quot;defaultMemberPermissions&quot;&gt;The default member permissions.&lt;/param&gt;
⋮----
///     Gets the name of this command.
⋮----
///     Gets the description of this command.
⋮----
///     Gets the needed permission of this command.
⋮----
///     Gets the allowed contexts of this command.
⋮----
///     Gets the allowed integration types of this command.
⋮----
///     Gets whether this command is marked as NSFW.</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandCooldownAttribute.cs">/// &lt;summary&gt;
///     Defines a cooldown for this command. This allows you to define how many times can users execute a specific command.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     Defines a cooldown for this command. This means that users will be able to use the command a specific number of
///     times before they have to wait to use it again.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;maxUses&quot;&gt;Number of times the command can be used before triggering a cooldown.&lt;/param&gt;
/// &lt;param name=&quot;resetAfter&quot;&gt;Number of seconds after which the cooldown is reset.&lt;/param&gt;
/// &lt;param name=&quot;bucketType&quot;&gt;
///     Type of cooldown bucket. This allows controlling whether the bucket will be cooled down per
///     user, guild, member, channel, and/or globally.
/// &lt;/param&gt;
/// &lt;param name=&quot;cooldownResponderType&quot;&gt;The responder type used to respond to cooldown ratelimit hits.&lt;/param&gt;
⋮----
public sealed class SlashCommandCooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : ApplicationCommandCheckBaseAttribute, ICooldown&lt;BaseContext, CooldownBucket&gt;
⋮----
///     Gets the responder type.
⋮----
///     Gets the maximum number of uses before this command triggers a cooldown for its bucket.
⋮----
///     Gets the time after which the cooldown is reset.
⋮----
public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
⋮----
///     Gets the type of the cooldown bucket. This determines how cooldowns are applied.
⋮----
///     Gets a cooldown bucket for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Command context to get cooldown bucket for.&lt;/param&gt;
/// &lt;returns&gt;Requested cooldown bucket, or null if one wasn&apos;t present.&lt;/returns&gt;
public CooldownBucket GetBucket(BaseContext ctx)
⋮----
var bid = this.GetBucketId(ctx, out _, out _, out _, out _);
ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
⋮----
///     Calculates the cooldown remaining for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate the cooldown.&lt;/param&gt;
/// &lt;returns&gt;Remaining cooldown, or zero if no cooldown is active.&lt;/returns&gt;
public TimeSpan GetRemainingCooldown(BaseContext ctx)
⋮----
var bucket = this.GetBucket(ctx);
⋮----
/// &lt;inheritdoc /&gt;
public async Task&lt;bool&gt; RespondRatelimitHitAsync(BaseContext ctx, bool noHit, CooldownBucket bucket)
⋮----
await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;));
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($&quot;Error: Ratelimit hit\nTry again {bucket.ResetsAt.Timestamp()}&quot;).AsEphemeral());
⋮----
var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
var providerInstance = Activator.CreateInstance(this.ResponderType);
await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
⋮----
///     Calculates bucket ID for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate bucket ID for.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;ID of the user with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;ID of the channel with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;ID of the guild with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;memberId&quot;&gt;ID of the member with which this bucket is associated.&lt;/param&gt;
/// &lt;returns&gt;Calculated bucket ID.&lt;/returns&gt;
private string GetBucketId(BaseContext ctx, out ulong userId, out ulong channelId, out ulong guildId, out ulong memberId)
⋮----
if (this.BucketType.HasFlag(CooldownBucketType.User))
⋮----
if (this.BucketType.HasFlag(CooldownBucketType.Channel))
⋮----
if (ctx.Guild is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Guild))
⋮----
if (ctx.Guild is not null &amp;&amp; ctx.Member is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Member))
⋮----
var bid = CooldownBucket.MakeId(ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), userId, channelId, guildId, memberId);
⋮----
///     Executes a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteChecksAsync(BaseContext ctx)
⋮----
var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld, out var mem);
if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
⋮----
bucket = new(this.MaxUses, this.Reset, ctx.FullCommandName, ctx.Interaction.Data.Id.ToString(CultureInfo.InvariantCulture), usr, chn, gld, mem);
ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.ApplicationCommands/Attributes/SlashCommand/SlashCommandGroupAttribute.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationCommand&quot; /&gt; group.
/// &lt;/summary&gt;
⋮----
public class SlashCommandGroupAttribute : Attribute
⋮----
///     Marks this class as a slash command group.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the slash command group.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the slash command group.&lt;/param&gt;
/// &lt;param name=&quot;isNsfw&quot;&gt;Whether the slash command group is marked as NSFW.&lt;/param&gt;
/// &lt;param name=&quot;allowedContexts&quot;&gt;The allowed contexts of the slash command group.&lt;/param&gt;
/// &lt;param name=&quot;integrationTypes&quot;&gt;The allowed integration types of the slash command group.&lt;/param&gt;
⋮----
this.Name = name.ToLower();
⋮----
///     Marks this method as a slash command group.
⋮----
/// &lt;param name=&quot;defaultMemberPermissions&quot;&gt;The default member permissions of the slash command group.&lt;/param&gt;
⋮----
///     Gets the name of this slash command group.
⋮----
///     Gets the description of this slash command group.
⋮----
///     Gets the needed permission of this slash command group.
⋮----
///     Gets the allowed contexts of this slash command group.
⋮----
///     Gets the allowed integration types of this slash command group.
⋮----
///     Gets whether this slash command group is marked as NSFW.</file><file path="DisCatSharp.ApplicationCommands/Checks/ApplicationCommandEqualityChecks.cs">/// &lt;summary&gt;
///     The application command equality checks.
/// &lt;/summary&gt;
internal static class ApplicationCommandEqualityChecks
⋮----
///     Whether two application commands are equal.
⋮----
/// &lt;param name=&quot;ac1&quot;&gt;Source command.&lt;/param&gt;
/// &lt;param name=&quot;targetApplicationCommand&quot;&gt;Command to check against.&lt;/param&gt;
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;isGuild&quot;&gt;Whether the equal check is performed for a guild command.&lt;/param&gt;
internal static bool IsEqualTo(
⋮----
DiscordApplicationCommand sourceApplicationCommand = new(
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel,
⋮----
JsonConvert.SerializeObject(sourceApplicationCommand),
JsonConvert.SerializeObject(targetApplicationCommand));
⋮----
return ac1.Type == targetApplicationCommand.Type &amp;&amp; sourceApplicationCommand.SoftEqual(targetApplicationCommand,
⋮----
///     Checks softly whether two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;s are the same.
///     Excluding id, application id and version here.
⋮----
/// &lt;param name=&quot;source&quot;&gt;Source application command.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;Application command to check against.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The application command type.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;localizationEnabled&quot;&gt;Whether localization is enabled.&lt;/param&gt;
/// &lt;param name=&quot;guild&quot;&gt;Whether the equal check is performed for a guild command.&lt;/param&gt;
internal static bool SoftEqual(
⋮----
&amp;&amp; source.AllowedContexts.NullableSequenceEqual(target.AllowedContexts) &amp;&amp;
source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes) &amp;&amp;
source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations)
⋮----
source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes)
⋮----
&amp;&amp; source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations)
⋮----
///     Performs a SequenceEqual on an enumerable if both &lt;paramref name=&quot;source&quot; /&gt; and &lt;paramref name=&quot;target&quot; /&gt; is not
///     null.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The containing type within the list.&lt;/typeparam&gt;
/// &lt;param name=&quot;source&quot;&gt;The source enumerable.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target enumerable.&lt;/param&gt;
/// &lt;returns&gt;Whether both nullable enumerable are equal.&lt;/returns&gt;
internal static bool NullableSequenceEqual&lt;T&gt;(this List&lt;T&gt;? source, List&lt;T&gt;? target)
⋮----
? source.All(target.Contains) &amp;&amp; source.Count == target.Count
⋮----
///     Checks whether two dictionaries are equal.
⋮----
/// &lt;param name=&quot;sourceDictionary&quot;&gt;The source dictionary.&lt;/param&gt;
/// &lt;param name=&quot;targetDictionary&quot;&gt;The target dictionary.&lt;/param&gt;
/// &lt;returns&gt;Whether both dictionaries are equal.&lt;/returns&gt;
internal static bool AreDictionariesEqual(this Dictionary&lt;string, string&gt; sourceDictionary, Dictionary&lt;string, string&gt; targetDictionary)
⋮----
if (!targetDictionary.TryGetValue(kvp.Key, out var value) || value != kvp.Value)
⋮----
///     Checks deeply whether two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;s are the same.
⋮----
internal static bool DeepEqual(
⋮----
source.AllowedContexts.NullableSequenceEqual(target.AllowedContexts) &amp;&amp;
source.IntegrationTypes.NullableSequenceEqual(target.IntegrationTypes);
⋮----
source.RawNameLocalizations.AreDictionariesEqual(target.RawNameLocalizations) &amp;&amp;
source.RawDescriptionLocalizations.AreDictionariesEqual(target.RawDescriptionLocalizations);
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;Inequality found in options of {name} - {reason}&quot;, name, reason);
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;Inequality found in root of {name}&quot;, name);
⋮----
///     Checks deeply whether &lt;see cref=&quot;DiscordApplicationCommandOption&quot; /&gt;s are the same.
⋮----
/// &lt;param name=&quot;sourceOptions&quot;&gt;Source options.&lt;/param&gt;
/// &lt;param name=&quot;targetOptions&quot;&gt;Options to check against.&lt;/param&gt;
⋮----
private static (bool Equal, string? Reason) DeepEqualOptions(
⋮----
sourceOption.RawNameLocalizations.AreDictionariesEqual(targetOption.RawNameLocalizations) &amp;&amp;
sourceOption.RawDescriptionLocalizations.AreDictionariesEqual(targetOption
⋮----
var j1 = JsonConvert.SerializeObject(sourceOption.Choices.OrderBy(x =&gt; x.Name), Formatting.None);
var j2 = JsonConvert.SerializeObject(targetOption.Choices.OrderBy(x =&gt; x.Name), Formatting.None);
⋮----
!sourceOption.ChannelTypes.OrderBy(x =&gt; x).All(targetOption.ChannelTypes.OrderBy(x =&gt; x).Contains)))</file><file path="DisCatSharp.ApplicationCommands/Context/ApplicationCommandsTranslationContext.cs">/// &lt;summary&gt;
///     The application commands translation context.
/// &lt;/summary&gt;
public sealed class ApplicationCommandsTranslationContext
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandsTranslationContext&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
⋮----
///     Gets the type.
⋮----
///     Gets the name.
⋮----
///     Gets the group translation json.
⋮----
///     Gets the single translation json.
⋮----
///     Adds the group translation.
⋮----
/// &lt;param name=&quot;translationJson&quot;&gt;&lt;/param&gt;
public void AddGroupTranslation(string translationJson)
⋮----
///     Adds the single translation.
⋮----
public void AddSingleTranslation(string translationJson)</file><file path="DisCatSharp.ApplicationCommands/Context/AutocompleteContext.cs">/// &lt;summary&gt;
///     Represents a context for an autocomplete interaction.
/// &lt;/summary&gt;
public sealed class AutocompleteContext : DisCatSharpCommandContext
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;AutocompleteContext&quot; /&gt; class.
⋮----
///     The interaction created.
⋮----
///     Gets the guild this interaction was executed in.
⋮----
///     Gets the channel this interaction was executed in.
⋮----
///     Gets the user which executed this interaction.
⋮----
///     Gets the member which executed this interaction, or null if the command is in a DM.
⋮----
///     Gets the invoking user locale.
⋮----
///     Gets the guild locale if applicable.
⋮----
///     Gets the applications permissions.
⋮----
///     &lt;para&gt;Gets the entitlements.&lt;/para&gt;
///     &lt;para&gt;This is related to premium subscriptions for bots.&lt;/para&gt;
///     &lt;para&gt;
///         &lt;note type=&quot;warning&quot;&gt;Can only be used if you have an associated application subscription sku.&lt;/note&gt;
///     &lt;/para&gt;
⋮----
///     Gets the slash command module this interaction was created in.
⋮----
///     &lt;para&gt;Gets the service provider.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to an empty service provider.&lt;/para&gt;
⋮----
public IServiceProvider Services { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);
⋮----
///     The options already provided.
⋮----
///     The option to autocomplete.</file><file path="DisCatSharp.ApplicationCommands/Context/ContextMenuContext.cs">/// &lt;summary&gt;
///     Represents a context for a context menu.
/// &lt;/summary&gt;
public sealed class ContextMenuContext(DisCatSharpCommandType type) : BaseContext(type)
⋮----
///     The user this command targets, if applicable.
⋮----
///     The member this command targets, if applicable.
⋮----
///     The message this command targets, if applicable.</file><file path="DisCatSharp.ApplicationCommands/Context/InteractionContext.cs">/// &lt;summary&gt;
///     Represents a context for an interaction.
/// &lt;/summary&gt;
public sealed class InteractionContext() : BaseContext(DisCatSharpCommandType.SlashCommand)
⋮----
///     Gets the users mentioned in the command parameters.
⋮----
///     Gets the roles mentioned in the command parameters.
⋮----
///     Gets the channels mentioned in the command parameters.
⋮----
///     Gets the attachments in the command parameters, if applicable.</file><file path="DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.ApplicationCommands/Entities/ChoiceTranslator.cs">/// &lt;summary&gt;
///     Represents a choice translator.
/// &lt;/summary&gt;
public sealed class ChoiceTranslator
⋮----
///     Gets the choice name.
⋮----
///     Gets the choice name translations.
⋮----
///     Converts a &lt;see cref=&quot;DiscordApplicationCommandOptionChoice&quot; /&gt; to a &lt;see cref=&quot;ChoiceTranslator&quot; /&gt;.
⋮----
/// &lt;param name=&quot;choice&quot;&gt;The choice to convert.&lt;/param&gt;
public static ChoiceTranslator FromApplicationCommandChoice(DiscordApplicationCommandOptionChoice choice)
⋮----
var translator = new ChoiceTranslator</file><file path="DisCatSharp.ApplicationCommands/Entities/CommandTranslator.cs">/// &lt;summary&gt;
///     Represents a command translator.
/// &lt;/summary&gt;
public sealed class CommandTranslator
⋮----
///     Gets the command name.
⋮----
///     Gets the command description.
⋮----
///     Gets the application command type.
///     Used to determine whether it is an translator for context menu or not.
⋮----
///     Gets the command name translations.
⋮----
///     Gets the command description translations.
⋮----
///     Gets the option translators, if applicable.</file><file path="DisCatSharp.ApplicationCommands/Entities/FakeApplicationCommandObjects.cs">// ReSharper disable InternalOrPrivateMemberNotDocumented
internal sealed class CommandGroupWithSubGroups : BaseCommand
⋮----
internal sealed class CommandGroup : BaseCommand
⋮----
internal sealed class Command : BaseCommand
⋮----
this.Options = options.Select(OptionTranslator.FromApplicationCommandOption).ToList();
⋮----
internal class BaseCommand
⋮----
// ReSharper restore InternalOrPrivateMemberNotDocumented</file><file path="DisCatSharp.ApplicationCommands/Entities/GroupTranslator.cs">/// &lt;summary&gt;
///     Represents a group translator.
/// &lt;/summary&gt;
public sealed class GroupTranslator
⋮----
///     Gets the group name.
⋮----
///     Gets the group description.
⋮----
///     Gets the application command type.
///     Used to determine whether it is an translator for context menu or not.
⋮----
///     Gets the group name translations.
⋮----
///     Gets the group description translations.
⋮----
///     Gets the sub group translators, if applicable.
⋮----
///     Gets the command translators, if applicable.</file><file path="DisCatSharp.ApplicationCommands/Entities/ICooldownResponder.cs">/// &lt;summary&gt;
///     The cooldown responder.
/// &lt;/summary&gt;
public interface ICooldownResponder
⋮----
///     Responds to cooldown ratelimit hits with given response.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt;
/// &lt;param name=&quot;cooldownBucket&quot;&gt;Gets the current cooldown bucket.&lt;/param&gt;
Task Responder(BaseContext context, CooldownBucket cooldownBucket);</file><file path="DisCatSharp.ApplicationCommands/Entities/OptionTranslator.cs">/// &lt;summary&gt;
///     Represents a option translator.
/// &lt;/summary&gt;
public sealed class OptionTranslator
⋮----
///     Gets the option name.
⋮----
///     Gets the option description.
⋮----
///     Gets the option type
⋮----
///     Gets the option name translations.
⋮----
///     Gets the option description translations.
⋮----
///     Gets the choice translators, if applicable.
⋮----
///     Converts a &lt;see cref=&quot;DiscordApplicationCommandOption&quot; /&gt; to a &lt;see cref=&quot;OptionTranslator&quot; /&gt;.
⋮----
/// &lt;param name=&quot;option&quot;&gt;The option to convert.&lt;/param&gt;
public static OptionTranslator FromApplicationCommandOption(DiscordApplicationCommandOption option)
⋮----
var optionTranslator = new OptionTranslator
⋮----
optionTranslator.Choices = option.Choices.Select(ChoiceTranslator.FromApplicationCommandChoice).ToList();</file><file path="DisCatSharp.ApplicationCommands/Entities/RegisteredDiscordApplicationCommand.cs">/// &lt;summary&gt;
///     Represents a discord application command registered by the ApplicationCommands extensions.
/// &lt;/summary&gt;
public sealed class RegisteredDiscordApplicationCommand : DiscordApplicationCommand
⋮----
///     Creates a new empty registered discord application command.
⋮----
///     Creates a new registered discord application command.
⋮----
/// &lt;param name=&quot;parent&quot;&gt;The original application command&lt;/param&gt;
⋮----
if (ApplicationCommandsExtension.CommandMethods.Any(x =&gt; x.CommandId == this.Id))
⋮----
this.CommandMethod = ApplicationCommandsExtension.CommandMethods.First(x =&gt; x.CommandId == this.Id).Method;
⋮----
this.CustomAttributes = this.CommandMethod.GetCustomAttributes().Where(x =&gt; !x.GetType().Namespace.StartsWith(&quot;DisCatSharp&quot;, StringComparison.Ordinal)).ToList();
⋮----
else if (ApplicationCommandsExtension.ContextMenuCommands.Any(x =&gt; x.CommandId == this.Id))
⋮----
this.CommandMethod = ApplicationCommandsExtension.ContextMenuCommands.First(x =&gt; x.CommandId == this.Id).Method;
⋮----
else if (ApplicationCommandsExtension.GroupCommands.Any(x =&gt; x.CommandId == this.Id))
⋮----
this.CommandType = ApplicationCommandsExtension.GroupCommands.First(x =&gt; x.CommandId == this.Id).Methods.First().Value.DeclaringType;
⋮----
this.CustomAttributes = this.CommandType.GetCustomAttributes().Where(x =&gt; !x.GetType().Namespace.StartsWith(&quot;DisCatSharp&quot;, StringComparison.Ordinal)).ToList();
⋮----
ApplicationCommandsExtension.Logger.LogError(&quot;Failed to generate reflection properties for &apos;{cmd}&apos;&quot;, parent.Name);
⋮----
///     The method that will be executed when somebody runs this command.
///     &lt;see langword=&quot;null&quot; /&gt; if command is a group command or reflection failed.
⋮----
///     The type that contains the sub commands of this command.
///     &lt;see langword=&quot;null&quot; /&gt; if command is not a group command or reflection failed.
⋮----
///     The type this command is contained in.
///     &lt;see langword=&quot;null&quot; /&gt; if reflection failed.
⋮----
///     Gets all Non-DisCatSharp attributes this command has.</file><file path="DisCatSharp.ApplicationCommands/Entities/SubGroupTranslator.cs">/// &lt;summary&gt;
///     Represents a sub group translator.
/// &lt;/summary&gt;
public sealed class SubGroupTranslator
⋮----
///     Gets the sub group name.
⋮----
///     Gets the sub group description.
⋮----
///     Gets the sub group name translations.
⋮----
///     Gets the sub group description translations.
⋮----
///     Gets the command translators.</file><file path="DisCatSharp.ApplicationCommands/Enums/ApplicationCommandFinalType.cs"></file><file path="DisCatSharp.ApplicationCommands/Enums/ApplicationCommandModuleLifespan.cs">/// &lt;summary&gt;
///     Represents a application command module lifespan.
/// &lt;/summary&gt;
⋮----
///     Whether this module should be initiated every time a command is run, with dependencies injected from a scope.
⋮----
///     Whether this module should be initiated every time a command is run.
⋮----
///     Whether this module should be initiated at startup.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuErrorEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.ContextMenuErrored&quot; /&gt;
/// &lt;/summary&gt;
public class ContextMenuErrorEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ContextMenuErrorEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     The context of the command.
⋮----
///     The exception thrown.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/ContextMenu/ContextMenuExecutedEventArgs.cs">/// &lt;summary&gt;
///     Represents the arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.ContextMenuExecuted&quot; /&gt; event
/// &lt;/summary&gt;
public sealed class ContextMenuExecutedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ContextMenuExecutedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     The context of the command.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleReadyEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.ApplicationCommandsModuleReady&quot; /&gt; event.
/// &lt;/summary&gt;
public sealed class ApplicationCommandsModuleReadyEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandsModuleReadyEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets a list of all guild ids missing the application commands scope.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/ApplicationCommandsModuleStartupFinishedEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.ApplicationCommandsModuleStartupFinished&quot; /&gt;
///     event.
/// &lt;/summary&gt;
public sealed class ApplicationCommandsModuleStartupFinishedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandsModuleStartupFinishedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets a list of all guild ids missing the application commands scope.
⋮----
///     Gets all registered global commands.
⋮----
///     Gets all registered guild commands mapped by guild id.
⋮----
///     Gets the shard id of the shard that finished loading.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/GlobalApplicationCommandsRegisteredEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.GlobalApplicationCommandsRegistered&quot; /&gt; event.
/// &lt;/summary&gt;
public sealed class GlobalApplicationCommandsRegisteredEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GlobalApplicationCommandsRegisteredEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets all registered global commands.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/Module/GuildApplicationCommandsRegisteredEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.GuildApplicationCommandsRegistered&quot; /&gt; event.
/// &lt;/summary&gt;
public sealed class GuildApplicationCommandsRegisteredEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildApplicationCommandsRegisteredEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the target guild id.
⋮----
///     Gets all registered guild commands.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandErrorEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.SlashCommandErrored&quot; /&gt; event
/// &lt;/summary&gt;
public class SlashCommandErrorEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SlashCommandErrorEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     The context of the command.
⋮----
///     The exception thrown.</file><file path="DisCatSharp.ApplicationCommands/EventArgs/SlashCommand/SlashCommandExecutedEventArgs.cs">/// &lt;summary&gt;
///     Represents the arguments for a &lt;see cref=&quot;ApplicationCommandsExtension.SlashCommandExecuted&quot; /&gt; event
/// &lt;/summary&gt;
public class SlashCommandExecutedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SlashCommandExecutedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     The context of the command.</file><file path="DisCatSharp.ApplicationCommands/Exceptions/ContextMenu/ContextMenuExecutionChecksFailedException.cs">/// &lt;summary&gt;
///     Thrown when a pre-execution check for a context menu command fails.
/// &lt;/summary&gt;
public sealed class ContextMenuExecutionChecksFailedException : Exception
⋮----
///     The list of failed checks.</file><file path="DisCatSharp.ApplicationCommands/Exceptions/SlashCommand/SlashExecutionChecksFailedException.cs">/// &lt;summary&gt;
///     Thrown when a pre-execution check for a slash command fails.
/// &lt;/summary&gt;
public class SlashExecutionChecksFailedException : Exception
⋮----
///     The list of failed checks.</file><file path="DisCatSharp.ApplicationCommands/ExtensionMethods.cs">/// &lt;summary&gt;
///     Defines various extension methods for application commands.
/// &lt;/summary&gt;
public static class ExtensionMethods
⋮----
///     Enables application commands on this &lt;see cref=&quot;DiscordClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to enable application commands for.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;Configuration to use.&lt;/param&gt;
/// &lt;returns&gt;Created &lt;see cref=&quot;ApplicationCommandsExtension&quot; /&gt;.&lt;/returns&gt;
public static ApplicationCommandsExtension UseApplicationCommands(
⋮----
throw new InvalidOperationException(&quot;Application commands are already enabled for that client.&quot;);
⋮----
var scomm = new ApplicationCommandsExtension(config);
client.AddExtension(scomm);
⋮----
///     Gets the application commands module for this client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to get application commands for.&lt;/param&gt;
/// &lt;returns&gt;The module, or null if not activated.&lt;/returns&gt;
public static ApplicationCommandsExtension GetApplicationCommands(this DiscordClient client)
⋮----
///     Gets the application commands from this &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to get application commands from.&lt;/param&gt;
/// &lt;returns&gt;A dictionary of current &lt;see cref=&quot;ApplicationCommandsExtension&quot; /&gt; with the key being the shard id.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt;&gt; GetApplicationCommandsAsync(this DiscordShardedClient client)
⋮----
await client.InitializeShardsAsync().ConfigureAwait(false);
return client.ShardClients.Values.ToDictionary(shard =&gt; shard.ShardId, shard =&gt; shard.GetExtension&lt;ApplicationCommandsExtension&gt;()!);
⋮----
///     Registers a command class with optional translation setup globally.
⋮----
/// &lt;param name=&quot;extensions&quot;&gt;Sharding extensions.&lt;/param&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;The command class to register.&lt;/typeparam&gt;
/// &lt;param name=&quot;translationSetup&quot;&gt;A callback to setup translations with.&lt;/param&gt;
public static void RegisterGlobalCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
⋮----
/// &lt;param name=&quot;type&quot;&gt;The &lt;see cref=&quot;System.Type&quot; /&gt; of the command class to register.&lt;/param&gt;
⋮----
public static void RegisterGlobalCommands(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Type type, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
⋮----
if (!typeof(ApplicationCommandsModule).IsAssignableFrom(type))
throw new ArgumentException(&quot;Command classes have to inherit from ApplicationCommandsModule&quot;, nameof(type));
⋮----
extension.RegisterGlobalCommands(type, translationSetup);
⋮----
///     Registers a command class with optional translation setup for a guild.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to register it on.&lt;/param&gt;
⋮----
public static void RegisterGuildCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
⋮----
public static void RegisterGuildCommands(this IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt; extensions, Type type, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt; translationSetup = null)
⋮----
extension.RegisterGuildCommands(type, guildId, translationSetup);
⋮----
///     Enables application commands on this &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to enable application commands on.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A dictionary of created &lt;see cref=&quot;ApplicationCommandsExtension&quot; /&gt; with the key being the shard id.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, ApplicationCommandsExtension&gt;&gt; UseApplicationCommandsAsync(this DiscordShardedClient client, ApplicationCommandsConfiguration? config = null)
⋮----
scomm ??= shard.UseApplicationCommands(config);
⋮----
///     Gets the name from the &lt;see cref=&quot;ChoiceNameAttribute&quot; /&gt; for this enum value.
⋮----
/// &lt;returns&gt;The name.&lt;/returns&gt;
public static string GetName&lt;T&gt;(this T e) where T : IConvertible
⋮----
var type = e.GetType();
var values = Enum.GetValues(type);
⋮----
where val == e.ToInt32(CultureInfo.InvariantCulture)
let memInfo = type.GetMember(type.GetEnumName(val))
⋮----
.GetCustomAttributes(typeof(ChoiceNameAttribute), false)
.FirstOrDefault() is ChoiceNameAttribute nameAttribute
⋮----
: type.GetEnumName(val)).FirstOrDefault()!;</file><file path="DisCatSharp.ApplicationCommands/GlobalSuppressions.cs"></file><file path="DisCatSharp.ApplicationCommands/Workers/ApplicationCommandWorker.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;CommandWorker&quot; /&gt;.
/// &lt;/summary&gt;
internal class CommandWorker
⋮----
///     Parses context menu application commands.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;methods&quot;&gt;List of method infos.&lt;/param&gt;
/// &lt;param name=&quot;translator&quot;&gt;The optional command translations.&lt;/param&gt;
/// &lt;returns&gt;Too much.&lt;/returns&gt;
⋮----
&gt; ParseContextMenuCommands(Type type, IEnumerable&lt;MethodInfo&gt; methods, List&lt;CommandTranslator&gt;? translator = null)
⋮----
var command = new DiscordApplicationCommand(contextAttribute.Name, null, null, contextAttribute.Type, nameLocalizations, null, contextAttribute.DefaultMemberPermissions, contextAttribute.IsNsfw, contextAttribute.AllowedContexts, contextAttribute.IntegrationTypes);
⋮----
var parameters = contextMethod.GetParameters();
if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.FirstOrDefault()?.ParameterType, typeof(ContextMenuContext)))
throw new ArgumentException($&quot;The first argument of the command &apos;{contextAttribute.Name}&apos; has to be an ContextMenuContext!&quot;);
⋮----
throw new ArgumentException($&quot;The context menu command &apos;{contextAttribute.Name}&apos; cannot have parameters!&quot;);
⋮----
contextMenuCommands.Add(new()
⋮----
commands.Add(command);
commandTypeSources.Add(new(type, type));
⋮----
return Task.FromResult((commands, commandTypeSources, contextMenuCommands, translator is not null));
⋮----
///     Parses single application commands.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The optional guild id.&lt;/param&gt;
⋮----
&gt; ParseBasicSlashCommandsAsync(Type type, IEnumerable&lt;MethodInfo&gt; methods, ulong? guildId = null, List&lt;CommandTranslator&gt;? translator = null)
⋮----
var parameters = method.GetParameters();
if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.FirstOrDefault()?.ParameterType, typeof(InteractionContext)))
throw new ArgumentException($&quot;The first argument of the command &apos;{commandAttribute.Name}&apos; has to be an InteractionContext!&quot;);
⋮----
var options = await ApplicationCommandsExtension.ParseParametersAsync(parameters.Skip(1), commandAttribute.Name, guildId).ConfigureAwait(false);
⋮----
commandMethods.Add(new()
⋮----
choices.Add(new(choice.Name, choice.Value, commandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations));
⋮----
throw new AggregateException($&quot;Failed to register choice &apos;{choice.Name}&apos; in command &apos;{commandAttribute.Name}&apos;&quot;, ex);
⋮----
localizedOptions.Add(new(option.Name, option.Description, option.Type, option.Required,
⋮----
commandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, commandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
⋮----
throw new AggregateException($&quot;Failed to register option &apos;{option.Name}&apos; in command &apos;{commandAttribute.Name}&apos;&quot;, ex);
⋮----
var payload = new DiscordApplicationCommand(commandAttribute.Name, commandAttribute.Description, (localizedOptions is not null &amp;&amp; localizedOptions.Count is not 0 ? localizedOptions : null) ?? (options is not null &amp;&amp; options.Count is not 0 ? options : null), ApplicationCommandType.ChatInput, nameLocalizations, descriptionLocalizations, commandAttribute.DefaultMemberPermissions,
⋮----
commands.Add(payload);
⋮----
throw new AggregateException($&quot;Failed to register command with method name &apos;{method.Name}&apos;&quot;, ex);
⋮----
///     Represents a &lt;see cref=&quot;NestedCommandWorker&quot; /&gt;.
⋮----
internal class NestedCommandWorker
⋮----
///     Parses application command groups.
⋮----
/// &lt;param name=&quot;types&quot;&gt;List of type infos.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;translator&quot;&gt;The optional group translations.&lt;/param&gt;
⋮----
&gt; ParseSlashGroupsAsync(Type type, List&lt;TypeInfo&gt; types, ulong? guildId = null, List&lt;GroupTranslator&gt;? translator = null)
⋮----
//Handles groups
⋮----
//Gets the attribute and methods in the group
⋮----
var submethods = subclassInfo.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null).ToList();
var subclasses = subclassInfo.DeclaredNestedTypes.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandGroupAttribute&gt;() is not null).ToList();
⋮----
//Initializes the command
var payload = new DiscordApplicationCommand(groupAttribute.Name, groupAttribute.Description, nameLocalizations: nameLocalizations, descriptionLocalizations: descriptionLocalizations, defaultMemberPermissions: groupAttribute.DefaultMemberPermissions, isNsfw: groupAttribute.IsNsfw, allowedContexts: groupAttribute.AllowedContexts,
⋮----
//Handles commands in the group
⋮----
//Gets the parameters and accounts for InteractionContext
var parameters = submethod.GetParameters();
if (parameters.Length is 0 || parameters is null || !ReferenceEquals(parameters.First().ParameterType, typeof(InteractionContext)))
⋮----
choices.AddRange(option.Choices.Select(choice =&gt; new DiscordApplicationCommandOptionChoice(choice.Name, choice.Value, subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations)));
⋮----
subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, subCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
⋮----
//Creates the subcommand and adds it to the main command
var subpayload = new DiscordApplicationCommandOption(commandAttribute.Name, commandAttribute.Description, ApplicationCommandOptionType.SubCommand, false, null, localizedOptions ?? options, nameLocalizations: subNameLocalizations, descriptionLocalizations: subDescriptionLocalizations);
⋮----
commandTypeSources.Add(new(subclassInfo, type));
⋮----
//Adds it to the method lists
commandMethods.Add(new(commandAttribute.Name, submethod));
groupCommands.Add(new()
⋮----
var command = new SubGroupCommand
⋮----
//Handles subgroups
⋮----
var subsubmethods = subclass.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null);
⋮----
var subCommandTranslation = subGroupCommandTranslation?.SubGroups.Single(sc =&gt; sc.Name == subgroupAttribute.Name);
⋮----
//Similar to the one for regular groups
⋮----
var parameters = subsubmethod.GetParameters();
⋮----
throw new ArgumentException($&quot;The first argument of the command &apos;{subgroupAttribute.Name}&apos; has to be an InteractionContext!&quot;);
⋮----
suboptions = [.. suboptions, .. await ApplicationCommandsExtension.ParseParametersAsync(parameters.Skip(1), subgroupAttribute.Name, guildId).ConfigureAwait(false)];
⋮----
var subSubCommandTranslation = subCommandTranslation?.Commands.Single(sc =&gt; sc.Name == commatt.Name);
⋮----
choices.AddRange(option.Choices.Select(choice =&gt; new DiscordApplicationCommandOptionChoice(choice.Name, choice.Value, subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).Choices.Single(c =&gt; c.Name == choice.Name).NameTranslations)));
⋮----
subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).NameTranslations, subSubCommandTranslation.Options.Single(o =&gt; o.Name == option.Name).DescriptionTranslations,
⋮----
var subsubpayload = new DiscordApplicationCommandOption(commatt.Name, commatt.Description, ApplicationCommandOptionType.SubCommand, false, null, (localizedOptions is not null &amp;&amp; localizedOptions.Count is not 0 ? localizedOptions : null) ?? (suboptions is not null &amp;&amp; suboptions.Count is not 0 ? suboptions : null), nameLocalizations: subSubNameLocalizations, descriptionLocalizations: subSubDescriptionLocalizations);
options.Add(subsubpayload);
commandMethods.Add(new(commatt.Name, subsubmethod));
currentMethods.Add(new(commatt.Name, subsubmethod));
⋮----
//Adds the group to the command and method lists
var subpayload = new DiscordApplicationCommandOption(subgroupAttribute.Name, subgroupAttribute.Description, ApplicationCommandOptionType.SubCommandGroup, false, null, options, nameLocalizations: subNameLocalizations, descriptionLocalizations: subDescriptionLocalizations);
command.SubCommands.Add(new()
⋮----
commandTypeSources.Add(new(subclass, type));
⋮----
//Accounts for lifespans for the sub group
⋮----
singletonModules.Add(ApplicationCommandsExtension.CreateInstance(subclass, ApplicationCommandsExtension.Configuration?.ServiceProvider));
⋮----
if (command.SubCommands.Count is not 0) subGroupCommands.Add(command);
⋮----
//Accounts for lifespans
⋮----
singletonModules.Add(ApplicationCommandsExtension.CreateInstance(subclassInfo, ApplicationCommandsExtension.Configuration?.ServiceProvider));</file><file path="DisCatSharp.ApplicationCommands/Workers/RegistrationWorker.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;RegistrationWorker&quot; /&gt;.
/// &lt;/summary&gt;
internal class RegistrationWorker
⋮----
///     Registers the global commands.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;commands&quot;&gt;The command list.&lt;/param&gt;
/// &lt;param name=&quot;entryPointCommand&quot;&gt;The entry point command.&lt;/param&gt;
/// &lt;returns&gt;A list of registered commands.&lt;/returns&gt;
internal static async Task&lt;List&lt;DiscordApplicationCommand&gt;?&gt; RegisterGlobalCommandsAsync(DiscordClient client, List&lt;DiscordApplicationCommand&gt; commands, DiscordApplicationCommand? entryPointCommand = null)
⋮----
if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Creating, re-using and overwriting application commands&quot;);
⋮----
var discordBackendCommand = await client.CreateGlobalApplicationCommandAsync(cmd).ConfigureAwait(false);
commands.Add(discordBackendCommand);
⋮----
var discordBackendCommand = await client.EditGlobalApplicationCommandAsync(key, action =&gt;
⋮----
action.Options = Optional.FromNullable(command.Options);
⋮----
}).ConfigureAwait(false);
⋮----
commands.AddRange(unchangedCommands);
⋮----
else if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; (unchangedCommands!.NotEmptyAndNotNull() || changedCommands!.NotEmptyAndNotNull()))
⋮----
if (changedCommands!.NotEmptyAndNotNull())
⋮----
if (unchangedCommands!.NotEmptyAndNotNull())
⋮----
else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Editing &amp; re-using application commands&quot;);
⋮----
else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Overwriting all application commands&quot;);
⋮----
overwriteList.Add(cmd);
⋮----
var discordBackendCommands = await client.BulkOverwriteGlobalApplicationCommandsAsync(overwriteList).ConfigureAwait(false);
commands.AddRange(discordBackendCommands);
⋮----
else if (globalCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Creating all application commands&quot;);
⋮----
var cmds = await client.BulkOverwriteGlobalApplicationCommandsAsync(globalCommandsCreateList).ConfigureAwait(false);
commands.AddRange(cmds);
⋮----
else if (globalCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Re-using all application commands&quot;);
⋮----
if (!globalCommandsDeleteList.NotEmptyAndNotNull())
return commands.NotEmpty() ? commands : null;
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GLOBAL] Deleting missing application commands&quot;);
⋮----
await client.DeleteGlobalApplicationCommandAsync(cmdId).ConfigureAwait(false);
⋮----
client.Logger.LogError(&quot;Could not delete global command {cmd}. Please clean up manually&quot;, cmdId);
⋮----
///     Registers the guild commands.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The target guild id.&lt;/param&gt;
⋮----
internal static async Task&lt;List&lt;DiscordApplicationCommand&gt;?&gt; RegisterGuildCommandsAsync(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt; commands)
⋮----
if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Creating, re-using and overwriting application commands. Guild ID: {guild}&quot;, guildId);
⋮----
var discordBackendCommand = await client.CreateGuildApplicationCommandAsync(guildId, cmd).ConfigureAwait(false);
⋮----
var discordBackendCommand = await client.EditGuildApplicationCommandAsync(guildId, key, action =&gt;
⋮----
else if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; (unchangedCommands!.NotEmptyAndNotNull() || changedCommands!.NotEmptyAndNotNull()))
⋮----
else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Editing &amp; re-using application commands. Guild ID: {guild}&quot;, guildId);
⋮----
else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.NotEmptyAndNotNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Overwriting all application commands. Guild ID: {guild}&quot;, guildId);
⋮----
var discordBackendCommands = await client.BulkOverwriteGuildApplicationCommandsAsync(guildId, overwriteList).ConfigureAwait(false);
⋮----
else if (guildCommandsCreateList!.NotEmptyAndNotNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.EmptyOrNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Creating all application commands. Guild ID: {guild}&quot;, guildId);
⋮----
var cmds = await client.BulkOverwriteGuildApplicationCommandsAsync(guildId, guildCommandsCreateList).ConfigureAwait(false);
⋮----
else if (guildCommandsCreateList!.EmptyOrNull() &amp;&amp; changedCommands!.EmptyOrNull() &amp;&amp; unchangedCommands!.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Re-using all application commands Guild ID: {guild}&quot;, guildId);
⋮----
if (!guildCommandsDeleteList.NotEmptyAndNotNull())
⋮----
client.Logger.Log(ApplicationCommandsExtension.ApplicationCommandsLogLevel, &quot;[AC GUILD] Deleting missing application commands. Guild ID: {guild}&quot;, guildId);
⋮----
await client.DeleteGuildApplicationCommandAsync(guildId, cmdId).ConfigureAwait(false);
⋮----
client.Logger.LogError(&quot;Could not delete guild command {cmd} in guild {guild}. Please clean up manually&quot;, cmdId, guildId);
⋮----
///     Builds a list of guild command ids to be deleted on discords backend.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id these commands belong to.&lt;/param&gt;
/// &lt;param name=&quot;updateList&quot;&gt;The command list.&lt;/param&gt;
/// &lt;returns&gt;A list of command ids.&lt;/returns&gt;
private static List&lt;ulong&gt;? BuildGuildDeleteList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
⋮----
|| !ApplicationCommandsExtension.GuildDiscordCommands!.TryGetFirstValueByKey(guildId, out var discord)
⋮----
invalidCommandIds.AddRange(discord.Select(cmd =&gt; cmd.Id));
⋮----
invalidCommandIds.AddRange(from cmd in discord where updateList.All(ul =&gt; ul.Name != cmd.Name) select cmd.Id);
⋮----
///     Builds a list of guild commands to be created on discords backend.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
private static List&lt;DiscordApplicationCommand&gt;? BuildGuildCreateList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
⋮----
var success = ApplicationCommandsExtension.GuildDiscordCommands.TryGetFirstValueByKey(guildId, out var discord);
⋮----
newCommands.AddRange(updateList.Where(cmd =&gt; discord.All(d =&gt; d.Name != cmd.Name)));
⋮----
///     Builds a list of guild commands to be overwritten on discords backend.
⋮----
/// &lt;returns&gt;A dictionary of command id and command.&lt;/returns&gt;
⋮----
) BuildGuildOverwriteList(DiscordClient client, ulong guildId, List&lt;DiscordApplicationCommand&gt;? updateList = null)
⋮----
|| ApplicationCommandsExtension.GuildDiscordCommands.All(l =&gt; l.Key != guildId) || updateList is null
⋮----
if (discord!.TryGetFirstValueWhere(d =&gt; d?.Name == cmd.Name, out var command))
if (command.IsEqualTo(cmd, client, true))
⋮----
client.Logger.LogDebug(&quot;[AC] Command {cmdName} unchanged&quot;, cmd.Name);
⋮----
unchangedCommands.Add(cmd);
⋮----
client.Logger.LogDebug(&quot;[AC] Command {cmdName} changed&quot;, cmd.Name);
updateCommands.Add(command.Id, cmd);
⋮----
///     Builds a list of global command ids to be deleted on discords backend.
⋮----
private static List&lt;ulong&gt;? BuildGlobalDeleteList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null, DiscordApplicationCommand? entryPointCommand = null)
⋮----
if (entryPointCommand is not null &amp;&amp; invalidCommandIds.Contains(entryPointCommand.Id))
invalidCommandIds.Remove(entryPointCommand.Id);
⋮----
///     Builds a list of global commands to be created on discords backend.
⋮----
/// &lt;returns&gt;A list of commands.&lt;/returns&gt;
private static List&lt;DiscordApplicationCommand&gt;? BuildGlobalCreateList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null, DiscordApplicationCommand? entryPointCommand = null)
⋮----
if (entryPointCommand is not null &amp;&amp; newCommands.All(command =&gt; command.Name != &quot;launch&quot;))
newCommands.Add(entryPointCommand);
⋮----
///     Builds a list of global commands to be overwritten on discords backend.
⋮----
/// &lt;returns&gt;A dictionary of command ids and commands.&lt;/returns&gt;
⋮----
) BuildGlobalOverwriteList(DiscordClient client, List&lt;DiscordApplicationCommand&gt;? updateList = null)
⋮----
if (command.IsEqualTo(cmd, client, false))
⋮----
changedCommands.Add(command.Id, cmd);</file><file path="DisCatSharp.Attributes/DeprecatedAttribute.cs">/// &lt;summary&gt;
///     Marks something as deprecated by DisCatSharp.
/// &lt;/summary&gt;
⋮----
public sealed class DeprecatedAttribute : Attribute
⋮----
///     The additional information message.</file><file path="DisCatSharp.Attributes/DisCatSharp.Attributes.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;VersionPrefix&gt;2025.03.27&lt;/VersionPrefix&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; != &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)-$(BuildNumber)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/FileVersion&gt;
		&lt;PackageVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/PackageVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
		&lt;PackageVersion&gt;$(VersionPrefix).0&lt;/PackageVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
		&lt;PackageVersion&gt;$(VersionPrefix).0&lt;/PackageVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;TargetFrameworks&gt;netstandard2.0&lt;/TargetFrameworks&gt;
		&lt;GeneratePackageOnBuild&gt;True&lt;/GeneratePackageOnBuild&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
	&lt;/PropertyGroup&gt;
		
	&lt;PropertyGroup&gt;
		&lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
		&lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;
		&lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;
		&lt;DebugType&gt;Portable&lt;/DebugType&gt;
		&lt;AllowedOutputExtensionsInPackageBuildOutputFolder&gt;$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb&lt;/AllowedOutputExtensionsInPackageBuildOutputFolder&gt;
		&lt;PackageReleaseNotes&gt;$([System.IO.File]::ReadAllText(&quot;$(MSBuildProjectDirectory)/../RELEASENOTES.md&quot;))&lt;/PackageReleaseNotes&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(TF_BUILD)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(CI)&apos; == &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; != &apos;true&apos; And &apos;$(TF_BUILD)&apos; != &apos;true&apos; And &apos;$(CI)&apos; != &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;false&lt;/ContinuousIntegrationBuild&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos; And &apos;$(SENTRY_AUTH_TOKEN)&apos; != &apos;&apos;&quot;&gt;
		&lt;SentryOrg&gt;aitsys&lt;/SentryOrg&gt;
		&lt;SentryProject&gt;discatsharp&lt;/SentryProject&gt;
		&lt;SentryUploadSymbols&gt;true&lt;/SentryUploadSymbols&gt;
		&lt;SentryUploadSources&gt;true&lt;/SentryUploadSources&gt;
		&lt;UseSentryCLI&gt;true&lt;/UseSentryCLI&gt;
		&lt;SentryCreateRelease&gt;true&lt;/SentryCreateRelease&gt;
		&lt;SentrySetCommits&gt;true&lt;/SentrySetCommits&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;Authors&gt;AITSYS, DisCatSharp, DisCatSharp Contributors&lt;/Authors&gt;
		&lt;Company&gt;AITSYS&lt;/Company&gt;
		&lt;GeneratePackageOnBuild&gt;False&lt;/GeneratePackageOnBuild&gt;
		&lt;PackageProjectUrl&gt;https://docs.dcs.aitsys.dev&lt;/PackageProjectUrl&gt;
		&lt;RepositoryUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/RepositoryUrl&gt;
		&lt;RepositoryType&gt;Git&lt;/RepositoryType&gt;
		&lt;PackageIcon&gt;logo-pride.png&lt;/PackageIcon&gt;
		&lt;PackageLicenseExpression /&gt;
		&lt;PackageLicenseFile&gt;LICENSE.md&lt;/PackageLicenseFile&gt;
		&lt;PackageRequireLicenseAcceptance&gt;True&lt;/PackageRequireLicenseAcceptance&gt;
		&lt;RunAnalyzersDuringBuild&gt;False&lt;/RunAnalyzersDuringBuild&gt;
		&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\LICENSE.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\RELEASENOTES.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\DisCatSharp.Logos\logo-pride.png&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Attributes&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Attributes&lt;/RootNamespace&gt;
		&lt;Title&gt;DisCatSharp Attributes&lt;/Title&gt;
	&lt;/PropertyGroup&gt;
	
	&lt;PropertyGroup&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;NETSDK1188;CS8600;CS8625;CS8601;CS8604;CS0219;CS8618;CS8619;CS8597;CS8603;CS8602;CS8765;CS8632;CS8633;CS8714;CS8629;CS8767;CS8620&lt;/NoWarn&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;
	
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Debug&apos;&quot;&gt;
		&lt;Optimize&gt;False&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;
	
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Release&apos;&quot;&gt;
		&lt;Optimize&gt;True&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Attributes&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp.Attributes

			Special Attributes for DisCatSharp.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,DisCatSharp Attributes&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Attributes/DisCatSharp.Attributes.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Attributes/DiscordDeprecatedAttribute.cs">/// &lt;summary&gt;
///     Marks something as deprecated by discord.
/// &lt;/summary&gt;
⋮----
public sealed class DiscordDeprecatedAttribute : Attribute
⋮----
///     The additional information message.</file><file path="DisCatSharp.Attributes/DiscordInExperimentAttribute.cs">/// &lt;summary&gt;
///     Marks something as in experiment by discord.
/// &lt;/summary&gt;
⋮----
public sealed class DiscordInExperimentAttribute : Attribute
⋮----
///     The additional information message.</file><file path="DisCatSharp.Attributes/DiscordUnreleasedAttribute.cs">/// &lt;summary&gt;
///     Marks something as unreleased by discord.
/// &lt;/summary&gt;
⋮----
public sealed class DiscordUnreleasedAttribute : Attribute
⋮----
///     The additional information message.</file><file path="DisCatSharp.Attributes/ExperimentalAttribute.cs">/// &lt;summary&gt;
///     Marks something as experimental by DisCatSharp.
/// &lt;/summary&gt;
⋮----
public sealed class ExperimentalAttribute : Attribute
⋮----
///     The additional information message.</file><file path="DisCatSharp.Attributes/Features.cs">/// &lt;summary&gt;
///     Features enum.
/// &lt;/summary&gt;
⋮----
///     Defines a readable name for this feature requirement.
⋮----
public sealed class FeatureDescriptionAttribute : Attribute
⋮----
/// &lt;param name=&quot;description&quot;&gt;Readable name for this feature requirement.&lt;/param&gt;
⋮----
///     Gets the readable name for this feature requirement.</file><file path="DisCatSharp.Attributes/GlobalSuppressions.cs">// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.</file><file path="DisCatSharp.Attributes/Properties/AssemblyProperties.cs"></file><file path="DisCatSharp.Attributes/RequiresFeatureAttribute.cs">/// &lt;summary&gt;
///     Informs that something requires a certain feature to use it.
/// &lt;/summary&gt;
⋮----
public sealed class RequiresFeatureAttribute : Attribute
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequiresFeatureAttribute&quot; /&gt; class with specified features and a
///     message.
⋮----
/// &lt;param name=&quot;features&quot;&gt;Specifies the required features.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;Provides a message that describes the requirement or purpose of the attribute.&lt;/param&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequiresFeatureAttribute&quot; /&gt; class.
⋮----
///     The additional information message.
⋮----
///     The required features.</file><file path="DisCatSharp.Attributes/RequiresOverrideAttribute.cs">/// &lt;summary&gt;
///     Informs that something requires a certain override to use it.
/// &lt;/summary&gt;
⋮----
public sealed class RequiresOverrideAttribute : Attribute
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequiresOverrideAttribute&quot; /&gt; class with specified override
///     information.
⋮----
/// &lt;param name=&quot;lastKnownOverride&quot;&gt;Specifies the last known working override value.&lt;/param&gt;
/// &lt;param name=&quot;overrideDate&quot;&gt;Specifies the date of the override.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;Provides a message associated with the attribute for additional context.&lt;/param&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequiresOverrideAttribute&quot; /&gt; class with a specified override value.
⋮----
///     The additional information message.
⋮----
///     The last known working override.
⋮----
///     The date of the override.</file><file path="DisCatSharp.CommandsNext/Attributes/AliasesAttribute.cs">/// &lt;summary&gt;
///     Adds aliases to this command or group.
/// &lt;/summary&gt;
⋮----
public sealed class AliasesAttribute : Attribute
⋮----
/// &lt;param name=&quot;aliases&quot;&gt;Aliases to add to this command or group.&lt;/param&gt;
⋮----
if (aliases.Any(xa =&gt; xa == null || xa.Any(xc =&gt; char.IsWhiteSpace(xc))))
throw new ArgumentException(&quot;Aliases cannot contain whitespace characters or null strings.&quot;, nameof(aliases));
⋮----
///     Gets this group&apos;s aliases.</file><file path="DisCatSharp.CommandsNext/Attributes/CheckBaseAttribute.cs">/// &lt;summary&gt;
///     Represents a base for all command pre-execution check attributes.
/// &lt;/summary&gt;
⋮----
public abstract class CheckBaseAttribute : Attribute
⋮----
///     Asynchronously checks whether this command can be executed within given context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context to check execution ability for.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;
///     Whether this check is being executed from help or not. This can be used to probe whether command can
///     be run without setting off certain fail conditions (such as cooldowns).
/// &lt;/param&gt;
/// &lt;returns&gt;Whether the command can be executed in given context.&lt;/returns&gt;
public abstract Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help);</file><file path="DisCatSharp.CommandsNext/Attributes/CommandAttribute.cs">/// &lt;summary&gt;
///     Marks this method as a command.
/// &lt;/summary&gt;
⋮----
public sealed class CommandAttribute : Attribute
⋮----
///     Marks this method as a command, using the method&apos;s name as command name.
⋮----
///     Marks this method as a command with specified name.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of this command.&lt;/param&gt;
⋮----
if (string.IsNullOrWhiteSpace(name))
throw new ArgumentNullException(nameof(name), &quot;Command names cannot be null, empty, or all-whitespace.&quot;);
⋮----
if (name.Any(xc =&gt; char.IsWhiteSpace(xc)))
throw new ArgumentException(&quot;Command names cannot contain whitespace characters.&quot;, nameof(name));
⋮----
///     Gets the name of this command.
⋮----
///     Marks this method as a group command.
⋮----
public sealed class GroupCommandAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/CooldownAttribute.cs">/// &lt;summary&gt;
///     Defines a cooldown for this command. This allows you to define how many times can users execute a specific command
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     Defines a cooldown for this command. This means that users will be able to use the command a specific number of
///     times before they have to wait to use it again.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;maxUses&quot;&gt;Number of times the command can be used before triggering a cooldown.&lt;/param&gt;
/// &lt;param name=&quot;resetAfter&quot;&gt;Number of seconds after which the cooldown is reset.&lt;/param&gt;
/// &lt;param name=&quot;bucketType&quot;&gt;
///     Type of cooldown bucket. This allows controlling whether the bucket will be cooled down per
///     user, guild, channel, or globally.
/// &lt;/param&gt;
/// &lt;param name=&quot;cooldownResponderType&quot;&gt;The responder type used to respond to cooldown ratelimit hits.&lt;/param&gt;
⋮----
public sealed class CooldownAttribute(int maxUses, double resetAfter, CooldownBucketType bucketType, Type? cooldownResponderType = null) : CheckBaseAttribute, ICooldown&lt;CommandContext, CooldownBucket&gt;
⋮----
///     Gets the responder type.
⋮----
///     Gets the maximum number of uses before this command triggers a cooldown for its bucket.
⋮----
///     Gets the time after which the cooldown is reset.
⋮----
public TimeSpan Reset { get; } = TimeSpan.FromSeconds(resetAfter);
⋮----
///     Gets the type of the cooldown bucket. This determines how cooldowns are applied.
⋮----
///     Gets a cooldown bucket for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Command context to get cooldown bucket for.&lt;/param&gt;
/// &lt;returns&gt;Requested cooldown bucket, or null if one wasn&apos;t present.&lt;/returns&gt;
public CooldownBucket GetBucket(CommandContext ctx)
⋮----
var bid = this.GetBucketId(ctx, out _, out _, out _);
ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket);
⋮----
///     Calculates the cooldown remaining for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate the cooldown.&lt;/param&gt;
/// &lt;returns&gt;Remaining cooldown, or zero if no cooldown is active.&lt;/returns&gt;
public TimeSpan GetRemainingCooldown(CommandContext ctx)
⋮----
var bucket = this.GetBucket(ctx);
⋮----
/// &lt;inheritdoc /&gt;
public async Task&lt;bool&gt; RespondRatelimitHitAsync(CommandContext ctx, bool noHit, CooldownBucket bucket)
⋮----
await ctx.Message.CreateReactionAsync(DiscordEmoji.FromName(ctx.Client, &quot;:x:&quot;, false));
⋮----
// ignore
⋮----
var providerMethod = this.ResponderType.GetMethod(nameof(ICooldownResponder.Responder));
var providerInstance = Activator.CreateInstance(this.ResponderType);
await ((Task)providerMethod.Invoke(providerInstance, [ctx, bucket])).ConfigureAwait(false);
⋮----
///     Calculates bucket ID for given command context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate bucket ID for.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;ID of the user with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;ID of the channel with which this bucket is associated.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;ID of the guild with which this bucket is associated.&lt;/param&gt;
/// &lt;returns&gt;Calculated bucket ID.&lt;/returns&gt;
private string GetBucketId(CommandContext ctx, out ulong userId, out ulong channelId, out ulong guildId)
⋮----
if (this.BucketType.HasFlag(CooldownBucketType.User))
⋮----
if (this.BucketType.HasFlag(CooldownBucketType.Channel))
⋮----
if (this.BucketType.HasFlag(CooldownBucketType.Guild) &amp;&amp; ctx.Guild is null)
⋮----
if (ctx.Guild is not null &amp;&amp; this.BucketType.HasFlag(CooldownBucketType.Guild))
⋮----
var bid = CooldownBucket.MakeId(ctx.Command.QualifiedName, &quot;text&quot;, userId, channelId, guildId);
⋮----
///     Executes a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
var bid = this.GetBucketId(ctx, out var usr, out var chn, out var gld);
if (ctx.Client.CommandCooldownBuckets.TryGetValue(bid, out var bucket))
return await this.RespondRatelimitHitAsync(ctx, await bucket.DecrementUseAsync(ctx), bucket);
⋮----
ctx.Client.CommandCooldownBuckets.AddOrUpdate(bid, bucket, (k, v) =&gt; bucket);</file><file path="DisCatSharp.CommandsNext/Attributes/DescriptionAttribute.cs">/// &lt;summary&gt;
///     Gives this command, group, or argument a description, which is used when listing help.
/// &lt;/summary&gt;
⋮----
public sealed class DescriptionAttribute : Attribute
⋮----
/// &lt;param name=&quot;description&quot;&gt;&lt;/param&gt;
⋮----
///     Gets the description for this command, group, or argument.</file><file path="DisCatSharp.CommandsNext/Attributes/DontInjectAttribute.cs">/// &lt;summary&gt;
///     Prevents this field or property from having its value injected by dependency injection.
/// &lt;/summary&gt;
⋮----
public class DontInjectAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/GroupAttribute.cs">/// &lt;summary&gt;
///     Marks this class as a command group.
/// &lt;/summary&gt;
⋮----
public sealed class GroupAttribute : Attribute
⋮----
///     Marks this class as a command group, using the class&apos; name as group name.
⋮----
///     Marks this class as a command group with specified name.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of this group.&lt;/param&gt;
⋮----
if (string.IsNullOrWhiteSpace(name))
throw new ArgumentNullException(nameof(name), &quot;Group names cannot be null, empty, or all-whitespace.&quot;);
⋮----
if (name.Any(xc =&gt; char.IsWhiteSpace(xc)))
throw new ArgumentException(&quot;Group names cannot contain whitespace characters.&quot;, nameof(name));
⋮----
///     Gets the name of this group.</file><file path="DisCatSharp.CommandsNext/Attributes/HiddenAttribute.cs">/// &lt;summary&gt;
///     Marks this command or group as hidden.
/// &lt;/summary&gt;
⋮----
public sealed class HiddenAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/ModuleLifespanAttribute.cs">/// &lt;summary&gt;
///     Defines a lifespan for this command module.
/// &lt;/summary&gt;
⋮----
public class ModuleLifespanAttribute : Attribute
⋮----
/// &lt;param name=&quot;lifespan&quot;&gt;Lifespan for this module.&lt;/param&gt;
⋮----
///     Gets the lifespan defined for this module.
⋮----
///     Defines lifespan of a command module.
⋮----
///     Defines that this module will be instantiated once.
⋮----
///     Defines that this module will be instantiated every time a containing command is called.</file><file path="DisCatSharp.CommandsNext/Attributes/PriorityAttribute.cs">/// &lt;summary&gt;
///     Defines this command overload&apos;s priority. This determines the order in which overloads will be attempted to be
///     called. Commands will be attempted in order of priority, in descending order.
/// &lt;/summary&gt;
⋮----
public sealed class PriorityAttribute : Attribute
⋮----
/// &lt;param name=&quot;priority&quot;&gt;Priority of this command overload.&lt;/param&gt;
⋮----
///     Gets the priority of this command overload.</file><file path="DisCatSharp.CommandsNext/Attributes/RemainingTextAttribute.cs">/// &lt;summary&gt;
///     Indicates that the command argument takes the rest of the input without parsing.
/// &lt;/summary&gt;
⋮----
public class RemainingTextAttribute : Attribute</file><file path="DisCatSharp.CommandsNext/Attributes/RequireBoostingAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to boosters.
/// &lt;/summary&gt;
⋮----
public sealed class RequireBoostingAttribute : CheckBaseAttribute
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequireBoostingAttribute&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;days&quot;&gt;Boosting since days.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;Target guild id.&lt;/param&gt;
⋮----
///     Gets the required boost time.
⋮----
///     Gets the required guild.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
var guild = await ctx.Client.GetGuildAsync(this.GuildId).ConfigureAwait(false);
var member = await guild.GetMemberAsync(ctx.User.Id).ConfigureAwait(false);
return member != null &amp;&amp; member.PremiumSince.HasValue ? await Task.FromResult(member.PremiumSince.Value.UtcDateTime.Date &lt; DateTime.UtcNow.Date.AddDays(-this.Since)).ConfigureAwait(false) : await Task.FromResult(false).ConfigureAwait(false);
⋮----
return ctx.Member != null &amp;&amp; ctx.Member.PremiumSince.HasValue ? await Task.FromResult(ctx.Member.PremiumSince.Value.UtcDateTime.Date &lt; DateTime.UtcNow.Date.AddDays(-this.Since)).ConfigureAwait(false) : await Task.FromResult(false).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireBotPermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is only possible when the bot is granted a specific permission.
/// &lt;/summary&gt;
⋮----
public sealed class RequireBotPermissionsAttribute : CheckBaseAttribute
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
channel = await ctx.Client.GetChannelAsync(ctx.Channel.Id, true).ConfigureAwait(false);
var pbot = channel.PermissionsFor(bot);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireCertifiedModeratorAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to discord certified moderators.
/// &lt;/summary&gt;
⋮----
public sealed class RequireCertifiedModeratorAttribute : CheckBaseAttribute
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; ctx.User.Flags.HasValue ? Task.FromResult(ctx.User.Flags.Value.HasFlag(UserFlags.CertifiedModerator)) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireCommunityAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable within a community-enabled guild.
/// &lt;/summary&gt;
⋮----
public sealed class RequireCommunityAttribute : CheckBaseAttribute
⋮----
///     Defines that this command is only usable within a community-enabled guild.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.IsCommunity);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireDirectMessageAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable within a direct message channel.
/// &lt;/summary&gt;
⋮----
public sealed class RequireDirectMessageAttribute : CheckBaseAttribute
⋮----
///     Defines that this command is only usable within a direct message channel.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
=&gt; Task.FromResult(ctx.Channel is DiscordDmChannel);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireGuildAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable within a guild.
/// &lt;/summary&gt;
public sealed class RequireGuildAttribute : CheckBaseAttribute
⋮----
///     Defines that this command is only usable within a guild.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
=&gt; Task.FromResult(ctx.Guild != null);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireGuildOwnerAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to the guild owner.
/// &lt;/summary&gt;
⋮----
public sealed class RequireGuildOwnerAttribute : CheckBaseAttribute
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
var guild = await Task.FromResult(ctx.Guild != null).ConfigureAwait(false);
⋮----
var owner = await Task.FromResult(ctx.Member == ctx.Guild.Owner).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireMemberVerificationGateAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable within a guild which has enabled the member verification gate.
/// &lt;/summary&gt;
public sealed class RequireMemberVerificationGateAttribute : CheckBaseAttribute
⋮----
///     Defines that this command is only usable within guild which has enabled the member verification gate.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.HasMemberVerificationGate);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireNsfwAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to NSFW channels.
/// &lt;/summary&gt;
⋮----
public sealed class RequireNsfwAttribute : CheckBaseAttribute
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
=&gt; Task.FromResult(ctx.Channel.Guild == null || ctx.Channel.IsNsfw);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireOwnerAttribute.cs">// TODO: Like in applciation commands, allow the different team roles to be chosen
/// &lt;summary&gt;
///     Defines that usage of this command is restricted to the owner(s) of the bot.
/// &lt;/summary&gt;
⋮----
public sealed class RequireOwnerAttribute : CheckBaseAttribute
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
return app != null ? Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id)) : Task.FromResult(ctx.User.Id == me.Id);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireOwnerOrIdAttribute.cs">// TODO: Like in applciation commands, allow the different team roles to be chosen
/// &lt;summary&gt;
///     Requires ownership of the bot or a whitelisted id to execute this command.
/// &lt;/summary&gt;
⋮----
public sealed class RequireOwnerOrIdAttribute : CheckBaseAttribute
⋮----
///     Defines that usage of this command is restricted to the owner or whitelisted ids of the bot.
⋮----
/// &lt;param name=&quot;userIds&quot;&gt;List of allowed user ids&lt;/param&gt;
⋮----
///     Allowed user ids
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
var owner = app != null ? await Task.FromResult(app.Members.Any(x =&gt; x.Id == ctx.User.Id)).ConfigureAwait(false) : await Task.FromResult(ctx.User.Id == me.Id).ConfigureAwait(false);
⋮----
var allowed = this.UserIds.Contains(ctx.User.Id);</file><file path="DisCatSharp.CommandsNext/Attributes/RequirePermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to members with specified permissions. This check also verifies
///     that the bot has the same permissions.
/// &lt;/summary&gt;
⋮----
public sealed class RequirePermissionsAttribute : CheckBaseAttribute
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override async Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
channel = await ctx.Client.GetChannelAsync(ctx.Channel.Id, true).ConfigureAwait(false);
⋮----
var pusr = channel.PermissionsFor(usr);
⋮----
var bot = await ctx.Guild.GetMemberAsync(ctx.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
var pbot = channel.PermissionsFor(bot);</file><file path="DisCatSharp.CommandsNext/Attributes/RequirePrefixesAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is only allowed with specific prefixes.
/// &lt;/summary&gt;
⋮----
public sealed class RequirePrefixesAttribute : CheckBaseAttribute
⋮----
/// &lt;param name=&quot;prefixes&quot;&gt;Prefixes with which the execution of this command is allowed.&lt;/param&gt;
⋮----
throw new ArgumentNullException(nameof(prefixes), &quot;The allowed prefix collection cannot be null or empty.&quot;);
⋮----
///     Gets the array of prefixes with which execution of this command is allowed.
⋮----
///     &lt;para&gt;
///         Gets or sets default help behaviour for this check. When this is enabled, invoking help without matching
///         prefix will show the commands.
///     &lt;/para&gt;
///     &lt;para&gt;Defaults to false.&lt;/para&gt;
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
=&gt; Task.FromResult((help &amp;&amp; this.ShowInHelp) || this.Prefixes.Contains(ctx.Prefix, ctx.CommandsNext.GetStringComparer()));</file><file path="DisCatSharp.CommandsNext/Attributes/RequireReferencedMessageAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable when sent in reply. Command will appear in help regardless of this attribute.
/// &lt;/summary&gt;
public sealed class RequireReferencedMessageAttribute : CheckBaseAttribute
⋮----
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
=&gt; Task.FromResult(help || ctx.Message.ReferencedMessage != null);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireRolesAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to members with specified role. Note that it&apos;s much preferred to
///     restrict access using &lt;see cref=&quot;RequirePermissionsAttribute&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
public sealed class RequireRolesAttribute : CheckBaseAttribute
⋮----
/// &lt;param name=&quot;checkMode&quot;&gt;Role checking mode.&lt;/param&gt;
/// &lt;param name=&quot;roleNames&quot;&gt;Names of the role to be verified by this check.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;roleIds&quot;&gt;Ids of the role to be verified by this check.&lt;/param&gt;
⋮----
///		Gets whether role ids are used.
⋮----
///     Gets the name of the role required to execute this command.
⋮----
///     Gets the ids of the role required to execute this command.
⋮----
///     Gets the role checking mode. Refer to &lt;see cref=&quot;RoleCheckMode&quot; /&gt; for more information.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
return Task.FromResult(false);
⋮----
var rns = ctx.Member.Roles.Select(xr =&gt; xr.Id);
rnc = rns.Count();
var ins = rns.Where(this.RoleIds.Contains);
inc = ins.Count();
⋮----
var rns = ctx.Member.Roles.Select(xr =&gt; xr.Name);
⋮----
var ins = rns.Intersect(this.RoleNames, ctx.CommandsNext.GetStringComparer());
⋮----
RoleCheckMode.All =&gt; Task.FromResult(this.UsesRoleIds ? this.RoleIds.Count == inc : this.RoleNames.Count == inc),
RoleCheckMode.SpecifiedOnly =&gt; Task.FromResult(rnc == inc),
RoleCheckMode.None =&gt; Task.FromResult(inc == 0),
_ =&gt; Task.FromResult(inc &gt; 0)
⋮----
///     Specifies how does &lt;see cref=&quot;RequireRolesAttribute&quot; /&gt; check for roles.
⋮----
///     Member is required to have any of the specified roles.
⋮----
///     Member is required to have all of the specified roles.
⋮----
///     Member is required to have exactly the same roles as specified; no extra roles may be present.
⋮----
///     Member is required to have none of the specified roles.</file><file path="DisCatSharp.CommandsNext/Attributes/RequireStaffAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to discord employees.
/// &lt;/summary&gt;
⋮----
public sealed class RequireStaffAttribute : CheckBaseAttribute
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; ctx.User.Flags.HasValue ? Task.FromResult(ctx.User.Flags.Value.HasFlag(UserFlags.Staff)) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireUserPermissionsAttribute.cs">/// &lt;summary&gt;
///     Defines that usage of this command is restricted to members with specified permissions.
/// &lt;/summary&gt;
⋮----
public sealed class RequireUserPermissionsAttribute : CheckBaseAttribute
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;Permissions required to execute this command.&lt;/param&gt;
/// &lt;param name=&quot;ignoreDms&quot;&gt;
///     Sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false
///     means that it will always fail.
/// &lt;/param&gt;
⋮----
///     Gets the permissions required by this attribute.
⋮----
///     Gets or sets this check&apos;s behaviour in DMs. True means the check will always pass in DMs, whereas false means that
///     it will always fail.
⋮----
///     Executes the a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
⋮----
return Task.FromResult(this.IgnoreDms);
⋮----
return Task.FromResult(false);
⋮----
return Task.FromResult(true);
⋮----
var pusr = ctx.Channel.PermissionsFor(usr);
⋮----
return (pusr &amp; this.Permissions) == this.Permissions ? Task.FromResult(true) : Task.FromResult(false);</file><file path="DisCatSharp.CommandsNext/Attributes/RequireWelcomeScreenAttribute.cs">/// &lt;summary&gt;
///     Defines that a command is only usable within a guild which has enabled the welcome screen.
/// &lt;/summary&gt;
⋮----
public sealed class RequireWelcomeScreenAttribute : CheckBaseAttribute
⋮----
///     Defines that this command is only usable within a guild which has enabled the welcome screen.
⋮----
///     Executes a check.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;If true, help - returns true.&lt;/param&gt;
public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help) =&gt; Task.FromResult(ctx.Guild != null &amp;&amp; ctx.Guild.HasWelcomeScreen);</file><file path="DisCatSharp.CommandsNext/BaseCommandModule.cs">/// &lt;summary&gt;
///     Represents a base class for all command modules.
/// &lt;/summary&gt;
public abstract class BaseCommandModule
⋮----
///     Called before a command in the implementing module is executed.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context in which the method is being executed.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public virtual Task BeforeExecutionAsync(CommandContext ctx)
=&gt; Task.Delay(0);
⋮----
///     Called after a command in the implementing module is successfully executed.
⋮----
public virtual Task AfterExecutionAsync(CommandContext ctx)</file><file path="DisCatSharp.CommandsNext/CommandsNextConfiguration.cs">/// &lt;summary&gt;
///     &lt;para&gt;
///         Represents a delegate for a function that takes a message, and returns the position of the start of command
///         invocation in the message. It has to return -1 if prefix is not present.
///     &lt;/para&gt;
⋮----
///         It is recommended that helper methods
///         &lt;see cref=&quot;CommandsNextUtilities.GetStringPrefixLength(DiscordMessage, string, StringComparison)&quot; /&gt; and
///         &lt;see cref=&quot;CommandsNextUtilities.GetMentionPrefixLength(DiscordMessage, DiscordUser)&quot; /&gt;
///         be used internally for checking. Their output can be passed through.
⋮----
/// &lt;/summary&gt;
/// &lt;param name=&quot;msg&quot;&gt;Message to check for prefix.&lt;/param&gt;
/// &lt;returns&gt;Position of the command invocation or -1 if not present.&lt;/returns&gt;
⋮----
///     Represents a configuration for &lt;see cref=&quot;CommandsNextExtension&quot; /&gt;.
⋮----
public sealed class CommandsNextConfiguration
⋮----
///     Creates a new configuration with default values.
⋮----
///     Utilized via dependency injection pipeline.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The service provider.&lt;/param&gt;
⋮----
///     Creates a new instance of &lt;see cref=&quot;CommandsNextConfiguration&quot; /&gt;, copying the properties of another
///     configuration.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Configuration the properties of which are to be copied.&lt;/param&gt;
⋮----
///     &lt;para&gt;Sets the string prefixes used for commands.&lt;/para&gt;
///     &lt;para&gt;Defaults to no value (disabled).&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the custom prefix resolver used for commands.&lt;/para&gt;
///     &lt;para&gt;Defaults to none (disabled).&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether to allow mentioning the bot to be used as command prefix.&lt;/para&gt;
///     &lt;para&gt;Defaults to true.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether strings should be matched in a case-sensitive manner.&lt;/para&gt;
///     &lt;para&gt;This switch affects the behaviour of default prefix resolver, command searching, and argument conversion.&lt;/para&gt;
///     &lt;para&gt;Defaults to false.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether to enable default help command.&lt;/para&gt;
///     &lt;para&gt;Disabling this will allow you to make your own help command.&lt;/para&gt;
⋮----
///         Modifying default help can be achieved via custom help formatters (see
///         &lt;see cref=&quot;DisCatSharp.CommandsNext.Converters.BaseHelpFormatter&quot; /&gt; and
///         &lt;see cref=&quot;CommandsNextExtension.SetHelpFormatter{T}()&quot; /&gt; for more details).
///         It is recommended to use help formatter instead of disabling help.
⋮----
///     &lt;para&gt;Controls whether the default help will be sent via DMs or not.&lt;/para&gt;
///     &lt;para&gt;Enabling this will make the bot respond with help via direct messages.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the default pre-execution checks for the built-in help command.&lt;/para&gt;
///     &lt;para&gt;Only applicable if default help is enabled.&lt;/para&gt;
///     &lt;para&gt;Defaults to null.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether commands sent via direct messages should be processed.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the service provider for this CommandsNext instance.&lt;/para&gt;
⋮----
///         Objects in this provider are used when instantiating command modules. This allows passing data around without
///         resorting to static members.
⋮----
///     &lt;para&gt;Defaults to an empty service provider.&lt;/para&gt;
⋮----
public IServiceProvider ServiceProvider { internal get; set; } = new ServiceCollection().BuildServiceProvider(true);
⋮----
///         Gets whether any extra arguments passed to commands should be ignored or not. If this is set to false, extra
///         arguments will throw, otherwise they will be ignored.
⋮----
///     &lt;para&gt;Gets or sets whether to automatically enable handling commands.&lt;/para&gt;
///     &lt;para&gt;If this is set to false, you will need to manually handle each incoming message and pass it to CommandsNext.&lt;/para&gt;</file><file path="DisCatSharp.CommandsNext/CommandsNextEvents.cs">/// &lt;summary&gt;
///     Contains well-defined event IDs used by CommandsNext.
/// &lt;/summary&gt;
public static class CommandsNextEvents
⋮----
///     Miscellaneous events, that do not fit in any other category.
⋮----
///     Events pertaining to Gateway Intents. Typically diagnostic information.</file><file path="DisCatSharp.CommandsNext/CommandsNextExtension.cs">/// &lt;summary&gt;
///     This is the class which handles command registration, management, and execution.
/// &lt;/summary&gt;
public class CommandsNextExtension : BaseExtension
⋮----
///     Gets the config.
⋮----
private readonly CommandsNextConfiguration _config;
⋮----
///     Gets the convert generic.
⋮----
private readonly MethodInfo _convertGeneric;
⋮----
///     Gets the help formatter.
⋮----
private readonly HelpFormatterFactory _helpFormatter;
⋮----
///     Gets the user friendly type names.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandsNextExtension&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;cfg&quot;&gt;The cfg.&lt;/param&gt;
⋮----
[typeof(string)] = new StringConverter(),
[typeof(bool)] = new BoolConverter(),
[typeof(sbyte)] = new Int8Converter(),
[typeof(byte)] = new Uint8Converter(),
[typeof(short)] = new Int16Converter(),
[typeof(ushort)] = new Uint16Converter(),
[typeof(int)] = new Int32Converter(),
[typeof(uint)] = new Uint32Converter(),
[typeof(long)] = new Int64Converter(),
[typeof(ulong)] = new Uint64Converter(),
[typeof(float)] = new Float32Converter(),
[typeof(double)] = new Float64Converter(),
[typeof(decimal)] = new Float128Converter(),
[typeof(DateTime)] = new DateTimeConverter(),
[typeof(DateTimeOffset)] = new DateTimeOffsetConverter(),
[typeof(TimeSpan)] = new TimeSpanConverter(),
[typeof(Uri)] = new UriConverter(),
[typeof(DiscordUser)] = new DiscordUserConverter(),
[typeof(DiscordMember)] = new DiscordMemberConverter(),
[typeof(DiscordRole)] = new DiscordRoleConverter(),
[typeof(DiscordChannel)] = new DiscordChannelConverter(),
[typeof(DiscordGuild)] = new DiscordGuildConverter(),
[typeof(DiscordMessage)] = new DiscordMessageConverter(),
[typeof(DiscordEmoji)] = new DiscordEmojiConverter(),
[typeof(DiscordThreadChannel)] = new DiscordThreadChannelConverter(),
[typeof(DiscordInvite)] = new DiscordInviteConverter(),
[typeof(DiscordColor)] = new DiscordColorConverter(),
[typeof(DiscordScheduledEvent)] = new DiscordScheduledEventConverter()
⋮----
foreach (var xt in this.ArgumentConverters.Keys.ToArray())
⋮----
var xti = xt.GetTypeInfo();
⋮----
var xcvt = typeof(NullableConverter&lt;&gt;).MakeGenericType(xt);
var xnt = typeof(Nullable&lt;&gt;).MakeGenericType(xt);
if (this.ArgumentConverters.ContainsKey(xcvt))
⋮----
var xcv = Activator.CreateInstance(xcvt) as IArgumentConverter;
⋮----
var t = this.GetType();
var ms = t.GetTypeInfo().DeclaredMethods;
var m = ms.FirstOrDefault(xm =&gt; xm is { Name: &quot;ConvertArgumentToObj&quot;, ContainsGenericParameters: true } and { IsStatic: false, IsPrivate: true });
⋮----
///     Gets the argument converters.
⋮----
///     Gets the service provider this CommandsNext module was configured with.
⋮----
///     Sets the help formatter to use with the default help command.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the formatter to use.&lt;/typeparam&gt;
public void SetHelpFormatter&lt;T&gt;() where T : BaseHelpFormatter =&gt; this._helpFormatter.SetFormatterType&lt;T&gt;();
⋮----
///     DO NOT USE THIS MANUALLY.
⋮----
/// &lt;param name=&quot;client&quot;&gt;DO NOT USE THIS MANUALLY.&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot; /&gt;
protected internal override void Setup(DiscordClient client)
⋮----
throw new InvalidOperationException(&quot;What did I tell you?&quot;);
⋮----
this.Client.Logger.LogWarning(CommandsNextEvents.Misc, &quot;Not attaching default command handler - if this is intentional, you can ignore this message&quot;);
⋮----
this.RegisterCommands(typeof(DefaultHelpModule), null, null, out var tcmds);
⋮----
var checks = this._config.DefaultHelpChecks.ToArray();
⋮----
cb.WithExecutionChecks(checks);
⋮----
this.AddToCommandDictionary(xc.Build(null));
⋮----
///     Creates a fake command context to execute commands with.
⋮----
/// &lt;param name=&quot;actor&quot;&gt;The user or member to use as message author.&lt;/param&gt;
/// &lt;param name=&quot;channel&quot;&gt;The channel the message is supposed to appear from.&lt;/param&gt;
/// &lt;param name=&quot;messageContents&quot;&gt;Contents of the message.&lt;/param&gt;
/// &lt;param name=&quot;prefix&quot;&gt;Command prefix, used to execute commands.&lt;/param&gt;
/// &lt;param name=&quot;cmd&quot;&gt;Command to execute.&lt;/param&gt;
/// &lt;param name=&quot;rawArguments&quot;&gt;Raw arguments to pass to command.&lt;/param&gt;
/// &lt;returns&gt;Created fake context.&lt;/returns&gt;
public CommandContext CreateFakeContext(DiscordUser actor, DiscordChannel channel, string messageContents, string prefix, Command cmd, string rawArguments = null)
⋮----
var epoch = new DateTimeOffset(2015, 1, 1, 0, 0, 0, TimeSpan.Zero);
⋮----
// create fake message
var msg = new DiscordMessage
⋮----
MentionEveryone = messageContents.Contains(&quot;@everyone&quot;),
⋮----
TimestampRaw = now.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;),
⋮----
if (!string.IsNullOrWhiteSpace(msg.Content))
⋮----
mentionedUsers = Utilities.GetUserMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.Members.GetValueOrDefault(xid)).Cast&lt;DiscordUser&gt;().ToList();
mentionedRoles = Utilities.GetRoleMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.GetRole(xid)).ToList();
mentionedChannels = Utilities.GetChannelMentions(msg.Content).Select(xid =&gt; msg.Channel.Guild.GetChannel(xid)).ToList();
⋮----
mentionedUsers = Utilities.GetUserMentions(msg.Content).Select(this.Client.GetCachedOrEmptyUserInternal).ToList();
⋮----
var ctx = new CommandContext
⋮----
var scope = ctx.Services.CreateScope();
⋮----
///     Represents the default help module.
⋮----
public class DefaultHelpModule : BaseCommandModule
⋮----
///     Defaults the help async.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The ctx.&lt;/param&gt;
/// &lt;param name=&quot;command&quot;&gt;The command.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
⋮----
public async Task DefaultHelpAsync(CommandContext ctx, [Description(&quot;Command to provide help for.&quot;)] params string[] command)
⋮----
var topLevel = ctx.CommandsNext._topLevelCommands.Values.Distinct();
var helpBuilder = ctx.CommandsNext._helpFormatter.Create(ctx);
⋮----
Command cmd = null;
⋮----
? searchIn.FirstOrDefault(xc =&gt; xc.Name == c || (xc.Aliases != null &amp;&amp; xc.Aliases.Contains(c)))
: searchIn.FirstOrDefault(xc =&gt; string.Equals(xc.Name, c, StringComparison.InvariantCultureIgnoreCase) || (xc.Aliases != null &amp;&amp; xc.Aliases.Select(xs =&gt; xs.ToLowerInvariant()).Contains(c.ToLowerInvariant())));
⋮----
var failedChecks = await cmd.RunChecksAsync(ctx, true).ConfigureAwait(false);
if (failedChecks.Any())
throw new ChecksFailedException(cmd, ctx, failedChecks);
⋮----
throw new CommandNotFoundException(string.Join(&quot; &quot;, command));
⋮----
helpBuilder.WithCommand(cmd);
⋮----
var commandsToSearch = group.Children.Where(xc =&gt; !xc.IsHidden);
⋮----
if (candidateCommand.ExecutionChecks == null || !candidateCommand.ExecutionChecks.Any())
⋮----
eligibleCommands.Add(candidateCommand);
⋮----
var candidateFailedChecks = await candidateCommand.RunChecksAsync(ctx, true).ConfigureAwait(false);
if (!candidateFailedChecks.Any())
⋮----
helpBuilder.WithSubcommands(eligibleCommands.OrderBy(xc =&gt; xc.Name));
⋮----
var commandsToSearch = topLevel.Where(xc =&gt; !xc.IsHidden);
⋮----
if (sc.ExecutionChecks == null || !sc.ExecutionChecks.Any())
⋮----
eligibleCommands.Add(sc);
⋮----
var candidateFailedChecks = await sc.RunChecksAsync(ctx, true).ConfigureAwait(false);
⋮----
var helpMessage = helpBuilder.Build();
⋮----
var builder = new DiscordMessageBuilder().WithContent(helpMessage.Content).AddEmbed(helpMessage.Embed);
⋮----
await ctx.RespondAsync(builder).ConfigureAwait(false);
⋮----
await ctx.Member.SendMessageAsync(builder).ConfigureAwait(false);
⋮----
///     Handles the commands async.
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The e.&lt;/param&gt;
⋮----
private async Task HandleCommandsAsync(DiscordClient sender, MessageCreateEventArgs e)
⋮----
if (e.Author.IsBot) // bad bot
⋮----
mpos = e.Message.GetMentionPrefixLength(this.Client.CurrentUser);
⋮----
foreach (var pfix in this._config.StringPrefixes.Where(pfix =&gt; mpos == -1 &amp;&amp; !string.IsNullOrWhiteSpace(pfix)))
mpos = e.Message.GetStringPrefixLength(pfix, this._config.CaseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase);
⋮----
mpos = await this._config.PrefixResolver(e.Message).ConfigureAwait(false);
⋮----
var fname = cnt.ExtractNextArgument(ref __);
⋮----
var cmd = this.FindCommand(cnt, out var args);
var ctx = this.CreateContext(e.Message, pfx, cmd, args);
⋮----
await this._error.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
Exception = new CommandNotFoundException(fname)
}).ConfigureAwait(false);
⋮----
_ = Task.Run(async () =&gt; await this.ExecuteCommandAsync(ctx).ConfigureAwait(false));
⋮----
///     Finds a specified command by its qualified name, then separates arguments.
⋮----
/// &lt;param name=&quot;commandString&quot;&gt;Qualified name of the command, optionally with arguments.&lt;/param&gt;
/// &lt;param name=&quot;rawArguments&quot;&gt;Separated arguments.&lt;/param&gt;
/// &lt;returns&gt;Found command or null if none was found.&lt;/returns&gt;
public Command FindCommand(string commandString, out string? rawArguments)
⋮----
var next = commandString.ExtractNextArgument(ref pos);
⋮----
if (!this.RegisteredCommands.TryGetValue(next, out var cmd))
⋮----
next = next.ToLowerInvariant();
var cmdKvp = this.RegisteredCommands.FirstOrDefault(x =&gt; x.Key.ToLowerInvariant() == next);
⋮----
rawArguments = commandString[pos..].Trim();
⋮----
next = commandString.ExtractNextArgument(ref pos);
⋮----
cmd = cm2.Children.FirstOrDefault(x =&gt; x.Name.ToLowerInvariant() == next || x.Aliases?.Any(xx =&gt; xx.ToLowerInvariant() == next) == true);
⋮----
cmd = cm2.Children.FirstOrDefault(x =&gt; x.Name == next || x.Aliases?.Contains(next) == true);
⋮----
///     Creates a command execution context from specified arguments.
⋮----
/// &lt;param name=&quot;msg&quot;&gt;Message to use for context.&lt;/param&gt;
⋮----
/// &lt;returns&gt;Created command execution context.&lt;/returns&gt;
public CommandContext CreateContext(DiscordMessage msg, string prefix, Command cmd, string? rawArguments = null)
⋮----
///     Executes specified command from given context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context to execute command from.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public async Task ExecuteCommandAsync(CommandContext ctx)
⋮----
await this.RunAllChecksAsync(cmd, ctx).ConfigureAwait(false);
⋮----
var res = await cmd.ExecuteAsync(ctx).ConfigureAwait(false);
⋮----
await this._executed.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
ctx.ServiceScopeContext.Dispose();
⋮----
///     Runs the all checks async.
⋮----
/// &lt;param name=&quot;cmd&quot;&gt;The cmd.&lt;/param&gt;
⋮----
private async Task RunAllChecksAsync(Command cmd, CommandContext ctx)
⋮----
await this.RunAllChecksAsync(cmd.Parent, ctx).ConfigureAwait(false);
⋮----
var fchecks = await cmd.RunChecksAsync(ctx, false).ConfigureAwait(false);
if (fchecks.Any())
throw new ChecksFailedException(cmd, ctx, fchecks);
⋮----
///     Gets a dictionary of registered top-level commands.
⋮----
///     Gets or sets the top level commands.
⋮----
///     Registers all commands from a given assembly. The command classes need to be public to be considered for
///     registration.
⋮----
/// &lt;param name=&quot;assembly&quot;&gt;Assembly to register commands from.&lt;/param&gt;
public void RegisterCommands(Assembly assembly)
⋮----
var types = assembly.ExportedTypes.Where(xt =&gt;
⋮----
return xti.IsModuleCandidateType() &amp;&amp; !xti.IsNested;
⋮----
this.RegisterCommands(xt);
⋮----
///     Registers all commands from a given command class.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Class which holds commands to register.&lt;/typeparam&gt;
public void RegisterCommands&lt;T&gt;() where T : BaseCommandModule
⋮----
this.RegisterCommands(t);
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type of the class which holds commands to register.&lt;/param&gt;
public void RegisterCommands(Type t)
⋮----
throw new ArgumentNullException(nameof(t), &quot;Type cannot be null.&quot;);
⋮----
if (!t.IsModuleCandidateType())
throw new ArgumentNullException(nameof(t), &quot;Type must be a class, which cannot be abstract or static.&quot;);
⋮----
this.RegisterCommands(t, null, null, out var tempCommands);
⋮----
this.AddToCommandDictionary(command.Build(null));
⋮----
///     Registers the commands.
⋮----
/// &lt;param name=&quot;t&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;currentParent&quot;&gt;The current parent.&lt;/param&gt;
/// &lt;param name=&quot;inheritedChecks&quot;&gt;The inherited checks.&lt;/param&gt;
/// &lt;param name=&quot;foundCommands&quot;&gt;The found commands.&lt;/param&gt;
private void RegisterCommands(Type t, CommandGroupBuilder currentParent, IEnumerable&lt;CheckBaseAttribute&gt; inheritedChecks, out List&lt;CommandBuilder&gt; foundCommands)
⋮----
var ti = t.GetTypeInfo();
⋮----
var module = new CommandModuleBuilder()
.WithType(t)
.WithLifespan(moduleLifespan)
.Build(this.Services);
⋮----
// restrict parent lifespan to more or equally restrictive
⋮----
throw new InvalidOperationException(&quot;In a transient module, child modules can only be transient.&quot;);
⋮----
// check if we are anything
var groupBuilder = new CommandGroupBuilder(module);
⋮----
var moduleAttributes = ti.GetCustomAttributes();
⋮----
if (moduleName.EndsWith(&quot;Group&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Group&quot;)
⋮----
else if (moduleName.EndsWith(&quot;Module&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Module&quot;)
⋮----
else if (moduleName.EndsWith(&quot;Commands&quot;, StringComparison.Ordinal) &amp;&amp; moduleName != &quot;Commands&quot;)
⋮----
moduleName = moduleName.ToLowerInvariant();
⋮----
groupBuilder.WithName(moduleName);
⋮----
groupBuilder.WithExecutionCheck(chk);
⋮----
foreach (var mi in ti.DeclaredMethods.Where(x =&gt; x.IsCommandCandidate(out _) &amp;&amp; x.GetCustomAttribute&lt;GroupCommandAttribute&gt;() != null))
groupBuilder.WithOverload(new(mi));
⋮----
groupBuilder.WithAlias(this._config.CaseSensitive ? xalias : xalias.ToLowerInvariant());
⋮----
groupBuilder.WithHiddenStatus(true);
⋮----
groupBuilder.WithDescription(d.Description);
⋮----
moduleChecks.Add(c);
groupBuilder.WithExecutionCheck(c);
⋮----
groupBuilder.WithCustomAttribute(xa);
⋮----
moduleChecks.AddRange(inheritedChecks);
⋮----
// candidate methods
⋮----
if (!m.IsCommandCandidate(out _))
⋮----
var attrs = m.GetCustomAttributes();
if (attrs.FirstOrDefault(xa =&gt; xa is CommandAttribute) is not CommandAttribute cattr)
⋮----
if (commandName.EndsWith(&quot;Async&quot;, StringComparison.Ordinal) &amp;&amp; commandName != &quot;Async&quot;)
⋮----
commandName = commandName.ToLowerInvariant();
⋮----
if (!commandBuilders.TryGetValue(commandName, out var commandBuilder))
⋮----
commandBuilders.Add(commandName, commandBuilder = new CommandBuilder(module).WithName(commandName));
⋮----
currentParent.WithChild(commandBuilder);
⋮----
commands.Add(commandBuilder);
⋮----
groupBuilder.WithChild(commandBuilder);
⋮----
commandBuilder.WithOverload(new(m));
⋮----
commandBuilder.WithExecutionCheck(chk);
⋮----
commandBuilder.WithAlias(this._config.CaseSensitive ? xalias : xalias.ToLowerInvariant());
⋮----
commandBuilder.WithExecutionCheck(p);
⋮----
commandBuilder.WithDescription(d.Description);
⋮----
commandBuilder.WithHiddenStatus(true);
⋮----
commandBuilder.WithCustomAttribute(xa);
⋮----
// candidate types
⋮----
.Where(xt =&gt; xt.IsModuleCandidateType() &amp;&amp; xt.DeclaredConstructors.Any(xc =&gt; xc.IsPublic));
⋮----
this.RegisterCommands(type.AsType(),
⋮----
groupBuilder.WithChild(xtcmd);
⋮----
commands.AddRange(tempCommands);
⋮----
commands.Add(groupBuilder);
⋮----
currentParent.WithChild(groupBuilder);
⋮----
///     Builds and registers all supplied commands.
⋮----
/// &lt;param name=&quot;cmds&quot;&gt;Commands to build and register.&lt;/param&gt;
public void RegisterCommands(params CommandBuilder[] cmds)
⋮----
this.AddToCommandDictionary(cmd.Build(null));
⋮----
///     Unregister specified commands from CommandsNext.
⋮----
/// &lt;param name=&quot;cmds&quot;&gt;Commands to unregister.&lt;/param&gt;
public void UnregisterCommands(params Command[] cmds)
⋮----
if (cmds.Any(x =&gt; x.Parent != null))
throw new InvalidOperationException(&quot;Cannot unregister nested commands.&quot;);
⋮----
var keys = this.RegisteredCommands.Where(x =&gt; cmds.Contains(x.Value)).Select(x =&gt; x.Key).ToList();
⋮----
this._topLevelCommands.Remove(key);
⋮----
///     Adds the to command dictionary.
⋮----
private void AddToCommandDictionary(Command cmd)
⋮----
if (this._topLevelCommands.ContainsKey(cmd.Name) || (cmd.Aliases != null &amp;&amp; cmd.Aliases.Any(xs =&gt; this._topLevelCommands.ContainsKey(xs))))
throw new DuplicateCommandException(cmd.QualifiedName);
⋮----
///     Converts a string to specified type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to convert to.&lt;/typeparam&gt;
/// &lt;param name=&quot;value&quot;&gt;Value to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;Context in which to convert to.&lt;/param&gt;
/// &lt;returns&gt;Converted object.&lt;/returns&gt;
public async Task&lt;T&gt; ConvertArgument&lt;T&gt;(string value, CommandContext ctx)
⋮----
if (!this.ArgumentConverters.ContainsKey(t))
throw new ArgumentException(&quot;There is no converter specified for given type.&quot;, nameof(T));
⋮----
throw new ArgumentException(&quot;Invalid converter registered for this type.&quot;, nameof(T));
⋮----
var cvr = await cv.ConvertAsync(value, ctx).ConfigureAwait(false);
return !cvr.HasValue ? throw new ArgumentException(&quot;Could not convert specified value to given type.&quot;, nameof(value)) : cvr.Value;
⋮----
/// &lt;param name=&quot;type&quot;&gt;Type to convert to.&lt;/param&gt;
⋮----
public async Task&lt;object&gt; ConvertArgument(string value, CommandContext ctx, Type type)
⋮----
var m = this._convertGeneric.MakeGenericMethod(type);
⋮----
return await (m.Invoke(this, [value, ctx]) as Task&lt;object&gt;).ConfigureAwait(false);
⋮----
///     Registers an argument converter for specified type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type for which to register the converter.&lt;/typeparam&gt;
/// &lt;param name=&quot;converter&quot;&gt;Converter to register.&lt;/param&gt;
public void RegisterConverter&lt;T&gt;(IArgumentConverter&lt;T&gt; converter)
⋮----
throw new ArgumentNullException(nameof(converter), &quot;Converter cannot be null.&quot;);
⋮----
var nullableConverterType = typeof(NullableConverter&lt;&gt;).MakeGenericType(t);
var nullableType = typeof(Nullable&lt;&gt;).MakeGenericType(t);
if (this.ArgumentConverters.ContainsKey(nullableType))
⋮----
var nullableConverter = Activator.CreateInstance(nullableConverterType) as IArgumentConverter;
⋮----
///     Unregister an argument converter for specified type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type for which to unregister the converter.&lt;/typeparam&gt;
public void UnregisterConverter&lt;T&gt;()
⋮----
this.ArgumentConverters.Remove(t);
⋮----
this._userFriendlyTypeNames.Remove(t);
⋮----
if (!this.ArgumentConverters.ContainsKey(nullableType))
⋮----
this.ArgumentConverters.Remove(nullableType);
this._userFriendlyTypeNames.Remove(nullableType);
⋮----
///     Registers a user-friendly type name.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to register the name for.&lt;/typeparam&gt;
/// &lt;param name=&quot;value&quot;&gt;Name to register.&lt;/param&gt;
public void RegisterUserFriendlyTypeName&lt;T&gt;(string value)
⋮----
if (string.IsNullOrWhiteSpace(value))
throw new ArgumentNullException(nameof(value), &quot;Name cannot be null or empty.&quot;);
⋮----
throw new InvalidOperationException(&quot;Cannot register a friendly name for a type which has no associated converter.&quot;);
⋮----
///     Converts a type into user-friendly type name.
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type to convert.&lt;/param&gt;
/// &lt;returns&gt;User-friendly type name.&lt;/returns&gt;
public string GetUserFriendlyTypeName(Type t)
⋮----
if (this._userFriendlyTypeNames.TryGetValue(t, out var userFriendlyTypeName))
⋮----
if (!ti.IsGenericTypeDefinition || t.GetGenericTypeDefinition() != typeof(Nullable&lt;&gt;)) return t.Name;
⋮----
return this._userFriendlyTypeNames.TryGetValue(tn, out var name) ? name : tn.Name;
⋮----
///     Allows easier interoperability with reflection by turning the &lt;see cref=&quot;Task{T}&quot; /&gt; returned by
///     &lt;see cref=&quot;ConvertArgument&quot; /&gt;
///     into a task containing &lt;see cref=&quot;object&quot; /&gt;, using the provided generic type information.
⋮----
private async Task&lt;object&gt; ConvertArgumentToObj&lt;T&gt;(string value, CommandContext ctx)
=&gt; await this.ConvertArgument&lt;T&gt;(value, ctx).ConfigureAwait(false);
⋮----
///     Gets the configuration-specific string comparer. This returns &lt;see cref=&quot;StringComparer.Ordinal&quot; /&gt; or
///     &lt;see cref=&quot;StringComparer.OrdinalIgnoreCase&quot; /&gt;,
///     depending on whether &lt;see cref=&quot;CommandsNextConfiguration.CaseSensitive&quot; /&gt; is set to &lt;see langword=&quot;true&quot; /&gt; or
///     &lt;see langword=&quot;false&quot; /&gt;.
⋮----
/// &lt;returns&gt;A string comparer.&lt;/returns&gt;
internal IEqualityComparer&lt;string&gt; GetStringComparer()
⋮----
///     Triggered whenever a command executes successfully.
⋮----
add =&gt; this._executed.Register(value);
remove =&gt; this._executed.Unregister(value);
⋮----
///     Triggered whenever a command throws an exception during execution.
⋮----
add =&gt; this._error.Register(value);
remove =&gt; this._error.Unregister(value);
⋮----
///     Fires when a command gets executed.
⋮----
/// &lt;param name=&quot;e&quot;&gt;The command execution event arguments.&lt;/param&gt;
private Task OnCommandExecuted(CommandExecutionEventArgs e)
=&gt; this._executed.InvokeAsync(this, e);
⋮----
///     Fires when a command fails.
⋮----
/// &lt;param name=&quot;e&quot;&gt;The command error event arguments.&lt;/param&gt;
private Task OnCommandErrored(CommandErrorEventArgs e)
=&gt; this._error.InvokeAsync(this, e);</file><file path="DisCatSharp.CommandsNext/CommandsNextUtilities.cs">/// &lt;summary&gt;
///     Various CommandsNext-related utilities.
/// &lt;/summary&gt;
public static class CommandsNextUtilities
⋮----
///     Checks whether the message has a specified string prefix.
⋮----
/// &lt;param name=&quot;msg&quot;&gt;Message to check.&lt;/param&gt;
/// &lt;param name=&quot;str&quot;&gt;String to check for.&lt;/param&gt;
/// &lt;param name=&quot;comparisonType&quot;&gt;Method of string comparison for the purposes of finding prefixes.&lt;/param&gt;
/// &lt;returns&gt;Positive number if the prefix is present, -1 otherwise.&lt;/returns&gt;
public static int GetStringPrefixLength(this DiscordMessage msg, string str, StringComparison comparisonType = StringComparison.Ordinal)
⋮----
: !content.StartsWith(str, comparisonType)
⋮----
///     Checks whether the message contains a specified mention prefix.
⋮----
/// &lt;param name=&quot;user&quot;&gt;User to check for.&lt;/param&gt;
⋮----
public static int GetMentionPrefixLength(this DiscordMessage msg, DiscordUser user)
⋮----
if (!content.StartsWith(&quot;&lt;@&quot;, StringComparison.Ordinal))
⋮----
var cni = content.IndexOf(&apos;&gt;&apos;);
⋮----
var m = DiscordRegEx.UserRegex().Match(cnp);
⋮----
var userId = ulong.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
⋮----
//internal static string ExtractNextArgument(string str, out string remainder)
⋮----
///     Extracts the next argument.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string.&lt;/param&gt;
/// &lt;param name=&quot;startPos&quot;&gt;The start position.&lt;/param&gt;
internal static string ExtractNextArgument(this string str, ref int startPos)
⋮----
if (string.IsNullOrWhiteSpace(str))
⋮----
if (!char.IsWhiteSpace(str[i]))
⋮----
if (char.IsWhiteSpace(str[i]) &amp;&amp; !inQuote &amp;&amp; !inTripleBacktick &amp;&amp; !inBacktick &amp;&amp; !inEscape)
⋮----
if (str.IndexOf(&quot;\\`&quot;, i) == i || str.IndexOf(&quot;\\\&quot;&quot;, i) == i || str.IndexOf(&quot;\\\\&quot;, i) == i || (str.Length &gt;= i &amp;&amp; char.IsWhiteSpace(str[i + 1])))
removeIndices.Add(i - startPosition);
⋮----
else if ((inBacktick || inTripleBacktick) &amp;&amp; str.IndexOf(&quot;\\`&quot;, i) == i)
⋮----
var tripleBacktick = str.IndexOf(&quot;```&quot;, i) == i;
⋮----
return startPosition != endPosition ? str[startPosition..endPosition].CleanupString(removeIndices) : null;
⋮----
return startPos != startPosition ? str[startPosition..].CleanupString(removeIndices) : null;
⋮----
///     Cleanups the string.
⋮----
/// &lt;param name=&quot;s&quot;&gt;The string.&lt;/param&gt;
/// &lt;param name=&quot;indices&quot;&gt;The indices.&lt;/param&gt;
internal static string CleanupString(this string s, IList&lt;int&gt; indices)
⋮----
if (!indices.Any())
⋮----
var li = indices.Last();
⋮----
s = s.Remove(li - ll + 1, ll);
⋮----
return s.Remove(li - ll + 1, ll);
⋮----
///     Binds the arguments.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;ignoreSurplus&quot;&gt;If true, ignore further text in string.&lt;/param&gt;
internal static async Task&lt;ArgumentBindingResult&gt; BindArguments(CommandContext ctx, bool ignoreSurplus)
⋮----
rawArgumentList.Add(argValue);
⋮----
argValue = argString[foundAt..].Trim();
⋮----
return new(new ArgumentException(&quot;Not enough arguments supplied to the command.&quot;));
⋮----
rawArgumentList.Add(null);
⋮----
return new(new ArgumentException(&quot;Too many arguments were supplied to this command.&quot;));
⋮----
var array = Array.CreateInstance(arg.Type, rawArgumentList.Count - i);
⋮----
array.SetValue(await ctx.CommandsNext.ConvertArgument(rawArgumentList[i], ctx, arg.Type).ConfigureAwait(false), i - start);
⋮----
args[i + 2] = rawArgumentList[i] != null ? await ctx.CommandsNext.ConvertArgument(rawArgumentList[i], ctx, arg.Type).ConfigureAwait(false) : arg.DefaultValue;
⋮----
///     Whether this module is a candidate type.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
internal static bool IsModuleCandidateType(this Type type)
=&gt; type.GetTypeInfo().IsModuleCandidateType();
⋮----
/// &lt;param name=&quot;ti&quot;&gt;The type info.&lt;/param&gt;
internal static bool IsModuleCandidateType(this TypeInfo ti)
⋮----
// check if compiler-generated
⋮----
// check if derives from the required base class
⋮----
var timodule = tmodule.GetTypeInfo();
if (!timodule.IsAssignableFrom(ti))
⋮----
// check if anonymous
if (ti.IsGenericType &amp;&amp; ti.Name.Contains(&quot;AnonymousType&quot;) &amp;&amp; (ti.Name.StartsWith(&quot;&lt;&gt;&quot;, StringComparison.Ordinal) || ti.Name.StartsWith(&quot;VB$&quot;, StringComparison.Ordinal)) &amp;&amp; (ti.Attributes &amp; TypeAttributes.NotPublic) == TypeAttributes.NotPublic)
⋮----
// check if abstract, static, or not a class
⋮----
// check if delegate type
var tdelegate = typeof(Delegate).GetTypeInfo();
if (tdelegate.IsAssignableFrom(ti))
⋮----
// qualifies if any method or type qualifies
return ti.DeclaredMethods.Any(xmi =&gt; xmi.IsCommandCandidate(out _)) || ti.DeclaredNestedTypes.Any(xti =&gt; xti.IsModuleCandidateType());
⋮----
///     Whether this is a command candidate.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;parameters&quot;&gt;The parameters.&lt;/param&gt;
internal static bool IsCommandCandidate(this MethodInfo method, out ParameterInfo[] parameters)
⋮----
// check if exists
⋮----
// check if static, non-public, abstract, a constructor, or a special name
⋮----
// check if appropriate return and arguments
parameters = method.GetParameters();
⋮----
return parameters.Length != 0 &amp;&amp; parameters.First().ParameterType == typeof(CommandContext) &amp;&amp; method.ReturnType == typeof(Task);
⋮----
///     Creates the instance.
⋮----
/// &lt;param name=&quot;t&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;services&quot;&gt;The services provider.&lt;/param&gt;
internal static object CreateInstance(this Type t, IServiceProvider services)
⋮----
var ti = t.GetTypeInfo();
⋮----
.Where(xci =&gt; xci.IsPublic)
.ToArray();
⋮----
throw new ArgumentException(&quot;Specified type does not contain a public constructor or contains more than one public constructor.&quot;);
⋮----
var constructorArgs = constructor.GetParameters();
⋮----
throw new InvalidOperationException(&quot;Dependency collection needs to be specified for parameterized constructors.&quot;);
⋮----
// inject via constructor
⋮----
args[i] = services.GetRequiredService(constructorArgs[i].ParameterType);
⋮----
var moduleInstance = Activator.CreateInstance(t, args);
⋮----
// inject into properties
var props = t.GetRuntimeProperties().Where(xp =&gt; xp.CanWrite &amp;&amp; xp.SetMethod != null &amp;&amp; !xp.SetMethod.IsStatic &amp;&amp; xp.SetMethod.IsPublic);
⋮----
var service = services.GetService(prop.PropertyType);
⋮----
prop.SetValue(moduleInstance, service);
⋮----
// inject into fields
var fields = t.GetRuntimeFields().Where(xf =&gt; !xf.IsInitOnly &amp;&amp; xf is { IsStatic: false, IsPublic: true });
⋮----
var service = services.GetService(field.FieldType);
⋮----
field.SetValue(moduleInstance, service);</file><file path="DisCatSharp.CommandsNext/Converters/ArgumentBindingResult.cs">/// &lt;summary&gt;
///     Represents a argument binding result.
/// &lt;/summary&gt;
⋮----
///     Gets a value indicating whether the binding is successful.
⋮----
///     Gets the converted.
⋮----
///     Gets the raw.
⋮----
///     Gets the reason.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ArgumentBindingResult&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;converted&quot;&gt;The converted.&lt;/param&gt;
/// &lt;param name=&quot;raw&quot;&gt;The raw.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;ex&quot;&gt;The ex.&lt;/param&gt;</file><file path="DisCatSharp.CommandsNext/Converters/BaseHelpFormatter.cs">/// &lt;summary&gt;
///     Represents a base class for all default help formatters.
/// &lt;/summary&gt;
public abstract class BaseHelpFormatter
⋮----
///     Creates a new help formatter for specified CommandsNext extension instance.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context in which this formatter is being invoked.&lt;/param&gt;
⋮----
///     Gets the context in which this formatter is being invoked.
⋮----
///     Gets the CommandsNext extension which constructed this help formatter.
⋮----
///     Sets the command this help message will be for.
⋮----
/// &lt;param name=&quot;command&quot;&gt;Command for which the help message is being produced.&lt;/param&gt;
/// &lt;returns&gt;This help formatter.&lt;/returns&gt;
public abstract BaseHelpFormatter WithCommand(Command command);
⋮----
///     Sets the subcommands for this command, if applicable. This method will be called with filtered data.
⋮----
/// &lt;param name=&quot;subcommands&quot;&gt;Subcommands for this command group.&lt;/param&gt;
⋮----
public abstract BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; subcommands);
⋮----
///     Constructs the help message.
⋮----
/// &lt;returns&gt;Data for the help message.&lt;/returns&gt;
public abstract CommandHelpMessage Build();</file><file path="DisCatSharp.CommandsNext/Converters/DefaultHelpFormatter.cs">/// &lt;summary&gt;
///     Default CommandsNext help formatter.
/// &lt;/summary&gt;
public class DefaultHelpFormatter : BaseHelpFormatter
⋮----
///     Gets or sets the command.
⋮----
private Command _command;
⋮----
///     Creates a new default help formatter.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context in which this formatter is being invoked.&lt;/param&gt;
⋮----
this.EmbedBuilder = new DiscordEmbedBuilder()
.WithTitle(&quot;Help&quot;)
.WithColor(0x007FFF);
⋮----
///     Gets the embed builder.
⋮----
///     Sets the command this help message will be for.
⋮----
/// &lt;param name=&quot;command&quot;&gt;Command for which the help message is being produced.&lt;/param&gt;
/// &lt;returns&gt;This help formatter.&lt;/returns&gt;
public override BaseHelpFormatter WithCommand(Command command)
⋮----
this.EmbedBuilder.WithDescription($&quot;{command.Name.InlineCode()}: {command.Description ?? &quot;No description provided.&quot;}&quot;);
⋮----
this.EmbedBuilder.WithDescription($&quot;{this.EmbedBuilder.Description}\n\nThis group can be executed as a standalone command.&quot;);
⋮----
this.EmbedBuilder.AddField(new(&quot;Aliases&quot;, string.Join(&quot;, &quot;, command.Aliases.Select(Formatter.InlineCode))));
⋮----
var sb = new StringBuilder();
⋮----
foreach (var ovl in command.Overloads.OrderByDescending(x =&gt; x.Priority))
⋮----
sb.Append(&apos;`&apos;).Append(command.QualifiedName);
⋮----
sb.Append(arg.IsOptional || arg.IsCatchAll ? &quot; [&quot; : &quot; &lt;&quot;).Append(arg.Name).Append(arg.IsCatchAll ? &quot;...&quot; : &quot;&quot;).Append(arg.IsOptional || arg.IsCatchAll ? &apos;]&apos; : &apos;&gt;&apos;);
⋮----
sb.Append(&quot;`\n&quot;);
⋮----
sb.Append(&apos;`&apos;).Append(arg.Name).Append(&quot; (&quot;).Append(this.CommandsNext.GetUserFriendlyTypeName(arg.Type)).Append(&quot;)`: &quot;).Append(arg.Description ?? &quot;No description provided.&quot;).Append(&apos;\n&apos;);
⋮----
sb.Append(&apos;\n&apos;);
⋮----
this.EmbedBuilder.AddField(new(&quot;Arguments&quot;, sb.ToString().Trim()));
⋮----
///     Sets the subcommands for this command, if applicable. This method will be called with filtered data.
⋮----
/// &lt;param name=&quot;subcommands&quot;&gt;Subcommands for this command group.&lt;/param&gt;
⋮----
public override BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; subcommands)
⋮----
this.EmbedBuilder.AddField(new(this._command != null ? &quot;Subcommands&quot; : &quot;Commands&quot;, string.Join(&quot;, &quot;, subcommands.Select(x =&gt; x.Name.InlineCode()))));
⋮----
///     Construct the help message.
⋮----
/// &lt;returns&gt;Data for the help message.&lt;/returns&gt;
public override CommandHelpMessage Build()
⋮----
this.EmbedBuilder.WithDescription(&quot;Listing all top-level commands and groups. Specify a command to see more information.&quot;);
⋮----
return new(embed: this.EmbedBuilder.Build());</file><file path="DisCatSharp.CommandsNext/Converters/EntityConverters.cs">/// &lt;summary&gt;
///     Represents a discord user converter.
/// &lt;/summary&gt;
public class DiscordUserConverter : IArgumentConverter&lt;DiscordUser&gt;
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
async Task&lt;Optional&lt;DiscordUser&gt;&gt; IArgumentConverter&lt;DiscordUser&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var uid))
⋮----
var result = await ctx.Client.GetUserAsync(uid).ConfigureAwait(false);
return Optional.FromNullable(result);
⋮----
var m = DiscordRegEx.UserRegex().Match(value);
if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out uid))
⋮----
value = value.ToLowerInvariant();
⋮----
var di = value.IndexOf(&apos;#&apos;);
⋮----
.SelectMany(xkvp =&gt; xkvp.Members.Values)
.Where(xm =&gt; (cs ? xm.Username : xm.Username.ToLowerInvariant()) == un &amp;&amp; ((dv != null &amp;&amp; xm.Discriminator == dv) || dv == null));
⋮----
var usr = us.FirstOrDefault();
⋮----
///     Represents a discord member converter.
⋮----
public class DiscordMemberConverter : IArgumentConverter&lt;DiscordMember&gt;
⋮----
async Task&lt;Optional&lt;DiscordMember&gt;&gt; IArgumentConverter&lt;DiscordMember&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
var result = await ctx.Guild.GetMemberAsync(uid).ConfigureAwait(false);
⋮----
var searchResult = await ctx.Guild.SearchMembersAsync(value).ConfigureAwait(false);
if (searchResult.Any())
return Optional.Some(searchResult.First());
⋮----
.Where(xm =&gt; ((cs ? xm.Username : xm.Username.ToLowerInvariant()) == un &amp;&amp; ((dv != null &amp;&amp; xm.Discriminator == dv) || dv == null))
⋮----
return Optional.FromNullable(us.FirstOrDefault());
⋮----
///     Represents a discord channel converter.
⋮----
public class DiscordChannelConverter : IArgumentConverter&lt;DiscordChannel&gt;
⋮----
async Task&lt;Optional&lt;DiscordChannel&gt;&gt; IArgumentConverter&lt;DiscordChannel&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var cid))
⋮----
var result = await ctx.Client.GetChannelAsync(cid).ConfigureAwait(false);
⋮----
var m = DiscordRegEx.ChannelRegex().Match(value);
if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out cid))
⋮----
var chn = ctx.Guild?.Channels.Values.FirstOrDefault(xc =&gt; (cs ? xc.Name : xc.Name.ToLowerInvariant()) == value);
return Optional.FromNullable(chn);
⋮----
///     Represents a discord thread channel converter.
⋮----
public class DiscordThreadChannelConverter : IArgumentConverter&lt;DiscordThreadChannel&gt;
⋮----
async Task&lt;Optional&lt;DiscordThreadChannel&gt;&gt; IArgumentConverter&lt;DiscordThreadChannel&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var tid))
⋮----
var result = await ctx.Client.GetThreadAsync(tid).ConfigureAwait(false);
⋮----
if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out tid))
⋮----
var tchn = ctx.Guild?.Threads.Values.FirstOrDefault(xc =&gt; (cs ? xc.Name : xc.Name.ToLowerInvariant()) == value);
return Optional.FromNullable(tchn);
⋮----
///     Represents a discord role converter.
⋮----
public class DiscordRoleConverter : IArgumentConverter&lt;DiscordRole&gt;
⋮----
Task&lt;Optional&lt;DiscordRole&gt;&gt; IArgumentConverter&lt;DiscordRole&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
return Task.FromResult(Optional&lt;DiscordRole&gt;.None);
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var rid))
⋮----
var result = ctx.Guild.GetRole(rid);
return Task.FromResult(Optional.FromNullable(result));
⋮----
var m = DiscordRegEx.RoleRegex().Match(value);
if (m.Success &amp;&amp; ulong.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out rid))
⋮----
var rol = ctx.Guild.Roles.Values.FirstOrDefault(xr =&gt; (cs ? xr.Name : xr.Name.ToLowerInvariant()) == value);
return Task.FromResult(Optional.FromNullable(rol));
⋮----
///     Represents a discord guild converter.
⋮----
public class DiscordGuildConverter : IArgumentConverter&lt;DiscordGuild&gt;
⋮----
Task&lt;Optional&lt;DiscordGuild&gt;&gt; IArgumentConverter&lt;DiscordGuild&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var gid))
return ctx.Client.Guilds.TryGetValue(gid, out var result)
? Task.FromResult(Optional.Some(result))
: Task.FromResult(Optional&lt;DiscordGuild&gt;.None);
⋮----
var gld = ctx.Client.Guilds.Values.FirstOrDefault(xg =&gt; (cs ? xg.Name : xg.Name.ToLowerInvariant()) == value);
return Task.FromResult(Optional.FromNullable(gld));
⋮----
///     Represents a discord invite converter.
⋮----
public class DiscordInviteConverter : IArgumentConverter&lt;DiscordInvite&gt;
⋮----
async Task&lt;Optional&lt;DiscordInvite&gt;&gt; IArgumentConverter&lt;DiscordInvite&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
var m = DiscordRegEx.InviteRegex().Match(value);
⋮----
ulong? eventId = ulong.TryParse(m.Groups[&quot;event&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
⋮----
var result = await ctx.Client.GetInviteByCodeAsync(m.Groups[&quot;code&quot;].Value, scheduledEventId: eventId).ConfigureAwait(false);
⋮----
var inv = await ctx.Client.GetInviteByCodeAsync(value).ConfigureAwait(false);
return Optional.FromNullable(inv);
⋮----
///     Represents a discord message converter.
⋮----
public class DiscordMessageConverter : IArgumentConverter&lt;DiscordMessage&gt;
⋮----
async Task&lt;Optional&lt;DiscordMessage&gt;&gt; IArgumentConverter&lt;DiscordMessage&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (string.IsNullOrWhiteSpace(value))
⋮----
var msguri = value.StartsWith(&quot;&lt;&quot;, StringComparison.Ordinal) &amp;&amp; value.EndsWith(&quot;&gt;&quot;, StringComparison.Ordinal) ? value[1..^1] : value;
⋮----
if (Uri.TryCreate(msguri, UriKind.Absolute, out var uri))
⋮----
var uripath = DiscordRegEx.MessageLinkRegex().Match(uri.AbsoluteUri);
⋮----
|| !ulong.TryParse(uripath.Groups[&quot;channel&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var cid)
|| !ulong.TryParse(uripath.Groups[&quot;message&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out mid))
⋮----
var chn = await ctx.Client.GetChannelAsync(cid).ConfigureAwait(false);
⋮----
var msg = await chn.GetMessageAsync(mid).ConfigureAwait(false);
return Optional.FromNullable(msg);
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out mid))
⋮----
var result = await ctx.Channel.GetMessageAsync(mid).ConfigureAwait(false);
⋮----
///     Represents a discord scheduled event converter.
⋮----
public class DiscordScheduledEventConverter : IArgumentConverter&lt;DiscordScheduledEvent&gt;
⋮----
async Task&lt;Optional&lt;DiscordScheduledEvent&gt;&gt; IArgumentConverter&lt;DiscordScheduledEvent&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
var uripath = DiscordRegEx.EventRegex().Match(uri.AbsoluteUri);
⋮----
&amp;&amp; ulong.TryParse(uripath.Groups[&quot;guild&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
⋮----
&amp;&amp; ulong.TryParse(uripath.Groups[&quot;event&quot;].Value, NumberStyles.Integer, CultureInfo.InvariantCulture,
⋮----
var guild = await ctx.Client.GetGuildAsync(gid).ConfigureAwait(false);
⋮----
var ev = await guild.GetScheduledEventAsync(seid).ConfigureAwait(false);
return Optional.FromNullable(ev);
⋮----
var invite = await ctx.CommandsNext.ConvertArgument&lt;DiscordInvite&gt;(value, ctx).ConfigureAwait(false);
return Optional.FromNullable(invite.GuildScheduledEvent);
⋮----
if (ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out seid))
⋮----
var result = await ctx.Guild.GetScheduledEventAsync(seid).ConfigureAwait(false);
⋮----
///     Represents a discord emoji converter.
⋮----
public class DiscordEmojiConverter : IArgumentConverter&lt;DiscordEmoji&gt;
⋮----
Task&lt;Optional&lt;DiscordEmoji&gt;&gt; IArgumentConverter&lt;DiscordEmoji&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (DiscordEmoji.TryFromUnicode(ctx.Client, value, out var emoji))
⋮----
return Task.FromResult(Optional.Some(result));
⋮----
var m = DiscordRegEx.EmojiRegex().Match(value);
⋮----
return !ulong.TryParse(sid, NumberStyles.Integer, CultureInfo.InvariantCulture, out var id)
? Task.FromResult(Optional&lt;DiscordEmoji&gt;.None)
: DiscordEmoji.TryFromGuildEmote(ctx.Client, id, out emoji)
? Task.FromResult(Optional.Some(emoji))
: Task.FromResult(Optional.Some(new DiscordEmoji
⋮----
return Task.FromResult(Optional&lt;DiscordEmoji&gt;.None);
⋮----
///     Represents a discord color converter.
⋮----
public class DiscordColorConverter : IArgumentConverter&lt;DiscordColor&gt;
⋮----
Task&lt;Optional&lt;DiscordColor&gt;&gt; IArgumentConverter&lt;DiscordColor&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
var m = CommonRegEx.HexColorStringRegex().Match(value);
if (m.Success &amp;&amp; int.TryParse(m.Groups[1].Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var clr))
return Task.FromResult(Optional.Some&lt;DiscordColor&gt;(clr));
⋮----
m = CommonRegEx.RgbColorStringRegex().Match(value);
⋮----
var p1 = byte.TryParse(m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var r);
var p2 = byte.TryParse(m.Groups[2].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var g);
var p3 = byte.TryParse(m.Groups[3].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var b);
⋮----
? Task.FromResult(Optional&lt;DiscordColor&gt;.None)
: Task.FromResult(Optional.Some(new DiscordColor(r, g, b)));
⋮----
return Task.FromResult(Optional&lt;DiscordColor&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/EnumConverter.cs">/// &lt;summary&gt;
///     Represents a enum converter.
/// &lt;/summary&gt;
public class EnumConverter&lt;T&gt; : IArgumentConverter&lt;T&gt; where T : struct, IComparable, IConvertible, IFormattable
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
Task&lt;Optional&lt;T&gt;&gt; IArgumentConverter&lt;T&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
var ti = t.GetTypeInfo();
⋮----
? throw new InvalidOperationException(&quot;Cannot convert non-enum value to an enum.&quot;)
: Enum.TryParse(value, !ctx.Config.CaseSensitive, out T ev)
? Task.FromResult(Optional.Some(ev))
: Task.FromResult(Optional&lt;T&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/HelpFormatterFactory.cs">/// &lt;summary&gt;
///     Represents the help formatter factory.
/// &lt;/summary&gt;
internal class HelpFormatterFactory
⋮----
///     Gets or sets the factory.
⋮----
private ObjectFactory _factory;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;HelpFormatterFactory&quot; /&gt; class.
⋮----
///     Sets the formatter type.
⋮----
public void SetFormatterType&lt;T&gt;() where T : BaseHelpFormatter =&gt; this._factory = ActivatorUtilities.CreateFactory(typeof(T), [typeof(CommandContext)]);
⋮----
///     Creates the help formatter.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
public BaseHelpFormatter Create(CommandContext ctx) =&gt; this._factory(ctx.Services, [ctx]) as BaseHelpFormatter;</file><file path="DisCatSharp.CommandsNext/Converters/IArgumentConverter.cs">/// &lt;summary&gt;
///     Argument converter abstract.
/// &lt;/summary&gt;
public interface IArgumentConverter
⋮----
///     Represents a converter for specific argument type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type for which the converter is to be registered.&lt;/typeparam&gt;
public interface IArgumentConverter&lt;T&gt; : IArgumentConverter
⋮----
///     Converts the raw value into the specified type.
⋮----
/// &lt;param name=&quot;value&quot;&gt;Value to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;Context in which the value will be converted.&lt;/param&gt;
/// &lt;returns&gt;A structure containing information whether the value was converted, and, if so, the converted value.&lt;/returns&gt;
Task&lt;Optional&lt;T&gt;&gt; ConvertAsync(string value, CommandContext ctx);</file><file path="DisCatSharp.CommandsNext/Converters/NullableConverter.cs">/// &lt;summary&gt;
///     Represents a nullable converter.
/// &lt;/summary&gt;
public class NullableConverter&lt;T&gt; : IArgumentConverter&lt;T?&gt; where T : struct
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
async Task&lt;Optional&lt;T?&gt;&gt; IArgumentConverter&lt;T?&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
value = value.ToLowerInvariant();
⋮----
if (ctx.CommandsNext.ArgumentConverters.TryGetValue(typeof(T), out var cv))
⋮----
var val = await cvx.ConvertAsync(value, ctx).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Converters/NumericConverters.cs">/// &lt;summary&gt;
///     The bool converter.
/// &lt;/summary&gt;
public class BoolConverter : IArgumentConverter&lt;bool&gt;
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
Task&lt;Optional&lt;bool&gt;&gt; IArgumentConverter&lt;bool&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
bool.TryParse(value, out var result)
? Task.FromResult(Optional.Some(result))
: Task.FromResult(Optional&lt;bool&gt;.None);
⋮----
///     The int8 converter.
⋮----
public class Int8Converter : IArgumentConverter&lt;sbyte&gt;
⋮----
Task&lt;Optional&lt;sbyte&gt;&gt; IArgumentConverter&lt;sbyte&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
sbyte.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;sbyte&gt;.None);
⋮----
///     The uint8 converter.
⋮----
public class Uint8Converter : IArgumentConverter&lt;byte&gt;
⋮----
Task&lt;Optional&lt;byte&gt;&gt; IArgumentConverter&lt;byte&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
byte.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;byte&gt;.None);
⋮----
///     The int16 converter.
⋮----
public class Int16Converter : IArgumentConverter&lt;short&gt;
⋮----
Task&lt;Optional&lt;short&gt;&gt; IArgumentConverter&lt;short&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
short.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;short&gt;.None);
⋮----
///     The uint16 converter.
⋮----
public class Uint16Converter : IArgumentConverter&lt;ushort&gt;
⋮----
Task&lt;Optional&lt;ushort&gt;&gt; IArgumentConverter&lt;ushort&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
ushort.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;ushort&gt;.None);
⋮----
///     The int32 converter.
⋮----
public class Int32Converter : IArgumentConverter&lt;int&gt;
⋮----
Task&lt;Optional&lt;int&gt;&gt; IArgumentConverter&lt;int&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;int&gt;.None);
⋮----
///     The uint32 converter.
⋮----
public class Uint32Converter : IArgumentConverter&lt;uint&gt;
⋮----
Task&lt;Optional&lt;uint&gt;&gt; IArgumentConverter&lt;uint&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
uint.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;uint&gt;.None);
⋮----
///     The int64 converter.
⋮----
public class Int64Converter : IArgumentConverter&lt;long&gt;
⋮----
Task&lt;Optional&lt;long&gt;&gt; IArgumentConverter&lt;long&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;long&gt;.None);
⋮----
///     The uint64 converter.
⋮----
public class Uint64Converter : IArgumentConverter&lt;ulong&gt;
⋮----
Task&lt;Optional&lt;ulong&gt;&gt; IArgumentConverter&lt;ulong&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
ulong.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;ulong&gt;.None);
⋮----
///     The float32 converter.
⋮----
public class Float32Converter : IArgumentConverter&lt;float&gt;
⋮----
Task&lt;Optional&lt;float&gt;&gt; IArgumentConverter&lt;float&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;float&gt;.None);
⋮----
///     The float64 converter.
⋮----
public class Float64Converter : IArgumentConverter&lt;double&gt;
⋮----
Task&lt;Optional&lt;double&gt;&gt; IArgumentConverter&lt;double&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;double&gt;.None);
⋮----
///     The float128 converter.
⋮----
public class Float128Converter : IArgumentConverter&lt;decimal&gt;
⋮----
Task&lt;Optional&lt;decimal&gt;&gt; IArgumentConverter&lt;decimal&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
decimal.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result)
⋮----
: Task.FromResult(Optional&lt;decimal&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/StringConverter.cs">/// &lt;summary&gt;
///     Represents a string converter.
/// &lt;/summary&gt;
public class StringConverter : IArgumentConverter&lt;string&gt;
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
Task&lt;Optional&lt;string&gt;&gt; IArgumentConverter&lt;string&gt;.ConvertAsync(string value, CommandContext ctx)
=&gt; Task.FromResult(Optional.Some(value));
⋮----
///     Represents a uri converter.
⋮----
public class UriConverter : IArgumentConverter&lt;Uri&gt;
⋮----
Task&lt;Optional&lt;Uri&gt;&gt; IArgumentConverter&lt;Uri&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
if (value.StartsWith(&quot;&lt;&quot;, StringComparison.Ordinal) &amp;&amp; value.EndsWith(&quot;&gt;&quot;, StringComparison.Ordinal))
⋮----
return Task.FromResult(Optional.Some(new Uri(value)));
⋮----
return Task.FromResult(Optional&lt;Uri&gt;.None);</file><file path="DisCatSharp.CommandsNext/Converters/TimeConverters.cs">/// &lt;summary&gt;
///     Represents a date time converter.
/// &lt;/summary&gt;
public sealed class DateTimeConverter : IArgumentConverter&lt;DateTime&gt;
⋮----
///     Converts a string.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The string to convert.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
Task&lt;Optional&lt;DateTime&gt;&gt; IArgumentConverter&lt;DateTime&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
DateTime.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.None, out var result)
? Task.FromResult(Optional.Some(result))
: Task.FromResult(Optional&lt;DateTime&gt;.None);
⋮----
///     Represents a date time offset converter.
⋮----
public sealed class DateTimeOffsetConverter : IArgumentConverter&lt;DateTimeOffset&gt;
⋮----
Task&lt;Optional&lt;DateTimeOffset&gt;&gt; IArgumentConverter&lt;DateTimeOffset&gt;.ConvertAsync(string value, CommandContext ctx) =&gt;
DateTimeOffset.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.None, out var result)
⋮----
: Task.FromResult(Optional&lt;DateTimeOffset&gt;.None);
⋮----
///     Represents a time span converter.
⋮----
public sealed class TimeSpanConverter : IArgumentConverter&lt;TimeSpan&gt;
⋮----
Task&lt;Optional&lt;TimeSpan&gt;&gt; IArgumentConverter&lt;TimeSpan&gt;.ConvertAsync(string value, CommandContext ctx)
⋮----
return Task.FromResult(Optional.Some(TimeSpan.Zero));
⋮----
if (int.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out _))
return Task.FromResult(Optional&lt;TimeSpan&gt;.None);
⋮----
value = value.ToLowerInvariant();
⋮----
if (TimeSpan.TryParse(value, CultureInfo.InvariantCulture, out var result))
return Task.FromResult(Optional.Some(result));
⋮----
var mtc = CommonRegEx.TimeSpanRegex().Match(value);
⋮----
if (string.IsNullOrWhiteSpace(gpc))
⋮----
int.TryParse(gpc[..^1], NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);</file><file path="DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandBuilder.cs">/// &lt;summary&gt;
///     Represents an interface to build a command.
/// &lt;/summary&gt;
public class CommandBuilder
⋮----
///     Gets the alias list.
⋮----
///     Gets the custom attribute list.
⋮----
///     Gets the execution check list.
⋮----
///     Gets the overload argument sets.
⋮----
///     Gets the overload list.
⋮----
///     Creates a new module-less command builder.
⋮----
///     Creates a new command builder.
⋮----
/// &lt;param name=&quot;module&quot;&gt;Module on which this command is to be defined.&lt;/param&gt;
⋮----
///     Gets the name set for this command.
⋮----
///     Gets the aliases set for this command.
⋮----
///     Gets the description set for this command.
⋮----
///     Gets whether this command will be hidden or not.
⋮----
///     Gets the execution checks defined for this command.
⋮----
///     Gets the collection of this command&apos;s overloads.
⋮----
///     Gets the module on which this command is to be defined.
⋮----
///     Gets custom attributes defined on this command.
⋮----
///     Sets the name for this command.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name for this command.&lt;/param&gt;
/// &lt;returns&gt;This builder.&lt;/returns&gt;
public CommandBuilder WithName(string name)
⋮----
if (name == null || name.ToCharArray().Any(xc =&gt; char.IsWhiteSpace(xc)))
throw new ArgumentException(&quot;Command name cannot be null or contain any whitespace characters.&quot;, nameof(name));
⋮----
throw new InvalidOperationException(&quot;This command already has a name.&quot;);
⋮----
if (this._aliasList.Contains(name))
throw new ArgumentException(&quot;Command name cannot be one of its aliases.&quot;, nameof(name));
⋮----
///     Adds aliases to this command.
⋮----
/// &lt;param name=&quot;aliases&quot;&gt;Aliases to add to the command.&lt;/param&gt;
⋮----
public CommandBuilder WithAliases(params string[] aliases)
⋮----
throw new ArgumentException(&quot;You need to pass at least one alias.&quot;, nameof(aliases));
⋮----
this.WithAlias(alias);
⋮----
///     Adds an alias to this command.
⋮----
/// &lt;param name=&quot;alias&quot;&gt;Alias to add to the command.&lt;/param&gt;
⋮----
public CommandBuilder WithAlias(string alias)
⋮----
if (alias.ToCharArray().Any(xc =&gt; char.IsWhiteSpace(xc)))
throw new ArgumentException(&quot;Aliases cannot contain whitespace characters or null strings.&quot;, nameof(alias));
⋮----
if (this.Name == alias || this._aliasList.Contains(alias))
throw new ArgumentException(&quot;Aliases cannot contain the command name, and cannot be duplicate.&quot;, nameof(alias));
⋮----
this._aliasList.Add(alias);
⋮----
///     Sets the description for this command.
⋮----
/// &lt;param name=&quot;description&quot;&gt;Description to use for this command.&lt;/param&gt;
⋮----
public CommandBuilder WithDescription(string description)
⋮----
///     Sets whether this command is to be hidden.
⋮----
/// &lt;param name=&quot;hidden&quot;&gt;Whether the command is to be hidden.&lt;/param&gt;
⋮----
public CommandBuilder WithHiddenStatus(bool hidden)
⋮----
///     Adds pre-execution checks to this command.
⋮----
/// &lt;param name=&quot;checks&quot;&gt;Pre-execution checks to add to this command.&lt;/param&gt;
⋮----
public CommandBuilder WithExecutionChecks(params CheckBaseAttribute[] checks)
⋮----
this._executionCheckList.AddRange(checks.Except(this._executionCheckList));
⋮----
///     Adds a pre-execution check to this command.
⋮----
/// &lt;param name=&quot;check&quot;&gt;Pre-execution check to add to this command.&lt;/param&gt;
⋮----
public CommandBuilder WithExecutionCheck(CheckBaseAttribute check)
⋮----
if (!this._executionCheckList.Contains(check))
this._executionCheckList.Add(check);
⋮----
///     Adds overloads to this command. An executable command needs to have at least one overload.
⋮----
/// &lt;param name=&quot;overloads&quot;&gt;Overloads to add to this command.&lt;/param&gt;
⋮----
public CommandBuilder WithOverloads(params CommandOverloadBuilder[] overloads)
⋮----
this.WithOverload(overload);
⋮----
///     Adds an overload to this command. An executable command needs to have at least one overload.
⋮----
/// &lt;param name=&quot;overload&quot;&gt;Overload to add to this command.&lt;/param&gt;
⋮----
public CommandBuilder WithOverload(CommandOverloadBuilder overload)
⋮----
if (this._overloadArgumentSets.Contains(overload.ArgumentSet))
throw new DuplicateOverloadException(this.Name, overload.Arguments.Select(x =&gt; x.Type).ToList(), overload.ArgumentSet);
⋮----
this._overloadArgumentSets.Add(overload.ArgumentSet);
this._overloadList.Add(overload);
⋮----
///     Adds a custom attribute to this command. This can be used to indicate various custom information about a command.
⋮----
/// &lt;param name=&quot;attribute&quot;&gt;Attribute to add.&lt;/param&gt;
⋮----
public CommandBuilder WithCustomAttribute(Attribute attribute)
⋮----
this._customAttributeList.Add(attribute);
⋮----
///     Adds multiple custom attributes to this command. This can be used to indicate various custom information about a
///     command.
⋮----
/// &lt;param name=&quot;attributes&quot;&gt;Attributes to add.&lt;/param&gt;
⋮----
public CommandBuilder WithCustomAttributes(params Attribute[] attributes)
⋮----
this.WithCustomAttribute(attr);
⋮----
///     Builds the command.
⋮----
/// &lt;param name=&quot;parent&quot;&gt;The parent command group.&lt;/param&gt;
internal virtual Command Build(CommandGroup parent)
⋮----
var cmd = new Command
⋮----
Overloads = new ReadOnlyCollection&lt;CommandOverload&gt;(this.Overloads.Select(xo =&gt; xo.Build()).ToList()),</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandGroupBuilder.cs">/// &lt;summary&gt;
///     Represents an interface to build a command group.
/// &lt;/summary&gt;
public sealed class CommandGroupBuilder : CommandBuilder
⋮----
///     Gets the children list.
⋮----
///     Creates a new module-less command group builder.
⋮----
///     Creates a new command group builder.
⋮----
/// &lt;param name=&quot;module&quot;&gt;Module on which this group is to be defined.&lt;/param&gt;
⋮----
///     Gets the list of child commands registered for this group.
⋮----
///     Adds a command to the collection of child commands for this group.
⋮----
/// &lt;param name=&quot;child&quot;&gt;Command to add to the collection of child commands for this group.&lt;/param&gt;
/// &lt;returns&gt;This builder.&lt;/returns&gt;
public CommandGroupBuilder WithChild(CommandBuilder child)
⋮----
this._childrenList.Add(child);
⋮----
///     Builds the command group.
⋮----
/// &lt;param name=&quot;parent&quot;&gt;The parent command group.&lt;/param&gt;
internal override Command Build(CommandGroup parent)
⋮----
var cmd = new CommandGroup
⋮----
Overloads = new ReadOnlyCollection&lt;CommandOverload&gt;(this.Overloads.Select(xo =&gt; xo.Build()).ToList()),
⋮----
cs.Add(xc.Build(cmd));</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandModuleBuilder.cs">/// &lt;summary&gt;
///     Represents an interface to build a command module.
/// &lt;/summary&gt;
public sealed class CommandModuleBuilder
⋮----
///     Creates a new command module builder.
⋮----
///     Gets the type this build will construct a module out of.
⋮----
///     Gets the lifespan for the built module.
⋮----
///     Sets the type this builder will construct a module out of.
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type to build a module out of. It has to derive from &lt;see cref=&quot;BaseCommandModule&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;This builder.&lt;/returns&gt;
public CommandModuleBuilder WithType(Type t)
⋮----
if (!t.IsModuleCandidateType())
throw new ArgumentException(&quot;Specified type is not a valid module type.&quot;, nameof(t));
⋮----
///     Lifespan to give this module.
⋮----
/// &lt;param name=&quot;lifespan&quot;&gt;Lifespan for this module.&lt;/param&gt;
⋮----
public CommandModuleBuilder WithLifespan(ModuleLifespan lifespan)
⋮----
///     Builds the command module.
⋮----
/// &lt;param name=&quot;services&quot;&gt;The services.&lt;/param&gt;
internal ICommandModule Build(IServiceProvider services) =&gt;
⋮----
ModuleLifespan.Singleton =&gt; new SingletonCommandModule(this.Type, services),
ModuleLifespan.Transient =&gt; new TransientCommandModule(this.Type),
_ =&gt; throw new NotSupportedException(&quot;Module lifespans other than transient and singleton are not supported.&quot;)</file><file path="DisCatSharp.CommandsNext/Entities/Builders/CommandOverloadBuilder.cs">/// &lt;summary&gt;
///     Represents an interface to build a command overload.
/// &lt;/summary&gt;
public sealed class CommandOverloadBuilder
⋮----
///     Gets the invocation target.
⋮----
///     Creates a new command overload builder from specified method.
⋮----
/// &lt;param name=&quot;method&quot;&gt;Method to use for this overload.&lt;/param&gt;
⋮----
///     Creates a new command overload builder from specified delegate.
⋮----
/// &lt;param name=&quot;method&quot;&gt;Delegate to use for this overload.&lt;/param&gt;
⋮----
: this(method.GetMethodInfo(), method.Target)
⋮----
///     Prevents a default instance of the &lt;see cref=&quot;CommandOverloadBuilder&quot; /&gt; class from being created.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target.&lt;/param&gt;
⋮----
if (!method.IsCommandCandidate(out var prms))
throw new ArgumentException(&quot;Specified method is not suitable for a command.&quot;, nameof(method));
⋮----
// create the argument array
⋮----
var iep = Expression.Parameter(target?.GetType() ?? method.DeclaringType, &quot;instance&quot;);
⋮----
ea[1] = Expression.Parameter(typeof(CommandContext), &quot;ctx&quot;);
⋮----
var setb = new StringBuilder();
foreach (var arg in prms.Skip(1))
⋮----
setb.Append(arg.ParameterType).Append(&apos;;&apos;);
var ca = new CommandArgument
⋮----
var attrs = arg.GetCustomAttributes();
⋮----
ca.Type = arg.ParameterType.GetElementType();
⋮----
attrsCustom.Add(xa);
⋮----
throw new InvalidOverloadException(&quot;Non-optional argument cannot appear after an optional one&quot;, method, arg);
⋮----
throw new InvalidOverloadException(&quot;Cannot use array arguments without params modifier.&quot;, method, arg);
⋮----
args.Add(ca);
ea[i++] = Expression.Parameter(arg.ParameterType, arg.Name);
⋮----
//var ec = Expression.Call(iev, method, ea.Skip(2));
var ec = Expression.Call(iep, method, ea.Skip(1));
var el = Expression.Lambda(ec, ea);
⋮----
this.ArgumentSet = setb.ToString();
⋮----
this.Callable = el.Compile();
⋮----
///     Gets a value that uniquely identifies an overload.
⋮----
///     Gets the collection of arguments this overload takes.
⋮----
///     Gets this overload&apos;s priority when picking a suitable one for execution.
⋮----
///     Gets the overload&apos;s callable delegate.
⋮----
///     Sets the priority for this command overload.
⋮----
/// &lt;param name=&quot;priority&quot;&gt;Priority for this command overload.&lt;/param&gt;
/// &lt;returns&gt;This builder.&lt;/returns&gt;
public CommandOverloadBuilder WithPriority(int priority)
⋮----
///     Builds the command overload.
⋮----
internal CommandOverload Build()
⋮----
var ovl = new CommandOverload</file><file path="DisCatSharp.CommandsNext/Entities/Command.cs">/// &lt;summary&gt;
///     Represents a command.
/// &lt;/summary&gt;
public class Command
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Command&quot; /&gt; class.
⋮----
///     Gets this command&apos;s name.
⋮----
///     Gets this command&apos;s qualified name (i.e. one that includes all module names).
⋮----
=&gt; this.Parent != null ? string.Concat(this.Parent.QualifiedName, &quot; &quot;, this.Name) : this.Name;
⋮----
///     Gets this command&apos;s aliases.
⋮----
///     Gets this command&apos;s parent module, if any.
⋮----
///     Gets this command&apos;s description.
⋮----
///     Gets whether this command is hidden.
⋮----
///     Gets a collection of pre-execution checks for this command.
⋮----
///     Gets a collection of this command&apos;s overloads.
⋮----
///     Gets the module in which this command is defined.
⋮----
///     Gets the custom attributes defined on this command.
⋮----
///     Executes this command with specified context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context to execute the command in.&lt;/param&gt;
/// &lt;returns&gt;Command&apos;s execution results.&lt;/returns&gt;
public virtual async Task&lt;CommandResult&gt; ExecuteAsync(CommandContext ctx)
⋮----
CommandResult res = default;
⋮----
foreach (var ovl in this.Overloads.OrderByDescending(x =&gt; x.Priority))
⋮----
var args = await CommandsNextUtilities.BindArguments(ctx, ctx.Config.IgnoreExtraArguments).ConfigureAwait(false);
⋮----
await bcmBefore.BeforeExecutionAsync(ctx).ConfigureAwait(false);
⋮----
var ret = (Task)ovl.Callable.DynamicInvoke(args.Converted);
await ret.ConfigureAwait(false);
⋮----
await bcmAfter.AfterExecutionAsync(ctx).ConfigureAwait(false);
⋮----
throw new ArgumentException(&quot;Could not find a suitable overload for the command.&quot;);
⋮----
///     Runs pre-execution checks for this command and returns any that fail for given context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context in which the command is executed.&lt;/param&gt;
/// &lt;param name=&quot;help&quot;&gt;
///     Whether this check is being executed from help or not. This can be used to probe whether command can
///     be run without setting off certain fail conditions (such as cooldowns).
/// &lt;/param&gt;
/// &lt;returns&gt;Pre-execution checks that fail for given context.&lt;/returns&gt;
public async Task&lt;IEnumerable&lt;CheckBaseAttribute&gt;&gt; RunChecksAsync(CommandContext ctx, bool help)
⋮----
if (this.ExecutionChecks != null &amp;&amp; this.ExecutionChecks.Any())
⋮----
if (!await ec.ExecuteCheckAsync(ctx, help).ConfigureAwait(false))
fchecks.Add(ec);
⋮----
///     Checks whether this command is equal to another one.
⋮----
/// &lt;param name=&quot;cmd1&quot;&gt;Command to compare to.&lt;/param&gt;
/// &lt;param name=&quot;cmd2&quot;&gt;Command to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two commands are equal.&lt;/returns&gt;
⋮----
///     Checks whether this command is not equal to another one.
⋮----
/// &lt;returns&gt;Whether the two commands are not equal.&lt;/returns&gt;
⋮----
///     Checks whether this command equals another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether this command is equal to another object.&lt;/returns&gt;
public override bool Equals(object obj)
⋮----
///     Gets this command&apos;s hash code.
⋮----
/// &lt;returns&gt;This command&apos;s hash code.&lt;/returns&gt;
public override int GetHashCode() =&gt; this.QualifiedName.GetHashCode();
⋮----
///     Returns a string representation of this command.
⋮----
/// &lt;returns&gt;String representation of this command.&lt;/returns&gt;
public override string ToString() =&gt;</file><file path="DisCatSharp.CommandsNext/Entities/CommandArgument.cs">/// &lt;summary&gt;
///     Represents a command argument.
/// &lt;/summary&gt;
public sealed class CommandArgument
⋮----
///     Gets this argument&apos;s name.
⋮----
///     Gets this argument&apos;s type.
⋮----
///     Gets or sets whether this argument is an array argument.
⋮----
///     Gets whether this argument is optional.
⋮----
///     Gets this argument&apos;s default value.
⋮----
///     Gets whether this argument catches all remaining arguments.
⋮----
///     Gets this argument&apos;s description.
⋮----
///     Gets the custom attributes attached to this argument.</file><file path="DisCatSharp.CommandsNext/Entities/CommandGroup.cs">/// &lt;summary&gt;
///     Represents a command group.
/// &lt;/summary&gt;
public class CommandGroup : Command
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandGroup&quot; /&gt; class.
⋮----
///     Gets all the commands that belong to this module.
⋮----
///     Gets whether this command is executable without subcommands.
⋮----
///     Executes this command or its subcommand with specified context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context to execute the command in.&lt;/param&gt;
/// &lt;returns&gt;Command&apos;s execution results.&lt;/returns&gt;
public override async Task&lt;CommandResult&gt; ExecuteAsync(CommandContext ctx)
⋮----
var cn = ctx.RawArgumentString.ExtractNextArgument(ref findPos);
⋮----
? this.Children.FirstOrDefault(xc =&gt; xc.Name == cn || (xc.Aliases != null &amp;&amp; xc.Aliases.Contains(cn)))
: this.Children.FirstOrDefault(xc =&gt; string.Equals(xc.Name, cn, StringComparison.InvariantCultureIgnoreCase) || (xc.Aliases != null &amp;&amp; xc.Aliases.Select(xs =&gt; xs.ToLowerInvariant()).Contains(cn.ToLowerInvariant())));
⋮----
// pass the execution on
var xctx = new CommandContext
⋮----
var fchecks = await cmd.RunChecksAsync(xctx, false).ConfigureAwait(false);
return fchecks.Any()
⋮----
Exception = new ChecksFailedException(cmd, xctx, fchecks),
⋮----
: await cmd.ExecuteAsync(xctx).ConfigureAwait(false);
⋮----
Exception = new InvalidOperationException(&quot;No matching subcommands were found, and this group is not executable.&quot;),
⋮----
: await base.ExecuteAsync(ctx).ConfigureAwait(false);</file><file path="DisCatSharp.CommandsNext/Entities/CommandHelpMessage.cs">/// &lt;summary&gt;
///     Represents a formatted help message.
/// &lt;/summary&gt;
⋮----
///     Gets the contents of the help message.
⋮----
///     Gets the embed attached to the help message.
⋮----
///     Creates a new instance of a help message.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Contents of the message.&lt;/param&gt;
/// &lt;param name=&quot;embed&quot;&gt;Embed to attach to the message.&lt;/param&gt;</file><file path="DisCatSharp.CommandsNext/Entities/CommandModule.cs">/// &lt;summary&gt;
///     Represents a base interface for all types of command modules.
/// &lt;/summary&gt;
public interface ICommandModule
⋮----
///     Gets the type of this module.
⋮----
///     Returns an instance of this module.
⋮----
/// &lt;param name=&quot;services&quot;&gt;Services to instantiate the module with.&lt;/param&gt;
/// &lt;returns&gt;A created instance of this module.&lt;/returns&gt;
BaseCommandModule GetInstance(IServiceProvider services);
⋮----
///     Represents a transient command module. This type of module is reinstantiated on every command call.
⋮----
public class TransientCommandModule : ICommandModule
⋮----
///     Creates a new transient module.
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type of the module to create.&lt;/param&gt;
⋮----
///     Creates a new instance of this module.
⋮----
/// &lt;returns&gt;Created module.&lt;/returns&gt;
public BaseCommandModule GetInstance(IServiceProvider services)
=&gt; this.ModuleType.CreateInstance(services) as BaseCommandModule;
⋮----
///     Represents a singleton command module. This type of module is instantiated only when created.
⋮----
public class SingletonCommandModule : ICommandModule
⋮----
///     Creates a new singleton module, and instantiates it.
⋮----
this.Instance = t.CreateInstance(services) as BaseCommandModule;
⋮----
///     Gets this module&apos;s instance.
⋮----
///     Returns the instance of this module.
⋮----
/// &lt;returns&gt;This module&apos;s instance.&lt;/returns&gt;</file><file path="DisCatSharp.CommandsNext/Entities/CommandOverload.cs">/// &lt;summary&gt;
///     Represents a specific overload of a command.
/// &lt;/summary&gt;
public sealed class CommandOverload
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandOverload&quot; /&gt; class.
⋮----
///     Gets this command overload&apos;s arguments.
⋮----
///     Gets this command overload&apos;s priority.
⋮----
///     Gets this command overload&apos;s delegate.
⋮----
///     Gets or sets the invocation target.</file><file path="DisCatSharp.CommandsNext/Entities/CommandResult.cs">/// &lt;summary&gt;
///     Represents a command&apos;s execution result.
/// &lt;/summary&gt;
⋮----
///     Gets whether the command execution succeeded.
⋮----
///     Gets the exception (if any) that occurred when executing the command.
⋮----
///     Gets the context in which the command was executed.</file><file path="DisCatSharp.CommandsNext/Entities/ICooldownResponder.cs">/// &lt;summary&gt;
///     The cooldown responder.
/// &lt;/summary&gt;
public interface ICooldownResponder
⋮----
///     &lt;para&gt;Responds to cooldown ratelimit hits with given actions.&lt;/para&gt;
///     &lt;para&gt;For example you could respond with a reaction or send a dm.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt;
/// &lt;param name=&quot;cooldownBucket&quot;&gt;Gets the current cooldown bucket.&lt;/param&gt;
Task Responder(CommandContext context, CooldownBucket cooldownBucket);</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandContext.cs">/// &lt;summary&gt;
///     Represents a context in which a command is executed.
/// &lt;/summary&gt;
public sealed class CommandContext : DisCatSharpCommandContext
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandContext&quot; /&gt; class.
⋮----
this._lazyMember = new(() =&gt; this.Guild is not null &amp;&amp; this.Guild.Members.TryGetValue(this.User.Id, out var member) ? member : this.Guild?.GetMemberAsync(this.User.Id).ConfigureAwait(false).GetAwaiter().GetResult());
⋮----
///     Gets the message that triggered the execution.
⋮----
///     Gets the channel in which the execution was triggered,
⋮----
///     Gets the guild in which the execution was triggered. This property is null for commands sent over direct messages.
⋮----
///     Gets the user who triggered the execution.
⋮----
///     Gets the member who triggered the execution. This property is null for commands sent over direct messages.
⋮----
///     Gets the CommandsNext service instance that handled this command.
⋮----
///     Gets the service provider for this CNext instance.
⋮----
///     Gets the command that is being executed.
⋮----
/// &lt;inheritdoc /&gt;
⋮----
///     Gets the overload of the command that is being executed.
⋮----
///     Gets the list of raw arguments passed to the command.
⋮----
///     Gets the raw string from which the arguments were extracted.
⋮----
///     Gets the prefix used to invoke the command.
⋮----
///     Gets or sets the config.
⋮----
///     Gets or sets the service scope context.
⋮----
///     Quickly respond to the message that triggered the command.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Message to respond with.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public Task&lt;DiscordMessage&gt; RespondAsync(string content)
=&gt; this.Message.RespondAsync(content);
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to attach.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(DiscordEmbed embed)
=&gt; this.Message.RespondAsync(embed);
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(string content, DiscordEmbed embed)
=&gt; this.Message.RespondAsync(content, embed);
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The Discord Message builder.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(DiscordMessageBuilder builder)
=&gt; this.Message.RespondAsync(builder);
⋮----
/// &lt;param name=&quot;action&quot;&gt;The Discord Message builder.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(Action&lt;DiscordMessageBuilder&gt; action)
=&gt; this.Message.RespondAsync(action);
⋮----
///     Triggers typing in the channel containing the message that triggered the command.
⋮----
public Task TriggerTypingAsync()
=&gt; this.Channel.TriggerTypingAsync();
⋮----
///     Gets the provider.
⋮----
///     Gets the scope.
⋮----
///     Gets a value indicating whether is initialized.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ServiceContext&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;services&quot;&gt;The services.&lt;/param&gt;
/// &lt;param name=&quot;scope&quot;&gt;The scope.&lt;/param&gt;
⋮----
///     Disposes the command context.
⋮----
public void Dispose()</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandErrorEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;CommandsNextExtension.CommandErrored&quot; /&gt; event.
/// &lt;/summary&gt;
public class CommandErrorEventArgs : CommandEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandErrorEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the exception.</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandEventArgs.cs">/// &lt;summary&gt;
///     Base class for all CNext-related events.
/// &lt;/summary&gt;
public class CommandEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the context in which the command was executed.
⋮----
///     Gets the command that was executed.</file><file path="DisCatSharp.CommandsNext/EventArgs/CommandExecutionEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;CommandsNextExtension.CommandExecuted&quot; /&gt; event.
/// &lt;/summary&gt;
public class CommandExecutionEventArgs : CommandEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CommandExecutionEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;</file><file path="DisCatSharp.CommandsNext/Exceptions/ChecksFailedException.cs">/// &lt;summary&gt;
///     Indicates that one or more checks for given command have failed.
/// &lt;/summary&gt;
public class ChecksFailedException : Exception
⋮----
///     Creates a new &lt;see cref=&quot;ChecksFailedException&quot; /&gt;.
⋮----
/// &lt;param name=&quot;command&quot;&gt;Command that failed to execute.&lt;/param&gt;
/// &lt;param name=&quot;ctx&quot;&gt;Context in which the command was executed.&lt;/param&gt;
/// &lt;param name=&quot;failedChecks&quot;&gt;A collection of checks that failed.&lt;/param&gt;
⋮----
///     Gets the command that was executed.
⋮----
///     Gets the context in which given command was executed.
⋮----
///     Gets the checks that failed.</file><file path="DisCatSharp.CommandsNext/Exceptions/CommandNotFoundException.cs">/// &lt;summary&gt;
///     Thrown when the command service fails to find a command.
/// &lt;/summary&gt;
public sealed class CommandNotFoundException : Exception
⋮----
///     Creates a new &lt;see cref=&quot;CommandNotFoundException&quot; /&gt;.
⋮----
/// &lt;param name=&quot;command&quot;&gt;Name of the command that was not found.&lt;/param&gt;
⋮----
///     Gets the name of the command that was not found.
⋮----
///     Returns a string representation of this &lt;see cref=&quot;CommandNotFoundException&quot; /&gt;.
⋮----
/// &lt;returns&gt;A string representation.&lt;/returns&gt;
public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}&quot;; // much like System.ArgumentNullException works</file><file path="DisCatSharp.CommandsNext/Exceptions/DuplicateCommandException.cs">/// &lt;summary&gt;
///     Indicates that given command name or alias is taken.
/// &lt;/summary&gt;
public class DuplicateCommandException : Exception
⋮----
///     Creates a new exception indicating that given command name is already taken.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the command that was taken.&lt;/param&gt;
⋮----
///     Gets the name of the command that already exists.
⋮----
///     Returns a string representation of this &lt;see cref=&quot;DuplicateCommandException&quot; /&gt;.
⋮----
/// &lt;returns&gt;A string representation.&lt;/returns&gt;
public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}&quot;; // much like System.ArgumentException works</file><file path="DisCatSharp.CommandsNext/Exceptions/DuplicateOverloadException.cs">/// &lt;summary&gt;
///     Indicates that given argument set already exists as an overload for specified command.
/// &lt;/summary&gt;
public class DuplicateOverloadException : Exception
⋮----
///     Gets the argument set key.
⋮----
///     Creates a new exception indicating given argument set already exists as an overload for specified command.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the command with duplicated argument sets.&lt;/param&gt;
/// &lt;param name=&quot;argumentTypes&quot;&gt;Collection of ordered argument types for the command.&lt;/param&gt;
/// &lt;param name=&quot;argumentSetKey&quot;&gt;Overload identifier.&lt;/param&gt;
⋮----
///     Gets the name of the command that already has the overload.
⋮----
///     Gets the ordered collection of argument types for the specified overload.
⋮----
///     Returns a string representation of this &lt;see cref=&quot;DuplicateOverloadException&quot; /&gt;.
⋮----
/// &lt;returns&gt;A string representation.&lt;/returns&gt;
public override string ToString() =&gt; $&quot;{this.GetType()}: {this.Message}\nCommand name: {this.CommandName}\nArgument types: {this._argumentSetKey}&quot;; // much like System.ArgumentException works</file><file path="DisCatSharp.CommandsNext/Exceptions/InvalidOverloadException.cs">/// &lt;summary&gt;
///     Thrown when the command service fails to build a command due to a problem with its overload.
/// &lt;/summary&gt;
public sealed class InvalidOverloadException : Exception
⋮----
///     Creates a new &lt;see cref=&quot;InvalidOverloadException&quot; /&gt;.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Exception message.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;Method that caused the problem.&lt;/param&gt;
/// &lt;param name=&quot;parameter&quot;&gt;Method argument that caused the problem.&lt;/param&gt;
⋮----
///     Gets the method that caused this exception.
⋮----
///     Gets or sets the argument that caused the problem. This can be null.
⋮----
///     Returns a string representation of this &lt;see cref=&quot;InvalidOverloadException&quot; /&gt;.
⋮----
/// &lt;returns&gt;A string representation.&lt;/returns&gt;
public override string ToString() =&gt;
// much like System.ArgumentNullException works
⋮----
? $&quot;{this.GetType()}: {this.Message}\nMethod: {this.Method} (declared in {this.Method.DeclaringType})&quot;
: $&quot;{this.GetType()}: {this.Message}\nMethod: {this.Method} (declared in {this.Method.DeclaringType})\nArgument: {this.Parameter.ParameterType} {this.Parameter.Name}&quot;;</file><file path="DisCatSharp.CommandsNext/ExtensionMethods.cs">/// &lt;summary&gt;
///     Defines various extensions specific to CommandsNext.
/// &lt;/summary&gt;
public static class ExtensionMethods
⋮----
///     Enables CommandsNext module on this &lt;see cref=&quot;DiscordClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to enable CommandsNext for.&lt;/param&gt;
/// &lt;param name=&quot;cfg&quot;&gt;CommandsNext configuration to use.&lt;/param&gt;
/// &lt;returns&gt;Created &lt;see cref=&quot;CommandsNextExtension&quot; /&gt;.&lt;/returns&gt;
public static CommandsNextExtension UseCommandsNext(this DiscordClient client, CommandsNextConfiguration cfg)
⋮----
throw new InvalidOperationException(&quot;CommandsNext is already enabled for that client.&quot;);
⋮----
if (!Utilities.HasMessageIntents(client.Configuration.Intents))
client.Logger.LogCritical(CommandsNextEvents.Intents, &quot;The CommandsNext extension is registered but there are no message intents enabled. It is highly recommended to enable them.&quot;);
⋮----
if (!client.Configuration.Intents.HasIntent(DiscordIntents.Guilds))
client.Logger.LogCritical(CommandsNextEvents.Intents, &quot;The CommandsNext extension is registered but the guilds intent is not enabled. It is highly recommended to enable it.&quot;);
⋮----
cfg.ServiceProvider ??= client.ServiceProvider ?? new ServiceCollection().BuildServiceProvider(true);
⋮----
var cnext = new CommandsNextExtension(cfg);
client.AddExtension(cnext);
⋮----
///     Enables CommandsNext module on all shards in this &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
⋮----
/// &lt;returns&gt;A dictionary of created &lt;see cref=&quot;CommandsNextExtension&quot; /&gt;, indexed by shard id.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, CommandsNextExtension&gt;&gt; UseCommandsNextAsync(this DiscordShardedClient client, CommandsNextConfiguration cfg)
⋮----
await client.InitializeShardsAsync().ConfigureAwait(false);
⋮----
foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
⋮----
cnext ??= shard.UseCommandsNext(cfg);
⋮----
///     Gets the active CommandsNext module for this client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to get CommandsNext module from.&lt;/param&gt;
/// &lt;returns&gt;The module, or null if not activated.&lt;/returns&gt;
public static CommandsNextExtension GetCommandsNext(this DiscordClient client)
⋮----
///     Gets the active CommandsNext modules for all shards in this client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to get CommandsNext instances from.&lt;/param&gt;
/// &lt;returns&gt;A dictionary of the modules, indexed by shard id.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, CommandsNextExtension&gt;&gt; GetCommandsNextAsync(this DiscordShardedClient client)
⋮----
extensions.Add(shard.ShardId, shard.GetExtension&lt;CommandsNextExtension&gt;());
⋮----
///     Registers all commands from a given assembly. The command classes need to be public to be considered for
///     registration.
⋮----
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to register commands on.&lt;/param&gt;
/// &lt;param name=&quot;assembly&quot;&gt;Assembly to register commands from.&lt;/param&gt;
public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, Assembly assembly)
⋮----
extension.RegisterCommands(assembly);
⋮----
///     Registers all commands from a given command class.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Class which holds commands to register.&lt;/typeparam&gt;
⋮----
public static void RegisterCommands&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions) where T : BaseCommandModule
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type of the class which holds commands to register.&lt;/param&gt;
public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, Type t)
⋮----
extension.RegisterCommands(t);
⋮----
///     Builds and registers all supplied commands.
⋮----
/// &lt;param name=&quot;cmds&quot;&gt;Commands to build and register.&lt;/param&gt;
public static void RegisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, params CommandBuilder[] cmds)
⋮----
extension.RegisterCommands(cmds);
⋮----
///     Unregisters specified commands from CommandsNext.
⋮----
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to unregister commands on.&lt;/param&gt;
/// &lt;param name=&quot;cmds&quot;&gt;Commands to unregister.&lt;/param&gt;
public static void UnregisterCommands(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, params Command[] cmds)
⋮----
extension.UnregisterCommands(cmds);
⋮----
///     Registers an argument converter for specified type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type for which to register the converter.&lt;/typeparam&gt;
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to register the converter on.&lt;/param&gt;
/// &lt;param name=&quot;converter&quot;&gt;Converter to register.&lt;/param&gt;
public static void RegisterConverter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, IArgumentConverter&lt;T&gt; converter)
⋮----
extension.RegisterConverter(converter);
⋮----
///     Unregisters an argument converter for specified type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type for which to unregister the converter.&lt;/typeparam&gt;
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to unregister the converter on.&lt;/param&gt;
public static void UnregisterConverter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions)
⋮----
///     Registers a user-friendly type name.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to register the name for.&lt;/typeparam&gt;
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to register the name on.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Name to register.&lt;/param&gt;
public static void RegisterUserFriendlyTypeName&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions, string value)
⋮----
///     Sets the help formatter to use with the default help command.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the formatter to use.&lt;/typeparam&gt;
/// &lt;param name=&quot;extensions&quot;&gt;Extensions to set the help formatter on.&lt;/param&gt;
public static void SetHelpFormatter&lt;T&gt;(this IReadOnlyDictionary&lt;int, CommandsNextExtension&gt; extensions) where T : BaseHelpFormatter</file><file path="DisCatSharp.CommandsNext/GlobalSuppressions.cs"></file><file path="DisCatSharp.Common/DisCatSharp.Common.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Common/GlobalSuppressions.cs">// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.</file><file path="DisCatSharp.Common/RegularExpressions/CommonRegEx.cs">/// &lt;summary&gt;
///     Provides common regex.
/// &lt;/summary&gt;
public static partial class CommonRegEx
⋮----
public static partial Regex HexColorStringRegex();
⋮----
public static partial Regex RgbColorStringRegex();
⋮----
public static partial Regex TimeSpanRegex();
⋮----
public static partial Regex AdvancedYoutubeRegex();
⋮----
public static partial Regex MdStripRegex();
⋮----
public static partial Regex MdSanitizeRegex();
⋮----
public static partial Regex HttpRouteRegex();</file><file path="DisCatSharp.Common/RegularExpressions/DiscordRegEx.cs">/// &lt;summary&gt;
///     Provides common regex for discord related things.
/// &lt;/summary&gt;
public static partial class DiscordRegEx
⋮----
public static partial Regex InviteRegex();
⋮----
public static partial Regex MessageLinkRegex();
⋮----
public static partial Regex EmojiRegex();
⋮----
public static partial Regex AnimatedEmojiRegex();
⋮----
public static partial Regex StaticEmojiRegex();
⋮----
public static partial Regex TimestampRegex();
⋮----
public static partial Regex DefaultStyledTimestampRegex();
⋮----
public static partial Regex StyledTimestampRegex();
⋮----
public static partial Regex RoleRegex();
⋮----
public static partial Regex ChannelRegex();
⋮----
public static partial Regex UserRegex();
⋮----
public static partial Regex IdRegex();
⋮----
public static partial Regex UserWithNicknameRegex();
⋮----
public static partial Regex UserWithOptionalNicknameRegex();
⋮----
public static partial Regex UserWithoutNicknameRegex();
⋮----
public static partial Regex EventRegex();
⋮----
public static partial Regex ApplicationCommandNameRegex();
⋮----
public static partial Regex WebhookRegex();
⋮----
public static partial Regex SoundRegex();</file><file path="DisCatSharp.Common/Serialization/DateTimeFormatAttribute.cs">// ReSharper disable InconsistentNaming
⋮----
/// &lt;summary&gt;
///     Defines the format for string-serialized &lt;see cref=&quot;DateTime&quot; /&gt; and &lt;see cref=&quot;DateTimeOffset&quot; /&gt; objects.
/// &lt;/summary&gt;
⋮----
public sealed class DateTimeFormatAttribute : SerializationAttribute
⋮----
///     Gets the ISO 8601 format string of &quot;yyyy-MM-ddTHH:mm:ss.fffzzz&quot;.
⋮----
///     Gets the RFC 1123 format string of &quot;R&quot;.
⋮----
///     Gets the general long format.
⋮----
///     Gets the general short format.
⋮----
///     Specifies a predefined format to use.
⋮----
/// &lt;param name=&quot;kind&quot;&gt;Predefined format kind to use.&lt;/param&gt;
⋮----
throw new ArgumentOutOfRangeException(nameof(kind), &quot;Specified format kind is not legal or supported.&quot;);
⋮----
///     &lt;para&gt;Specifies a custom format to use.&lt;/para&gt;
///     &lt;para&gt;
///         See https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings for more
///         details.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;format&quot;&gt;Custom format string to use.&lt;/param&gt;
⋮----
if (string.IsNullOrWhiteSpace(format))
throw new ArgumentNullException(nameof(format), &quot;Specified format cannot be null or empty.&quot;);
⋮----
///     Gets the custom datetime format string to use.
⋮----
///     Gets the predefined datetime format kind.
⋮----
///         Defines which built-in format to use for for &lt;see cref=&quot;DateTime&quot; /&gt; and &lt;see cref=&quot;System.DateTimeOffset&quot; /&gt;
///         serialization.
⋮----
///         See https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings and
///         https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings for more
⋮----
///     Specifies ISO 8601 format, which is equivalent to .NET format string of &quot;yyyy-MM-ddTHH:mm:ss.fffzzz&quot;.
⋮----
///     Specifies RFC 1123 format, which is equivalent to .NET format string of &quot;R&quot;.
⋮----
///     Specifies a format defined by &lt;see cref=&quot;System.Globalization.CultureInfo.CurrentCulture&quot; /&gt;, with a format string
///     of &quot;G&quot;. This format is not recommended for portability reasons.
⋮----
///     of &quot;g&quot;. This format is not recommended for portability reasons.
⋮----
///     Specifies a format defined by &lt;see cref=&quot;System.Globalization.CultureInfo.InvariantCulture&quot; /&gt;, with a format
///     string of &quot;G&quot;.
⋮----
///     string of &quot;g&quot;.
⋮----
///     Specifies a custom format. This value is not usable directly.</file><file path="DisCatSharp.Common/Serialization/DecomposerAttribute.cs">/// &lt;summary&gt;
///     Specifies a decomposer for a given type or property.
/// &lt;/summary&gt;
⋮----
public sealed class DecomposerAttribute : SerializationAttribute
⋮----
///     Specifies a decomposer for given type or property.
⋮----
/// &lt;param name=&quot;type&quot;&gt;Type of decomposer to use.&lt;/param&gt;
⋮----
if (!typeof(IDecomposer).IsAssignableFrom(type) || !type.IsClass || type.IsAbstract) // abstract covers static - static = abstract + sealed
throw new ArgumentException(&quot;Invalid type specified. Must be a non-abstract class which implements DisCatSharp.Common.Serialization.IDecomposer interface.&quot;, nameof(type));
⋮----
///     Gets the type of the decomposer.</file><file path="DisCatSharp.Common/Serialization/EnumAttributes.cs">/// &lt;summary&gt;
///     &lt;para&gt;Specifies that this enum should be serialized and deserialized as its underlying numeric type.&lt;/para&gt;
///     &lt;para&gt;This is used to change the behaviour of enum serialization.&lt;/para&gt;
/// &lt;/summary&gt;
⋮----
///     &lt;para&gt;Specifies that this enum should be serialized and deserialized as its string representation.&lt;/para&gt;</file><file path="DisCatSharp.Common/Serialization/Int53Attribute.cs">/// &lt;summary&gt;
///     &lt;para&gt;Specifies that this 64-bit integer uses no more than 53 bits to represent its value.&lt;/para&gt;
///     &lt;para&gt;
///         This is used to indicate that large numbers are safe for direct serialization into formats which do support
///         64-bit integers natively (such as JSON).
///     &lt;/para&gt;
/// &lt;/summary&gt;
⋮----
public sealed class Int53Attribute : SerializationAttribute
⋮----
///     &lt;para&gt;Gets the maximum safe value representable as an integer by a IEEE754 64-bit binary floating point value.&lt;/para&gt;
///     &lt;para&gt;This value equals to 9007199254740991.&lt;/para&gt;
⋮----
///     &lt;para&gt;Gets the minimum safe value representable as an integer by a IEEE754 64-bit binary floating point value.&lt;/para&gt;
///     &lt;para&gt;This value equals to -9007199254740991.&lt;/para&gt;</file><file path="DisCatSharp.Common/Serialization/SerializationAttribute.cs">/// &lt;summary&gt;
///     ABC for serialization attributes.
/// &lt;/summary&gt;</file><file path="DisCatSharp.Common/Serialization/TimeSpanAttributes.cs">/// &lt;summary&gt;
///     &lt;para&gt;Specifies that this &lt;see cref=&quot;TimeSpan&quot; /&gt; will be serialized as a number of whole seconds.&lt;/para&gt;
///     &lt;para&gt;This value will always be serialized as a number.&lt;/para&gt;
/// &lt;/summary&gt;
⋮----
///     &lt;para&gt;Specifies that this &lt;see cref=&quot;TimeSpan&quot; /&gt; will be serialized as a number of whole milliseconds.&lt;/para&gt;</file><file path="DisCatSharp.Common/Serialization/TimeSpanFormatAttribute.cs">// ReSharper disable InconsistentNaming
⋮----
/// &lt;summary&gt;
///     Defines the format for string-serialized &lt;see cref=&quot;TimeSpan&quot; /&gt; objects.
/// &lt;/summary&gt;
⋮----
public sealed class TimeSpanFormatAttribute : SerializationAttribute
⋮----
///     Gets the ISO 8601 format string of @&quot;ddThh\:mm\:ss\.fff&quot;.
⋮----
///     Gets the constant format.
⋮----
///     Gets the general long format.
⋮----
///     Gets the general short format.
⋮----
///     Specifies a predefined format to use.
⋮----
/// &lt;param name=&quot;kind&quot;&gt;Predefined format kind to use.&lt;/param&gt;
⋮----
throw new ArgumentOutOfRangeException(nameof(kind), &quot;Specified format kind is not legal or supported.&quot;);
⋮----
///     &lt;para&gt;Specifies a custom format to use.&lt;/para&gt;
///     &lt;para&gt;
///         See https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-timespan-format-strings for more
///         details.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;format&quot;&gt;Custom format string to use.&lt;/param&gt;
⋮----
if (string.IsNullOrWhiteSpace(format))
throw new ArgumentNullException(nameof(format), &quot;Specified format cannot be null or empty.&quot;);
⋮----
///     Gets the custom datetime format string to use.
⋮----
///     Gets the predefined datetime format kind.
⋮----
///     &lt;para&gt;Defines which built-in format to use for &lt;see cref=&quot;TimeSpan&quot; /&gt; serialization.&lt;/para&gt;
⋮----
///         See https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings and
///         https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-timespan-format-strings for more details.
⋮----
///     Specifies ISO 8601-like time format, which is equivalent to .NET format string of @&quot;ddThh\:mm\:ss\.fff&quot;.
⋮----
///     Specifies a format defined by &lt;see cref=&quot;System.Globalization.CultureInfo.InvariantCulture&quot; /&gt;, with a format
///     string of &quot;c&quot;.
⋮----
///     Specifies a format defined by &lt;see cref=&quot;System.Globalization.CultureInfo.CurrentCulture&quot; /&gt;, with a format string
///     of &quot;G&quot;. This format is not recommended for portability reasons.
⋮----
///     of &quot;g&quot;. This format is not recommended for portability reasons.
⋮----
///     string of &quot;G&quot;. This format is not recommended for portability reasons.
⋮----
///     string of &quot;g&quot;. This format is not recommended for portability reasons.
⋮----
///     Specifies a custom format. This value is not usable directly.</file><file path="DisCatSharp.Common/Serialization/UnixTimestampAttributes.cs">/// &lt;summary&gt;
///     &lt;para&gt;
///         Specifies that this &lt;see cref=&quot;DateTime&quot; /&gt; or &lt;see cref=&quot;DateTimeOffset&quot; /&gt; will be serialized as Unix
///         timestamp seconds.
///     &lt;/para&gt;
///     &lt;para&gt;This value will always be serialized as a number.&lt;/para&gt;
/// &lt;/summary&gt;
⋮----
///         timestamp milliseconds.</file><file path="DisCatSharp.Common/Types/CharSpanLookupDictionary.cs">/// &lt;summary&gt;
///     Represents collection of string keys and &lt;typeparamref name=&quot;TValue&quot; /&gt; values, allowing the use of
///     &lt;see cref=&quot;ReadOnlySpan{T}&quot; /&gt; for dictionary operations.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TValue&quot;&gt;Type of items in this dictionary.&lt;/typeparam&gt;
public sealed class CharSpanLookupDictionary&lt;TValue&gt; :
IDictionary&lt;string, TValue?&gt;,
IReadOnlyDictionary&lt;string, TValue?&gt;,
IDictionary
⋮----
///     Gets the internal buckets.
⋮----
///     Creates a new, empty &lt;see cref=&quot;CharSpanLookupDictionary{TValue}&quot; /&gt; with string keys and items of type
///     &lt;typeparamref name=&quot;TValue&quot; /&gt;.
⋮----
///     &lt;typeparamref name=&quot;TValue&quot; /&gt; and sets its initial capacity to specified value.
⋮----
/// &lt;param name=&quot;initialCapacity&quot;&gt;Initial capacity of the dictionary.&lt;/param&gt;
⋮----
///     Creates a new &lt;see cref=&quot;CharSpanLookupDictionary{TValue}&quot; /&gt; with string keys and items of type
///     &lt;typeparamref name=&quot;TValue&quot; /&gt; and populates it with key-value pairs from supplied dictionary.
⋮----
/// &lt;param name=&quot;values&quot;&gt;Dictionary containing items to populate this dictionary with.&lt;/param&gt;
⋮----
this.Add(k, v);
⋮----
///     &lt;typeparamref name=&quot;TValue&quot; /&gt; and populates it with key-value pairs from supplied key-value collection.
⋮----
///     Gets or sets a value corresponding to given key in this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to get or set the value for.&lt;/param&gt;
/// &lt;returns&gt;Value matching the supplied key, if applicable.&lt;/returns&gt;
⋮----
get =&gt; !this.TryRetrieveInternal(key, out var value)
? throw new KeyNotFoundException(&quot;The given key was not present in the dictionary.&quot;)
⋮----
fixed (char* chars = &amp;key.GetPinnableReference())
⋮----
this.TryInsertInternal(new(chars, 0, key.Length), value, true);
⋮----
///     Gets the keys.
⋮----
ICollection IDictionary.Keys =&gt; this.GetKeysInternal();
⋮----
///     Gets the values.
⋮----
ICollection IDictionary.Values =&gt; this.GetValuesInternal();
⋮----
///     Gets whether this dictionary has a fixed size.
⋮----
///     Gets whether this dictionary is considered thread-safe.
⋮----
///     Gets the object which allows synchronizing access to this dictionary.
⋮----
/// &lt;inheritdoc /&gt;
⋮----
? throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;)
: !this.TryRetrieveInternal(tkey.AsSpan(), out var value)
? throw new KeyNotFoundException($&quot;The given key &apos;{tkey}&apos; was not present in the dictionary.&quot;)
⋮----
throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;);
⋮----
throw new ArgumentException($&quot;Value needs to be an instance of {typeof(TValue)}.&quot;);
⋮----
this.TryInsertInternal(tkey, tvalue, true);
⋮----
///     Adds the.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
void IDictionary.Add(object key, object? value)
⋮----
this.Add(tkey, tvalue);
⋮----
///     Removes the.
⋮----
void IDictionary.Remove(object key)
⋮----
this.TryRemove(tkey, out _);
⋮----
///     Contains the.
⋮----
/// &lt;returns&gt;A bool.&lt;/returns&gt;
bool IDictionary.Contains(object key)
=&gt; key is not string tkey ? throw new ArgumentException(&quot;Key needs to be an instance of a string.&quot;) : this.ContainsKey(tkey);
⋮----
///     Gets the enumerator.
⋮----
/// &lt;returns&gt;An IDictionaryEnumerator.&lt;/returns&gt;
IDictionaryEnumerator IDictionary.GetEnumerator()
=&gt; new Enumerator(this);
⋮----
///     Copies the to.
⋮----
/// &lt;param name=&quot;array&quot;&gt;The array.&lt;/param&gt;
/// &lt;param name=&quot;arrayIndex&quot;&gt;The array index.&lt;/param&gt;
void ICollection.CopyTo(Array array, int arrayIndex)
⋮----
(this as ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;).CopyTo(tarray, arrayIndex);
⋮----
throw new ArgumentException($&quot;Array needs to be an instance of {typeof(TValue[])} or object[].&quot;);
⋮----
array.SetValue(new KeyValuePair&lt;string, TValue?&gt;(kdv.Key, kdv.Value), i++);
⋮----
ICollection&lt;string&gt; IDictionary&lt;string, TValue?&gt;.Keys =&gt; this.GetKeysInternal();
⋮----
ICollection&lt;TValue?&gt; IDictionary&lt;string, TValue?&gt;.Values =&gt; this.GetValuesInternal();
⋮----
///     Gets the total number of items in this dictionary.
⋮----
///     Gets whether this dictionary is read-only.
⋮----
ArgumentNullException.ThrowIfNull(key);
⋮----
return !this.TryRetrieveInternal(key.AsSpan(), out var value)
? throw new KeyNotFoundException($&quot;The given key &apos;{key}&apos; was not present in the dictionary.&quot;)
⋮----
this.TryInsertInternal(key, value, true);
⋮----
///     Inserts a specific key and corresponding value into this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to insert.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Value corresponding to this key.&lt;/param&gt;
public void Add(string key, TValue? value)
⋮----
if (!this.TryInsertInternal(key, value, false))
throw new ArgumentException(&quot;Given key is already present in the dictionary.&quot;, nameof(key));
⋮----
///     Attempts to retrieve a value corresponding to the supplied key from this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to retrieve the value for.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Retrieved value.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation was successful.&lt;/returns&gt;
public bool TryGetValue(string key, out TValue? value)
⋮----
return this.TryRetrieveInternal(key.AsSpan(), out value);
⋮----
///     Checks whether this dictionary contains the specified key.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to check for in this dictionary.&lt;/param&gt;
/// &lt;returns&gt;Whether the key was present in the dictionary.&lt;/returns&gt;
public bool ContainsKey(string key)
=&gt; this.ContainsKeyInternal(key.AsSpan());
⋮----
///     Removes all items from this dictionary.
⋮----
public void Clear()
⋮----
this._internalBuckets.Clear();
⋮----
///     Gets an enumerator over key-value pairs in this dictionary.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt; GetEnumerator()
=&gt; new Enumerator(this!);
⋮----
bool IDictionary&lt;string, TValue?&gt;.Remove(string key)
=&gt; this.TryRemove(key.AsSpan(), out _);
⋮----
/// &lt;param name=&quot;item&quot;&gt;The item.&lt;/param&gt;
void ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Add(KeyValuePair&lt;string, TValue?&gt; item)
=&gt; this.Add(item.Key, item.Value);
⋮----
bool ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Remove(KeyValuePair&lt;string, TValue?&gt; item)
=&gt; this.TryRemove(item.Key, out _);
⋮----
bool ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.Contains(KeyValuePair&lt;string, TValue?&gt; item)
=&gt; this.TryGetValue(item.Key, out var value) &amp;&amp; EqualityComparer&lt;TValue?&gt;.Default.Equals(value, item.Value);
⋮----
void ICollection&lt;KeyValuePair&lt;string, TValue?&gt;&gt;.CopyTo(KeyValuePair&lt;string, TValue?&gt;[] array, int arrayIndex)
⋮----
throw new ArgumentException(&quot;Target array is too small.&quot;, nameof(array));
⋮----
/// &lt;returns&gt;An IEnumerator.&lt;/returns&gt;
IEnumerator IEnumerable.GetEnumerator()
=&gt; this.GetEnumerator();
⋮----
///     Gets the collection of all keys present in this dictionary.
⋮----
public IEnumerable&lt;string&gt; Keys =&gt; this.GetKeysInternal();
⋮----
///     Gets the collection of all values present in this dictionary.
⋮----
public IEnumerable&lt;TValue?&gt; Values =&gt; this.GetValuesInternal();
⋮----
public void Add(ReadOnlySpan&lt;char&gt; key, TValue? value)
⋮----
if (!this.TryInsertInternal(new(chars, 0, key.Length), value, false))
⋮----
///     Attempts to insert a specific key and corresponding value into this dictionary.
⋮----
public bool TryAdd(string key, TValue? value)
=&gt; this.TryInsertInternal(key, value, false);
⋮----
public bool TryAdd(ReadOnlySpan&lt;char&gt; key, TValue? value)
⋮----
return this.TryInsertInternal(new(chars, 0, key.Length), value, false);
⋮----
public bool TryGetValue(ReadOnlySpan&lt;char&gt; key, out TValue? value)
=&gt; this.TryRetrieveInternal(key, out value);
⋮----
///     Attempts to remove a value corresponding to the supplied key from this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to remove the value for.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Removed value.&lt;/param&gt;
⋮----
public bool TryRemove(string key, out TValue? value)
⋮----
return this.TryRemoveInternal(key.AsSpan(), out value);
⋮----
public bool TryRemove(ReadOnlySpan&lt;char&gt; key, out TValue? value)
=&gt; this.TryRemoveInternal(key, out value);
⋮----
public bool ContainsKey(ReadOnlySpan&lt;char&gt; key)
=&gt; this.ContainsKeyInternal(key);
⋮----
///     Tries the insert internal.
⋮----
/// &lt;param name=&quot;replace&quot;&gt;If true, replace.&lt;/param&gt;
⋮----
private bool TryInsertInternal(string key, TValue? value, bool replace)
⋮----
throw new ArgumentNullException(nameof(key), &quot;Key cannot be null.&quot;);
⋮----
var hash = key.CalculateKnuthHash();
if (!this._internalBuckets.ContainsKey(hash))
⋮----
this._internalBuckets.Add(hash, new(key, hash, value));
⋮----
///     Tries the retrieve internal.
⋮----
private bool TryRetrieveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
⋮----
if (!this._internalBuckets.TryGetValue(hash, out var kdv))
⋮----
if (key.SequenceEqual(kdv.Key.AsSpan()))
⋮----
///     Tries the remove internal.
⋮----
private bool TryRemoveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
⋮----
case null when key.SequenceEqual(kdv.Key.AsSpan()):
// Only bucket under this hash and key matches, pop the entire bucket
⋮----
this._internalBuckets.Remove(hash);
⋮----
// Only bucket under this hash and key does not match, cannot remove
⋮----
// First key in the bucket matches, pop it and set its child as current bucket
⋮----
// Key matched, remove this bucket from the chain
⋮----
///     Contains the key internal.
⋮----
private bool ContainsKeyInternal(ReadOnlySpan&lt;char&gt; key)
⋮----
///     Gets the keys internal.
⋮----
/// &lt;returns&gt;An ImmutableArray.&lt;/returns&gt;
private ImmutableArray&lt;string&gt; GetKeysInternal()
⋮----
builder.Add(kdv.Key);
⋮----
return builder.MoveToImmutable();
⋮----
///     Gets the values internal.
⋮----
private ImmutableArray&lt;TValue?&gt; GetValuesInternal()
⋮----
builder.Add(kdv.Value);
⋮----
///     The keyed value.
⋮----
/// &lt;remarks&gt;
///     Initializes a new instance of the &lt;see cref=&quot;KeyedValue&quot; /&gt; class.
/// &lt;/remarks&gt;
⋮----
/// &lt;param name=&quot;keyHash&quot;&gt;The key hash.&lt;/param&gt;
⋮----
///     Gets the key hash.
⋮----
///     Gets the key.
⋮----
///     Gets or sets the value.
⋮----
///     Gets or sets the next.
⋮----
///     The enumerator.
⋮----
private sealed class Enumerator :
IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt;,
IDictionaryEnumerator
⋮----
///     Gets the internal dictionary.
⋮----
///     Gets the internal enumerator.
⋮----
///     Gets or sets the current value.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Enumerator&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;spDict&quot;&gt;The sp dict.&lt;/param&gt;
⋮----
this._internalEnumerator = this._internalDictionary._internalBuckets.GetEnumerator();
⋮----
///     Gets the value.
⋮----
///     Gets the entry.
⋮----
///     Gets the current.
⋮----
///     Moves the next.
⋮----
public bool MoveNext()
⋮----
if (!this._internalEnumerator.MoveNext())
⋮----
///     Resets the.
⋮----
public void Reset()
⋮----
this._internalEnumerator.Reset();
⋮----
///     Disposes the.
⋮----
public void Dispose() =&gt; this.Reset();</file><file path="DisCatSharp.Common/Types/CharSpanLookupReadOnlyDictionary.cs">/// &lt;summary&gt;
///     Represents collection of string keys and &lt;typeparamref name=&quot;TValue&quot; /&gt; values, allowing the use of
///     &lt;see cref=&quot;ReadOnlySpan{T}&quot; /&gt; for dictionary operations.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TValue&quot;&gt;Type of items in this dictionary.&lt;/typeparam&gt;
public sealed class CharSpanLookupReadOnlyDictionary&lt;TValue&gt; : IReadOnlyDictionary&lt;string, TValue?&gt;
⋮----
///     Gets the internal buckets.
⋮----
///     Creates a new &lt;see cref=&quot;CharSpanLookupReadOnlyDictionary{TValue}&quot; /&gt; with string keys and items of type
///     &lt;typeparamref name=&quot;TValue&quot; /&gt; and populates it with key-value pairs from supplied dictionary.
⋮----
/// &lt;param name=&quot;values&quot;&gt;Dictionary containing items to populate this dictionary with.&lt;/param&gt;
⋮----
///     &lt;typeparamref name=&quot;TValue&quot; /&gt; and populates it with key-value pairs from supplied key-value collection.
⋮----
ArgumentNullException.ThrowIfNull(values);
⋮----
///     Gets a value corresponding to given key in this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to get or set the value for.&lt;/param&gt;
/// &lt;returns&gt;Value matching the supplied key, if applicable.&lt;/returns&gt;
⋮----
=&gt; !this.TryRetrieveInternal(key, out var value)
? throw new KeyNotFoundException(&quot;The given key was not present in the dictionary.&quot;)
⋮----
///     Gets the collection of all keys present in this dictionary.
⋮----
public IEnumerable&lt;string&gt; Keys =&gt; this.GetKeysInternal();
⋮----
///     Gets the collection of all values present in this dictionary.
⋮----
public IEnumerable&lt;TValue?&gt; Values =&gt; this.GetValuesInternal();
⋮----
///     Gets the total number of items in this dictionary.
⋮----
ArgumentNullException.ThrowIfNull(key);
⋮----
return !this.TryRetrieveInternal(key.AsSpan(), out var value)
? throw new KeyNotFoundException($&quot;The given key &apos;{key}&apos; was not present in the dictionary.&quot;)
⋮----
///     Attempts to retrieve a value corresponding to the supplied key from this dictionary.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to retrieve the value for.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Retrieved value.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation was successful.&lt;/returns&gt;
public bool TryGetValue(string key, out TValue? value)
⋮----
return this.TryRetrieveInternal(key.AsSpan(), out value);
⋮----
///     Checks whether this dictionary contains the specified key.
⋮----
/// &lt;param name=&quot;key&quot;&gt;Key to check for in this dictionary.&lt;/param&gt;
/// &lt;returns&gt;Whether the key was present in the dictionary.&lt;/returns&gt;
public bool ContainsKey(string key)
=&gt; this.ContainsKeyInternal(key.AsSpan());
⋮----
///     Gets an enumerator over key-value pairs in this dictionary.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt; GetEnumerator()
=&gt; new Enumerator(this!);
⋮----
///     Gets the enumerator.
⋮----
/// &lt;returns&gt;An IEnumerator.&lt;/returns&gt;
IEnumerator IEnumerable.GetEnumerator()
=&gt; this.GetEnumerator();
⋮----
public bool TryGetValue(ReadOnlySpan&lt;char&gt; key, out TValue? value)
=&gt; this.TryRetrieveInternal(key, out value);
⋮----
public bool ContainsKey(ReadOnlySpan&lt;char&gt; key)
=&gt; this.ContainsKeyInternal(key);
⋮----
///     Tries the retrieve internal.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;returns&gt;A bool.&lt;/returns&gt;
private bool TryRetrieveInternal(ReadOnlySpan&lt;char&gt; key, out TValue? value)
⋮----
var hash = key.CalculateKnuthHash();
if (!this._internalBuckets.TryGetValue(hash, out var kdv))
⋮----
if (key.SequenceEqual(kdv.Key.AsSpan()))
⋮----
///     Contains the key internal.
⋮----
private bool ContainsKeyInternal(ReadOnlySpan&lt;char&gt; key)
⋮----
///     Gets the keys internal.
⋮----
/// &lt;returns&gt;An ImmutableArray.&lt;/returns&gt;
private ImmutableArray&lt;string&gt; GetKeysInternal()
⋮----
builder.Add(kdv.Key);
⋮----
return builder.MoveToImmutable();
⋮----
///     Gets the values internal.
⋮----
private ImmutableArray&lt;TValue?&gt; GetValuesInternal()
⋮----
builder.Add(kdv.Value);
⋮----
///     Prepares the items.
⋮----
/// &lt;param name=&quot;items&quot;&gt;The items.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;The count.&lt;/param&gt;
/// &lt;returns&gt;An IReadOnlyDictionary.&lt;/returns&gt;
private static ReadOnlyDictionary&lt;ulong, KeyedValue?&gt; PrepareItems(IEnumerable&lt;KeyValuePair&lt;string, TValue?&gt;&gt; items, out int count)
⋮----
throw new ArgumentException(&quot;Keys cannot be null.&quot;, nameof(items));
⋮----
var hash = k.CalculateKnuthHash();
if (!dict.ContainsKey(hash))
⋮----
dict.Add(hash, new(k, hash, v));
⋮----
throw new ArgumentException(&quot;Given key is already present in the dictionary.&quot;, nameof(items));
⋮----
///     The keyed value.
⋮----
/// &lt;remarks&gt;
///     Initializes a new instance of the &lt;see cref=&quot;KeyedValue&quot; /&gt; class.
/// &lt;/remarks&gt;
⋮----
/// &lt;param name=&quot;keyHash&quot;&gt;The key hash.&lt;/param&gt;
⋮----
///     Gets the key hash.
⋮----
///     Gets the key.
⋮----
///     Gets or sets the value.
⋮----
///     Gets or sets the next.
⋮----
///     The enumerator.
⋮----
private sealed class Enumerator : IEnumerator&lt;KeyValuePair&lt;string, TValue?&gt;&gt;
⋮----
///     Gets the internal dictionary.
⋮----
///     Gets the internal enumerator.
⋮----
///     Gets or sets the current value.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Enumerator&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;spDict&quot;&gt;The sp dict.&lt;/param&gt;
⋮----
this._internalEnumerator = this._internalDictionary._internalBuckets.GetEnumerator();
⋮----
///     Gets the current.
⋮----
///     Moves the next.
⋮----
public bool MoveNext()
⋮----
if (!this._internalEnumerator.MoveNext())
⋮----
///     Resets the.
⋮----
public void Reset()
⋮----
this._internalEnumerator.Reset();
this._internalEnumerator.Dispose();
⋮----
///     Disposes the.
⋮----
public void Dispose()
=&gt; this.Reset();</file><file path="DisCatSharp.Common/Types/ContinuousMemoryBuffer.cs">/// &lt;summary&gt;
///     Provides a resizable memory buffer analogous to &lt;see cref=&quot;MemoryBuffer{T}&quot; /&gt;, using a single continuous memory
///     region instead.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of item to hold in the buffer.&lt;/typeparam&gt;
public sealed class ContinuousMemoryBuffer&lt;T&gt; : IMemoryBuffer&lt;T&gt; where T : unmanaged
⋮----
///     Creates a new buffer with a specified segment size, specified number of initially-allocated segments, and supplied
///     memory pool.
⋮----
/// &lt;param name=&quot;initialSize&quot;&gt;Initial size of the buffer in bytes. Defaults to 64KiB.&lt;/param&gt;
/// &lt;param name=&quot;memPool&quot;&gt;Memory pool to use for renting buffers. Defaults to &lt;see cref=&quot;MemoryPool{T}.Shared&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;clearOnDispose&quot;&gt;
///     Determines whether the underlying buffers should be cleared on exit. If dealing with
///     sensitive data, it might be a good idea to set this option to true.
/// &lt;/param&gt;
⋮----
this._buffOwner = this._pool.Rent(initialSize);
⋮----
/// &lt;inheritdoc /&gt;
⋮----
public void Write(ReadOnlySpan&lt;T&gt; data)
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
var bytes = MemoryMarshal.AsBytes(data);
this.EnsureSize(this._pos + bytes.Length);
⋮----
bytes.CopyTo(this._buff[this._pos..].Span);
⋮----
public void Write(T[] data, int start, int count)
=&gt; this.Write(data.AsSpan(start, count));
⋮----
public void Write(ArraySegment&lt;T&gt; data)
=&gt; this.Write(data.AsSpan());
⋮----
public void Write(Stream stream)
⋮----
this.WriteStreamSeekable(stream);
⋮----
this.WriteStreamUnseekable(stream);
⋮----
public bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten)
⋮----
throw new ArgumentOutOfRangeException(nameof(source), &quot;Cannot copy data from beyond the buffer.&quot;);
⋮----
var dbuff = MemoryMarshal.AsBytes(destination);
⋮----
sbuff.CopyTo(dbuff);
⋮----
public bool Read(T[] data, int start, int count, ulong source, out int itemsWritten)
=&gt; this.Read(data.AsSpan(start, count), source, out itemsWritten);
⋮----
public bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten)
=&gt; this.Read(data.AsSpan(), source, out itemsWritten);
⋮----
public T[] ToArray()
⋮----
return MemoryMarshal.Cast&lt;byte, T&gt;(this._buff[..this._pos].Span).ToArray();
⋮----
public void CopyTo(Stream destination)
⋮----
var buff = this._buff[..this._pos].ToArray();
destination.Write(buff, 0, buff.Length);
⋮----
public void Clear()
⋮----
///     Disposes of any resources claimed by this buffer.
⋮----
public void Dispose()
⋮----
this._buff.Span.Clear();
⋮----
this._buffOwner.Dispose();
⋮----
///     Writes the stream seekable.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The stream.&lt;/param&gt;
private void WriteStreamSeekable(Stream stream)
⋮----
throw new ArgumentException(&quot;Stream is too long.&quot;, nameof(stream));
⋮----
this.EnsureSize(this._pos + (int)stream.Length);
var memo = ArrayPool&lt;byte&gt;.Shared.Rent((int)stream.Length);
⋮----
var br = stream.Read(memo, 0, memo.Length);
memo.AsSpan(0, br).CopyTo(this._buff[this._pos..].Span);
⋮----
ArrayPool&lt;byte&gt;.Shared.Return(memo);
⋮----
///     Writes the stream unseekable.
⋮----
private void WriteStreamUnseekable(Stream stream)
⋮----
var memo = ArrayPool&lt;byte&gt;.Shared.Rent(4096);
⋮----
while ((br = stream.Read(memo, 0, memo.Length)) != 0)
⋮----
this.EnsureSize(this._pos + br);
⋮----
///     Ensures the size.
⋮----
/// &lt;param name=&quot;newCapacity&quot;&gt;The new capacity.&lt;/param&gt;
private void EnsureSize(int newCapacity)
⋮----
var newBuffOwner = this._pool.Rent(newActualCapacity);
⋮----
this._buff.Span.CopyTo(newBuff.Span);</file><file path="DisCatSharp.Common/Types/IMemoryBuffer.cs">/// &lt;summary&gt;
///     An interface describing the API of resizable memory buffers, such as &lt;see cref=&quot;MemoryBuffer{T}&quot; /&gt; and
///     &lt;see cref=&quot;ContinuousMemoryBuffer{T}&quot; /&gt;.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of item to hold in the buffer.&lt;/typeparam&gt;
public interface IMemoryBuffer&lt;T&gt; : IDisposable where T : unmanaged
⋮----
///     Gets the total capacity of this buffer. The capacity is the number of segments allocated, multiplied by size of
///     individual segment.
⋮----
///     Gets the amount of bytes currently written to the buffer. This number is never greater than &lt;see cref=&quot;Capacity&quot; /&gt;
///     .
⋮----
///     Gets the number of items currently written to the buffer. This number is equal to &lt;see cref=&quot;Count&quot; /&gt; divided by
///     size of &lt;typeparamref name=&quot;T&quot; /&gt;.
⋮----
///     Appends data from a supplied buffer to this buffer, growing it if necessary.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Buffer containing data to write.&lt;/param&gt;
void Write(ReadOnlySpan&lt;T&gt; data);
⋮----
///     Appends data from a supplied array to this buffer, growing it if necessary.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Array containing data to write.&lt;/param&gt;
/// &lt;param name=&quot;start&quot;&gt;Index from which to start reading the data.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;Number of bytes to read from the source.&lt;/param&gt;
void Write(T[] data, int start, int count);
⋮----
///     Appends data from a supplied array slice to this buffer, growing it if necessary.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Array slice containing data to write.&lt;/param&gt;
void Write(ArraySegment&lt;T&gt; data);
⋮----
///     Appends data from a supplied stream to this buffer, growing it if necessary.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;Stream to copy data from.&lt;/param&gt;
void Write(Stream stream);
⋮----
///     Reads data from this buffer to the specified destination buffer. This method will write either as many
///     bytes as there are in the destination buffer, or however many bytes are available in this buffer,
///     whichever is less.
⋮----
/// &lt;param name=&quot;destination&quot;&gt;Buffer to read the data from this buffer into.&lt;/param&gt;
/// &lt;param name=&quot;source&quot;&gt;Starting position in this buffer to read from.&lt;/param&gt;
/// &lt;param name=&quot;itemsWritten&quot;&gt;Number of items written to the destination buffer.&lt;/param&gt;
/// &lt;returns&gt;Whether more data is available in this buffer.&lt;/returns&gt;
bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten);
⋮----
///     Reads data from this buffer to specified destination array. This method will write either as many bytes
///     as specified for the destination array, or however many bytes are available in this buffer, whichever is
///     less.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Array to read the data from this buffer into.&lt;/param&gt;
/// &lt;param name=&quot;start&quot;&gt;Starting position in the target array to write to.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;Maximum number of bytes to write to target array.&lt;/param&gt;
⋮----
bool Read(T[] data, int start, int count, ulong source, out int itemsWritten);
⋮----
///     Reads data from this buffer to specified destination array slice. This method will write either as many
///     bytes as specified in the target slice, or however many bytes are available in this buffer, whichever is
⋮----
/// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
⋮----
bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten);
⋮----
///     Converts this buffer into a single continuous byte array.
⋮----
/// &lt;returns&gt;Converted byte array.&lt;/returns&gt;
T[] ToArray();
⋮----
///     Copies all the data from this buffer to a stream.
⋮----
/// &lt;param name=&quot;destination&quot;&gt;Stream to copy this buffer&apos;s data to.&lt;/param&gt;
void CopyTo(Stream destination);
⋮----
///     Resets the buffer&apos;s pointer to the beginning, allowing for reuse.
⋮----
void Clear();</file><file path="DisCatSharp.Common/Types/LinqMethods.cs">/// &lt;summary&gt;
///     Various Methods for Linq
/// &lt;/summary&gt;
public static class LinqMethods
⋮----
///     Safely tries to get the first match out of a list.
⋮----
/// &lt;typeparam name=&quot;TSource&quot;&gt;Value type of list.&lt;/typeparam&gt;
/// &lt;param name=&quot;list&quot;&gt;The list to use.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value to get if succeeded&lt;/param&gt;
/// &lt;returns&gt;Whether a value was found.&lt;/returns&gt;
public static bool TryGetFirstValueWhere&lt;TSource&gt;(this List&lt;TSource?&gt;? list, Func&lt;TSource?, bool&gt; predicate, [NotNullWhen(true)] out TSource? value)
⋮----
ArgumentNullException.ThrowIfNull(predicate);
if (list.EmptyOrNull())
⋮----
value = list.Where(predicate).FirstOrDefault();
⋮----
///     Safely tries to extract the value of the first match where target key is found, otherwise null.
⋮----
/// &lt;typeparam name=&quot;TKey&quot;&gt;Key type of dictionary.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TValue&quot;&gt;Value type of dictionary.&lt;/typeparam&gt;
/// &lt;param name=&quot;dict&quot;&gt;The dictionary to use.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to search for.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value to get if succeeded.&lt;/param&gt;
/// &lt;returns&gt;Whether a value was found through the key.&lt;/returns&gt;
public static bool TryGetFirstValueByKey&lt;TKey, TValue&gt;(this Dictionary&lt;TKey, TValue?&gt;? dict, TKey key, [NotNullWhen(true)] out TValue? value)
where TKey : notnull
⋮----
return dict.TryGetValue(key, out value);</file><file path="DisCatSharp.Common/Types/MemoryBuffer.cs">/// &lt;summary&gt;
///     Provides a resizable memory buffer, which can be read from and written to. It will automatically resize whenever
///     required.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of item to hold in the buffer.&lt;/typeparam&gt;
public sealed class MemoryBuffer&lt;T&gt; : IMemoryBuffer&lt;T&gt; where T : unmanaged
⋮----
///     Creates a new buffer with a specified segment size, specified number of initially-allocated segments, and supplied
///     memory pool.
⋮----
/// &lt;param name=&quot;segmentSize&quot;&gt;Byte size of an individual segment. Defaults to 64KiB.&lt;/param&gt;
/// &lt;param name=&quot;initialSegmentCount&quot;&gt;Number of segments to allocate. Defaults to 0.&lt;/param&gt;
/// &lt;param name=&quot;memPool&quot;&gt;Memory pool to use for renting buffers. Defaults to &lt;see cref=&quot;MemoryPool{T}.Shared&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;clearOnDispose&quot;&gt;
///     Determines whether the underlying buffers should be cleared on exit. If dealing with
///     sensitive data, it might be a good idea to set this option to true.
/// &lt;/param&gt;
⋮----
throw new ArgumentException(&quot;Segment size must match size of individual item.&quot;);
⋮----
this._segments = Enumerable.Range(0, initialSegmentCount)
.Select(x =&gt; this._pool.Rent(this._segmentSize))
.ToList();
⋮----
/// &lt;inheritdoc /&gt;
⋮----
this._segments.Aggregate(0UL, (a, x) =&gt; a + (ulong)x.Memory.Length); // .Sum() does only int
⋮----
public void Write(ReadOnlySpan&lt;T&gt; data)
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
var src = MemoryMarshal.AsBytes(data);
this.Grow(src.Length);
⋮----
src[..avs].CopyTo(dmem.Span);
⋮----
public void Write(T[] data, int start, int count)
=&gt; this.Write(data.AsSpan(start, count));
⋮----
public void Write(ArraySegment&lt;T&gt; data)
=&gt; this.Write(data.AsSpan());
⋮----
public void Write(Stream stream)
⋮----
this.WriteStreamSeekable(stream);
⋮----
this.WriteStreamUnseekable(stream);
⋮----
public bool Read(Span&lt;T&gt; destination, ulong source, out int itemsWritten)
⋮----
throw new ArgumentOutOfRangeException(nameof(source), &quot;Cannot copy data from beyond the buffer.&quot;);
⋮----
// Find where to begin
⋮----
// Do actual copy
⋮----
var dst = MemoryMarshal.AsBytes(destination);
⋮----
src.CopyTo(dst);
⋮----
public bool Read(T[] data, int start, int count, ulong source, out int itemsWritten)
=&gt; this.Read(data.AsSpan(start, count), source, out itemsWritten);
⋮----
public bool Read(ArraySegment&lt;T&gt; data, ulong source, out int itemsWritten)
=&gt; this.Read(data.AsSpan(), source, out itemsWritten);
⋮----
public T[] ToArray()
⋮----
this.Read(bytes, 0, out _);
⋮----
public void CopyTo(Stream destination)
⋮----
var longest = this._segments.Max(x =&gt; x.Memory.Length);
⋮----
var spn = buff.AsSpan(0, mem.Length);
⋮----
mem.CopyTo(spn);
destination.Write(buff, 0, spn.Length);
⋮----
public void Clear()
⋮----
///     Disposes of any resources claimed by this buffer.
⋮----
public void Dispose()
⋮----
segment.Memory.Span.Clear();
⋮----
segment.Dispose();
⋮----
///     Writes the stream seekable.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The stream.&lt;/param&gt;
private void WriteStreamSeekable(Stream stream)
⋮----
this.Grow(len);
⋮----
_ = stream.Read(buff, 0, slen);
buff.AsSpan(0, slen).CopyTo(dmem.Span);
⋮----
///     Writes the stream unseekable.
⋮----
private void WriteStreamUnseekable(Stream stream)
⋮----
var buffs = buff.AsSpan();
while ((read = stream.Read(buff, 0, buff.Length - this._lastSegmentLength)) != 0)
this.Write(MemoryMarshal.Cast&lt;byte, T&gt;(buffs[..read]));
⋮----
///     Grows the.
⋮----
/// &lt;param name=&quot;minAmount&quot;&gt;The min amount.&lt;/param&gt;
private void Grow(int minAmount)
⋮----
return; // we&apos;re good
⋮----
// Basically List&lt;T&gt;.EnsureCapacity
// Default grow behaviour is minimum current*2
⋮----
this._segments.Add(this._pool.Rent(this._segmentSize));</file><file path="DisCatSharp.Common/Types/SecureRandom.cs">/// &lt;summary&gt;
///     Provides a cryptographically-secure pseudorandom number generator (CSPRNG) implementation compatible with
///     &lt;see cref=&quot;Random&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class SecureRandom : Random, IDisposable
⋮----
///     Gets the random number generator.
⋮----
private readonly RandomNumberGenerator _rng = RandomNumberGenerator.Create();
⋮----
///     Whether this &lt;see cref=&quot;SecureRandom&quot; /&gt; instance has been disposed.
⋮----
///     Creates a new instance of &lt;see cref=&quot;SecureRandom&quot; /&gt;.
⋮----
///     Disposes this &lt;see cref=&quot;SecureRandom&quot; /&gt; instance and its resources.
⋮----
public void Dispose()
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
this._rng.Dispose();
GC.SuppressFinalize(this);
⋮----
///     Finalizes this &lt;see cref=&quot;SecureRandom&quot; /&gt; instance by disposing it.
⋮----
this.Dispose();
⋮----
///     Fills a supplied buffer with random bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Buffer to fill with random bytes.&lt;/param&gt;
public void GetBytes(byte[] buffer) =&gt; this._rng.GetBytes(buffer);
⋮----
///     Fills a supplied buffer with random nonzero bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Buffer to fill with random nonzero bytes.&lt;/param&gt;
public void GetNonZeroBytes(byte[] buffer) =&gt; this._rng.GetNonZeroBytes(buffer);
⋮----
///     Fills a supplied memory region with random bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Memory region to fill with random bytes.&lt;/param&gt;
public void GetBytes(Span&lt;byte&gt; buffer)
⋮----
var buff = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length);
⋮----
var buffSpan = buff.AsSpan(0, buffer.Length);
this._rng.GetBytes(buff);
buffSpan.CopyTo(buffer);
⋮----
ArrayPool&lt;byte&gt;.Shared.Return(buff);
⋮----
///     Fills a supplied memory region with random nonzero bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Memory region to fill with random nonzero bytes.&lt;/param&gt;
public void GetNonZeroBytes(Span&lt;byte&gt; buffer)
⋮----
this._rng.GetNonZeroBytes(buff);
⋮----
///     Generates a signed 8-bit integer within specified range.
⋮----
/// &lt;param name=&quot;min&quot;&gt;Minimum value to generate. Defaults to 0.&lt;/param&gt;
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;sbyte.MaxValue&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;Generated random value.&lt;/returns&gt;
public sbyte GetInt8(sbyte min = 0, sbyte max = sbyte.MaxValue)
⋮----
throw new ArgumentException(&quot;Maximum needs to be greater than minimum.&quot;, nameof(max));
⋮----
return (sbyte)((Math.Abs(this.Generate&lt;sbyte&gt;()) % (max - min)) + min - offset);
⋮----
///     Generates a unsigned 8-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;byte.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public byte GetUInt8(byte min = 0, byte max = byte.MaxValue)
⋮----
? throw new ArgumentException(&quot;Maximum needs to be greater than minimum.&quot;, nameof(max))
⋮----
///     Generates a signed 16-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;short.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public short GetInt16(short min = 0, short max = short.MaxValue)
⋮----
return (short)((Math.Abs(this.Generate&lt;short&gt;()) % (max - min)) + min - offset);
⋮----
///     Generates a unsigned 16-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;ushort.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public ushort GetUInt16(ushort min = 0, ushort max = ushort.MaxValue)
⋮----
///     Generates a signed 32-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;int.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public int GetInt32(int min = 0, int max = int.MaxValue)
⋮----
return (Math.Abs(this.Generate&lt;int&gt;()) % (max - min)) + min - offset;
⋮----
///     Generates a unsigned 32-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;uint.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public uint GetUInt32(uint min = 0, uint max = uint.MaxValue)
⋮----
///     Generates a signed 64-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;long.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public long GetInt64(long min = 0, long max = long.MaxValue)
⋮----
return (Math.Abs(this.Generate&lt;long&gt;()) % (max - min)) + min - offset;
⋮----
///     Generates a unsigned 64-bit integer within specified range.
⋮----
/// &lt;param name=&quot;max&quot;&gt;Maximum value to generate. Defaults to &lt;see cref=&quot;ulong.MaxValue&quot; /&gt;.&lt;/param&gt;
⋮----
public ulong GetUInt64(ulong min = 0, ulong max = ulong.MaxValue)
⋮----
///     Generates a 32-bit floating-point number between 0.0 and 1.0.
⋮----
/// &lt;returns&gt;Generated 32-bit floating-point number.&lt;/returns&gt;
public float GetSingle()
⋮----
var (i1, i2) = ((float)this.GetInt32(), (float)this.GetInt32());
⋮----
///     Generates a 64-bit floating-point number between 0.0 and 1.0.
⋮----
/// &lt;returns&gt;Generated 64-bit floating-point number.&lt;/returns&gt;
public double GetDouble()
⋮----
var (i1, i2) = ((double)this.GetInt64(), (double)this.GetInt64());
⋮----
///     Generates a 32-bit integer between 0 and &lt;see cref=&quot;int.MaxValue&quot; /&gt;. Upper end exclusive.
⋮----
/// &lt;returns&gt;Generated 32-bit integer.&lt;/returns&gt;
public override int Next()
=&gt; this.GetInt32();
⋮----
///     Generates a 32-bit integer between 0 and &lt;paramref name=&quot;maxValue&quot; /&gt;. Upper end exclusive.
⋮----
/// &lt;param name=&quot;maxValue&quot;&gt;Maximum value of the generated integer.&lt;/param&gt;
⋮----
public override int Next(int maxValue)
=&gt; this.GetInt32(0, maxValue);
⋮----
///     Generates a 32-bit integer between &lt;paramref name=&quot;minValue&quot; /&gt; and &lt;paramref name=&quot;maxValue&quot; /&gt;. Upper end
///     exclusive.
⋮----
/// &lt;param name=&quot;minValue&quot;&gt;Minimum value of the generate integer.&lt;/param&gt;
⋮----
public override int Next(int minValue, int maxValue)
=&gt; this.GetInt32(minValue, maxValue);
⋮----
///     Generates a 64-bit floating-point number between 0.0 and 1.0. Upper end exclusive.
⋮----
public override double NextDouble()
=&gt; this.GetDouble();
⋮----
///     Fills specified buffer with random bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Buffer to fill with bytes.&lt;/param&gt;
public override void NextBytes(byte[] buffer)
=&gt; this.GetBytes(buffer);
⋮----
///     Fills specified memory region with random bytes.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;Memory region to fill with bytes.&lt;/param&gt;
public new void NextBytes(Span&lt;byte&gt; buffer)
⋮----
///     Generates a random 64-bit floating-point number between 0.0 and 1.0. Upper end exclusive.
⋮----
protected override double Sample()
⋮----
///     Generates the.
⋮----
/// &lt;returns&gt;A T.&lt;/returns&gt;
private T Generate&lt;T&gt;() where T : struct
⋮----
this.GetBytes(buff);</file><file path="DisCatSharp.Common/Types/Serialization/ComplexDecomposer.cs">/// &lt;summary&gt;
///     Decomposes &lt;see cref=&quot;Complex&quot; /&gt; numbers into tuples (arrays of 2).
/// &lt;/summary&gt;
public sealed class ComplexDecomposer : IDecomposer
⋮----
///     Gets the complex type.
⋮----
///     Gets the double array.
⋮----
///     Gets the double enumerable.
⋮----
///     Gets the object array.
⋮----
///     Gets the object enumerable.
⋮----
/// &lt;inheritdoc /&gt;
public bool CanDecompose(Type t)
⋮----
public bool CanRecompose(Type t)
⋮----
|| s_doubleEnumerable.IsAssignableFrom(t)
|| s_objectEnumerable.IsAssignableFrom(t);
⋮----
public bool TryDecompose(object obj, Type tobj, out object? decomposed, out Type tdecomposed)
⋮----
public bool TryRecompose(object obj, Type tobj, Type trecomposed, out object? recomposed)
⋮----
// ie&lt;double&gt;
if (s_doubleEnumerable.IsAssignableFrom(tobj) &amp;&amp; obj is IEnumerable&lt;double&gt; ied)
⋮----
if (!ied.TryFirstTwo(out var values))
⋮----
recomposed = new Complex(real, imag);
⋮----
// ie&lt;obj&gt;
if (s_objectEnumerable.IsAssignableFrom(tobj) &amp;&amp; obj is IEnumerable&lt;object&gt; ieo)
⋮----
if (!ieo.TryFirstTwo(out var values))
⋮----
recomposed = new Complex(dreal, dimag);</file><file path="DisCatSharp.Common/Types/Serialization/IDecomposer.cs">/// &lt;summary&gt;
///     Provides an interface to decompose an object into another object or combination of objects.
/// &lt;/summary&gt;
public interface IDecomposer
⋮----
///     Checks whether the decomposer can decompose a specific type.
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type to check.&lt;/param&gt;
/// &lt;returns&gt;Whether the decomposer can decompose a given type.&lt;/returns&gt;
bool CanDecompose(Type t);
⋮----
///     &lt;para&gt;Checks whether the decomposer can recompose a specific decomposed type.&lt;/para&gt;
///     &lt;para&gt;
///         Note that while a type might be considered recomposable, other factors might prevent recomposing operation
///         from being successful.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;t&quot;&gt;Decomposed type to check.&lt;/param&gt;
⋮----
bool CanRecompose(Type t);
⋮----
///     Attempts to decompose a given object of specified source type. The operation produces the decomposed object and the
///     type it got decomposed into.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to decompose.&lt;/param&gt;
/// &lt;param name=&quot;tobj&quot;&gt;Type to decompose.&lt;/param&gt;
/// &lt;param name=&quot;decomposed&quot;&gt;Decomposition result.&lt;/param&gt;
/// &lt;param name=&quot;tdecomposed&quot;&gt;Type of the result.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation was successful.&lt;/returns&gt;
bool TryDecompose(object obj, Type tobj, out object? decomposed, out Type tdecomposed);
⋮----
///     Attempts to recompose given object of specified source type, into specified target type. The operation produces the
///     recomposed object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to recompose from.&lt;/param&gt;
/// &lt;param name=&quot;tobj&quot;&gt;Type of data to recompose.&lt;/param&gt;
/// &lt;param name=&quot;trecomposed&quot;&gt;Type to recompose into.&lt;/param&gt;
/// &lt;param name=&quot;recomposed&quot;&gt;Recomposition result.&lt;/param&gt;
⋮----
bool TryRecompose(object obj, Type tobj, Type trecomposed, out object? recomposed);</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEvent.cs">/// &lt;summary&gt;
///     ABC for &lt;see cref=&quot;AsyncEvent{TSender, TArgs}&quot; /&gt;, allowing for using instances thereof without knowing the
///     underlying instance&apos;s type parameters.
/// &lt;/summary&gt;
public abstract class AsyncEvent
⋮----
///     Prevents a default instance of the &lt;see cref=&quot;AsyncEvent&quot; /&gt; class from being created.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
⋮----
///     Gets the name of this event.
⋮----
///     Implementation of asynchronous event. The handlers of such events are executed asynchronously, but sequentially.
⋮----
/// &lt;typeparam name=&quot;TSender&quot;&gt;Type of the object that dispatches this event.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TArgs&quot;&gt;Type of event argument object passed to this event&apos;s handlers.&lt;/typeparam&gt;
/// &lt;remarks&gt;
///     Creates a new asynchronous event with specified name and exception handler.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;name&quot;&gt;Name of this event.&lt;/param&gt;
/// &lt;param name=&quot;maxExecutionTime&quot;&gt;Maximum handler execution time. A value of &lt;see cref=&quot;TimeSpan.Zero&quot; /&gt; means infinite.&lt;/param&gt;
/// &lt;param name=&quot;exceptionHandler&quot;&gt;Delegate which handles exceptions caused by this event.&lt;/param&gt;
public sealed class AsyncEvent&lt;TSender, TArgs&gt;(string name, TimeSpan maxExecutionTime, AsyncEventExceptionHandler&lt;TSender, TArgs&gt;? exceptionHandler) : AsyncEvent(name)
where TArgs : AsyncEventArgs
⋮----
///     Gets or sets the exception handler.
⋮----
///     Gets the lock.
⋮----
private readonly Lock _lock = new();
⋮----
///     Gets or sets the event handlers.
⋮----
///     Gets the maximum allotted execution time for all handlers. Any event which causes the handler to time out
///     will raise a non-fatal &lt;see cref=&quot;AsyncEventTimeoutException{TSender, TArgs}&quot; /&gt;.
⋮----
///     Registers a new handler for this event.
⋮----
/// &lt;param name=&quot;handler&quot;&gt;Handler to register for this event.&lt;/param&gt;
public void Register(AsyncEventHandler&lt;TSender, TArgs&gt; handler)
⋮----
ArgumentNullException.ThrowIfNull(handler);
⋮----
this._handlers = this._handlers.Add(handler);
⋮----
///     Unregisters an existing handler from this event.
⋮----
/// &lt;param name=&quot;handler&quot;&gt;Handler to unregister from the event.&lt;/param&gt;
public void Unregister(AsyncEventHandler&lt;TSender, TArgs&gt; handler)
⋮----
this._handlers = this._handlers.Remove(handler);
⋮----
///     Unregisters all existing handlers from this event.
⋮----
public void UnregisterAll() =&gt; this._handlers = [];
⋮----
///     &lt;para&gt;Raises this event by invoking all of its registered handlers, in order of registration.&lt;/para&gt;
///     &lt;para&gt;All exceptions throw during invocation will be handled by the event&apos;s registered exception handler.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;sender&quot;&gt;Object which raised this event.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;Arguments for this event.&lt;/param&gt;
/// &lt;param name=&quot;exceptionMode&quot;&gt;Defines what to do with exceptions caught from handlers.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public async Task InvokeAsync(TSender sender, TArgs e, AsyncEventExceptionMode exceptionMode = AsyncEventExceptionMode.Default)
⋮----
// Collect exceptions
⋮----
exceptions = new(handlers.Length * 2 /* timeout + regular */);
⋮----
// If we have a timeout configured, start the timeout task
var timeout = this.MaximumExecutionTime &gt; TimeSpan.Zero ? Task.Delay(this.MaximumExecutionTime) : null;
⋮----
// Start the handler execution
⋮----
// If timeout is configured, wait for any task to finish
// If the timeout task finishes first, the handler is causing a timeout
var result = await Task.WhenAny(timeout, handlerTask).ConfigureAwait(false);
⋮----
// Notify about the timeout and complete execution
⋮----
this.HandleException(timeoutEx, handler, sender, e);
⋮----
exceptions.Add(timeoutEx);
⋮----
await handlerTask.ConfigureAwait(false);
⋮----
// No timeout is configured, or timeout already expired, proceed as usual
⋮----
this.HandleException(ex, handler, sender, e);
⋮----
exceptions.Add(ex);
⋮----
throw new AggregateException(&quot;Exceptions were thrown during execution of the event&apos;s handlers.&quot;, exceptions);
⋮----
///     Handles the exception.
⋮----
/// &lt;param name=&quot;ex&quot;&gt;The ex.&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;The handler.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The args.&lt;/param&gt;
private void HandleException(Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs args)</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventArgs.cs">/// &lt;summary&gt;
///     Contains arguments passed to an asynchronous event.
/// &lt;/summary&gt;
public class AsyncEventArgs : EventArgs
⋮----
///     &lt;para&gt;Gets or sets whether this event was handled.&lt;/para&gt;
///     &lt;para&gt;Setting this to true will prevent other handlers from running.&lt;/para&gt;</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionHandler.cs">/// &lt;summary&gt;
///     Handles any exception raised by an &lt;see cref=&quot;AsyncEvent{TSender, TArgs}&quot; /&gt; or its handlers.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TSender&quot;&gt;Type of the object that dispatches this event.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TArgs&quot;&gt;Type of the object which holds arguments for this event.&lt;/typeparam&gt;
/// &lt;param name=&quot;asyncEvent&quot;&gt;Asynchronous event which threw the exception.&lt;/param&gt;
/// &lt;param name=&quot;exception&quot;&gt;Exception that was thrown&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;Handler which threw the exception.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;Object which dispatched the event.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;Arguments with which the event was dispatched.&lt;/param&gt;
⋮----
where TArgs : AsyncEventArgs;</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventExceptionMode.cs">/// &lt;summary&gt;
///     Defines the behaviour for throwing exceptions from
///     &lt;see cref=&quot;AsyncEvent{TSender, TArgs}.InvokeAsync(TSender, TArgs, AsyncEventExceptionMode)&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
///     Defines that no exceptions should be thrown. Only exception handlers will be used.
⋮----
///     Defines that only fatal (i.e. non-&lt;see cref=&quot;AsyncEventTimeoutException{TSender, TArgs}&quot; /&gt;) exceptions
///     should be thrown.
⋮----
///     Defines that only non-fatal (i.e. &lt;see cref=&quot;AsyncEventTimeoutException{TSender, TArgs}&quot; /&gt;) exceptions
⋮----
///     Defines that all exceptions should be thrown. This is equivalent to combining &lt;see cref=&quot;ThrowFatal&quot; /&gt; and
///     &lt;see cref=&quot;ThrowNonFatal&quot; /&gt; flags.
⋮----
///     should be handled by the specified exception handler.
⋮----
///     Defines that all exceptions should be handled by the specified exception handler. This is equivalent to
///     combining &lt;see cref=&quot;HandleFatal&quot; /&gt; and &lt;see cref=&quot;HandleNonFatal&quot; /&gt; flags.
⋮----
///     Defines that all exceptions should be thrown and handled by the specified exception handler. This is
///     equivalent to combining &lt;see cref=&quot;HandleAll&quot; /&gt; and &lt;see cref=&quot;ThrowAll&quot; /&gt; flags.
⋮----
///     Default mode, equivalent to &lt;see cref=&quot;HandleAll&quot; /&gt;.</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventHandler.cs">/// &lt;summary&gt;
///     Handles an asynchronous event of type &lt;see cref=&quot;AsyncEvent{TSender, TArgs}&quot; /&gt;. The handler will take an instance
///     of &lt;typeparamref name=&quot;TArgs&quot; /&gt; as its arguments.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TSender&quot;&gt;Type of the object that dispatches this event.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TArgs&quot;&gt;Type of the object which holds arguments for this event.&lt;/typeparam&gt;
/// &lt;param name=&quot;sender&quot;&gt;Object which raised this event.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;Arguments for this event.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public delegate Task AsyncEventHandler&lt;in TSender, in TArgs&gt;(TSender sender, TArgs e) where TArgs : AsyncEventArgs;</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncEventTimeoutException.cs">/// &lt;summary&gt;
///     ABC for &lt;see cref=&quot;AsyncEventHandler{TSender, TArgs}&quot; /&gt;, allowing for using instances thereof without knowing the
///     underlying instance&apos;s type parameters.
/// &lt;/summary&gt;
public abstract class AsyncEventTimeoutException : Exception
⋮----
///     Prevents a default instance of the &lt;see cref=&quot;AsyncEventTimeoutException&quot; /&gt; class from being created.
⋮----
/// &lt;param name=&quot;asyncEvent&quot;&gt;The async event.&lt;/param&gt;
/// &lt;param name=&quot;eventHandler&quot;&gt;The event handler.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
⋮----
///     Gets the event the invocation of which caused the timeout.
⋮----
///     Gets the handler which caused the timeout.
⋮----
///     &lt;para&gt;
///         Thrown whenever execution of an &lt;see cref=&quot;AsyncEventHandler{TSender, TArgs}&quot; /&gt; exceeds maximum time
///         allowed.
///     &lt;/para&gt;
///     &lt;para&gt;This is a non-fatal exception, used primarily to inform users that their code is taking too long to execute.&lt;/para&gt;
⋮----
/// &lt;typeparam name=&quot;TSender&quot;&gt;Type of sender that dispatched this asynchronous event.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TArgs&quot;&gt;Type of event arguments for the asynchronous event.&lt;/typeparam&gt;
/// &lt;remarks&gt;
///     Creates a new timeout exception for specified event and handler.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;asyncEvent&quot;&gt;Event the execution of which timed out.&lt;/param&gt;
/// &lt;param name=&quot;eventHandler&quot;&gt;Handler which timed out.&lt;/param&gt;
⋮----
where TArgs : AsyncEventArgs
⋮----
public new AsyncEvent&lt;TSender, TArgs&gt; Event =&gt; base.Event as AsyncEvent&lt;TSender, TArgs&gt; ?? throw new NullReferenceException();
⋮----
public new AsyncEventHandler&lt;TSender, TArgs&gt; Handler =&gt; base.Handler as AsyncEventHandler&lt;TSender, TArgs&gt; ?? throw new NullReferenceException();</file><file path="DisCatSharp.Common/Utilities/AsyncEvent/AsyncManualResetEvent.cs">// source: https://blogs.msdn.microsoft.com/pfxteam/2012/02/11/building-async-coordination-primitives-part-1-asyncmanualresetevent/
/// &lt;summary&gt;
///     Implements an async version of a &lt;see cref=&quot;ManualResetEvent&quot; /&gt;
///     This class does currently not support Timeouts or the use of CancellationTokens
/// &lt;/summary&gt;
internal class AsyncManualResetEvent
⋮----
///     The task completion source.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;AsyncManualResetEvent&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;initialState&quot;&gt;If true, initial state.&lt;/param&gt;
⋮----
if (initialState) this._tsc.TrySetResult(true);
⋮----
///     Gets a value indicating whether this is set.
⋮----
///     Waits the async waiter.
⋮----
public Task WaitAsync() =&gt; this._tsc.Task;
⋮----
///     Sets the async task.
⋮----
public Task SetAsync() =&gt; Task.Run(() =&gt; this._tsc.TrySetResult(true));
⋮----
///     Resets the async waiter.
⋮----
public void Reset()
⋮----
if (!tsc.Task.IsCompleted || Interlocked.CompareExchange(ref this._tsc, new(), tsc) == tsc)</file><file path="DisCatSharp.Common/Utilities/AsyncExecutor.cs">/// &lt;summary&gt;
///     Provides a simplified way of executing asynchronous code synchronously.
/// &lt;/summary&gt;
public class AsyncExecutor
⋮----
///     Creates a new instance of asynchronous executor.
⋮----
///     Executes a specified task in an asynchronous manner, waiting for its completion.
⋮----
/// &lt;param name=&quot;task&quot;&gt;Task to execute.&lt;/param&gt;
public void Execute(Task task)
⋮----
// create state object
⋮----
// queue a task and wait for it to finish executing
task.ContinueWith(TaskCompletionHandler!, taskState);
taskState.Lock.WaitOne();
⋮----
// check for and rethrow any exceptions
⋮----
// completion method
⋮----
// retrieve state data
⋮----
throw new NullReferenceException();
⋮----
// retrieve any exceptions or cancellation status
⋮----
stateRef.Exception = t.Exception?.InnerExceptions.Count is 1 ? t.Exception.InnerException : t.Exception; // unwrap if 1
⋮----
stateRef.Exception = new TaskCanceledException(t);
⋮----
// signal that the execution is done
stateRef.Lock.Set();
⋮----
///     Executes a specified task in an asynchronous manner, waiting for its completion, and returning the result.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the Task&apos;s return value.&lt;/typeparam&gt;
⋮----
/// &lt;returns&gt;Task&apos;s result.&lt;/returns&gt;
public T? Execute&lt;T&gt;(Task&lt;T&gt; task)
⋮----
// return the result, if any
⋮----
// throw exception if no result
⋮----
// return the result from the task, if any
⋮----
///     The state ref.
⋮----
/// &lt;remarks&gt;
///     Initializes a new instance of the &lt;see cref=&quot;StateRef{T}&quot; /&gt; class.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;lock&quot;&gt;The lock.&lt;/param&gt;
private sealed class StateRef&lt;T&gt;(AutoResetEvent @lock)
⋮----
///     Gets the lock used to wait for task&apos;s completion.
⋮----
///     Gets the exception that occurred during task&apos;s execution, if any.
⋮----
///     Gets the result returned by the task.
⋮----
///     Gets whether the task returned a result.</file><file path="DisCatSharp.Common/Utilities/AsyncManualResetEvent.cs">/// &lt;summary&gt;
///     Represents a thread synchronization event that, when signaled, must be reset manually. Unlike
///     &lt;see cref=&quot;ManualResetEventSlim&quot; /&gt;, this event is asynchronous.
/// &lt;/summary&gt;
public sealed class AsyncManualResetEvent
⋮----
///     Gets the task completion source for this event.
⋮----
///     Creates a new asynchronous synchronization event with initial state.
⋮----
/// &lt;param name=&quot;initialState&quot;&gt;Initial state of this event.&lt;/param&gt;
⋮----
this._resetTcs.TrySetResult(initialState);
⋮----
///     Gets whether this event has been signaled.
⋮----
// Spawn a threadpool thread instead of making a task
// Maybe overkill, but I am less unsure of this than awaits and
// potentially cross-scheduler interactions
⋮----
///     Asynchronously signal this event.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public Task SetAsync()
=&gt; Task.Run(() =&gt; this._resetTcs.TrySetResult(true));
⋮----
///     Asynchronously wait for this event to be signaled.
⋮----
public Task WaitAsync()
⋮----
///     Reset this event&apos;s signal state to unsignaled.
⋮----
public void Reset()
⋮----
if (!tcs.Task.IsCompleted || Interlocked.CompareExchange(ref this._resetTcs, new(), tcs) == tcs)</file><file path="DisCatSharp.Common/Utilities/EnsureObjectStates.cs">/// &lt;summary&gt;
///     Ensures that certain objects have the target state.
/// &lt;/summary&gt;
public static class EnsureObjectStates
⋮----
///     Checks whether the dictionary is null or empty.
⋮----
/// &lt;typeparam name=&quot;T1&quot;&gt;Any key type.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;T2&quot;&gt;Any value type.&lt;/typeparam&gt;
/// &lt;param name=&quot;dictionary&quot;&gt;The dictionary to check on.&lt;/param&gt;
/// &lt;returns&gt;True if satisfied, false otherwise.&lt;/returns&gt;
public static bool EmptyOrNull&lt;T1, T2&gt;([NotNullWhen(false)] this Dictionary&lt;T1, T2?&gt;? dictionary) where T1 : notnull
⋮----
///     Checks whether the dictionary is not null and not empty.
⋮----
public static bool NotEmptyAndNotNull&lt;T1, T2&gt;([NotNullWhen(true)] this Dictionary&lt;T1, T2?&gt;? dictionary) where T1 : notnull
⋮----
///     Checks whether the list is null or empty.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Any value type.&lt;/typeparam&gt;
/// &lt;param name=&quot;list&quot;&gt;The list to check on.&lt;/param&gt;
⋮----
public static bool EmptyOrNull&lt;T&gt;([NotNullWhen(false)] this List&lt;T?&gt;? list)
⋮----
///     Checks whether the list is not null and not empty.
⋮----
public static bool NotEmptyAndNotNull&lt;T&gt;([NotNullWhen(true)] this List&lt;T?&gt;? list)
⋮----
public static bool Empty&lt;T1, T2&gt;(this Dictionary&lt;T1, T2?&gt; dictionary) where T1 : notnull
⋮----
public static bool NotEmpty&lt;T1, T2&gt;(this Dictionary&lt;T1, T2?&gt; dictionary) where T1 : notnull
⋮----
public static bool Empty&lt;T&gt;(this List&lt;T&gt; list) where T : notnull
⋮----
public static bool NotEmpty&lt;T&gt;(this List&lt;T&gt; list) where T : notnull</file><file path="DisCatSharp.Common/Utilities/Extensions.cs">/// &lt;summary&gt;
///     Assortment of various extension and utility methods, designed to make working with various types a little easier.
/// &lt;/summary&gt;
public static class Extensions
⋮----
///     &lt;para&gt;
///         Deconstructs a &lt;see cref=&quot;Dictionary{TKey, TValue}&quot; /&gt; key-value pair item (
///         &lt;see cref=&quot;KeyValuePair{TKey, TValue}&quot; /&gt;) into 2 separate variables.
///     &lt;/para&gt;
⋮----
///         This allows for enumerating over dictionaries in foreach blocks by using a (k, v) tuple as the enumerator
///         variable, instead of having to use a &lt;see cref=&quot;KeyValuePair{TKey, TValue}&quot; /&gt; directly.
⋮----
/// &lt;typeparam name=&quot;TKey&quot;&gt;Type of dictionary item key.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TValue&quot;&gt;Type of dictionary item value.&lt;/typeparam&gt;
/// &lt;param name=&quot;kvp&quot;&gt;Key-value pair to deconstruct.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;Deconstructed key.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Deconstructed value.&lt;/param&gt;
public static void Deconstruct&lt;TKey, TValue&gt;(this KeyValuePair&lt;TKey, TValue&gt; kvp, out TKey key, out TValue value)
⋮----
///     Calculates the length of string representation of given number in base 10 (including sign, if present).
⋮----
/// &lt;param name=&quot;num&quot;&gt;Number to calculate the length of.&lt;/param&gt;
/// &lt;returns&gt;Calculated number length.&lt;/returns&gt;
⋮----
public static int CalculateLength(this sbyte num)
=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == sbyte.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
⋮----
public static int CalculateLength(this byte num)
=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(num)) + 1;
⋮----
public static int CalculateLength(this short num)
=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == short.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
⋮----
public static int CalculateLength(this ushort num)
⋮----
public static int CalculateLength(this int num)
=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == int.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
⋮----
public static int CalculateLength(this uint num)
⋮----
public static int CalculateLength(this long num)
=&gt; num == 0 ? 1 : (int)Math.Floor(Math.Log10(Math.Abs(num == long.MinValue ? num + 1 : num))) + (num &lt; 0 ? 2 /* include sign */ : 1);
⋮----
public static int CalculateLength(this ulong num)
⋮----
///     Tests whether given value is in supplied range, optionally allowing it to be an exclusive check.
⋮----
/// &lt;param name=&quot;num&quot;&gt;Number to test.&lt;/param&gt;
/// &lt;param name=&quot;min&quot;&gt;Lower bound of the range.&lt;/param&gt;
/// &lt;param name=&quot;max&quot;&gt;Upper bound of the range.&lt;/param&gt;
/// &lt;param name=&quot;inclusive&quot;&gt;Whether the check is to be inclusive.&lt;/param&gt;
/// &lt;returns&gt;Whether the value is in range.&lt;/returns&gt;
⋮----
public static bool IsInRange(this sbyte num, sbyte min, sbyte max, bool inclusive = true)
⋮----
public static bool IsInRange(this byte num, byte min, byte max, bool inclusive = true)
⋮----
public static bool IsInRange(this short num, short min, short max, bool inclusive = true)
⋮----
public static bool IsInRange(this ushort num, ushort min, ushort max, bool inclusive = true)
⋮----
public static bool IsInRange(this int num, int min, int max, bool inclusive = true)
⋮----
public static bool IsInRange(this uint num, uint min, uint max, bool inclusive = true)
⋮----
public static bool IsInRange(this long num, long min, long max, bool inclusive = true)
⋮----
public static bool IsInRange(this ulong num, ulong min, ulong max, bool inclusive = true)
⋮----
public static bool IsInRange(this float num, float min, float max, bool inclusive = true)
⋮----
public static bool IsInRange(this double num, double min, double max, bool inclusive = true)
⋮----
///     Returns whether supplied character is in any of the following ranges: a-z, A-Z, 0-9.
⋮----
/// &lt;param name=&quot;c&quot;&gt;Character to test.&lt;/param&gt;
/// &lt;returns&gt;Whether the character is in basic alphanumeric character range.&lt;/returns&gt;
⋮----
public static bool IsBasicAlphanumeric(this char c)
⋮----
///     Returns whether supplied character is in the 0-9 range.
⋮----
/// &lt;returns&gt;Whether the character is in basic numeric digit character range.&lt;/returns&gt;
⋮----
public static bool IsBasicDigit(this char c)
⋮----
///     Returns whether supplied character is in the a-z or A-Z range.
⋮----
/// &lt;returns&gt;Whether the character is in basic letter character range.&lt;/returns&gt;
⋮----
public static bool IsBasicLetter(this char c)
⋮----
///     Tests whether given string ends with given character.
⋮----
/// &lt;param name=&quot;s&quot;&gt;String to test.&lt;/param&gt;
/// &lt;param name=&quot;c&quot;&gt;Character to test for.&lt;/param&gt;
/// &lt;returns&gt;Whether the supplied string ends with supplied character.&lt;/returns&gt;
⋮----
public static bool EndsWithCharacter(this string s, char c)
⋮----
///     Tests whether given string starts with given character.
⋮----
/// &lt;returns&gt;Whether the supplied string starts with supplied character.&lt;/returns&gt;
⋮----
public static bool StartsWithCharacter(this string s, char c)
⋮----
// https://stackoverflow.com/questions/9545619/a-fast-hash-function-for-string-in-c-sharp
// Calls are inlined to call the underlying method directly
⋮----
///     Computes a 64-bit Knuth hash from supplied characters.
⋮----
/// &lt;param name=&quot;chars&quot;&gt;Characters to compute the hash value from.&lt;/param&gt;
/// &lt;returns&gt;Computer 64-bit Knuth hash.&lt;/returns&gt;
⋮----
public static ulong CalculateKnuthHash(this ReadOnlySpan&lt;char&gt; chars)
⋮----
public static ulong CalculateKnuthHash(this Span&lt;char&gt; chars)
⋮----
public static ulong CalculateKnuthHash(this ReadOnlyMemory&lt;char&gt; chars)
⋮----
public static ulong CalculateKnuthHash(this Memory&lt;char&gt; chars)
⋮----
public static ulong CalculateKnuthHash(this ArraySegment&lt;char&gt; chars)
=&gt; Knuth(chars.AsSpan());
⋮----
public static ulong CalculateKnuthHash(this char[] chars)
⋮----
/// &lt;param name=&quot;start&quot;&gt;Offset in the array to start calculating from.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;Number of characters to compute the hash from.&lt;/param&gt;
⋮----
public static ulong CalculateKnuthHash(this char[] chars, int start, int count)
=&gt; Knuth(chars.AsSpan(start, count));
⋮----
public static ulong CalculateKnuthHash(this string chars)
⋮----
public static ulong CalculateKnuthHash(this string chars, int start, int count)
⋮----
///     Gets the two first elements of the &lt;see cref=&quot;IEnumerable{T}&quot; /&gt;, if they exist.
⋮----
/// &lt;param name=&quot;enumerable&quot;&gt;The enumerable.&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;The output values. Undefined if &lt;code&gt;false&lt;/code&gt; is returned.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;IEnumerable{T}&quot; /&gt; contained enough elements.&lt;/returns&gt;
public static bool TryFirstTwo&lt;T&gt;(this IEnumerable&lt;T&gt; enumerable, out (T first, T second) values)
⋮----
using var enumerator = enumerable.GetEnumerator();
⋮----
if (!enumerator.MoveNext())
⋮----
///     Knuths the.
⋮----
/// &lt;param name=&quot;chars&quot;&gt;The chars.&lt;/param&gt;
/// &lt;returns&gt;An ulong.&lt;/returns&gt;
private static ulong Knuth(ReadOnlySpan&lt;char&gt; chars)
⋮----
///     Removes the first item matching the predicate from the list.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
/// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;Whether an item was removed.&lt;/returns&gt;
public static bool RemoveFirst&lt;T&gt;(this IList&lt;T&gt; list, Predicate&lt;T&gt; predicate)
⋮----
list.RemoveAt(i);
⋮----
///     Populates an array with the given value.
⋮----
/// &lt;param name=&quot;arr&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
public static void Populate&lt;T&gt;(this T[] arr, T value)
⋮----
///     Encodes a string to base64.
⋮----
/// &lt;param name=&quot;text&quot;&gt;The text to encode.&lt;/param&gt;
/// &lt;returns&gt;The base64 encoded string.&lt;/returns&gt;
public static string Base64Encode(this string text)
⋮----
ArgumentNullException.ThrowIfNull(text, nameof(text));
⋮----
var textBytes = Encoding.UTF8.GetBytes(text);
return Convert.ToBase64String(textBytes);
⋮----
///     Decodes a base64 string.
⋮----
/// &lt;param name=&quot;base64&quot;&gt;The base64 string to decode.&lt;/param&gt;
/// &lt;returns&gt;The decoded string.&lt;/returns&gt;
public static string Base64Decode(this string base64)
⋮----
ArgumentNullException.ThrowIfNull(base64, nameof(base64));
⋮----
base64 = WebUtility.UrlDecode(base64).Trim();
base64 = base64.Replace(&apos;-&apos;, &apos;+&apos;).Replace(&apos;_&apos;, &apos;/&apos;);
⋮----
base64 = base64.TrimEnd(&apos;=&apos;);
⋮----
var base64Bytes = Convert.FromBase64String(base64);
return Encoding.UTF8.GetString(base64Bytes);
⋮----
///     Generates a string from a stream.
⋮----
/// &lt;param name=&quot;inputStream&quot;&gt;The input stream.&lt;/param&gt;
/// &lt;returns&gt;The converted stream.&lt;/returns&gt;
public static async Task&lt;string&gt; GenerateStringFromStream(this Stream inputStream)
⋮----
ArgumentNullException.ThrowIfNull(inputStream, nameof(inputStream));
⋮----
using var reader = new StreamReader(inputStream, Encoding.UTF8);
return await reader.ReadToEndAsync().ConfigureAwait(false);
⋮----
///     Generates a memory stream from a string.
⋮----
/// &lt;param name=&quot;inputString&quot;&gt;The input string.&lt;/param&gt;
/// &lt;returns&gt;The converted memory stream.&lt;/returns&gt;
public static async Task&lt;MemoryStream&gt; GenerateStreamFromString(this string inputString)
⋮----
ArgumentNullException.ThrowIfNull(inputString, nameof(inputString));
⋮----
var stream = new MemoryStream();
await using var writer = new StreamWriter(stream);
await writer.WriteAsync(inputString).ConfigureAwait(false);
await writer.FlushAsync().ConfigureAwait(false);</file><file path="DisCatSharp.Common/Utilities/ReflectionUtilities.cs">/// &lt;summary&gt;
///     Contains various utilities for use with .NET&apos;s reflection.
/// &lt;/summary&gt;
public static class ReflectionUtilities
⋮----
///     &lt;para&gt;Creates an empty, uninitialized instance of specified type.&lt;/para&gt;
///     &lt;para&gt;
///         This method will not call the constructor for the specified type. As such, the object might not be properly
///         initialized.
///     &lt;/para&gt;
⋮----
/// &lt;remarks&gt;
///     This method is intended for reflection use only.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;t&quot;&gt;Type of the object to instantiate.&lt;/param&gt;
/// &lt;returns&gt;Empty, uninitialized object of specified type.&lt;/returns&gt;
public static object CreateEmpty(this Type t)
=&gt; RuntimeHelpers.GetUninitializedObject(t);
⋮----
///     &lt;para&gt;Creates an empty, uninitialized instance of type &lt;typeparamref name=&quot;T&quot; /&gt;.&lt;/para&gt;
⋮----
///         This method will not call the constructor for type &lt;typeparamref name=&quot;T&quot; /&gt;. As such, the object might not
///         be properly initialized.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the object to instantiate.&lt;/typeparam&gt;
⋮----
public static T CreateEmpty&lt;T&gt;()
=&gt; (T)RuntimeHelpers.GetUninitializedObject(typeof(T));
⋮----
///     Converts a given object into a dictionary of property name to property value mappings.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of object to convert.&lt;/typeparam&gt;
/// &lt;param name=&quot;obj&quot;&gt;Object to convert.&lt;/param&gt;
/// &lt;returns&gt;Converted dictionary.&lt;/returns&gt;
public static IReadOnlyDictionary&lt;string, object?&gt; ToDictionary&lt;T&gt;(this T obj)
⋮----
? throw new NullReferenceException()
: (IReadOnlyDictionary&lt;string, object?&gt;)new CharSpanLookupReadOnlyDictionary&lt;object?&gt;(typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
.Select(x =&gt; new KeyValuePair&lt;string, object?&gt;(x.Name, x.GetValue(obj))));</file><file path="DisCatSharp.Common/Utilities/RuntimeInformation.cs">/// &lt;summary&gt;
///     Gets information about current runtime.
/// &lt;/summary&gt;
public static class RuntimeInformation
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RuntimeInformation&quot; /&gt; class.
⋮----
var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
var mscorlib = loadedAssemblies.Select(x =&gt; new
⋮----
AssemblyName = x.GetName()
⋮----
.FirstOrDefault(x =&gt; x.AssemblyName.Name is &quot;mscorlib&quot; or &quot;System.Private.CoreLib&quot;);
⋮----
var assemblyFile = new FileInfo(location);
⋮----
var versionFile = new FileInfo(Path.Combine(assemblyFile.Directory.FullName, &quot;.version&quot;));
⋮----
var lines = File.ReadAllLines(versionFile.FullName, new UTF8Encoding(false));
⋮----
if (!string.IsNullOrWhiteSpace(infVersionString))
⋮----
Version = infVersionString.Split(&apos; &apos;).First();
⋮----
///     Gets the current runtime&apos;s version.</file><file path="DisCatSharp.Common/Utilities/WaveformConverter.cs">/// &lt;inheritdoc /&gt;
public sealed class WaveformConverter : JsonConverter&lt;byte[]?&gt;
⋮----
public override void WriteJson(JsonWriter writer, byte[]? value, JsonSerializer serializer)
⋮----
writer.WriteValue(Convert.ToBase64String(value));
⋮----
writer.WriteNull();
⋮----
public override byte[]? ReadJson(JsonReader reader, Type objectType, byte[]? existingValue, bool hasExistingValue, JsonSerializer serializer)
⋮----
return Convert.FromBase64String(base64String);</file><file path="DisCatSharp.Common/Utilities/WaveformVisualizer.cs">/// &lt;summary&gt;
///     Provides a &lt;see cref=&quot;WaveformVisualizer&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class WaveformVisualizer
⋮----
///     Gets the default background color.
⋮----
private readonly Color _defaultBackgroundColor = Colors.Black;
⋮----
///     Gets the default colors for &lt;see cref=&quot;CreateColorfulWaveformImage&quot; /&gt;.
⋮----
///     Gets the default colors for &lt;see cref=&quot;CreateWaveformImage&quot; /&gt;.
⋮----
///     Gets the image.
⋮----
///     Gets or sets the waveform byte data.
⋮----
///     Decodes the base 64 encoded waveform.
⋮----
/// &lt;param name=&quot;base64Waveform&quot;&gt;The base64 encoded waveform string.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private static byte[] DecodeWaveform(string base64Waveform)
=&gt; Convert.FromBase64String(base64Waveform);
⋮----
///     Attaches the raw waveform data as &lt;see cref=&quot;byte&quot; /&gt; array.
⋮----
/// &lt;param name=&quot;waveformByteData&quot;&gt;The waveforms byte array.&lt;/param&gt;
public WaveformVisualizer WithWaveformByteData(byte[] waveformByteData)
⋮----
/// &lt;param name=&quot;base64Waveform&quot;&gt;The waveforms byte array encoded as base64.&lt;/param&gt;
public WaveformVisualizer WithWaveformData(string base64Waveform)
⋮----
///     Creates a simple waveform image.
⋮----
/// &lt;param name=&quot;width&quot;&gt;The width.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height.&lt;/param&gt;
public WaveformVisualizer CreateWaveformImage(int width = 500, int height = 100)
⋮----
ArgumentNullException.ThrowIfNull(this.WAVEFORM_BYTE_DATA, nameof(this.WithWaveformByteData));
⋮----
throw new ArgumentException(&quot;Waveform data is empty.&quot;, nameof(this.WithWaveformByteData));
⋮----
var image = new PlatformBitmapExportService().CreateContext(width, height);
⋮----
canvas.FillRectangle(0, 0, width, height);
⋮----
.Select((color, index) =&gt; new PaintGradientStop((float)index / (this._defaultColors.Length - 1), color))
.ToArray();
⋮----
var gradient = new LinearGradientPaint(gradientStops, new PointF(0, 0), new PointF(0, height));
canvas.SetFillPaint(gradient, new(0, 0, width, height));
⋮----
var barHeight = Math.Max(2, this.WAVEFORM_BYTE_DATA[i] * yScale);
⋮----
canvas.FillRoundedRectangle(x1, y1, barWidth, barHeight * 2, barWidth / 4);
⋮----
canvas.SetShadow(new(2, 2), 5, this._defaultBackgroundColor.WithAlpha(0.5f));
⋮----
///     Creates a colorful waveform image.
⋮----
/// &lt;param name=&quot;backgroundColor&quot;&gt;The background color.&lt;/param&gt;
/// &lt;param name=&quot;barColors&quot;&gt;The bar colors.&lt;/param&gt;
public WaveformVisualizer CreateColorfulWaveformImage(int width = 500, int height = 100, Color? backgroundColor = null, params Color[]? barColors)
⋮----
var gradient = new LinearGradientPaint(gradientStops, new PointF(x1, y1), new PointF(x1, y2));
canvas.SetFillPaint(gradient, new(x1, y1, barWidth, barHeight * 2));
⋮----
canvas.SetShadow(new(2, 2), 5, backgroundColor.WithAlpha(0.5f));
⋮----
///     Saves a waveform image to given &lt;paramref name=&quot;filePath&quot; /&gt;.
⋮----
/// &lt;param name=&quot;filePath&quot;&gt;The path, including the files name, to save the image to.&lt;/param&gt;
public async Task&lt;WaveformVisualizer&gt; SaveImageAsync(string filePath)
⋮----
ArgumentNullException.ThrowIfNull(this.Image, nameof(this.Image));
await using var stream = File.OpenWrite(filePath);
await this.Image.SaveAsync(stream);
⋮----
///     Converts the waveform image to a &lt;see cref=&quot;Stream&quot; /&gt;.
⋮----
/// &lt;param name=&quot;format&quot;&gt;The image format. Defaults to &lt;see cref=&quot;ImageFormat.Png&quot; /&gt;.&lt;/param&gt;
public Stream AsStream(ImageFormat format = ImageFormat.Png)
⋮----
? this.Image.AsStream(format)
: throw new NullReferenceException(&quot;Image was null, did you even generate a waveform image?&quot;);</file><file path="DisCatSharp.Configuration/ConfigurationExtensions.cs">/// &lt;summary&gt;
///     The configuration extensions.
/// &lt;/summary&gt;
internal static class ConfigurationExtensions
⋮----
///     The factory error message.
⋮----
///     The default root lib.
⋮----
///     The config suffix.
⋮----
///     Easily piece together paths that will work within &lt;see cref=&quot;IConfiguration&quot; /&gt;
⋮----
/// &lt;param name=&quot;config&quot;&gt;(not used - only for adding context based functionality)&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;The strings to piece together&lt;/param&gt;
/// &lt;returns&gt;Strings joined together via &apos;:&apos;&lt;/returns&gt;
public static string ConfigPath(this IConfiguration config, params string[] values) =&gt; string.Join(&quot;:&quot;, values);
⋮----
///     Skims over the configuration section and only overrides values that are explicitly defined within the config.
⋮----
/// &lt;param name=&quot;config&quot;&gt;Instance of config&lt;/param&gt;
/// &lt;param name=&quot;section&quot;&gt;Section which contains values for &lt;paramref name=&quot;config&quot; /&gt;&lt;/param&gt;
private static void HydrateInstance(ref object config, ConfigSection section)
⋮----
var props = config.GetType().GetProperties();
⋮----
// Must have a set method for this to work, otherwise continue on
⋮----
var entry = section.GetValue(prop.Name);
⋮----
// We do NOT want to override value if nothing was provided
if (!string.IsNullOrEmpty(entry))
prop.SetValue(config, entry);
⋮----
// Handle collection types differently
if (typeof(IEnumerable).IsAssignableFrom(prop.PropertyType) &amp;&amp; prop.PropertyType != typeof(string))
⋮----
if (string.IsNullOrEmpty(entry))
⋮----
// Handle case for &quot;root:section:name:0&quot;
var subSection = section.Config.GetSection(section.GetPath(prop.Name));
if (subSection.Exists())
value = subSection.Get(prop.PropertyType);
⋮----
// Handle case for &quot;root:section:name&quot;
value = JsonConvert.DeserializeObject(entry, prop.PropertyType);
⋮----
prop.SetValue(config, value);
⋮----
// From this point onward we require the &apos;entry&apos; value to have something useful
⋮----
// Handle nullable types
if (Nullable.GetUnderlyingType(targetType) != null)
targetType = Nullable.GetUnderlyingType(targetType);
⋮----
// Primitive types and common types conversion
⋮----
value = Convert.ChangeType(entry, targetType);
⋮----
value = Enum.Parse(targetType, entry.Replace(&apos;|&apos;, &apos;,&apos;));
⋮----
value = TimeSpan.Parse(entry);
⋮----
value = DateTime.Parse(entry);
⋮----
value = DateTimeOffset.Parse(entry);
⋮----
throw new NotSupportedException($&quot;Type &apos;{targetType.Name}&apos; is not supported.&quot;);
⋮----
// Update value within our config instance
⋮----
Console.Error.WriteLine(
$&quot;Unable to convert value of &apos;{entry}&apos; to type &apos;{prop.PropertyType.Name}&apos; for property &apos;{prop.Name}&apos; in config &apos;{config.GetType().Name}&apos;:\n\t\t{ex.Message}&quot;);
⋮----
///     Instantiate an entity using &lt;paramref name=&quot;factory&quot; /&gt; then walk through the specified &lt;paramref name=&quot;section&quot; /&gt;
///     and translate user-defined config values to the instantiated instance from &lt;paramref name=&quot;factory&quot; /&gt;
⋮----
/// &lt;param name=&quot;section&quot;&gt;Section containing values for targeted config&lt;/param&gt;
/// &lt;param name=&quot;factory&quot;&gt;Function which generates a default entity&lt;/param&gt;
/// &lt;returns&gt;Hydrated instance of an entity which contains user-defined values (if any)&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;When &lt;paramref name=&quot;factory&quot; /&gt; is null&lt;/exception&gt;
public static object ExtractConfig(this ConfigSection section, Func&lt;object&gt; factory)
⋮----
throw new ArgumentNullException(nameof(factory), FACTORY_ERROR_MESSAGE);
⋮----
// Create default instance
⋮----
///     Instantiate an entity using &lt;paramref name=&quot;factory&quot; /&gt; then walk through the specified
///     &lt;paramref name=&quot;sectionName&quot; /&gt;
///     in &lt;paramref name=&quot;config&quot; /&gt;. Translate user-defined config values to the instantiated instance from
///     &lt;paramref name=&quot;factory&quot; /&gt;
⋮----
/// &lt;param name=&quot;config&quot;&gt;Loaded App Configuration&lt;/param&gt;
/// &lt;param name=&quot;sectionName&quot;&gt;Name of section to load&lt;/param&gt;
/// &lt;param name=&quot;factory&quot;&gt;Function which creates a default entity to work with&lt;/param&gt;
/// &lt;param name=&quot;rootSectionName&quot;&gt;
///     (Optional) Used when section is nested within another. Default value is
///     &lt;see cref=&quot;DEFAULT_ROOT_LIB&quot; /&gt;
/// &lt;/param&gt;
⋮----
public static object ExtractConfig(
⋮----
// create default instance
⋮----
///     Instantiate a new instance of &lt;typeparamref name=&quot;TConfig&quot; /&gt;, then walk through the specified
⋮----
///     in &lt;paramref name=&quot;config&quot; /&gt;. Translate user-defined config values to the &lt;typeparamref name=&quot;TConfig&quot; /&gt;
///     instance.
⋮----
/// &lt;param name=&quot;serviceProvider&quot;&gt;&lt;/param&gt;
⋮----
///     (Optional) Used when section is nested with another. Default value is
⋮----
/// &lt;typeparam name=&quot;TConfig&quot;&gt;Type of instance that &lt;paramref name=&quot;sectionName&quot; /&gt; represents&lt;/typeparam&gt;
/// &lt;returns&gt;Hydrated instance of &lt;typeparamref name=&quot;TConfig&quot; /&gt; which contains the user-defined values (if any).&lt;/returns&gt;
public static TConfig ExtractConfig&lt;TConfig&gt;(this IConfiguration config, IServiceProvider serviceProvider, string sectionName, string? rootSectionName = DEFAULT_ROOT_LIB)
where TConfig : new()
⋮----
// Default values should hopefully be provided from the constructor
var configInstance = ActivatorUtilities.CreateInstance(serviceProvider, typeof(TConfig));
⋮----
public static TConfig ExtractConfig&lt;TConfig&gt;(this IConfiguration config, string sectionName, string? rootSectionName = DEFAULT_ROOT_LIB)
⋮----
object configInstance = new TConfig();
⋮----
///     Determines if &lt;paramref name=&quot;config&quot; /&gt; contains a particular section/object (not value)
⋮----
/// &lt;remarks&gt;
///     &lt;code&gt;
/// {
///    &quot;Discord&quot;: {  // this is a section/object
///
///    },
///    &quot;Value&quot;: &quot;something&quot; // this is not a section/object
/// }
/// &lt;/code&gt;
/// &lt;/remarks&gt;
/// &lt;param name=&quot;config&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;True if section exists, otherwise false&lt;/returns&gt;
public static bool HasSection(this IConfiguration config, params string?[] values)
⋮----
return config.GetChildren().Any(x =&gt; x.Key == values[0]);
⋮----
if (config.GetChildren().All(x =&gt; x.Key != values[0]))
⋮----
var current = config.GetSection(values[0]);
⋮----
if (current.GetChildren().All(x =&gt; x.Key != values[i]))
⋮----
current = current.GetSection(values[i]);
⋮----
return current.GetChildren().Any(x =&gt; x.Key == values[^1]);
⋮----
///     Instantiates an instance of &lt;see cref=&quot;DiscordClient&quot; /&gt;, then consumes any custom
///     configuration from user/developer from &lt;paramref name=&quot;config&quot; /&gt;. &lt;br /&gt;
///     View remarks for more info
⋮----
///     This is an example of how your JSON structure should look if you wish
///     to override one or more of the default values from &lt;see cref=&quot;DiscordConfiguration&quot; /&gt;
⋮----
///   &quot;DisCatSharp&quot;: {
///      &quot;Discord&quot;: { }
///   }
⋮----
///     &lt;br /&gt;
///     Alternatively, you can use the type name itself
⋮----
///      &quot;DiscordConfiguration&quot;: { }
⋮----
///   &quot;botSectionName&quot;: {
⋮----
/// &lt;param name=&quot;botSectionName&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;Instance of &lt;see cref=&quot;DiscordClient&quot; /&gt;&lt;/returns&gt;
public static DiscordClient BuildClient(
⋮----
var section = config.HasSection(botSectionName, &quot;Discord&quot;)
⋮----
: config.HasSection(botSectionName, $&quot;Discord{CONFIG_SUFFIX}&quot;)
⋮----
return string.IsNullOrEmpty(section)
⋮----
: new DiscordClient(config.ExtractConfig&lt;DiscordConfiguration&gt;(serviceProvider, section, botSectionName));</file><file path="DisCatSharp.Configuration/GlobalSuppressions.cs"></file><file path="DisCatSharp.Configuration/Models/ConfigSection.cs">/// &lt;summary&gt;
///     Represents an object in &lt;see cref=&quot;IConfiguration&quot; /&gt;
/// &lt;/summary&gt;
⋮----
///     Key within &lt;see cref=&quot;Config&quot; /&gt; which represents an object containing multiple values
⋮----
///     Optional used to indicate this section is nested within another
⋮----
///     Reference to &lt;see cref=&quot;IConfiguration&quot; /&gt; used within application
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ConfigSection&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;config&quot;&gt;Reference to config&lt;/param&gt;
/// &lt;param name=&quot;sectionName&quot;&gt;Section of interest&lt;/param&gt;
/// &lt;param name=&quot;rootName&quot;&gt;
///     (Optional) Indicates &lt;paramref name=&quot;sectionName&quot; /&gt; is nested within this name. Default value
///     is DisCatSharp
/// &lt;/param&gt;
⋮----
///     Checks if key exists in &lt;see cref=&quot;Config&quot; /&gt;
⋮----
/// &lt;param name=&quot;name&quot;&gt;Property / Key to search for in section&lt;/param&gt;
/// &lt;returns&gt;True if key exists, otherwise false. Outputs path to config regardless&lt;/returns&gt;
public bool ContainsKey(string name)
⋮----
var path = string.IsNullOrEmpty(this.Root)
? this.Config.ConfigPath(this.SectionName, name)
: this.Config.ConfigPath(this.Root, this.SectionName, name);
⋮----
return !string.IsNullOrEmpty(this.Config[path]);
⋮----
///     Attempts to get value associated to the config path. &lt;br /&gt; Should be used in unison with
///     &lt;see cref=&quot;ContainsKey&quot; /&gt;
⋮----
/// &lt;param name=&quot;propName&quot;&gt;Config path to value&lt;/param&gt;
/// &lt;returns&gt;Value found at &lt;paramref name=&quot;propName&quot; /&gt;&lt;/returns&gt;
public string GetValue(string propName)
=&gt; this.Config[this.GetPath(propName)];
⋮----
///     Gets the path.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;returns&gt;A string.&lt;/returns&gt;
public string GetPath(string value) =&gt;
string.IsNullOrEmpty(this.Root)
? this.Config.ConfigPath(this.SectionName, value)
: this.Config.ConfigPath(this.Root, this.SectionName, value);</file><file path="DisCatSharp.Docs/404.md">---
uid: 404
title: Not Found
author: DisCatSharp Team
_disableTocFilter: true
_disableContribution: true
_noindex: true
_disableNextArticle: true
_disableBreadcrumb: true
_disableAffix: true
_disableToc: true
_disableFeatherlight: true
_twitterImage: /images/404.png
_ogImage: /images/404.png
description: Nyaa~ The page you were looking for has vanished, senpai!
---

&lt;h2 class=&quot;text-center&quot;&gt;Nyaa~ The page you were looking for has vanished, senpai!&lt;/h2&gt;

[![Not Found Cat](/images/404.png){width=&quot;40%&quot; height=&quot;40%&quot; style=&quot;display: block; margin: 0 auto&quot; }](#)

&lt;p class=&quot;text-center&quot;&gt;We prowled around high and low, but it seems this page is playing hide and seek! Let’s whisker you away to a cozier corner, nya~&lt;/p&gt;</file><file path="DisCatSharp.Docs/articles/experimental/gcp_attachments.md">---
uid: experimental_gcp_attachments
title: GCP Attachments
author: DisCatSharp Team
hasDiscordComponents: false
---

# GCP Attachments

## Overview

The GCP (Google Cloud Platform) Attachments feature in DisCatSharp allows for directzly uploading files to Discord via Google Cloud Storage. This feature is experimental, and while it offers advanced file management options, it is not officially supported or endorsed by Discord. Use this feature with caution, as it may break or become unsupported in the future.

## Uploading Files

To upload a file to Discord using GCP Attachments, you can use the `UploadFileAsync` method provided in the `DiscordChannelMethodHooks` class. This method handles the file upload and returns the necessary information for later use in a `DiscordMessageBuilder`.

### Example: Uploading a File

```cs
using DisCatSharp.Experimental.Entities;

// ...

public async Task UploadFileExample(DiscordChannel channel, string filePath)
{
    using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
    var uploadInfo = await channel.UploadFileAsync(&quot;my_file.txt&quot;, fileStream, &quot;My file description&quot;);

    // Now you can use this upload information to send a message
    var msg = new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file you uploaded!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

## Adding GCP Attachments to a Message

Once a file is uploaded, it can be attached to a message using the `AddGcpAttachment` method in the `DiscordMessageBuilderMethodHooks` class. This method takes a `GcpAttachmentUploadInformation` object, which contains the details of the uploaded file.

### Example: Sending a Message with an Uploaded File

```cs
using DisCatSharp.Experimental.Entities;

// ...

public async Task SendFileMessage(DiscordChannel channel, GcpAttachmentUploadInformation uploadInfo)
{
    var msg = await new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

## Conclusion

The GCP Attachments feature provides powerful file management capabilities for advanced use cases. However, due to its experimental nature, developers should use it carefully and be aware of the risks associated with using unsupported features.</file><file path="DisCatSharp.Docs/articles/experimental/index.md">---
uid: experimental_preamble
title: Experimental Features in DisCatSharp
author: DisCatSharp Team
hasDiscordComponents: false
---

# Experimental Features in DisCatSharp

## Overview

DisCatSharp introduces several experimental features to provide advanced capabilities and customization options. These features are not officially supported or endorsed by Discord, and they may break or change without notice. Use these features at your own risk, and be prepared for potential instability.

### Important Notes

- **Experimental Nature**: Features in the experimental package are subject to change or removal in future updates.
- **No Official Support**: Discord does not officially support these features, meaning they may not work as expected, and updates from Discord might break functionality.
- **Potential for Breaking Changes**: Given the experimental status, updates to the library could introduce breaking changes without warning.

### Enabling Experimental Features

To use experimental features, you need to reference the `DisCatSharp.Experimental` namespace. Some experimental methods require specific features or treatments to be enabled on your Discord account or guild.

### Examples of Experimental Features

#### Elasticsearch-Based Member Search

This feature allows you to perform advanced member searches within a guild using Elasticsearch. This functionality is especially useful for large servers where filtering members by various criteria is necessary.

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    Limit = 100,
    Sort = MemberSortType.JoinedAtDesc
};

var searchResponse = await guild.SearchMembersAsync(searchParams);
```

#### GCP Attachments

The GCP Attachments feature allows you to directly upload files to Discord via Google Cloud Storage. This is particularly useful for managing large files. However, this feature is experimental and should be used with caution.

```cs
using DisCatSharp.Experimental.Entities;

// Uploading a file to Discord using GCP
public async Task UploadFileExample(DiscordChannel channel, string filePath)
{
    using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
    var uploadInfo = await channel.UploadFileAsync(&quot;my_file.txt&quot;, fileStream, &quot;My file description&quot;);

    // Sending the file as an attachment in a message
    var msg = new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s the file you uploaded!&quot;)
        .AddGcpAttachment(uploadInfo)
        .SendAsync(channel);
}
```

### Handling Errors in Experimental Features

Since experimental features can be unstable, it&apos;s essential to handle exceptions appropriately. Some common exceptions include:

- **ValidationException**: Thrown when input parameters do not meet the expected format or constraints.
- **NotIndexedException**: Thrown when the Elasticsearch index is not yet available for the guild.
- **UnauthorizedException**: Thrown when the bot lacks the necessary permissions to perform the requested action.

### Conclusion

Experimental features in DisCatSharp offer powerful new capabilities but come with risks. Ensure you test thoroughly in a development environment before deploying these features in production. Always keep an eye on library updates, as breaking changes can occur.</file><file path="DisCatSharp.Docs/articles/experimental/search_guild_members.md">---
uid: experimental_search_guild_members
title: ElasticSearch-Based Member Search
author: DisCatSharp Team
hasDiscordComponents: false
---

# ElasticSearch-Based Member Search

## Overview

With the introduction of ElasticSearch in DisCatSharp, the member search functionality has become more powerful, allowing for complex queries to find members within a guild. This feature leverages ElasticSearch to return supplemental guild member objects that match specific criteria. It’s a significant upgrade from the previous search methods but requires a good understanding of ElasticSearch&apos;s capabilities and limitations.

### Prerequisites

- Requires the `MANAGE_GUILD` permission.
- The guild must be indexed in ElasticSearch. If the guild is not yet indexed, the request will return a `202 Accepted` response, indicating that the results are not immediately available. We will throw a `NotIndexedException` here.

### Validating Search Parameters

Given the complexity of the queries, a robust validation system has been implemented to ensure that user input adheres to the expected formats and limits. The validation checks:

- **Limit**: Ensures the `limit` parameter is between 1 and 1000.
- **OR Queries**: Validates that `OR` queries are only used where allowed and checks the number of items and types.
- **AND Queries**: Validates that `AND` queries are only used where allowed and checks the number of items and types.
- **Range Queries**: Ensures that `range` queries are only used with valid types like `snowflake` or `integer`.

If the search parameters do not meet these conditions, a `ValidationException` is thrown.

### Using the Member Search

To use the member search, you need to construct a `DiscordGuildMemberSearchParams` object and pass it to the `SearchMembersAsync` method on a `DiscordGuild` object.

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    Limit = 10,
    OrQuery = new DiscordMemberFilter
    {
        Usernames = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;username1&quot;, &quot;username2&quot; } },
        RoleIds = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;123456789012345678&quot; } }
    }
};

try
{
    var searchResponse = await guild.SearchMembersAsync(searchParams);
    foreach (var member in searchResponse.Members)
    {
        // Process each member
    }
}
catch (ValidationException ex)
{
    Console.WriteLine($&quot;Validation error: {ex.ErrorMessage}&quot;);
}
catch (NotIndexedException ex)
{
    Console.WriteLine($&quot;The guild is not yet indexed. Retry after: {ex.RetryAfter} seconds.&quot;);
}
```

### Handling Responses

The `SearchMembersAsync` method returns a `DiscordSearchGuildMembersResponse` object, which contains the following:

- `GuildId`: The ID of the guild searched.
- `Members`: A list of supplemental guild member objects matching the search criteria.
- `PageResultCount`: The number of results returned in the current page.
- `TotalResultCount`: The total number of results found.

### Example Scenarios

#### Search by Invite Code

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    OrQuery = new DiscordMemberFilter
    {
        SourceInviteCode = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;inviteCode123&quot; } }
    }
};
var searchResponse = await guild.SearchMembersAsync(searchParams);
```

#### Search by Role and Username

```cs
using DisCatSharp.Experimental.Entities;

// ...

var searchParams = new DiscordGuildMemberSearchParams
{
    AndQuery = new DiscordMemberFilter
    {
        RoleIds = new DiscordQuery { AndQuery = new List&lt;string&gt; { &quot;roleId123&quot; } }
    },
    OrQuery = new DiscordMemberFilter
    {
        Usernames = new DiscordQuery { OrQuery = new List&lt;string&gt; { &quot;username1&quot; } }
    }
};
var searchResponse = await guild.SearchMembersAsync(searchParams);
```</file><file path="DisCatSharp.Docs/articles/faq.md">---
uid: faq
title: Frequently Asked Questions
author: DisCatSharp Team
---

# Frequently Asked Questions

## Why don&apos;t you provide light mode for the documentation?

Because light attracts bugs.

Jokes aside, I mainly use dark mode, and I don&apos;t want to maintain two versions of the documentation. CSS is painful enough.

## What is a snowflake

Discord calls their IDs snowflakes.

A snowflake explanation can be seen in the following image:

![snowflake](/images/snowflake.png)

## What is a gateway

Discord uses a websocket connection to send and receive data. This is called the gateway. The gateway is used to send and receive events, and to send and receive messages.

![gateway](/images/gateway.png)

## Code I copied from an article isn&apos;t compiling or working as expected. Why?

_Please use the code snippets as a reference; don&apos;t blindly copy-paste code!_

The snippets of code in the articles are meant to serve as examples to help you understand how to use a part of the library.

Although most will compile and work at the time of writing, changes to the library over time can make some snippets obsolete.

Many issues can be resolved with Intellisense by searching for similarly named methods and verifying method parameters.

## Connecting to a voice channel with VoiceNext will either hang or throw an exception.

To troubleshoot, please ensure that:

-   You are using the latest version of DisCatSharp.
-   You have properly enabled VoiceNext with your instance of @DisCatSharp.DiscordClient.
-   You are _not_ using VoiceNext in an event handler.
-   You have [opus and libsodium](xref:modules_audio_voicenext_prerequisites) available in your target environment.

## Why am I getting _heartbeat skipped_ message in my console?

There are two possible reasons:

### Connection issue between your bot application and Discord.

Check your internet connection and ensure that the machine your bot is hosted on has a stable internet connection.&lt;br/&gt;
If your local network has no issues, the problem could be with either Discord or Cloudflare. In which case, it&apos;s out of your control.

### Complex, long-running code in an event handler.

Any event handlers that have the potential to run for more than a few seconds could cause a deadlock, and cause several heartbeats to be skipped.
Please take a look at our short article on [handling exceptions](xref:topics_events) to learn how to avoid this.

## Why am I getting a 4XX error and how can I fix it?

| HTTP Error Code | Cause                       | Resolution                                                                                                                                                      |
| :-------------: | :-------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|      `401`      | Invalid token.              | Verify your token and make sure no errors were made.&lt;br/&gt;The client secret found on the &apos;general information&apos; tab of your application page _is not_ your token. |
|      `403`      | Not enough permissions.     | Verify permissions and ensure your bot account has a role higher than the target user.&lt;br/&gt;Administrator permissions _do not_ bypass the role hierarchy.        |
|      `404`      | Requested object not found. | This usually means the entity does not exist. You should reattempt then inform your user.                                                                       |

## I cannot modify a specific user or role. Why is this?

In order to modify a user, the highest role of your bot account must be higher than the target user.&lt;br/&gt;
Changing the properties of a role requires that your bot account have a role higher than that role.

## Does CommandsNext support dependency injection?

It does! Please take a look at our [article](xref:modules_commandsnext_dependency_injection) on the subject.

Basically every module of DisCatSharp supports dependency injection.

## Can I use a user token?

Automating a user account is against Discord&apos;s [Terms of Service](https://dis.gd/terms) and is not supported by DisCatSharp.

## How can I set a custom status?

You can use either of the following

-   The overload for [ConnectAsync](xref:DisCatSharp.DiscordClient.ConnectAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) which accepts a [DiscordActivity](xref:DisCatSharp.Entities.DiscordActivity).
-   [UpdateStatusAsync](xref:DisCatSharp.DiscordClient.UpdateStatusAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) OR [UpdateStatusAsync](xref:DisCatSharp.DiscordShardedClient.UpdateStatusAsync*)(@DisCatSharp.Entities.DiscordActivity, @DisCatSharp.Entities.UserStatus?, [](xref:System.DateTimeOffset)?) (for the sharded client) at any point after `Ready` has been fired.

## Am I able to retrieve a @DisCatSharp.Entities.DiscordRole by name?

Yes. Use LINQ on the `Roles` property of your instance of [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild) and compare against the `Name` of each [DiscordRole](xref:DisCatSharp.Entities.DiscordRole).

## Why are my events not firing?

This is because in the Discord V8+ API, they require @DisCatSharp.Enums.DiscordIntents to be enabled on [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration) and the
Discord Application Portal. We have an [article](xref:topics_intents) that covers all that has to be done to set this up.</file><file path="DisCatSharp.Docs/articles/getting_started/bot_account.md">---
uid: getting_started_bot_account
title: Creating a Bot Account
author: DisCatSharp Team
---

# Creating a Bot Account

## Create an Application

&gt; [!NOTE]
&gt; You can also use discords official [getting started](https://discord.com/developers/docs/getting-started#building-your-first-discord-app) tutorial till step 2.

Before you&apos;re able to create a [bot account](https://discord.com/developers/docs/topics/oauth2#bots) to interact with the Discord API, you&apos;ll need to create a new OAuth2 application.
[Create](https://discord.com/developers/applications?new_application=true) a new application in the [Discord Developer Portal](https://discord.com/developers/).

![Discord Developer Portal](/images/getting_started_bot_account_01.png)

&lt;br/&gt;
You&apos;ll then be prompted to enter a name for your application.&lt;br/&gt;

![Naming Application](/images/getting_started_bot_account_02.png &quot;Naming Application&quot;)

The name of your application will be the name displayed to users when they add your bot to their Discord server.&lt;br/&gt;
With that in mind, it would be a good idea for your application name to match the desired name of your bot.

Enter your desired application name into the text box, accept the [Developer Terms of Service](https://discord.com/developers/docs/policies-and-agreements/terms-of-service) and [Developer Policy](https://discord.com/developers/docs/policies-and-agreements/developer-policy) and hit the `Create` button.

After you hit `Create`, you&apos;ll be taken to the application page for your newly created application.

![Application Page](/images/getting_started_bot_account_03.png)

That was easy, wasn&apos;t it?

Before you move on, you may want to upload an icon for your application and provide a short description of what your bot will do.
As with the name of your application, the application icon and description will be displayed to users when adding your bot.

# Using Your Bot Account

## Invite Your Bot

Now that you have a bot account, you&apos;ll probably want to invite it to a server!

A bot account joins a server through a special invite link that&apos;ll take users through the OAuth2 flow;
you&apos;ll probably be familiar with this if you&apos;ve ever added a public Discord bot to a server.
To get the invite link for your bot, head on over to the `OAuth2` page of your application and select the `URL Generator` page.

![OAuth2 URL Generator](/images/getting_started_bot_account_06.png &quot;OAuth2 URL Generator&quot;)

&lt;br/&gt;
We&apos;ll be using the *OAuth2 URL Generator* on this page.&lt;br/&gt;
Simply tick `bot` under the *scopes* panel; your bot invite link will be generated directly below.

![OAuth2 Scopes](/images/getting_started_bot_account_07.png &quot;OAuth2 Scopes&quot;)

&lt;br/&gt;
By default, the generated link will not grant any permissions to your bot when it joins a new server.&lt;br/&gt;
If your bot requires specific permissions to function, you&apos;d select them in the *bot permissions* panel.

![Permissions](/images/getting_started_bot_account_08.png &quot;Permissions Panel&quot;)

The invite link in the _scopes_ panel will update each time you change the permissions.&lt;br/&gt;
Be sure to copy it again after any changes!

## Get Bot Token

Instead of logging in to Discord with a username and password, bot accounts use a long string called a _token_ to authenticate.
You&apos;ll want to retrieve the token for your bot account so you can use it with DisCatSharp.

Head back to the bot page and click on `Reset Token` just below the bot&apos;s username field.

![Token Reset](/images/getting_started_bot_account_09.png &quot;Token Reset&quot;)

Click on `Yes, do it!` to confirm the reset.

![Token Reset Confirm](/images/getting_started_bot_account_10.png &quot;Token Reset Confirmation&quot;)

Go ahead and copy your bot token and save it somewhere. You&apos;ll be using it soon!

&gt; [!IMPORTANT]
&gt; Handle your bot token with care! Anyone who has your token will have access to your bot account.
&gt; Be sure to store it in a secure location and _never_ give it to _anybody_.
&gt;
&gt; If you ever believe your token has been compromised, be sure to hit the `Reset Token` button (as seen above) to invalidate your old token and get a brand new token.

## Write Some Code

You&apos;ve got a bot account set up and a token ready for use.&lt;br/&gt;
Sounds like it&apos;s time for you to [write your first bot](xref:getting_started_first_bot)!</file><file path="DisCatSharp.Docs/articles/getting_started/first_bot.md">---
uid: getting_started_first_bot
title: Your First Bot
author: DisCatSharp Team
hasDiscordComponents: true
---

# Your First Bot

&gt; [!NOTE]
&gt; This article assumes the following:
&gt;
&gt; -   You have [created a bot account](xref:getting_started_bot_account &quot;Creating a Bot Account&quot;) and have a bot token.
&gt; -   You have [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) installed on your computer.

## Create a Project

Open up Visual Studio and click on `Create a new project` towards the bottom right.

![Visual Studio Start Screen](/images/getting_started_first_bot_01.png)

&lt;br/&gt;
Select `Console App` then click on the `Next` button.

![New Project Screen](/images/getting_started_first_bot_02.png)

&lt;br/&gt;
Next, you&apos;ll give your project a name. For this example, we&apos;ll name it `MyFirstBot`.&lt;br/&gt;
If you&apos;d like, you can also change the directory that your project will be created in.

Enter your desired project name, then click on the `Create` button.

![Name Project Screen](/images/getting_started_first_bot_03.png)

&lt;br/&gt;
Now select `.NET 7.0` or `.NET 8.0` from the dropdown menu, tick the `Do not use top-level statements` checkbox and click on the `Next` button.

![Framework Project Screen](/images/getting_started_first_bot_04.png)

&lt;br/&gt;
Voilà! Your project has been created!
![Visual Studio IDE](/images/getting_started_first_bot_05.png)

## Install Package

Now that you have a project created, you&apos;ll want to get DisCatSharp installed.
Locate the _solution explorer_ on the right side, then right click on `Dependencies` and select `Manage NuGet Packages` from the context menu.

![Dependencies Context Menu](/images/getting_started_first_bot_06.png)

&lt;br/&gt;
You&apos;ll then be greeted by the NuGet package manager.

Select the `Browse` tab towards the top left, then type `DisCatSharp` into the search text box with the Pre-release checkbox checked **ON**.

![NuGet Package Search](/images/getting_started_first_bot_07.png)

&lt;br/&gt;
The first results should be the DisCatSharp packages.

&lt;!--![Search Results](/images/getting_started_first_bot_07.png)--&gt;

|              Package              |                                                       Description                                                       |
| :-------------------------------: | :---------------------------------------------------------------------------------------------------------------------: |
|           `DisCatSharp`           |                                            Main package; Discord API client.                                            |
|    `DisCatSharp.CommandsNext`     |                                       Add-on which provides a command framework.                                        |
|       `DisCatSharp.Common`        |                                                Common tools &amp; converters                                                |
|    `DisCatSharp.Interactivity`    |                                      Add-on which allows for interactive commands.                                      |
|      `DisCatSharp.Lavalink`       |           Client implementation for [Lavalink](xref:modules_audio_lavalink_v4_intro). Useful for music bots.            |
| `DisCatSharp.ApplicationCommands` |                              Add-on which makes dealing with application commands easier.                               |
|      `DisCatSharp.VoiceNext`      |                              Add-on which enables connectivity to Discord voice channels.                               |
|  `DisCatSharp.VoiceNext.Natives`  |                                                   Voice next natives.                                                   |
|  `DisCatSharp.Analyzers.Roselyn`  | Our custom analyzer, providing extended IntelliSense functions. As example warns you about deprecated discord features. |

&lt;br/&gt;
We&apos;ll only need the `DisCatSharp` package for the basic bot we&apos;ll be writing in this article.&lt;br/&gt;
Select it from the list then click the `Install` button to the right.

![Install DisCatSharp](/images/getting_started_first_bot_08.png)

You&apos;re now ready to write some code!

## First Lines of Code

DisCatSharp implements [Task-based Asynchronous Pattern](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern).
Because of this, the majority of DisCatSharp methods must be executed in a method marked as `async` so they can be properly `await`ed.

Due to the way the compiler generates the underlying [IL](https://en.wikipedia.org/wiki/Common_Intermediate_Language) code,
marking our `Main` method as `async` has the potential to cause problems. As a result, we must pass the program execution to an `async` method.

Head back to your _Program.cs_ tab and empty the `Main` method by deleting line 9.

![Code Editor](/images/getting_started_first_bot_09.png)

Now, create a new `static` method named `MainAsync` beneath your `Main` method. Have it return type `Task` and mark it as `async`.
After that, add `MainAsync().GetAwaiter().GetResult();` to your `Main` method.

```cs
static void Main(string[] args)
{
    MainAsync().GetAwaiter().GetResult();
}

static async Task MainAsync()
{

}
```

If you typed this in by hand, Intellisense should have generated the required `using` directive for you.&lt;br/&gt;
However, if you copy-pasted the snippet above, VS will complain about being unable to find the `Task` type.

Hover over `Task` with your mouse and click on `Show potential fixes` from the tooltip.

![Error Tooltip](/images/getting_started_first_bot_10.png)

Then apply the recommended solution.

![Solution Menu](/images/getting_started_first_bot_11.png)

&lt;br/&gt;
We&apos;ll now create a new `DiscordClient` instance in our brand new asynchronous method.

Create a new variable in `MainAsync` and assign it a new `DiscordClient` instance, then pass an instance of `DiscordConfiguration` to its constructor.
Create an object initializer for `DiscordConfiguration` and populate the `Token` property with your bot token then set the `TokenType` property to `TokenType.Bot`.
Next add the `Intents` Property and Populated it with the @DisCatSharp.DiscordIntents.AllUnprivileged and DiscordIntents.MessageContent values.
The message content intent must be enabled in the developer portal as well.
These Intents
are required for certain Events to be fired. Please visit this [article](xref:topics_intents) for more information.

```cs
var discord = new DiscordClient(new DiscordConfiguration()
{
    Token = &quot;My First Token&quot;,
    TokenType = TokenType.Bot,
    Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent
});
```

&gt; [!WARNING]
&gt; We hard-code the token in the above snippet to keep things simple and easy to understand.
&gt;
&gt; Hard-coding your token is _not_ a smart idea, especially if you plan on distributing your source code.
&gt; Instead you should store your token in an external medium, such as a configuration file or environment variable, and read that into your program to be used with DisCatSharp.

Follow that up with `await discord.ConnectAsync();` to connect and login to Discord, and `await Task.Delay(-1);` at the end of the method to prevent the console window from closing prematurely.

```cs
var discord = new DiscordClient();

await discord.ConnectAsync();
await Task.Delay(-1);
```

As before, Intellisense will have auto generated the needed `using` directive for you if you typed this in by hand.&lt;br/&gt;
If you&apos;ve copied the snippet, be sure to apply the recommended suggestion to insert the required directive.

If you hit `F5` on your keyboard to compile and run your program, you&apos;ll be greeted by a happy little console with a single log message from DisCatSharp. Woo hoo!

![Program Console](/images/getting_started_first_bot_12.png)

## Spicing Up Your Bot

Right now our bot doesn&apos;t do a whole lot. Let&apos;s bring it to life by having it respond to a message!

Hook the `MessageCreated` event fired by `DiscordClient` with a
[lambda](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions).&lt;br/&gt;
Mark it as `async` and give it two parameters: `s` and `e`.

```cs
discord.MessageCreated += async (s, e) =&gt;
{

};
```

Then, add an `if` statement into the body of your event lambda that will check if `e.Message.Content` starts with your desired trigger word and respond with
a message using `e.Message.RespondAsync` if it does. For this example, we&apos;ll have the bot to respond with _pong!_ for each message that starts with _ping_.

```cs
discord.MessageCreated += async (s, e) =&gt;
{
    if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;))
		await e.Message.RespondAsync(&quot;pong!&quot;);
};
```

## The Finished Product

Your entire program should now look like this:

```cs
using System;
using System.Threading.Tasks;
using DisCatSharp;
namespace MyFirstBot
{
    class Program
    {
        static void Main(string[] args)
        {
            MainAsync().GetAwaiter().GetResult();
        }

        static async Task MainAsync()
        {
            var discord = new DiscordClient(new DiscordConfiguration()
            {
				Token = &quot;My First Token&quot;,
				TokenType = TokenType.Bot,
				Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent
            });

            discord.MessageCreated += async (s, e) =&gt;
            {
                if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;))
                    await e.Message.RespondAsync(&quot;pong!&quot;);

            };

            await discord.ConnectAsync();
            await Task.Delay(-1);
        }
    }
}
```

Hit `F5` to run your bot, then send _ping_ in any channel your bot account has access to.&lt;br/&gt;
Your bot should respond with _pong!_ for each _ping_ you send.

Congrats, your bot now does something!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;ping&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;ping&lt;/discord-reply&gt;
        pong!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Further Reading

Now that you have a basic bot up and running, you should take a look at the following:

-   [Events](xref:topics_events)
-   [CommandsNext](xref:modules_commandsnext_intro)
-   [ApplicationCommands](xref:modules_application_commands_intro)</file><file path="DisCatSharp.Docs/articles/getting_started/templates.md">---
uid: getting_started_templates
title: Project Templates
author: DisCatSharp Team
---

&gt; [!WARNING]
&gt; The project templates are currently unmaintained and may not work as expected.

# Prerequisites

Install the following packages:

-   DisCatSharp.ProjectTemplates

To Install the latest:

```powershell
dotnet new --install DisCatSharp.ProjectTemplates
```

To install a specific version (example uses 10.0.0):

```powershell
dotnet new --install DisCatSharp.ProjectTemplates::10.0.0
```

# Steps

## ![Install Setup](/images/pt_nuget_install.png)

If you&apos;re using Visual Studio, the templates will show up when creating a new project/solution
![Install Setup](/images/pt_project_new.png)

To easily find the DCS templates, you can search for either `Bot` or `Discord`. These tags are generic so if anyone else creates their own
discord or bot template our DCS templates will still be discoverable. We shall be using the solution template for our example.
![Classification](/images/pt_project_new_classification.png)

For example sake, the project name is DCSTest
![Project Name](/images/pt_project_new_name.png)

Input your Discord Token which can be retrieved via Discord&apos;s Developer Portal. The checkboxes represent the various modules in the DCS library. Checking it,
will include it in your project. If it&apos;s an extension, it automatically gets configured/included.
![Parameters](/images/pt_project_new_options.png)

You should see something similar to the following image. It&apos;s worth noting that you need to set the Web project as the `Startup` project. Due to the web being
list last, the `Bot` project is considered the startup. You would think that a class-library which doesn&apos;t have an exe could be considered a startup project....
![Project Structure](/images/pt_scaffolded.png)

At this point in time the template is ready to run!

---

# Templates

## Bot Template

This is a class library in which you place bot related code. It contains its own json file where you can
configure your bot accordingly!

An extension class provides easy to call methods for adding the Bot&apos;s services/configuration into the dependency injection (DI) pipeline.

## Web Template

This is a very minimal project. By itself it only has a default endpoint which displays &quot;Hello World&quot;.

## Solution Template

Combines the bot and web templates. Includes the appropriate references/calls to get your bot up and running with minimal
effort.</file><file path="DisCatSharp.Docs/articles/getting_started/web_app.md">---
uid: getting_started_web_app
title: Bot as Hosted Service
author: DisCatSharp Team
---

# Prerequisites

Install the following packages:

-   DisCatSharp
-   DisCatSharp.Hosting

&gt; [!IMPORTANT]
&gt; Please be aware that this approach relies on Dependency Injection. You can either use one of Microsoft&apos;s default project templates for .Net Core Web App, or get a head start by using the
&gt; `DisCatSharp.Hosting.ProjectTemplates` pack which contains a Bot Template to jumpstart your development. If you do the latter, majority of this is done for you.

# Bot.cs

For the sake of example, create a new class called `Bot` which inherits from `DiscordHostedService`. You&apos;re welcome to replace `Bot` with whatever you want.

&gt; [!NOTE]
&gt; If you want to host a variety of bots it is important to provide a custom name into the `base` constructor. This indicates the `Key` within `IConfiguration` that will be used for
&gt; configuring your bot.

## Default

`DisCatSharp` is the default key used when configuring the bot.

```cs
public class Bot : DiscordHostedService
{
    public Bot(IConfiguration config,
            ILogger&lt;Bot&gt; logger,
            IServiceProvider provider,
            IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime)
    {
    }
}
```

## Custom

For example’s sake the custom bot name is &quot;Bot&quot;, so replace it with whatever you want.

```cs
public class Bot : DiscordHostedService
{
    public Bot(IConfiguration config,
            ILogger&lt;Bot&gt; logger,
            IServiceProvider provider,
            IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;Bot&quot;)
    {
    }
}
```

# Startup.cs

## DisCatSharp.Hosting.DependencyInjection

By using the `DisCatSharp.Hosting.DependencyInjection` module, this 1 line is enough to get
your basic bot running...

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscordHostedService&lt;Bot&gt;();
}
```

## Manual Registration

If you prefer another DI approach / the manual route -- the following two
lines are all you need! For example sake, this bot doesn&apos;t have anything fancy going on.
You&apos;re welcome to create your own interface which inherits from `IDiscordHostedService`.

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;IDiscordHostedService, Bot&gt;();
    services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;IDiscordHostedService&gt;());
}
```

Singleton - we only want 1 instance of Bot to ever run during runtime. &lt;br&gt;
Then we take the registered singleton to run as a `HostedService`.

# How to reference

Within a DI environment, whether it&apos;s via constructor or an `IServiceProvider`

## If explicitly registered as `Bot`

You either put `Bot` as part of your constructor. Or from a provider you do

```cs
Bot bot = provider.GetRequiredService&lt;Bot&gt;();
```

## Interface + Bot

This approach means you are mapping the Interface to your `Bot`. However, you might notice that

```cs
Bot bot = provider.GetRequiredService&lt;Bot&gt;();
```

or via constructor - you will get an exception indicating that `Bot` has not been registered. Well... it&apos;s true. It&apos;s looking for a key within the collection that matches the type you asked for.
When you use the Interface/Implementation combination it behaves **almost** like a dictionary -- `Bot` is not a valid key in this scenario.

So to retrieve your `Bot` reference you have to use the interface.

```cs
IBot bot = provider.GetRequiredService&lt;IBot&gt;();
```

If you go down this path of mapping interface to implementation you shouldn&apos;t be casting your interface to Bot, or whatever. You&apos;d be better off just using the explicitly registered type.
The reasoning behind this approach is to allow you to swap out the implementation type in **ONE** place, and **NOT** have to update any other code.

For instance, logging... there are SO many ways to do logging. You might be familiar with [ILogger](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger). So long as something implements this interface it doesn&apos;t matter. It could be Serilog,
or a custom logger you created, or another package from the internet. If later in a project you are dissatisfied with your custom-built logger (which inherits from `ILogger`) you could
easily swap it out with `Serilog` in one place. This makes swapping between packages extremely easy - a simple 1 to 2 line change compared to a project-wide impact.

# How to Configure

You must provide a token in order for the bot to work.

Add the following to `appsettings.json`

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	}
}
```

## Dependency Injection

The ServiceProvider where you register the `DiscordHostedService` is automatically copied to the DiscordClient.
Therefore, if you want to use any services in your [event handlers](xref:topics_events), you can simply register them before the `DiscordHostedService`:

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&lt;YourService&gt;();

    services.AddDiscordHostedService&lt;Bot&gt;();
}
```

In this case, `YourService` will be available in all your Discord event handlers.

## Initialization errors handling

During the initialization of bots, various exceptions can be thrown. For example: invalid token.
By default, the exception will be displayed in the console, after which the application will shutdown.
You can handle exceptions by overriding method `OnInitializationError` in your `DiscordHostedService`.

```cs
protected override void OnInitializationError(Exception ex)
{
    // your code here

    base.OnInitializationError(ex);
}
```

## Extensions

If you wish to add additional modules/extensions you can do so one of two ways.

1. Use the full namespace name
2. Namespace without the `DisCatSharp` prefix - because we assume the extension starts with DisCatSharp.

To add the extensions `Interactivity` and `CommandsNext`:

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Using&quot;: [&quot;DisCatSharp.Interactivity&quot;, &quot;CommandsNext&quot;],

		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		},

		&quot;Interactivity&quot;: {
			&quot;PollBehaviour&quot;: &quot;KeepEmojis&quot;
		},

		&quot;CommandsNext&quot;: {
			&quot;StringPrefixes&quot;: [&quot;!&quot;]
		}
	}
}
```

&gt; [!NOTE]
&gt; To configure an extension, you simply add a section for it under `DisCatSharp` in `appsettings.json`. You only have
&gt; to include values you **WISH TO OVERRIDE**. There is no need to include all config options if you only need to change 1 value.
&gt; For more info on which values are available checkout the following classes:
&gt;
&gt; -   `ApplicationCommandsConfiguration`
&gt; -   `CommandsNextConfiguration`
&gt; -   `DiscordConfiguration`
&gt; -   `InteractivityConfiguration`
&gt; -   `LavalinkConfiguration`
&gt; -   `VoiceNextConfiguration`
&gt;
&gt; For more information, you can also see the [example](https://github.com/Aiko-IT-Systems/DisCatSharp.Examples/tree/main/Hosting).

## Multiple bots

In case you need to use multiple bots in one application, you need to use different names for them in the `appsettings.json`:

```json
{
	&quot;BotOne&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	},
	&quot;BotTwo&quot;: {
		&quot;Discord&quot;: {
			&quot;Token&quot;: &quot;YOUR TOKEN HERE&quot;
		}
	}
}
```

Next, you need to create a new `DiscordHostedService` for each of the bots.

```cs
public class BotOne : DiscordHostedService
{
    public BotOne(IConfiguration config, ILogger&lt;DiscordHostedService&gt; logger, IServiceProvider provider,
        IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;BotOne&quot;)
    {
    }
}

public class BotTwo : DiscordHostedService
{
    public BotTwo(IConfiguration config, ILogger&lt;DiscordHostedService&gt; logger, IServiceProvider provider,
        IHostApplicationLifetime appLifetime) : base(config, logger, provider, appLifetime, &quot;BotTwo&quot;)
    {
    }
}
```

Note: you must also specify the name of the bot in the constructor, which must match the one specified in the config.

Now, you can simply register them in the usual way:

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscordHostedService&lt;BotOne&gt;();
    services.AddDiscordHostedService&lt;BotTwo&gt;();
}
```

---

## Values

It&apos;s worth mentioning the required formats for certain value types

### Enum

-   Single Flag/Value
    -   &quot;`Value`&quot;
-   Multiple Flags
    -   &quot;`Flag1|Flag2|Flag3`&quot;

#### Example

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;Intents&quot;: &quot;GuildMembers|GuildsBans&quot;
		}
	}
}
```

### TimeSpan

Hours:Minutes:Seconds &quot;`HH:mm:ss`&quot;

#### Example

HttpTimeout of 5 minutes

```json
{
	&quot;DisCatSharp&quot;: {
		&quot;Discord&quot;: {
			&quot;HttpTimeout&quot;: &quot;00:05:00&quot;
		}
	}
}
```</file><file path="DisCatSharp.Docs/articles/index.md">---
uid: preamble
title: Article Preamble
author: DisCatSharp Team
---

# How to use articles

Images used in articles might include version numbers, which may not be the latest version of DisCatSharp.

Example code should be treated as pseudo-code, and may not compile.

# Knowledge Prerequisites

Before attempting to write a Discord bot, you should be familiar with the concepts of [Object Oriented Programing](https://en.wikipedia.org/wiki/Object-oriented_programming), [the C# programming language](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/), and [Task-based Asynchronous Pattern](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap).

If you&apos;re brand new to C#, or programming in general, this library may prove difficult for you to use.&lt;/br&gt;
Fortunately, there are resources that can help you get started with the language!

An excellent tutorial series to go through would be [C# Fundamentals for Absolute Beginners](https://channel9.msdn.com/Series/CSharp-Fundamentals-for-Absolute-Beginners) by Bob Tabor.
His videos go through all the getting_started, from setting up your development environment up to some of the more advanced concepts.
If you&apos;re not sure what to do first, Bob&apos;s tutorial series should be your starting point!

Another great resource is Microsoft&apos;s [Introduction to C#](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/), which is an interactive tutorial.

# Supported .NET Implementations

DisCatSharp 10.6 and higher targets .NET 9 primary and backports .NET 8.

# Getting Started

If you&apos;re writing a Discord bot for the first time, you&apos;ll want to start with _[creating a bot account](xref:getting_started_bot_account)_.

Otherwise, if you have a bot account already, start off with the _[writing your first bot](xref:getting_started_first_bot)_ article.

Once you&apos;re up and running, feel free to browse through the [API Documentation](xref:api_index)!</file><file path="DisCatSharp.Docs/articles/misc/hosting.md">---
uid: misc_hosting
title: Hosting Solutions
author: DisCatSharp Team
---

# 24/7 Hosting Solutions

## Free hosting

If you&apos;re looking for free hosts, you&apos;ve likely considered using [Glitch](https://glitch.com/).
We advise against using these platforms as they are designed to host web services, not Discord bots, and instances from either of these companies will shut down if there isn&apos;t enough internet traffic.
Save yourself the headache and don&apos;t bother.

Outside of persuading somebody to host your bot, you won&apos;t find any good free hosting solutions.

## Self Hosting

If you have access to an unused machine, have the technical know-how, and you also have a solid internet connection, you might consider hosting your bot on your own.
Even if you don&apos;t have a space PC on hand, parts to build one are fairly cheap in most regions. You could think of it as a one time investment with no monthly server fees.
Any modern hardware will work just fine, new or used.

Depending on how complex your bot is, you may even consider purchasing a Raspberry Pi ($35).

### Termux

If you don&apos;t have a PC or other gear sitting around, you may use your phone instead. Using [Termux](https://termux.dev/en/) and a program called [proot-distro](https://github.com/termux/proot-distro), we create a Debian virtual machine and configure DotNET to run the bot. For anyone interested, the instructions are detailed below:

#### Requirements

- A phone with Android 7 or higher (5+ is possible but, not recommended as it posses security issues).
- Termux.
- An internet connection.
- Basic understanding of bash and nano.

#### Setup

- Initialize Termux.
```sh
pkg update &amp;&amp; pkg upgrade -y
```
&gt;[!TIP]
&gt; It might ask you for input, just click enter and let the default option be executed.

- Install proot-distro package.
```sh
pkg install proot-distro -y
```

- Install a Debian Virtual Machine (VM).
```sh
proot-distro install debian
```
&gt;[!NOTE]
&gt; Installation time for anything will depend on your internet speed.

- Login into Debian and initialize it.
```sh
proot-distro login debian
```
```sh
apt update -y &amp;&amp; apt upgrade -y
```

- Install Git and Wget.
```sh
apt install git wget -y
```

- We get the DotNET script.
```sh
wget https://dot.net/v1/dotnet-install.sh -O dotnet.sh &amp;&amp; chmod +x ./dotnet.sh
```

- Now, we install the DotNET SDK and runtime.
```sh
./dotnet.sh --channel 9.0
```
&gt;[!NOTE]
&gt; Incase the script does not automatically add &quot;dotnet&quot; to path, add `export PATH=$PATH:$HOME/.dotnet` at the end of your `.bashrc` file. Simply, run `nano ~/.bashrc` and paste it in. After which run `source ~/.bashrc` to apply our changes.
- When trying to run the bot later, we&apos;ll encounter errors such as &quot;0x8007000E&quot; and &quot;valid ICU package&quot;. To migitage this, we&apos;ll add the following to our `.bashrc` as stated in the note.
```sh
export DOTNET_GCHeapHardLimit=1C0000000
export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1
```
##### Cloud Hosted Code

- If you have your code hosted with git or simply are able to download it, get the source code and `cd` into the directory. Example of a git repository on GitHub:
```sh
git clone https://github.com/username/repo.git
cd repo
```
- Add your configuration file then build the project.

##### Local Source Code

- If you do not have your source code hosted remotely, you can move the source code inside the VM by following the given steps: 

- Enable developer options on your phone, find out [here](https://developer.android.com/studio/debug/dev-options) and also enable USB debugging which you can do by going inside `Settings &gt; Developer options &gt; USB debugging` or where ever your phone&apos;s is located.

- Find the option `Default USB configuration` and choose `Transferring files`. Disconnect your phone from the usb and reconnect it again.

- Double click on `Phone` or what it is named, then simply copy your project folder from your pc and paste it in there. If you want to keep it in a custom path, remember the path to the project.

&gt;[!NOTE]
&gt; Transferring of files might take a bit. Be sure to not interrupt the process by shutting down or disconnecting your phone.

- First, we setup Termux storage run, `termux-setup-storage` and then it&apos;ll prompt you to give Termux access to your files and folders. Then run, `ls ~/storage/shared` to make sure you have access.

&gt;[!WARNING]
&gt; If you do not give Termux access to your files and folders, nothing will work going from here on.

- Now, exit out of Debian and into normal Termux and make a new environment variable which leads us to the VM&apos;s root directory. Run, `export PROOTDISTROFS=/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs` and run `source $HOME/.bashrc`.

&gt;[!TIP]
&gt; If you don&apos;t have a `.bashrc` file in your $HOME, just run `nano $HOME/.bashrc`, save, and exit. Then run the source command again.

- Now, we&apos;ll move over the source code from our phone to the VM. Simply, run, `mv projectname/$PROOTDISTROFS/debian/root/`.

&gt;[!WARNING]
&gt; Double-check file paths, as you might accidentally move the wrong files around.

- Now, let&apos;s log back into Debian `proot-distro login debian` and check if the files are here. To check, you can run `ls` to list the current content of the folder.

- Add your configuration file then build the project.

&gt;[!CAUTION]
&gt; If you have folders such as `bin/` and `obj/` from your prior builds on your PC, delete those by running `rm -rf bin/ obj/`. You might run into issues otherwise.

#### Profit

The bot should be working fine, given you follow appropriate steps. For support or any inquires you can join the [Discord](https://discord.com/invite/2HWta4GXus).

## Third-Party Hosting

The simplest, and probably most hassle-free (and maybe cheapest in the long run for dedicated machines) option is to find a provider
that will lend you their machine or a virtual host so you can run your bot in there.

Generally, cheapest hosting options are all GNU/Linux-based, so it&apos;s highly recommended you familiarize yourself with the OS and its
environment, particularly the shell (command line), and concepts such as SSH.

There are several well-known, trusted, and cheap providers:

-   [Host Pls](https://host-pls.com/) - A hosting solution made by Discord bot developers. Based in America, starting from $2.49/mo.
-   [Vultr](https://www.vultr.com/products/cloud-compute/) - Based in the US with datacenters in many regions, including APAC. Starting at $2.50/mo.
-   [DigitalOcean](https://www.digitalocean.com/products/droplets/) - The gold standard, US based. Locations available world wide. Starting from $5.00/mo.
-   [Linode](https://www.linode.com/products/shared/) - US based host with many datacenters around the world. Starting at $5.00/mo.
-   [OVH](https://www.ovhcloud.com/en/vps/) - Very popular VPS host. Based in Canadian with French locations available. Starting from $6.00/mo.
-   [Contabo](https://contabo.com/?show=vps) - Based in Germany; extremely good value for the price. Starting from 4.99€/mo.

Things to keep in mind when looking for a VPS host:

-   The majority of cheap VPS hosts will be running some variant of Linux, and not Windows.
-   The primary Discord API server is located in East US.
    -   If latency matters for you application, choose a host that is closer to this location.

In addition to these, there are several hosting providers that offer free trials or in-service credit:

-   [**Microsoft Azure**](https://azure.microsoft.com/en-us/free/?cdn=disable &quot;Microsoft Azure&quot;): $200 in-service credit,
    to be used within month of registration. Requires credit or debit card for validation. Azure isn&apos;t cheap, but it supports
    both Windows and GNU/Linux-based servers. If you&apos;re enrolled in Microsoft Imagine, it&apos;s possible to get these cheaper or
    free.
-   [**Amazon Web Services**](https://aws.amazon.com/free/ &quot;AWS&quot;): Free for 12 months (with 750 compute hours per month). Not
    cheap once the trial runs out, but it&apos;s also considered industry standard in cloud services.
-   [**Google Cloud Platform**](https://cloud.google.com/free/ &quot;Google Cloud Platform&quot;): $300 in-service credit, to be used
    within year of registration. GCP is based in the US, and offers very scalable products. Like the above, it&apos;s not the
    cheapest of offerings.

## Hosting on Cloud Native Services

With most bots, unless if you host many of them, they dont require a whole machine to run them, just a slice of a machine. This is
where Docker and other cloud native hosting comes into play. There are many different options available to you and you will need
to chose which one will suit you best. Here are a few services that offer Docker or other cloud native solutions that are cheaper than running
a whole VM.

-   [**Azure App Service**](https://azure.microsoft.com/en-us/services/app-service/ &quot;Azure App Service&quot;): Allows for Hosting Website, Continuous Jobs,
    and Docker images on a Windows base or Linux base machine.
-   [**AWS Fargate**](https://aws.amazon.com/fargate/ &quot;AWS Fargate&quot;): Allows for hosting Docker images within Amazon Web Services
-   [**Jelastic**](https://jelastic.com/docker/ &quot;Jelastic&quot;): Allows for hosting Docker images.

# Making your publishing life easier

Now that we have covered where you can possibly host your application, now lets cover how to make your life easier publishing it. Many different
source control solutions out there are free and also offer some type of CI/CD integration (paid and free). Below are some of the
solutions that we recommend:

-   [**Azure Devops**](https://azure.microsoft.com/en-us/services/devops/?nav=min &quot;Azure Devops&quot;): Allows for GIT source control hosting along with integrated CI/CD
    pipelines to auto compile and publish your applications. You can also use their CI/CD service if your code is hosted in a different source control environment like Github.
-   [**Github**](https://github.com/ &quot;GitHub&quot;) Allows for GIT source control hosting. From here you can leverage many different CI/CD options to compile and publish your
    applications.
-   [**Bitbucket**](https://bitbucket.org/ &quot;Bitbucket&quot;): Allows for GIT source control hosting along with integrated CI/CD pipelines to auto compile and publish your applications.</file><file path="DisCatSharp.Docs/articles/misc/nightly_builds.md">---
uid: misc_nightly_builds
title: Nightly Builds
author: DisCatSharp Team
---

# Do you have nightly builds?

We offer nightly builds for DisCatSharp. They contain bugfixes and new features before the official NuGet releases, however they are
not guaranteed to be stable, or work at all.
Open the NuGet interface for your project, check **Prerelease**.

Then just select **Latest prerelease** version of DisCatSharp packages, and install them.

You might need to restart Visual Studio for changes to take effect.

If you find any problems in the nightly versions of the packages, please follow the instructions in [Reporting issues](xref:misc_reporting_issues)
article.

# But I&apos;m running GNU/Linux, Mac OS X, or BSD!

If you&apos;re running on a non-Windows OS, you&apos;ll have to get your hands dirty. Prepare your text editor and file browser.

Run `dotnet restore`, it should be able to restore the packages without problems.

# Do you have direct builds from the main branch?

Yes we do!

To use them, follow these instructions:

```bash
# Register Registry
dotnet nuget add source https://registry.aitsys-infra.tools/nuget/discatsharp-git-releases/index.json -n discatsharp-git-releases -u bytesafe -p 01HJ80HC4S65ADXD4H5SANV23E --store-password-in-clear-text

# Restore from registry
dotnet restore -s discatsharp-git-releases -f --no-cache

# Disable Registry
dotnet nuget remove source discatsharp-git-releases
```

These releases are considered to not be stable at all. Use them with care.

And before you ask, the token is public 😉 We created a read-only account just for this registry.


 &gt;[!NOTE]
 &gt; To get the correct version, look at git, copy the target commit hash and select the corresponding version with {version}-{hash}
 &gt; As example: DisCatSharp: 10.5.0-97ac8e24f400b6053da7e6e4b3dea338eaf1bdef
 &gt; The easiest way to do this is to install any version and modify the .csproj file afterwards.</file><file path="DisCatSharp.Docs/articles/misc/sentry.md">---
uid: misc_sentry
title: Sentry
author: DisCatSharp Team
---

# Sentry Integration in DisCatSharp

## Overview

Sentry is an error tracking tool that helps developers monitor and fix crashes in real-time. In DisCatSharp, Sentry is utilized to report and analyze errors and missing fields, ensuring a more robust and reliable library.

## How Sentry is Used in DisCatSharp

The Sentry integration in DisCatSharp is configured to capture and report exceptions, missing fields, and other critical information. This data helps developers identify and fix issues promptly. The integration is controlled by several configuration options within the `DiscordConfiguration` class.

## Configuration Options

The following configuration options are available for Sentry, and they are all **disabled** or set to **null** by default:

-   **ReportMissingFields**: Determines whether to report missing fields for Discord objects. This is useful for library development.

    ```csharp
    public bool ReportMissingFields { internal get; set; } = false;
    ```

-   **EnableSentry**: Enables the Sentry integration.

    ```csharp
    public bool EnableSentry { internal get; set; } = false;
    ```

-   **AttachRecentLogEntries**: If enabled, attaches the recent log entries.

    &gt; [!IMPORTANT]
    &gt; Please be mindful about how much information you log, if you enabled this. We might be able to see unwanted things.

    ```csharp
    public bool AttachRecentLogEntries { internal get; set; } = false;
    ```

-   **AttachUserInfo**: If enabled, attaches the bot&apos;s username and ID to Sentry reports to help pinpoint problems.

    ```csharp
    public bool AttachUserInfo { internal get; set; } = false;
    ```

-   **FeedbackEmail**: An email address that can be used to reach out when the bot encounters library bugs. It is only transmitted if `AttachUserInfo` is enabled.

    ```csharp
    public string? FeedbackEmail { internal get; set; } = null;
    ```

-   **DeveloperUserId**: The Discord user ID for contacting the developer when the bot encounters library bugs. It is only transmitted if `AttachUserInfo` is enabled.

    ```csharp
    public ulong? DeveloperUserId { internal get; set; } = null;
    ```

-   **EnableDiscordIdScrubber**: Optional, whether to additionally scrub discord-based ids from logs. Defaults to `false` since that isn&apos;t needed in most cases. Set it to `true` if you want additional filtering.
    ```csharp
    public bool EnableDiscordIdScrubber { internal get; set; } = false;
    ```

## Data Transmitted to Sentry

When an error or missing field is detected, the following data is transmitted to Sentry:

1. **Event Metadata**: Includes SDK information, event ID, and timestamps.

    ```json
    {
    	&quot;sdk&quot;: {
    		&quot;name&quot;: &quot;sentry.dotnet&quot;,
    		&quot;version&quot;: &quot;4.5.0&quot;
    	},
    	&quot;event_id&quot;: &quot;d9d303e3d75d400e992e1b1d7aef6641&quot;,
    	&quot;timestamp&quot;: &quot;2024-05-16T19:58:31.6006568+00:00&quot;
    }
    ```

2. **Exception Details**: Information about the exception, including the type, value, module, and stack trace.

    ```json
    {
    	&quot;exception&quot;: {
    		&quot;values&quot;: [
    			{
    				&quot;type&quot;: &quot;DisCatSharp.Exceptions.BadRequestException&quot;,
    				&quot;value&quot;: &quot;Bad request: BadRequest&quot;,
    				&quot;module&quot;: &quot;DisCatSharp, Version=10.6.3.0, Culture=neutral, PublicKeyToken=null&quot;,
    				&quot;stacktrace&quot;: {
    					&quot;frames&quot;: [
    						{
    							&quot;filename&quot;: &quot;Entities\\Command.cs&quot;,
    							&quot;function&quot;: &quot;async Task&lt;CommandResult&gt; Command.ExecuteAsync(CommandContext ctx)&quot;,
    							&quot;lineno&quot;: 100
    						}
    					]
    				}
    			}
    		]
    	}
    }
    ```

3. **Breadcrumbs**: Log entries leading up to the error, providing context for the issue.

    ```json
    {
    	&quot;breadcrumbs&quot;: [
    		{
    			&quot;timestamp&quot;: &quot;2024-05-16T19:58:09.814Z&quot;,
    			&quot;message&quot;: &quot;Release notes disabled by config&quot;,
    			&quot;category&quot;: &quot;DisCatSharp.BaseDiscordClient&quot;
    		}
    	]
    }
    ```

4. **User Information**: If `AttachUserInfo` is enabled, the bot&apos;s username, ID, and developer contact details.
    ```json
    {
    	&quot;user&quot;: {
    		&quot;id&quot;: &quot;822242444070092860&quot;,
    		&quot;username&quot;: &quot;nyuw#7780&quot;,
    		&quot;ip_address&quot;: &quot;{{auto}}&quot;,
    		&quot;other&quot;: {
    			&quot;developer&quot;: &quot;856780995629154305&quot;,
    			&quot;email&quot;: &quot;aiko@aitsys.dev&quot;
    		}
    	}
    }
    ```

## Ensuring User Privacy

No sensitive data, such as tokens or user messages, is logged or transmitted to Sentry. The only potentially sensitive data included are the bot&apos;s username and ID, which are only sent if explicitly enabled in the configuration. Additionally, steps have been taken to ensure that log lines sent with bad request reports do not contain sensitive information.

Furthermore, while the JSON payload includes the field `&quot;ip_address&quot;: &quot;{{auto}}&quot;`, no actual IP addresses are transmitted.

## Client-Side Filters

To enhance safety and ensure no sensitive information is leaked, various filters have been implemented on the client side:

1. **StripTokens Utility**: This utility function removes any Discord-based tokens from strings before they might be sent to Sentry.

    ```csharp
    public static string? StripTokens(string? str)
    {
       if (string.IsNullOrWhiteSpace(str))
          return str;

       str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
       str = Regex.Replace(str, @&quot;(mfa\\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);

       return str;
    }
    ```

2. **StripIds Utility**: This utility function removes any Discord-based tokens from strings before they might be sent to Sentry.

    ```csharp
    public static string? StripIds(string? str, bool strip)
    {
    	if (string.IsNullOrWhiteSpace(str) || !strip)
    		return str;

    	str = DiscordRegEx.IdRegex().Replace(str, &quot;{DISCORD_ID}&quot;);

    	return str;
    }
    ```

3. **Breadcrumb Filter**: Filters out sensitive information from breadcrumb logs before sending them to Sentry.

    ```csharp
    options.SetBeforeBreadcrumb(b
    =&gt; new(Utilities.StripIds(Utilities.StripTokens(b.Message), this.Configuration.EnableDiscordIdScrubber)!,
    	b.Type!,
    	b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripIds(Utilities.StripTokens(x.Value), this.Configuration.EnableDiscordIdScrubber)!))
          b.Category,
          b.Level));
    ```

4. **Transaction Filter**: Ensures that sensitive information is not included in transaction data sent to Sentry.

    ```csharp
    options.SetBeforeSendTransaction(tr =&gt;
    {
       if (tr.Request.Data is string str)
          tr.Request.Data = Utilities.StripIds(Utilities.StripTokens(str), this.Configuration.EnableDiscordIdScrubber);

       return tr;
    });
    ```

By maintaining these practices, DisCatSharp ensures user privacy while leveraging Sentry to improve the library&apos;s reliability and performance.

For more information on configuring and using Sentry in DisCatSharp, refer to the official [announcement](https://docs.dcs.aitsys.dev/changelogs/v10/10_6_0#sentry-integration).</file><file path="DisCatSharp.Docs/articles/misc/voice_activities.md">---
uid: misc_voice_activities
title: Voice Activities
author: DisCatSharp Team
---

# Voice Activities

&gt; [!WARNING]
&gt; This list is not maintained.
&gt; Please refer to https://github.com/Delitefully/DiscordLists/blob/master/activities.md instead.

Discord offers a variety of Voice activities. Here is a list of the applications that are currently usable in production.

| Application ID      | Application Name     | Boost level | Max participants |
| ------------------- | -------------------- | ----------- | ---------------- |
| 880218394199220334  | Watch Together       | 0           | Unlimited        |
| 755827207812677713  | Poker Night          | 1           | 25               |
| 773336526917861400  | Betrayal.io          | 0           | Unlimited        |
| 814288819477020702  | Fishington.io        | 0           | Unlimited        |
| 832012774040141894  | Chess In The Park    | 1           | Unlimited        |
| 902271654783242291  | Sketch Heads         | 0           | 16               |
| 879863686565621790  | Letter League        | 1           | 0                |
| 879863976006127627  | Word Snacks          | 0           | 8                |
| 852509694341283871  | SpellCast            | 1           | 100              |
| 832013003968348200  | Checkers In The Park | 1           | Unlimited        |
| 832025144389533716  | Blazing 8s           | 1           | 8                |
| 945737671223947305  | Putt Party           | 1           | Unlimited        |
| 903769130790969345  | Land-io              | 1           | 16               |
| 947957217959759964  | Bobble League        | 1           | 8                |
| 976052223358406656  | Ask Away             | 1           | 10               |
| 950505761862189096  | Know What I Meme     | 1           | 8                |
| 1006584476094177371 | Bash Out             | 1           | 16               |</file><file path="DisCatSharp.Docs/articles/modules/application_commands/cooldowns.md">---
uid: modules_application_commands_cooldowns
title: Cooldowns
author: DisCatSharp Team
hasDiscordComponents: true
---

## Cooldown Attribute

You can apply cooldowns to your application commands with the @DisCatSharp.ApplicationCommands.Attributes.SlashCommandCooldownAttribute &amp; @DisCatSharp.ApplicationCommands.Attributes.ContextMenuCooldownAttribute.

The cooldown attributes consists of three required parameters and one optional parameter.

- `int maxUses` - The number of times a command can be used during the definied time before being put on cooldown.
- `double resetAfter` - After how many seconds the cooldown resets.
- `CooldownBucketType bucketType` - The [type](xref:DisCatSharp.Enums.Core.CooldownBucketType) of bucket to use. Can be combined.

## Usage

```cs
// We create a slash command which sends a meow to the channel. This command can be executed twice every 40 seconds per channel.
[SlashCommand(&quot;meow&quot;, &quot;Meow at chat&quot;), SlashCommandCooldown(2, 40, CooldownBucketType.Channel)]
public async Task MeowAsync(InteractionContext ctx)
{
    await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Meow!&quot;));
}
```

### Visual Example

Please note that the timestamp would show the actual time of the cooldown reset.
We can&apos;t dynamically change the timestamp in the example, so we just use a static one.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; ephemeral&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Error: Ratelimit hit&lt;br/&gt;Try again &lt;discord-time timestamp=&quot;1894912612&quot; format=&quot;R&quot;&gt;&lt;/discord-time&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Customizing the cooldown hit response

You can customize the response that is sent when a user hits a cooldown by creating a custom class which inherits from [ICooldownResponder](xref:DisCatSharp.ApplicationCommands.Entities.ICooldownResponder).

```cs
public sealed class CooldownResponse : ICooldownResponder
{
    /// &lt;inheritdoc /&gt;
    public async Task Responder(BaseContext context)
    {
        await context.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;You hit a cooldown! Try again later.&quot;).AsEphemeral());
    }
}
```

You can then apply this to your command by using the `cooldownResponderType` property on the attribute.

```cs
[SlashCommand(&quot;meow&quot;, &quot;Meow at chat&quot;), SlashCommandCooldown(2, 40, CooldownBucketType.Channel, typeof(CooldownResponse))]
public async Task CooldownTestAsync(InteractionContext ctx)
{
    await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Meow!&quot;));
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; ephemeral&gt;
        &lt;discord-command slot=&quot;reply&quot; profile=&quot;dcs_user&quot; command=&quot;/meow&quot;&gt;&lt;/discord-command&gt;
        You hit a cooldown! Try again later.
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/application_commands/events.md">---
uid: modules_application_commands_events
title: Application Commands Events
---

# Application Commands events

Sometimes we need to add a variety of actions and checks before and after executing a command.
We can do this in the commands itself, or we can use special events for this.

## Before execution

The simplest example in this case: checking if the command was executed within the guild.
Suppose we have a certain class with commands that must be executed ONLY in the guilds:

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    [SlashCommand(&quot;mute&quot;, &quot;Mute user.&quot;)]
    public static async Task Mute(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;kick&quot;, &quot;Kick user.&quot;)]
    public static async Task Kick(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;ban&quot;, &quot;Ban user.&quot;)]
    public static async Task Ban(InteractionContext ctx)
    {

    }
}
```

In this case, the easiest way would be to override the method from [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    public override async Task&lt;bool&gt; BeforeSlashExecutionAsync(InteractionContext ctx)
    {
        if (ctx.Guild == null)
            return false;
    }

    [SlashCommand(&quot;mute&quot;, &quot;Mute user.&quot;)]
    public static async Task Mute(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;kick&quot;, &quot;Kick user.&quot;)]
    public static async Task Kick(InteractionContext ctx)
    {

    }
    [SlashCommand(&quot;ban&quot;, &quot;Ban user.&quot;)]
    public static async Task Ban(InteractionContext ctx)
    {

    }
}
```

Now, before executing any of these commands, the `BeforeSlashExecutionAsync` method will be executed. You can do anything in it, for example, special logging.
If you return `true`, then the command method will be executed after that, otherwise the execution will end there.

## After execution

If you want to create actions after executing the command, then you need to do the same, but override a different method:

```cs
public override async Task AfterSlashExecutionAsync(InteractionContext ctx)
{
    // some actions
}
```

## Context menus

You can also add similar actions for the context menus. But this time, you need to override the other methods:

```cs
public class MyGuildCommands : ApplicationCommandsModule
{
    public override async Task&lt;bool&gt; BeforeContextMenuExecutionAsync(ContextMenuContext ctx)
    {
        if (ctx.Guild == null)
            return false;
    }
    public override async Task AfterContextMenuExecutionAsync(ContextMenuContext ctx)
    {
        // some actions
    }
}
```

## Error handling

If you want to handle errors for slash commands, subscribe to the [SlashCommandErrored](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.SlashCommandErrored) event.

A separate event exists for context menus as [ContextMenuErrored](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsExtension.ContextMenuErrored) event.

It contains a castable field `Exception` with the exception that was thrown during the execution of the command.

As example it can be a type of [SlashExecutionChecksFailedException](xref:DisCatSharp.ApplicationCommands.Exceptions.SlashExecutionChecksFailedException) or [ContextMenuExecutionChecksFailedException](xref:DisCatSharp.ApplicationCommands.Exceptions.ContextMenuExecutionChecksFailedException) which contains a list of failed checks.</file><file path="DisCatSharp.Docs/articles/modules/application_commands/intro.md">---
uid: modules_application_commands_intro
title: Application Commands Introduction
---

&gt;[!NOTE]
&gt; This article assumes you&apos;ve recently read the article on *[writing your first bot](xref:getting_started_first_bot)*.

# Introduction to Application Commands
Discord provides built-in commands called: *Application Commands*.&lt;br/&gt;
Be sure to install the `DisCatSharp.ApplicationCommands` package from NuGet before continuing.

At the moment it is possible to create such commands:
- Slash commands
- User context menu commands
- Message context menu commands

## Writing an Application Commands

### Creation of the first commands

Each command is a method with the attribute [SlashCommand](xref:DisCatSharp.ApplicationCommands.Attributes.SlashCommandAttribute) or [ContextMenu](xref:DisCatSharp.ApplicationCommands.Attributes.ContextMenuAttribute). They must be in classes that inherit from [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).
Also, the first argument to the method must be [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext) or [ContextMenuContext](xref:DisCatSharp.ApplicationCommands.Context.ContextMenuContext).

Simple slash command:
```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public async Task MySlashCommand(InteractionContext ctx)
    {

    }
}
```

Simple context menu command:
```cs
public class MySecondCommand : ApplicationCommandsModule
{
    [ContextMenu(ApplicationCommandType.User, &quot;My Command&quot;)]
    public async Task MyContextMenuCommand(ContextMenuContext ctx)
    {

    }
}
```

Now let&apos;s add some actions to the commands, for example, send a reply:
```cs
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
{
    Content = &quot;Hello :3&quot;
});
```

If the command will be executed for more than 3 seconds, we must response at the beginning of execution and edit it at the end.
```cs
await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder());

await Task.Delay(5000); // Simulating a long command execution.

await ctx.EditResponseAsync(new DiscordWebhookBuilder()
{
    Content = &quot;Hello :3&quot;
});
```

&gt;[!NOTE]
&gt; Note that you can make your commands static, but then you cannot use [Dependency Injection](xref:modules_commandsnext_dependency_injection) in them.


### Registration of commands

After writing the commands, we must register them. For this we need a [DiscordClient](xref:DisCatSharp.DiscordClient).

```cs
var appCommands = client.UseApplicationCommands();

appCommands.RegisterGlobalCommands&lt;MyCommand&gt;();
appCommands.RegisterGlobalCommands&lt;MySecondCommand&gt;();
```
Simple, isn&apos;t it? You can register global and guild commands.
Global commands will be available on all guilds of which the bot is a member. Guild commands will only appear in a specific guild.

To register guild commands, it is enough to specify the Id of the guild as the first argument of the registration method.

```cs
var appCommands = client.UseApplicationCommands();

appCommands.RegisterGuildCommands&lt;MyCommand&gt;(&lt;guildId&gt;);
appCommands.RegisterGuildCommands&lt;MySecondCommand&gt;(&lt;guildId&gt;);
```

## Command Groups

Sometimes we may need to combine slash commands into groups.
In this case, we need to wrap our class with commands in another class and add the [SlashCommandGroup](xref:DisCatSharp.ApplicationCommands.Attributes.SlashCommandGroupAttribute) attribute.

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommandGroup(&quot;my_command&quot;, &quot;This is description of the command group.&quot;)]
    public class MyCommandGroup : ApplicationCommandsModule
    {
        [SlashCommand(&quot;first&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySlashCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is first subcommand.&quot;
            });
        }
        [SlashCommand(&quot;second&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySecondCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is second subcommand.&quot;
            });
        }
    }
}
```

Commands will now be available via `/my_command first` and `/my_command second`.
Also, note that both classes must inherit [ApplicationCommandsModule](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsModule).</file><file path="DisCatSharp.Docs/articles/modules/application_commands/options.md">---
uid: modules_application_commands_options
title: Application Commands Options
---

# Slash Commands options
For slash commands, you can create options. They allow users to submit additional information to commands.

Command options can be of the following types:
- string
- int
- long
- double
- bool
- [DiscordUser](xref:DisCatSharp.Entities.DiscordUser)
- [DiscordRole](xref:DisCatSharp.Entities.DiscordRole)
- [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel)
- [DiscordAttachment](xref:DisCatSharp.Entities.DiscordAttachment)
- mentionable (ulong)
- Enum

## Basic usage

&gt;[!NOTE]
&gt;Options can only be added in the slash commands. Context menus do not support this!

All of options must contain the [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute) attribute.
They should be after [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext).

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;argument&quot;, &quot;This is description of the option.&quot;)] string firstParam)
    {
        await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
        {
            Content = firstParam
        });
    }
}
```

## Choices
Sometimes, we need to allow users to choose from several pre-created options.
We can of course add a string or long parameter and let users guess the options, but why when we can make things more convenient?

We have 3 ways to make choices:
- Enums
- [Choice Attribute](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute)
- [Choice Providers](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider)

### Enums

This is the easiest option. We just need to specify the required Enum as a command parameter.

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;enum_param&quot;, &quot;Description&quot;)] MyEnum enumParameter)
    {

    }
}

public enum MyEnum
{
    FirstOption,
    SecondOption
}
```

In this case, the user will be shown this as options: `FirstOption` and `SecondOption`.
Therefore, if you want to define different names for options without changing the Enum, you can add a special attribute:
```cs
public enum MyEnum
{
    [ChoiceName(&quot;First option&quot;)]
    FirstOption,
    [ChoiceName(&quot;Second option&quot;)]
    SecondOption
}
```

### Choice Attribute

With this way, you can get rid of unnecessary conversions within the command.
To do this, you need to add one or more [Choice Attributes](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute) before the [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute) attribute
```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Choice(&quot;First option&quot;, 1)] [Choice(&quot;Second option&quot;, 2)] [Option(&quot;option&quot;, &quot;Description&quot;)] long firstParam)
{

}
```

As the first parameter, [Choice](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceAttribute) takes a name that will be visible to the user, and the second - a value that will be passed to the command.
You can also use strings.

### Choice Provider

Perhaps the most difficult way. It consists in writing a method that will generate a list of options when registering commands.
This way we don&apos;t have to list all of them in the code when there are many of them.

To create your own provider, you need to create a class that inherits [IChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider) and contains the `Provider()` method.
```cs
public class MyChoiceProvider : IChoiceProvider
{
    public Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider()
    {

    }
}
```

As seen above, the method should return a list of [DiscordApplicationCommandOptionChoice](xref:DisCatSharp.Entities.DiscordApplicationCommandOptionChoice).

Now we need to create a list and add items to it:
```cs
var options = new List&lt;DiscordApplicationCommandOptionChoice&gt;
{
    new DiscordApplicationCommandOptionChoice(&quot;First option&quot;, 1),
    new DiscordApplicationCommandOptionChoice(&quot;Second option&quot;, 2)
};

return Task.FromResult(options.AsEnumerable());
```

Of course you can generate this list as you like. The main thing is that the method should return this list.

Now let&apos;s add our new provider to the command.


```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [ChoiceProvider(typeof(MyChoiceProvider))] [Option(&quot;option&quot;, &quot;Description&quot;)] long option)
{

}
```

All the code that we got:
```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public static async Task MySlashCommand(InteractionContext ctx, [ChoiceProvider(typeof(MyChoiceProvider))] [Option(&quot;option&quot;, &quot;Description&quot;)] long option)
    {

    }
}

public class MyChoiceProvider : IChoiceProvider
{
    public Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt; Provider()
    {
        var options = new List&lt;DiscordApplicationCommandOptionChoice&gt;
        {
            new DiscordApplicationCommandOptionChoice(&quot;First option&quot;, 1),
            new DiscordApplicationCommandOptionChoice(&quot;Second option&quot;, 2)
        };

        return Task.FromResult(options.AsEnumerable());
    }
}
```

That&apos;s all, for a better example for [ChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider) refer to the examples.

## Autocomplete
Autocomplete works in the same way as ChoiceProvider, with one difference:
the method that creates the list of choices is triggered not once when the commands are registered, but whenever the user types a command.
It is advisable to use this method exactly when you have a list that will be updated while the bot is running.
In other cases, when the choices will not change, it is advisable to use the previous methods.

Creating an autocomplete is similar to creating a ChoiceProvider with a few changes:
```cs
public class MyAutocompleteProvider : IAutocompleteProvider
{
    public async Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext ctx)
    {
        var options = new List&lt;DiscordApplicationCommandAutocompleteChoice&gt;
        {
            new DiscordApplicationCommandAutocompleteChoice(&quot;First option&quot;, 1),
            new DiscordApplicationCommandAutocompleteChoice(&quot;Second option&quot;, 2)
        };

        return Task.FromResult(options.AsEnumerable());
    }
}
```

The changes are that instead of [IChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IChoiceProvider), the class inherits [IAutocompleteProvider](xref:DisCatSharp.ApplicationCommands.Attributes.IAutocompleteProvider), and the Provider method should return a list with [DiscordApplicationCommandAutocompleteChoice](xref:DisCatSharp.Entities.DiscordApplicationCommandAutocompleteChoice).

Now we add it to the command:
```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Autocomplete(typeof(MyAutocompleteProvider))] [Option(&quot;option&quot;, &quot;Description&quot;, true)] long option)
{

}
```

Note that we have not only replaced [ChoiceProvider](xref:DisCatSharp.ApplicationCommands.Attributes.ChoiceProviderAttribute) with [Autocomplete](xref:DisCatSharp.ApplicationCommands.Attributes.AutocompleteAttribute), but also added `true` to [Option](xref:DisCatSharp.ApplicationCommands.Attributes.OptionAttribute).

## Channel types

Sometimes we may need to give users the ability to select only a certain type of channels, for example, only text, or voice channels.

This can be done by adding the [ChannelTypes](xref:DisCatSharp.ApplicationCommands.Attributes.ChannelTypesAttribute) attribute to the option with the [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) type.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;You can select only text channels.&quot;), ChannelTypes(ChannelType.Text)] DiscordChannel channel)
{

}
```

This will make it possible to select only text channels.

## MinimumValue / MaximumValue Attribute

Sometimes we may need to give users the ability to select only a certain range of values.

This can be done by adding the [MinimumValue](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumValueAttribute) and [MaximumValue](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumValueAttribute) attribute to the option.
It can be used only for the types `double`, `int` and `long` tho.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;number&quot;, &quot;You can select only a certain range.&quot;), MinimumValue(50), MaximumValue(100)] int numbers)
{

}
```

## MinimumLength / MaximumLength Attribute

Sometimes we may need to limit the user to a certain string length.

This can be done by adding the [MinimumLength](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumLengthAttribute) and [MaximumLength](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumLengthAttribute) attribute to the option.
It can be used only for the type `string`.

```cs
[SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
public static async Task MySlashCommand(InteractionContext ctx, [Option(&quot;text&quot;, &quot;You can only send text with a length between 10 and 50 characters.&quot;), MinimumLength(10), MaximumLength(50)] string text)
{

}
```</file><file path="DisCatSharp.Docs/articles/modules/application_commands/translations/reference.md">---
uid: modules_application_commands_translations_reference
title: Translation Reference
---

# Translation Reference

&gt; [!NOTE]
&gt; DisCatSharp uses [JSON](https://www.json.org) to inject the translations of [Application Commands](https://discord.com/developers/docs/interactions/application-commands).

## Command Object

| Key                       | Value                                         | Description                                                                                                 |
| ------------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| name                      | string                                        | name of the application command                                                                             |
| description?              | string                                        | description of the application command                                                                      |
| type                      | int                                           | [type](#application-command-type) of application command, used to map command types, not valid for options  |
| name_translations         | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command name                                       |
| description_translations? | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command description, only valid for slash commands |
| options                   | array of [Option Objects](#option-object)     | array of option objects containing translations                                                             |

### Application Command Type

| Type                         | Value |
| ---------------------------- | ----- |
| Slash Command                | 1     |
| User Context Menu Command    | 2     |
| Message Context Menu Command | 3     |

## Command Group Object

| Key                      | Value                                                           | Description                                                                                                |
| ------------------------ | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| name                     | string                                                          | name of the application command group                                                                      |
| description              | string                                                          | description of the application command group                                                               |
| type                     | int                                                             | [type](#application-command-type) of application command, used to map command types, not valid for options |
| name_translations        | array of [Translation KVPs](#translation-kvp)                   | array of translation key-value-pairs for the application command group name                                |
| description_translations | array of [Translation KVPs](#translation-kvp)                   | array of translation key-value-pairs for the application command group description                         |
| commands                 | array of [Command Objects](#command-object)                     | array of command objects containing translations                                                           |
| groups                   | array of [Sub Command Group Objects](#sub-command-group-object) | array of sub command group objects containing translations                                                 |

## Sub Command Group Object

| Key                      | Value                                         | Description                                                                            |
| ------------------------ | --------------------------------------------- | -------------------------------------------------------------------------------------- |
| name                     | string                                        | name of the application command sub group                                              |
| description              | string                                        | description of the application command sub group                                       |
| name_translations        | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command sub group name        |
| description_translations | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command sub group description |
| commands                 | array of [Command Objects](#command-object)   | array of command objects containing translations                                       |

## Option Object

| Key                      | Value                                                   | Description                                                                         |
| ------------------------ | ------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| name                     | string                                                  | name of the application command option                                              |
| description              | string                                                  | description of the application command group                                        |
| name_translations        | array of [Translation KVPs](#translation-kvp)           | array of translation key-value-pairs for the application command option name        |
| description_translations | array of [Translation KVPs](#translation-kvp)           | array of translation key-value-pairs for the application command option description |
| choices                  | array of [Option Choice Objects](#option-choice-object) | array of option choice objects containing translations                              |

## Option Choice Object

| Key               | Value                                         | Description                                                                         |
| ----------------- | --------------------------------------------- | ----------------------------------------------------------------------------------- |
| name              | string                                        | name of the application command option choice                                       |
| name_translations | array of [Translation KVPs](#translation-kvp) | array of translation key-value-pairs for the application command option choice name |

## Translation KVP

A translation object is a key-value-pair of `&quot;locale&quot;: &quot;value&quot;`.

### Example Translation Array:

```json
{
	&quot;en-US&quot;: &quot;Hello&quot;,
	&quot;de&quot;: &quot;Hallo&quot;
}
```

## Valid Locales

| Locale | Language               |
| ------ | ---------------------- |
| id     | Indonesian             |
| da     | Danish                 |
| de     | German                 |
| en-GB  | English, UK            |
| en-US  | English, US            |
| es-ES  | Spanish                |
| es-419 | Spanish, Latin America |
| fr     | French                 |
| hr     | Croatian               |
| it     | Italian                |
| lt     | Lithuanian             |
| hu     | Hungarian              |
| nl     | Dutch                  |
| no     | Norwegian              |
| pl     | Polish                 |
| pt-BR  | Portuguese, Brazilian  |
| ro     | Romanian, Romania      |
| fi     | Finnish                |
| sv-SE  | Swedish                |
| vi     | Vietnamese             |
| tr     | Turkish                |
| cs     | Czech                  |
| el     | Greek                  |
| bg     | Bulgarian              |
| ru     | Russian                |
| uk     | Ukrainian              |
| hi     | Hindi                  |
| th     | Thai                   |
| zh-CN  | Chinese, China         |
| ja     | Japanese               |
| zh-TW  | Chinese, Taiwan        |
| ko     | Korean                 |</file><file path="DisCatSharp.Docs/articles/modules/application_commands/translations/using.md">---
uid: modules_application_commands_translations_using
title: Using Translations
---

# Using Translations

## Why Do We Outsource Translation In External JSON Files

Pretty simple: It&apos;s common to have translations external stored.
This makes it easier to modify them, while keeping the code itself clean.

## Adding Translations

Translations are added the same way like permissions are added to Application Commands:

```cs
const string TRANSLATION_PATH = &quot;translations/&quot;;

Client.GetApplicationCommands().RegisterGuildCommands&lt;MyCommand&gt;(1215484634894646844, translations =&gt;
{
    string json = File.ReadAllText(TRANSLATION_PATH + &quot;my_command.json&quot;);

    translations.AddGroupTranslation(json);
});

Client.GetApplicationCommands().RegisterGuildCommands&lt;MySimpleCommands&gt;(1215484634894646844, translations =&gt;
{
    string json = File.ReadAllText(TRANSLATION_PATH + &quot;my_simple_command.json&quot;);

    translations.AddSingleTranslation(json);
});
```

&gt; [!WARNING]
&gt; If you add a translation to a class, you have to supply translations for every command in this class. Otherwise it will fail.

## Creating The Translation JSON

We split the translation in two categories.
One for slash command groups and one for normal slash commands and context menu commands.
The `name` key in the JSON will be mapped to the command / option / choice names internally.

### Translation For Slash Command Groups

Imagine, your class look like the following example:

```cs
public class MyCommand : ApplicationCommandsModule
{
    [SlashCommandGroup(&quot;my_command&quot;, &quot;This is description of the command group.&quot;)]
    public class MyCommandGroup : ApplicationCommandsModule
    {
        [SlashCommand(&quot;first&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySlashCommand(InteractionContext ctx)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is first subcommand.&quot;
            });
        }
        [SlashCommand(&quot;second&quot;, &quot;This is description of the command.&quot;)]
        public async Task MySecondCommand(InteractionContext ctx, [Option(&quot;value&quot;, &quot;Some string value.&quot;)] string value)
        {
            await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
            {
                Content = &quot;This is second subcommand. The value was &quot; + value
            });
        }
    }
}
```

The translation json is a object of [Command Group Objects](xref:modules_application_commands_translations_reference#command-group-object)
A correct translation json for english and german would look like that:

```json
[
	{
		&quot;name&quot;: &quot;my_command&quot;,
		&quot;description&quot;: &quot;This is description of the command group.&quot;,
		&quot;type&quot;: 1,
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;my_command&quot;,
			&quot;de&quot;: &quot;mein_befehl&quot;
		},
		&quot;description_translations&quot;: {
			&quot;en-US&quot;: &quot;This is description of the command group.&quot;,
			&quot;de&quot;: &quot;Das ist die description der Befehl Gruppe.&quot;
		},
		&quot;groups&quot;: [],
		&quot;commands&quot;: [
			{
				&quot;name&quot;: &quot;first&quot;,
				&quot;description&quot;: &quot;First&quot;,
				&quot;name_translations&quot;: {
					&quot;en-US&quot;: &quot;first&quot;,
					&quot;de&quot;: &quot;erste&quot;
				},
				&quot;description_translations&quot;: {
					&quot;en-US&quot;: &quot;This is description of the command.&quot;,
					&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
				}
			},
			{
				&quot;name&quot;: &quot;second&quot;,
				&quot;description&quot;: &quot;Second&quot;,
				&quot;name_translations&quot;: {
					&quot;en-US&quot;: &quot;second&quot;,
					&quot;de&quot;: &quot;zweite&quot;
				},
				&quot;description_translations&quot;: {
					&quot;en-US&quot;: &quot;This is description of the command.&quot;,
					&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
				},
				&quot;options&quot;: [
					{
						&quot;name&quot;: &quot;value&quot;,
						&quot;description&quot;: &quot;Some string value.&quot;,
						&quot;type&quot;: 3,
						&quot;name_translations&quot;: {
							&quot;en-US&quot;: &quot;value&quot;,
							&quot;de&quot;: &quot;wert&quot;
						},
						&quot;description_translations&quot;: {
							&quot;en-US&quot;: &quot;Some string value.&quot;,
							&quot;de&quot;: &quot;Ein string Wert.&quot;
						}
					}
				]
			}
		]
	}
]
```

### Translation For Slash Commands &amp; Context Menu Commands

Now imagine, that your class look like this example:

```cs
public class MySimpleCommands : ApplicationCommandsModule
{
    [SlashCommand(&quot;my_command&quot;, &quot;This is description of the command.&quot;)]
    public async Task MySlashCommand(InteractionContext ctx)
    {

    }

    [ContextMenu(ApplicationCommandType.User, &quot;My Command&quot;)]
    public async Task MyContextMenuCommand(ContextMenuContext ctx)
    {

    }
}
```

The slash command is a simple [Command Object](xref:modules_application_commands_translations_reference#command-object).
Same goes for the context menu command, but note that it can&apos;t have a description.

Slash Commands has the [type](xref:modules_application_commands_translations_reference#application-command-type) `1` and context menu commands the [type](xref:modules_application_commands_translations_reference#application-command-type) `2` or `3`.
We use this to determine, where the translation belongs to.

Please note that the description field is optional. We suggest setting it for slash commands if you want to use our translation generator, which we&apos;re building right now.
Context menu commands can&apos;t have a description, so omit it.

A correct json for this example would look like that:

```json
[
	{
		&quot;name&quot;: &quot;my_command&quot;,
		&quot;description&quot;: &quot;This is description of the command.&quot;,
		&quot;type&quot;: 1, // Type 1 for slash command
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;my_command&quot;,
			&quot;de&quot;: &quot;mein_befehl&quot;
		},
		&quot;description_translations&quot;: {
			&quot;en-US&quot;: &quot;This is description of the command.&quot;,
			&quot;de&quot;: &quot;Das ist die Beschreibung des Befehls.&quot;
		}
	},
	{
		&quot;name&quot;: &quot;My Command&quot;,
		&quot;type&quot;: 2, // Type 2 for user context menu command
		&quot;name_translations&quot;: {
			&quot;en-US&quot;: &quot;My Command&quot;,
			&quot;de&quot;: &quot;Mein Befehl&quot;
		}
	}
]
```

## Available Locales

Discord has a limited choice of locales, in particular, the ones you can select in the client.
To see the available locales, visit [this](xref:modules_application_commands_translations_reference#valid-locales) page.

## Can We Get The User And Guild Locale?

Yes, you can!
Discord sends the user on all [interaction types](xref:DisCatSharp.Enums.InteractionType), except `Ping`.

We introduced two new properties `Locale` and `GuildLocale` on [InteractionContext](xref:DisCatSharp.ApplicationCommands.Context.InteractionContext), [ContextMenuContext](xref:DisCatSharp.ApplicationCommands.Context.ContextMenuContext), [AutoCompleteContext](xref:DisCatSharp.ApplicationCommands.Context.AutocompleteContext) and [DiscordInteraction](xref:DisCatSharp.Entities.DiscordInteraction).
`Locale` is the locale of the user and always represented.
`GuildLocale` is only represented, when the interaction is **not** in a DM.

Furthermore we cache known user locales on the [DiscordUser](xref:DisCatSharp.Entities.DiscordUser.Locale) object.</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/advanced.md">---
uid: modules_audio_lavalink_v4_advanced
title: Lavalink V4 Advanced
author: DisCatSharp Team
---

# Advanced Lavalink Usage

Given the new possibilities to use Lavalink with Spotify, Apple Music, Deezer and Yandex Music, we go a bit deeper into this topic here.

## Preamble

For this to work, you need the following plugin installed in your Lavalink server: https://github.com/topi314/LavaSrc

## Setup

General config:

```yml
lavalink:
  plugins:
    - dependency: &quot;com.github.topi314.lavasrc:lavasrc-plugin:4.3.0&quot;
      repository: &quot;https://maven.lavalink.dev/releases&quot;
[..]
plugins:
  lavasrc:
    providers: # Custom providers for track loading. This is the default
      - &quot;ytsearch:\&quot;%ISRC%\&quot;&quot; # Will be ignored if track does not have an ISRC. See https://esearch.wikipedia.org/wiki/International_Standard_Recording_Code
      - &quot;ytsearch:%QUERY%&quot; # Will be used if track has no ISRC or no track could be found for the ISRC
      - &quot;scsearch:%QUERY%&quot; # Soundcloud search provider
      - &quot;spsearch:%QUERY%&quot; # Spotify search provider
      - &quot;sprec:%QUERY%&quot; # Spotify recommendation search provider
      - &quot;ymsearch:%QUERY%&quot; # YouTube Music search provider
      - &quot;amsearch:%QUERY%&quot; # Apple Music search provider
      - &quot;dzisrc:%ISRC%&quot; # Deezer ISRC provider
      - &quot;dzsearch:%QUERY%&quot; # Deezer search provider
      - &quot;ymsearch:%QUERY%&quot; # Yandex Music search provider

    sources:
      spotify: true # Enable Spotify source
      applemusic: true # Enable Apple Music source
      deezer: true # Enable Deezer source
      yandexmusic: true # Enable Yandex Music source
```

### Spotify Setup

```yml
plugins:
  lavasrc:
[..]
    spotify:
        clientId: &quot;your client id&quot;
        clientSecret: &quot;your client secret&quot;
        countryCode: &quot;US&quot; # the country code you want to use for filtering the artists top tracks. See https://esearch.wikipedia.org/wiki/ISO_3166-1_alpha-2
        playlistLoadLimit: 6 # The number of pages at 100 tracks each
        albumLoadLimit: 6 # The number of pages at 50 tracks each
```

### Apple Music Setup

```yml
plugins:
  lavasrc:
[..]
    applemusic:
        countryCode: &quot;US&quot; # the country code you want to use for filtering the artists top tracks and language. See https://esearch.wikipedia.org/wiki/ISO_3166-1_alpha-2
        playlistLoadLimit: 6 # The number of pages at 100 tracks each
        albumLoadLimit: 6 # The number of pages at 50 tracks each
```

### Deezer Setup

```yml
plugins:
  lavasrc:
[..]
    deezer:
      masterDecryptionKey: &quot;your master decryption key&quot; # the master key used for decrypting the deezer tracks. (yes this is not here you need to get it from somewhere else)
```

### Yandex Music Setup

```yml
plugins:
  lavasrc:
[..]
    yandexmusic:
      accessToken: &quot;your access token&quot; # the token used for accessing the yandex music api. See https://github.com/topi314/LavaSrc#yandex-music
```

## Usage

### Client Configuration

You don&apos;t have to configure anything directly in DisCatSharp.Lavalink.

### Code Snippets

```cs
// We got the search as string from xy already
string search = &quot;spsearch:Shooting Stars&quot;;
// Node connection is already defined.
LavalinkNodeConnection nodeConnection;

// We set YouTube as default search type because it&apos;s the most common one.
var type = LavalinkSearchType.Youtube;
if (search.StartsWith(&quot;ytsearch:&quot;))
{
	search = search.Replace(&quot;ytsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.Youtube;
}
else if (search.StartsWith(&quot;scsearch:&quot;))
{
	search = search.Replace(&quot;ytsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.SoundCloud;
}
else if (search.StartsWith(&quot;spsearch:&quot;))
{
	search = search.Replace(&quot;spsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.Spotify;
}
else if (search.StartsWith(&quot;amsearch:&quot;))
{
	search = search.Replace(&quot;amsearch:&quot;, &quot;&quot;);
	type = LavalinkSearchType.AppleMusic;
}

// This function gives us a result from Lavalink.
LavalinkLoadResult result = await guildPlayer.LoadTracksAsync(type, query);

// Internally Lavalink searches the Spotify api, and then searches YouTube for the result.
// We can now use the result and play the song.
// Same for Apple Music.
```

## Conclusion

This is the most basic example of how to use the new Lavalink features. You can find more information in the Lavalink plugin docs: https://github.com/topi314/LavaSrc?tab=readme-ov-file#lavalink-usage</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/commands.md">---
uid: modules_audio_lavalink_v4_commands
title: Lavalink V4 Commands
author: DisCatSharp Team
hasDiscordComponents: true
---

# Adding Music Commands

This article assumes that you know how to use ApplicationCommands. If you do not, you should learn [here](xref:modules_application_commands_intro) before continuing with this guide.

## Prerequisites

Before we start we will need to make sure ApplicationCommands is configured. For this we can make a simple configuration and command class:

```cs
using DisCatSharp.ApplicationCommands;
namespace FirstLavalinkBot;

public class MyFirstLavalinkCommands : ApplicationCommandsModule
{ }
```

Next up you gotta register the ApplicationCommands module:

```cs
ApplicationCommands = Discord.UseApplicationCommands();
// Either as a global command
ApplicationCommands.RegisterGlobalCommands&lt;MyFirstLavalinkCommands&gt;();
// Or as a guild command
ulong myGuildId = 858089281214087179;
ApplicationCommands.RegisterGuildCommands&lt;MyFirstLavalinkCommands&gt;(myGuildId);
```

## Adding base commands

Your bot, and Lavalink, will need to connect to a voice channel to play music.

Let&apos;s create the base for these commands:

```cs
[SlashCommand(&quot;join&quot;, &quot;Join a voice channel&quot;)]
public async Task JoinAsync(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;Channel to join&quot;)] DiscordChannel channel)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}

[SlashCommand(&quot;leave&quot;, &quot;Leave the voice channel&quot;)]
public async Task LeaveAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}
```

To get the Lavalink node we will need to use the `GetLavalink()` extension method on the DiscordClient. This will return a [LavalinkExtension](xref:DisCatSharp.Lavalink.LavalinkExtension) object, which contains a collection of connected sessions. Since we only have one node, we can use linq&apos;s `.First()` method on the extensions connected nodes to get what we need.

If we have the session, we can use the `ConnectAsync()` method to connect to the voice channel. This method will return a [LavalinkGuildPlayer](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) object, which we can use to play music. We will also need to check if the channel is a voice channel. If the guild player is already connected, the function will return the existing player.

So far, your command class should look something like this:

```cs
using System.Threading.Tasks;
using DisCatSharp;
using DisCatSharp.Entities;
using DisCatSharp.ApplicationCommands;
using DisCatSharp.ApplicationCommands.Context;
using DisCatSharp.ApplicationCommands.Attributes;
using DisCatSharp.Lavalink;
using DisCatSharp.Lavalink.Entities;
using DisCatSharp.Lavalink.Enums;
namespace FirstLavalinkBot;

public class MyFirstLavalinkCommands : BaseCommandModule
{
	[SlashCommand(&quot;join&quot;, &quot;Join a voice channel&quot;)]
	public async Task JoinAsync(InteractionContext ctx, [Option(&quot;channel&quot;, &quot;Channel to join&quot;)] DiscordChannel channel)
	{
		await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
		var lavalink = ctx.Client.GetLavalink();
		if (!lavalink.ConnectedSessions.Any())
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;The Lavalink connection is not established&quot;));
			return;
		}

		var session = lavalink.ConnectedSessions.Values.First();

		if (channel.Type != ChannelType.Voice || channel.Type != ChannelType.Stage)
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Not a valid voice channel.&quot;));
			return;
		}

		await session.ConnectAsync(channel);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Joined {channel.Mention}!&quot;));
	}

	[SlashCommand(&quot;leave&quot;, &quot;Leave the voice channel&quot;)]
	public async Task LeaveAsync(InteractionContext ctx)
	{
		await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
		var lavalink = ctx.Client.GetLavalink();
		var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);
		if (guildPlayer == null)
		{
			await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink not connected.&quot;));
			return;
		}

		await guildPlayer.DisconnectAsync();
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Left {guildPlayer.channel.Mention}!&quot;));
	}
}
```

## Adding playback commands

Now that we have the base commands, we can add the playback commands. For this we will need to get the Lavalink session, the guild connection, and the track details. We will also need to check if Lavalink is connected.

```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
}
```
One of Lavalink&apos;s best features is its ability to search for tracks from a variety of media sources, such as YouTube, SoundCloud, Twitch, and more. This is what makes bots like Rythm, Fredboat, and Groovy popular

Lavalink can also play tracks directly from a media url. This is useful for playing tracks from other sources, such as Bandcamp, Vimeo, and more.

Like before, we will need to get our node and guild connection and have the appropriate checks. Since it wouldn&apos;t make sense to have the channel as a parameter, we will instead get it from the member&apos;s voice state:

```cs
// Important to check the voice state itself first, as it may throw a NullReferenceException if they don&apos;t have a voice state.
if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
{
	await ctx.RespondAsync(&quot;You are not in a voice channel.&quot;);
	return;
}

var lavalink = ctx.Client.GetLavalink();
var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

if (guildPlayer == null)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
	return;
}
```

```cs
var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);
```

The load result will contain an enum called `LoadResultType`, which will inform us if Lavalink was able to retrieve the track data. We can use this as a check:

```cs
// If something went wrong on Lavalink&apos;s end or it just couldn&apos;t find anything.
if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
	return;
}
```

Lavalink will return a dynamic result object. This object will contain the track data, as well as the type of result.

We can use the `LoadResultType` to determine what type of result we got. If we now the result type we need to specify the objects type.

A shorthand method exists as `GetResultAs&lt;T&gt;`:

```cs
LavalinkTrack track = loadResult.LoadType switch {
    LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
    LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
    LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().First(),
    _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
};
```

And finally, we can play the track:

```cs
await guildPlayer.PlayAsync(track);

await ctx.RespondAsync($&quot;Now playing {track.Title}!&quot;);
```

Your play command should look like this:
```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);

	if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
		return;
	}

	LavalinkTrack track = loadResult.LoadType switch {
        LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
        LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
        LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().Tracks.First(),
        _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
    };

	await guildPlayer.PlayAsync(track);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Now playing {query}!&quot;));
}
```

Being able to pause and resume the player is also useful. For this we can use most of the base from the play command:

```cs
[SlashCommand(&quot;pause&quot;, &quot;Pause a track&quot;)]
public async Task PauseAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}
}
```

For this command we will also want to check the player state to determine if we should send a pause command. We can do so by checking `guildPlayer.CurrentTrack`:

```cs
if (guildPlayer.CurrentTrack == null)
{
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
	return;
}
```

And finally, we can call pause:

```cs
await guildPlayer.PauseAsync();
```

The equivalent for resume:

```cs
await guildPlayer.ResumeAsync();
```

The finished commands should look like so:
```cs
[SlashCommand(&quot;pause&quot;, &quot;Pause a track&quot;)]
public async Task PauseAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	if (guildPlayer.CurrentTrack == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
		return;
	}

	await guildPlayer.PauseAsync();
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Playback paused!&quot;));
}

[SlashCommand(&quot;resume&quot;, &quot;Resume a track&quot;)]
public async Task ResumeAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
	if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
		return;
	}

	var lavalink = ctx.Client.GetLavalink();
	var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

	if (guildPlayer == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
		return;
	}

	if (guildPlayer.CurrentTrack == null)
	{
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;There are no tracks loaded.&quot;));
		return;
	}

	await guildPlayer.ResumeAsync();
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Playback resumed!&quot;));
}
```

Now we can use these commands to listen to music!

## Visual Example

&lt;discord-messages&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/join&quot;&gt;&lt;/discord-command&gt;
		Joined &lt;discord-mention type=&quot;voice&quot;&gt;Music&lt;/discord-mention&gt;!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/play&quot;&gt;&lt;/discord-command&gt;
		Now playing &lt;a target=&quot;_blank&quot; class=&quot;discord-link external&quot; href=&quot;https://youtu.be/38-cJT320aw&quot;&gt;https://youtu.be/38-cJT320aw&lt;/a&gt;!
		&lt;discord-embed
			slot=&quot;embeds&quot;
			provider=&quot;YouTube&quot;
            provider-url=&quot;https://www.youtube.com&quot;
			author-name=&quot;Raon&quot;
			author-url=&quot;https://www.youtube.com/channel/UCQn1FqrR2OCjSe6Nl4GlVHw&quot;
			color=&quot;#FF0000&quot;
			embed-title=&quot;Raon 라온 | ‘クネクネ (Wiggle Wiggle)’ M/V&quot;
			video=&quot;38-cJT320aw&quot;
			url=&quot;https://www.youtube.com/watch?v=38-cJT320aw&quot;
			image=&quot;https://cdn.aitsys.dev/file/data/kcrwt6baxsmr32rjnrdg/PHID-FILE-2w72lbyg6lrbstqo3geh/38-cJT320aw.jpg&quot;
		&gt;&lt;/discord-embed&gt;
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/pause&quot;&gt;&lt;/discord-command&gt;
		Playback paused!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/resume&quot;&gt;&lt;/discord-command&gt;
		Playback resumed!
	&lt;/discord-message&gt;
	&lt;discord-message profile=&quot;dcs&quot;&gt;
		&lt;discord-command slot=&quot;reply&quot; profile=&quot;user&quot; command=&quot;/leave&quot;&gt;&lt;/discord-command&gt;
		Left &lt;discord-mention type=&quot;voice&quot;&gt;Music&lt;/discord-mention&gt;!
	&lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/configuration.md">---
uid: modules_audio_lavalink_v4_configuration
title: Lavalink V4 Configuration
author: DisCatSharp Team
---

# Setting up DisCatSharp.Lavalink

## Configuring Your Client

To begin using DisCatSharp&apos;s Lavalink client, you will need to add the `DisCatSharp.Lavalink` nuget package. Once installed, simply add these namespaces at the top of your bot file:
```cs
using DisCatSharp.Net;
using DisCatSharp.Lavalink;
```

After that, we will need to create a configuration for our extension to use. This is where the special values from the server configuration are used.
```cs
var endpoint = new ConnectionEndpoint
{
    Hostname = &quot;127.0.0.1&quot;, // From your server configuration.
    Port = 2333 // From your server configuration
};

var lavalinkConfig = new LavalinkConfiguration
{
    Password = &quot;youshallnotpass&quot;, // From your server configuration.
    RestEndpoint = endpoint,
    SocketEndpoint = endpoint
};
```
Finally, initialize the extension.
```cs
var lavalink = Discord.UseLavalink();
```

## Connecting with Lavalink

We are now ready to connect to the server. Call the Lavalink extension&apos;s connect method and pass the configuration. Make sure to call this **after** your Discord client connects. This can be called either directly after your client&apos;s connect method or in your client&apos;s ready event.

```cs
LavalinkNode = await Lavalink.ConnectAsync(lavalinkConfig);
```

Your main bot file should now look like this:

```cs
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using DisCatSharp;
using DisCatSharp.Net;
using DisCatSharp.Lavalink;
namespace FirstLavalinkBot;

public class Program
{
	public static DiscordClient Discord { get; internal set; }

	public static void Main(string[] args = null)
	{
		MainAsync(args).ConfigureAwait(false).GetAwaiter().GetResult();
	}

	public static async Task MainAsync(string[] args)
	{
		Discord = new DiscordClient(new DiscordConfiguration
		{
			Token = &quot;&lt;token_here&gt;&quot;,
			TokenType = TokenType.Bot,
			MinimumLogLevel = LogLevel.Debug
		});

		var endpoint = new ConnectionEndpoint
		{
			Hostname = &quot;127.0.0.1&quot;, // From your server configuration.
			Port = 2333 // From your server configuration
		};

		var lavalinkConfig = new LavalinkConfiguration
		{
			Password = &quot;youshallnotpass&quot;, // From your server configuration.
			RestEndpoint = endpoint,
			SocketEndpoint = endpoint
		};

		var lavalink = Discord.UseLavalink();

		await Discord.ConnectAsync();
		await lavalink.ConnectAsync(lavalinkConfig); // Make sure this is after Discord.ConnectAsync().

		await Task.Delay(-1);
	}
}
```
We are now ready to start the bot. If everything is configured properly, you should see a Lavalink connection appear in your DisCatSharp console:

```yml
[2020-10-10 17:56:07 -04:00] [403 /LavalinkSessionConnected] [Debug] Connection to Lavalink established UwU
```

And a client connection appear in your Lavalink console:

```yml
INFO 4436 --- [  XNIO-1 task-1] io.undertow.servlet                      : Initializing Spring DispatcherServlet &apos;dispatcherServlet&apos;
INFO 4436 --- [  XNIO-1 task-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &apos;dispatcherServlet&apos;
INFO 4436 --- [  XNIO-1 task-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.RequestLoggingFilter  : GET /version?trace=false, client=127.0.0.1
INFO 4436 --- [  XNIO-1 task-1] l.server.io.HandshakeInterceptorImpl     : Incoming connection from /127.0.0.1:54649
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.RequestLoggingFilter  : GET /v4/websocket, client=127.0.0.1
INFO 4436 --- [  XNIO-1 task-1] lavalink.server.io.SocketServer          : Connection successfully established from DisCatSharp.Lavalink/10.6.6+38c8062e7f88b2e9920a535637d4f3afccbbf205
```

We are now ready to set up some music commands!</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/docker.md">---
uid: modules_audio_lavalink_v4_docker
title: Lavalink V4 Docker
author: DisCatSharp Team
---

# Template for running Lavalink in Docker

- Create a folder where you&apos;d save the lavalink config and plugins. I.e. `mkdir /opt/lavalink`.
- Follow the [Setup](xref:modules_audio_lavalink_v4_setup) instructions to create your `application.yml`. Make sure to set `0.0.0.0` as `address`.
- Save the `application.yml` in the created folder.
- Create a `docker-compose.yml` file like this and save it in the created folder:
```yml
services:
  lavalink:
    image: ghcr.io/lavalink-devs/lavalink:latest
    container_name: lavalink
    restart: unless-stopped
    environment:
      - _JAVA_OPTIONS=-Xmx6G
      - SERVER_PORT=2333
    volumes:
      - ./application.yml:/opt/Lavalink/application.yml
      - ./plugins/:/opt/Lavalink/plugins/
    networks:
      - lavalink
    expose:
      - 2333
    ports:
      - &quot;2333:2333&quot;
    extra_hosts:
      - &quot;host.docker.internal:host-gateway&quot;
networks:
  lavalink:
    name: lavalink
```
- Create a folder called `plugins` in the created folder.
- Run `docker compose up -d` to start lavalink</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/intro.md">---
uid: modules_audio_lavalink_v4_intro
title: Lavalink V4 Introduction
author: DisCatSharp Team
---

# Lavalink V4

Calling all Discord bot maestros and audio enthusiasts! Get ready to unleash the true power of music in your DisCatSharp-powered bots with our lively and feature-packed C# client library for Lavalink – the ultimate DJ for Discord.

Picture this: seamless audio streaming, mind-blowing playlists, and custom audio sources at your fingertips, all thanks to our vibrant C# client library. We&apos;ve carefully crafted this gem to harmonize perfectly with DisCatSharp, elevating your bot&apos;s audio playback game to legendary status!

Lavalink, the rockstar audio player library, takes center stage as it effortlessly syncs with the Discord API ecosystem. And with our C# client library in your arsenal, you become the conductor, orchestrating an unforgettable audio experience for your bot users.

Tune into your favorite audio sources like YouTube, SoundCloud, and more, letting Lavalink&apos;s magic bring those beats to life. Whether it&apos;s a catchy track, a curated playlist, or even a unique custom audio source, our C# client library knows just how to keep the party going.

But that&apos;s not all! With our library, you&apos;ll have full control over the volume knobs, precise track seeking, and an intuitive queue management system. Your bot will groove to your commands as you fine-tune the audio experience, ensuring your users get the perfect vibe every time.

So, bot maestros, join the audio revolution! Integrate our C# client library seamlessly into DisCatSharp and let the music take over. Elevate your Discord bot to superstar status, delivering an audio experience that will make your users want to dance the night away.

Get ready to rock and roll with our playful C# client library for Lavalink and DisCatSharp – because every bot deserves to be the life of the party!</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/queue.md">---
uid: modules_audio_lavalink_v4_queue_system
title: Lavalink V4 Queue System
author: DisCatSharp Team
---

# Lavalink Guild Player Queue System

The Lavalink module provides a built-in queue system for managing audio tracks. The queue system allows you to add, remove, and manipulate tracks in a guild-specific queue.

## Enabling the Queue System
The queue system is disabled by default, To use the queue system, you must enable it in your [`LavalinkConfiguration`](xref:DisCatSharp.Lavalink.LavalinkConfiguration):

```cs
var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true
};
```
## Basic Queue Operations
### Adding Tracks
You can add individual tracks or entire playlists to the queue:

```cs
// Add a single track
guildPlayer.AddToQueue(track);

// Add all tracks from a playlist
    var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);
var playlist = loadResult.GetResultAs&lt;LavalinkPlaylist&gt;()
guildPlayer.AddToQueue(playlist);
```

### Playing the Queue
To start playing tracks from the queue:
```cs
guildPlayer.PlayQueue();
```

The finished commands should look like so:
```cs
[SlashCommand(&quot;play&quot;, &quot;Play a track&quot;)]
public async Task PlayAsync(InteractionContext ctx, [Option(&quot;query&quot;, &quot;The query to search for&quot;)] string query)
{
    await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);
    if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;You are not in a voice channel.&quot;));
        return;
    }

    var lavalink = ctx.Client.GetLavalink();
    var guildPlayer = lavalink.GetGuildPlayer(ctx.Guild);

    if (guildPlayer == null)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Lavalink is not connected.&quot;));
        return;
    }

    var loadResult = await guildPlayer.LoadTracksAsync(LavalinkSearchType.Youtube, query);

    if (loadResult.LoadType == LavalinkLoadResultType.Empty || loadResult.LoadType == LavalinkLoadResultType.Error)
    {
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track search failed for {query}.&quot;));
        return;
    }

    LavalinkTrack track = loadResult.LoadType switch
    {
        LavalinkLoadResultType.Track =&gt; loadResult.GetResultAs&lt;LavalinkTrack&gt;(),
        LavalinkLoadResultType.Playlist =&gt; loadResult.GetResultAs&lt;LavalinkPlaylist&gt;().Tracks.First(),
        LavalinkLoadResultType.Search =&gt; loadResult.GetResultAs&lt;List&lt;LavalinkTrack&gt;&gt;().First(),
        _ =&gt; throw new InvalidOperationException(&quot;Unexpected load result type.&quot;)
    };

    if (guildPlayer.CurrentTrack == null)
    {
        guildPlayer.AddToQueue(track);
        guildPlayer.PlayQueue();
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Now playing {query}!&quot;));
    }
    else
    {
        guildPlayer.AddToQueue(track);
        await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;Track added to queue {track.Info.Title}!&quot;));
    }
}
```
### Skipping the Current Track
To skip the currently playing track, you can use the [`SkipAsync`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.SkipAsync*) method of the [`LavalinkGuildPlayer`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) class. This method will skip the current track. If the queue system is enabled and there are more tracks in the queue, the next track will automatically start playing.
```cs
await guildPlayer.SkipAsync();
```

### Managing the Queue

The queue system provides several other methods for managing tracks:
```cs
// See list queue
guildPlayer.Queue;

// Remove a specific track
guildPlayer.RemoveQueue(track);

// Remove a track by its title/identifier
guildPlayer.RemoveQueue(&quot;song title&quot;);

// Clear all tracks from the queue
guildPlayer.ClearQueue();

// Shuffle the queue
guildPlayer.ShuffleQueue();

// Reverse the queue order
guildPlayer.ReverseQueue();

...
```
## Queue Entry Pipeline
The Lavalink queue system includes a powerful pipeline system that allows you to execute custom actions before and after track playback. This is implemented through the [`IQueueEntry`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry) interface.
### Queue Entry Lifecycle
Each track in the queue goes through the following pipeline stages:
1. **Before Playing**: Called right before a track starts playing
2. **Track Playback**: The actual track playback
3. **After Playing**: Called after track playback completes

### Creating Custom Queue Entries
To create a custom queue entry, implement the [`IQueueEntry`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry) interface:

```cs
public class CustomQueueEntry : IQueueEntry
{
    public LavalinkTrack Track { get; set; }

    public async Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
    {
        // Execute code before the track plays
        // Return false to skip this track
        return true;
    }

    public async Task AfterPlayingAsync(LavalinkGuildPlayer player)
    {
        // Execute code after the track finishes playing
    }
}
```

### Configuring Custom Queue Entries
To use custom queue entries, configure them in your [`LavalinkConfiguration`](xref:DisCatSharp.Lavalink.LavalinkConfiguration):
```cs
var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true,
    QueueEntryFactory = () =&gt; new CustomQueueEntry()
};
```
or
```cs
 services.AddTransient&lt;IQueueEntry, CustomQueueEntry&gt;();

var config = new LavalinkConfiguration
{
    EnableBuiltInQueueSystem = true,
    QueueEntryFactory = () =&gt; scope.ServiceProvider.GetRequiredService&lt;IQueueEntry&gt;
};
```
In case you use dependency injection in `CustomQueueEntry`

### Pipeline Flow Control
- The [`BeforePlayingAsync`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry.BeforePlayingAsync*) method can control whether a track should be played by returning `true` or `false`
- The [`AfterPlayingAsync`](xref:DisCatSharp.Lavalink.Entities.IQueueEntry.AfterPlayingAsync*) method is called after the track finishes, allowing for cleanup or next-track preparation
- Both methods have access to the [`LavalinkGuildPlayer`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer) instance for advanced control

Example usage of flow control:
```cs
public async Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
{
    if (/* some condition */)
    {
        // Skip this track
        return false;
    }

    // Play this track
    await player.Channel.SendMessageAsync($&quot;Track Started: {Track.Info.Title}&quot;);
    return true;
}
```</file><file path="DisCatSharp.Docs/articles/modules/audio/lavalink_v4/setup.md">---
uid: modules_audio_lavalink_v4_setup
title: Lavalink V4 Setup
author: DisCatSharp Team
---

# Lavalink Setup

## Configuring Java

In order to run Lavalink, you must have Java 17 or greater installed. For more details check the [requirements](https://github.com/lavalink-devs/Lavalink/tree/master?tab=readme-ov-file#requirements) before downloading.
The latest v17 releases can be found [here](https://www.oracle.com/java/technologies/downloads/#java17).

Make sure the location of the newest JRE&apos;s bin folder is added to your system variable&apos;s path. This will make the `java` command run from the latest runtime. You can verify that you have the right version by entering `java -version` in your command prompt or terminal.

## Downloading Lavalink

Download the Lavalink V4 server from the [GitHub](https://github.com/lavalink-devs/Lavalink/releases).

To use the Lavalink server, you need to configure it first.

Create a new YAML file called `application.yml`, and use the [example file](https://github.com/lavalink-devs/Lavalink/blob/dev/LavalinkServer/application.yml.example), or copy this snippet:

&gt;[!NOTE]
&gt; For YouTube Support, see the sections `plugins -&gt; youtube` and `lavalink -&gt; plugins` in the config.

```yaml
server:
  port: 2333
  address: 127.0.0.1 # Set it to 0.0.0.0 if you run it in docker or if you want to share it
  http2:
    enabled: false # Personally we don&apos;t see any reason currently to enable it
plugins:
  youtube: # To read more about it&apos;s configuration visit https://github.com/lavalink-devs/youtube-source#plugin
    enabled: true
    allowSearch: true
    allowDirectVideoIds: true
    allowDirectPlaylistIds: true
    clients: # We suggest using it like this, since it switches through the clients to get streams and search running
      - M_WEB
      - WEB
      - MUSIC
      - WEBEMBEDDED
      - ANDROID_VR
      - TV
      - TVHTML5EMBEDDED
    oauth: # Read https://github.com/lavalink-devs/youtube-source?tab=readme-ov-file#using-oauth-tokens for more information
      enabled: true
      skipInitialization: false # Set to true if you got your refresh token
      # refreshToken: &quot;&quot; # Fill out after u got the refresh token
    pot: # Read https://github.com/lavalink-devs/youtube-source?tab=readme-ov-file#using-a-potoken for more information or use this one
      token: &quot;CgtLYnJKeDl1N0pJMCjW2cO8BjIKCgJERRIEEgAgKg==&quot;
      visitorData: &quot;MnRuJyEtJOv8LW4fImJbwY4qXcflEPdSWXwKWnQappnJt4Ee_3bFCJEUmiePXV3jvyjxMuT8pE3j-ZKoLtF-bIjo7-erKATkj38QRYgrGRsEHDC97Qk9a-tcYdXpmMQt2h6A1S325QgSsRfbfjBfBTeDq_oZBA==&quot;
  lavasrc: # To read more about it&apos;s configuration visit https://github.com/topi314/LavaSrc?tab=readme-ov-file
    providers:
      - &quot;ytsearch:\&quot;%ISRC%\&quot;&quot;
      - &quot;ytsearch:%QUERY%&quot;
      - &quot;scsearch:%QUERY%&quot;
      - &quot;spsearch:%QUERY%&quot;
      - &quot;sprec:%QUERY%&quot;
      - &quot;ymsearch:%QUERY%&quot;
      #- &quot;amsearch:%QUERY%&quot;
      #- &quot;dzisrc:%ISRC%&quot;
      #- &quot;dzsearch:%QUERY%&quot;
      - &quot;ymsearch:%QUERY%&quot;
    sources:
      spotify: true
      applemusic: false
      deezer: false
      yandexmusic: true
      flowerytts: true
      vkmusic: false
      youtube: true
    lyrics-sources:
      spotify: true
      deezer: false
      youtube: true
      yandexmusic: true
      vkmusic: false
    spotify:
        clientId: &quot;&quot; # Aquire it by visiting https://developer.spotify.com/dashboard/create
        clientSecret: &quot;&quot; # Aquire it by visiting https://developer.spotify.com/dashboard/create
        spDc: &quot;&quot; # Needed for lyrics, if used. Read https://github.com/topi314/LavaSrc?tab=readme-ov-file#spotify for more details.
        playlistLoadLimit: 6
        albumLoadLimit: 6
        resolveArtistsInSearch: false
        localFiles: true
    yandexmusic:
      accessToken: &quot;&quot; # Aquire it by visiting https://oauth.yandex.ru/authorize?response_type=token&amp;client_id=23cabbbdc6cd418abb4b39c32c41195d
      playlistLoadLimit: 1
      albumLoadLimit: 1
      artistLoadLimit: 1
    flowerytts:
      voice: &quot;default voice&quot;
      translate: false
      silence: 0
      speed: 1.0
      audioFormat: &quot;mp3&quot;
  lavalyrics: # To read more about it&apos;s configuration visit https://github.com/topi314/LavaLyrics?tab=readme-ov-file#lavalink-usage
    sources:
      - spotify
      - youtube
      #- deezer
      - yandexMusic
lavalink:
  plugins: # You can find more plugins on Lavalinks official site at https://lavalink.dev/plugins
    - dependency: &quot;dev.lavalink.youtube:youtube-plugin:1.11.4&quot; # Source: https://github.com/lavalink-devs/youtube-source
      snapshot: false
    - dependency: &quot;com.github.topi314.lavasearch:lavasearch-plugin:1.0.0&quot; # Source: https://github.com/topi314/LavaSearch
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
    - dependency: &quot;com.github.topi314.lavasrc:lavasrc-plugin:4.4.1&quot; # Source: https://github.com/topi314/LavaSrc
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
    - dependency: &quot;com.github.topi314.lavalyrics:lavalyrics-plugin&quot; # Source: https://github.com/topi314/LavaLyrics
      repository: &quot;https://maven.lavalink.dev/releases&quot;
      snapshot: false
  server:
    password: &quot;youshallnotpassMEOW&quot; # Set your lavalink password
    sources:
      youtube: false # Disabled youtube because it&apos;s not maintained anymore and got replaced by youtube-plugin
      bandcamp: true
      soundcloud: true
      twitch: true
      vimeo: true
      http: true
      local: true
      nico: true
    filters:
      volume: true
      equalizer: true
      karaoke: true
      timescale: true
      tremolo: true
      vibrato: true
      distortion: true
      rotation: true
      channelMix: true
      lowPass: true
    bufferDurationMs: 400
    frameBufferDurationMs: 5000
    opusEncodingQuality: 10
    resamplingQuality: MEDIUM
    trackStuckThresholdMs: 10000
    useSeekGhosting: true
    youtubePlaylistLoadLimit: 6
    playerUpdateInterval: 5
    youtubeSearchEnabled: true
    soundcloudSearchEnabled: true
    gc-warnings: true

metrics:
  prometheus:
    enabled: false
    endpoint: /metrics

sentry:
  dsn: &quot;&quot;
  environment: &quot;dev&quot;
logging:
  file:
    path: ./logs/

  level:
    root: INFO
    lavalink: INFO
    dev.lavalink.youtube.http.YoutubeOauth2Handler: INFO

  request:
    enabled: true
    includeClientInfo: true
    includeHeaders: false
    includeQueryString: true
    includePayload: true
    maxPayloadLength: 10000


  logback:
    rollingpolicy:
      max-file-size: 1GB
      max-history: 30
```
YAML is whitespace-sensitive. Make sure you are using a text editor which properly handles this.


There are a few values to keep in mind.

The `host` is the IP of the Lavalink host. This will be `0.0.0.0` by default, but it should be changed as it is a security risk. For this guide, set this to `127.0.0.1` as we will be running Lavalink locally.

`port` is the allowed port for the Lavalink connection. `2333` is the default port, and is what will be used for this guide.

The `password` is the password that you will need to specify when connecting. This can be anything as long as it is a valid YAML string. Keep it as `youshallnotpass` for this guide.

When you are finished configuring this, save the file in the same directory as your Lavalink executable.

Keep note of your `port`, `address`, and `password` values, as you will need them later for connecting.

## Starting Lavalink

Open your command prompt or terminal and navigate to the directory containing Lavalink.

Once there, type `java -jar Lavalink.jar`. You should start seeing log output from Lavalink.

If everything is configured properly, you should see this appear somewhere in the log output without any errors:
```yml
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Starting Launcher v4.0.8 using Java 18.0.2.1 with PID 1 (/opt/Lavalink/Lavalink.jar started by lavalink in /opt/Lavalink)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : No active profile set, falling back to 1 default profile: &quot;default&quot;
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;lavasearch-plugin&apos; version 1.0.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;lavasrc-plugin&apos; version 4.3.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;sponsorblock-plugin&apos; version 3.0.0
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Found plugin &apos;youtube-plugin&apos; version 1.11.3
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded lavasearch-plugin-1.0.0.jar (20 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded lavasrc-plugin-4.3.0.jar (168 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded sponsorblock-plugin-3.0.0.jar (90 classes)
INFO 1 --- [Lavalink] [           main] l.server.bootstrap.PluginManager         : Loaded youtube-plugin-1.11.3.jar (16 classes)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Started Launcher in 2.194 seconds (process running for 2.752)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 :

       .   _                  _ _       _    __ _ _
      /\\ | | __ ___   ____ _| (_)_ __ | | __\ \ \ \
     ( ( )| |/ _` \ \ / / _` | | | &apos;_ \| |/ / \ \ \ \
      \\/ | | (_| |\ V / (_| | | | | | |   &lt;   ) ) ) )
       &apos;  |_|\__,_| \_/ \__,_|_|_|_| |_|_|\_\ / / / /
    =========================================/_/_/_/

        Version:        4.0.8
        Build time:     20.09.2024 20:20:10 UTC
        Branch          HEAD
        Commit:         2946608
        Commit time:    20.09.2024 20:17:58 UTC
        JVM:            18.0.2.1
        Lavaplayer      2.2.2

INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : No active profile set, falling back to 1 default profile: &quot;default&quot;
WARN 1 --- [Lavalink] [           main] io.undertow.websockets.jsr               : UT026010: Buffer pool was not set on WebSocketDeploymentInfo, the default pool will be used
INFO 1 --- [Lavalink] [           main] io.undertow.servlet                      : Initializing Spring embedded WebApplicationContext
INFO 1 --- [Lavalink] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 712 ms
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Loading LavaSrc plugin...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Youtube Source audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Spotify search manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Youtube search manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Yandex Music search manager...
INFO 1 --- [Lavalink] [           main] c.s.d.l.tools.GarbageCollectionMonitor   : GC monitoring enabled, reporting results every 2 minutes.
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Spotify audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Yandex Music audio source manager...
INFO 1 --- [Lavalink] [           main] c.g.t.lavasrc.plugin.LavaSrcPlugin       : Registering Flowery TTS audio source manager...
WARN 1 --- [Lavalink] [           main] d.l.youtube.plugin.ClientProvider        : Failed to resolve M_WEB into a Client
INFO 1 --- [Lavalink] [           main] d.l.youtube.plugin.YoutubePluginLoader   : YouTube source initialised with clients: WEB, WEB_REMIX, WEB_EMBEDDED_PLAYER, ANDROID_VR, TVHTML5, TVHTML5_SIMPLY_EMBEDDED_PLAYER
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : OAUTH INTEGRATION: To give youtube-source access to your account, go to https://www.google.com/device and enter code &lt;redacted&gt;
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] Picked up _JAVA_OPTIONS: -Xmx6G
INFO 1 --- [Lavalink] [           main] c.g.t.s.plugin.SponsorBlockPlugin        : Loading SponsorBlock Plugin...
INFO 1 --- [Lavalink] [           main] l.server.config.KoeConfiguration         : OS: LINUX, Arch: X86_64
INFO 1 --- [Lavalink] [           main] l.server.config.KoeConfiguration         : Enabling JDA-NAS
INFO 1 --- [Lavalink] [           main] c.s.l.c.natives.NativeLibraryLoader      : Native library udpqueue: loading with filter null
INFO 1 --- [Lavalink] [           main] c.s.l.c.natives.NativeLibraryLoader      : Native library udpqueue: successfully loaded.
WARN 1 --- [Lavalink] [           main] l.server.config.SentryConfiguration      : Turning off sentry
INFO 1 --- [Lavalink] [           main] io.undertow                              : starting server: Undertow - 2.3.13.Final
INFO 1 --- [Lavalink] [           main] org.xnio                                 : XNIO version 3.8.8.Final
INFO 1 --- [Lavalink] [           main] org.xnio.nio                             : XNIO NIO Implementation Version 3.8.8.Final
INFO 1 --- [Lavalink] [           main] org.jboss.threads                        : JBoss Threads version 3.5.0.Final
INFO 1 --- [Lavalink] [           main] o.s.b.w.e.undertow.UndertowWebServer     : Undertow started on port 2333 (http) with context path &apos;/&apos;
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Started Launcher in 3.43 seconds (process running for 6.19)
INFO 1 --- [Lavalink] [           main] lavalink.server.Launcher                 : Lavalink is ready to accept connections.
```

If it does, congratulations. We are now ready to interact with it using DisCatSharp.

## YouTube OAuth Token

If you configured OAuth correctly, you should see the following in your logs:
```yml
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : OAUTH INTEGRATION: To give youtube-source access to your account, go to https://www.google.com/device and enter code XXX-XXX-XXX
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : !!! DO NOT AUTHORISE WITH YOUR MAIN ACCOUNT, USE A BURNER !!!
INFO 1 --- [Lavalink] [           main] d.l.youtube.http.YoutubeOauth2Handler    : ==================================================
```</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/prerequisites.md">---
uid: modules_audio_voicenext_prerequisites
title: VoiceNext Prerequisites
---

# VoiceNext Prerequisites

&gt; [!NOTE]
&gt; We highly suggest using the [DisCatSharp.Lavalink](xref:modules_audio_lavalink_v4_intro) package for audio playback. It is much easier to use and has a lot of features that VoiceNext does not have.

## Required Libraries

VoiceNext depends on the [libsodium](https://github.com/jedisct1/libsodium) and [Opus](https://opus-codec.org/) libraries to decrypt and process audio packets.&lt;br/&gt;
Both _must_ be available on your development and host machines otherwise VoiceNext will _not_ work.

### Windows

When installing VoiceNext though NuGet, an additional package containing the native Windows binaries will automatically be included with **no additional steps required**.

However, if you are using DisCatSharp from source or without a NuGet package manager, you must manually [download](xref:natives) the binaries and place them at the root of your working directory where your application is located.

If the package doesn&apos;t work, you might have to instruct msbuild to include it:

```xml
&lt;PackageReference Include=&quot;DisCatSharp.VoiceNext.Natives&quot; Version=&quot;10.6.0-nightly-001&quot;&gt;
	&lt;IncludeAssets&gt;runtime; native; contentfiles&lt;/IncludeAssets&gt;
&lt;/PackageReference&gt;
```


### MacOS

Native libraries for Apple&apos;s macOS can be installed using the [Homebrew](https://brew.sh) package manager:

```console
$ brew install opus libsodium
```

### Linux

#### Debian and Derivatives

Opus package naming is consistent across Debian, Ubuntu, and Linux Mint.

```bash
sudo apt-get install libopus0 libopus-dev
```

Package naming for _libsodium_ will vary depending on your distro and version:

|           Distributions            |                 Terminal Command                 |
| :--------------------------------: | :----------------------------------------------: |
|     Ubuntu 18.04+, Debian 10+      | `sudo apt-get install libsodium23 libsodium-dev` |
| Linux Mint, Ubuntu 16.04, Debian 9 | `sudo apt-get install libsodium18 libsodium-dev` |
|              Debian 8              | `sudo apt-get install libsodium13 libsodium-dev` |</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/receive.md">---
uid: modules_audio_voicenext_receive
title: Receiving
---

## Receiving with VoiceNext

### Enable Receiver

Receiving incoming audio is disabled by default to save on bandwidth, as most users will never make use of incoming data.
This can be changed by providing a configuration object to `DiscordClient#UseVoiceNext()`.

```cs
var discord = new DiscordClient();

discord.UseVoiceNext(new VoiceNextConfiguration()
{
    EnableIncoming = true
});
```

### Establish Connection

The voice channel join process is the exact same as when transmitting.

```cs
DiscordChannel channel;
VoiceNextConnection connection = await channel.ConnectAsync();
```

### Write Event Handler

We&apos;ll be able to receive incoming audio from the `VoiceReceived` event fired by `VoiceNextConnection`.

```cs
connection.VoiceReceived += ReceiveHandler;
```

Writing the logic for this event handler will depend on your overall goal.

The event arguments will contain a PCM audio packet for you to make use of.
You can convert each packet to another format, concatenate them all together, feed them into an external program, or process the packets any way that&apos;ll suit your needs.

When a user is speaking, `VoiceReceived` should fire once every twenty milliseconds and its packet will contain around twenty milliseconds worth of audio; this can vary due to differences in client settings.
To help keep track of the torrent of packets for each user, you can use user IDs in combination the synchronization value (SSRC) sent by Discord to determine the source of each packet.

This short-and-simple example will use [ffmpeg](https://ffmpeg.org/about.html) to convert each packet to a _wav_ file.

```cs
private async Task ReceiveHandler(VoiceNextConnection _, VoiceReceiveEventArgs args)
{
    var name = DateTimeOffset.Now.ToUnixTimeMilliseconds();
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 {name}.wav&quot;,
        RedirectStandardInput = true
    });

    await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData);
}
```

&lt;br/&gt;
That&apos;s really all there is to it. Connect to a voice channel, hook an event, process the data as you see fit.

![Wav Files](/images/voicenext_receive_01.png)

## Example Commands

```cs
[Command(&quot;start&quot;)]
public async Task StartCommand(CommandContext ctx, DiscordChannel channel = null)
{
    channel ??= ctx.Member.VoiceState?.Channel;
    var connection = await channel.ConnectAsync();

    Directory.CreateDirectory(&quot;Output&quot;);
    connection.VoiceReceived += VoiceReceiveHandler;
}


[Command(&quot;stop&quot;)]
public Task StopCommand(CommandContext ctx)
{
    var vnext = ctx.Client.GetVoiceNext();

    var connection = vnext.GetConnection(ctx.Guild);
    connection.VoiceReceived -= VoiceReceiveHandler;
    connection.Dispose();

    return Task.CompletedTask;
}

private async Task VoiceReceiveHandler(VoiceNextConnection connection, VoiceReceiveEventArgs args)
{
    var fileName = DateTimeOffset.Now.ToUnixTimeMilliseconds();
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 Output/{fileName}.wav&quot;,
        RedirectStandardInput = true
    });

    await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData);
    ffmpeg.Dispose();
}
```</file><file path="DisCatSharp.Docs/articles/modules/audio/voicenext/transmit.md">---
uid: modules_audio_voicenext_transmit
title: Transmitting
---

## Transmitting with VoiceNext

### Enable VoiceNext
Install the `DisCatSharp.VoiceNext` package from NuGet.

![NuGet Package Manager](/images/voicenext_transmit_01.png)

Then use the `UseVoiceNext` extension method on your instance of `DiscordClient`.
```cs
var discord = new DiscordClient();
discord.UseVoiceNext();
```

### Connect
Joining a voice channel is *very* easy; simply use the `ConnectAsync` extension method on `DiscordChannel`.
```cs
DiscordChannel channel;
VoiceNextConnection connection = await channel.ConnectAsync();
```

### Transmit
Discord requires that we send Opus encoded stereo PCM audio data at a sample rate of 48,000 Hz.

You&apos;ll need to convert your audio source to PCM S16LE using your preferred program for media conversion, then read
that data into a `Stream` object or an array of `byte` to be used with VoiceNext. Opus encoding of the PCM data will
be done automatically by VoiceNext before sending it to Discord.

This example will use [ffmpeg](https://ffmpeg.org/about.html) to convert an MP3 file to a PCM stream.
```cs
var filePath = &quot;funiculi_funicula.mp3&quot;;
var ffmpeg = Process.Start(new ProcessStartInfo
{
    FileName = &quot;ffmpeg&quot;,
    Arguments = $@&quot;-i &quot;&quot;{filePath}&quot;&quot; -ac 2 -f s16le -ar 48000 pipe:1&quot;,
    RedirectStandardOutput = true,
    UseShellExecute = false
});

Stream pcm = ffmpeg.StandardOutput.BaseStream;
```

Now that our audio is the correct format, we&apos;ll need to get a *transmit sink* for the channel we&apos;re connected to.
You can think of the transmit stream as our direct interface with a voice channel; any data written to one will be
processed by VoiceNext, queued, and sent to Discord which will then be output to the connected voice channel.
```cs
VoiceTransmitSink transmit = connection.GetTransmitSink();
```

Once we have a transmit sink, we can &apos;play&apos; our audio by copying our PCM data to the transmit sink buffer.
```cs
await pcm.CopyToAsync(transmit);
```
`Stream#CopyToAsync()` will copy PCM data from the input stream to the output sink, up to the sink&apos;s configured
capacity, at which point it will wait until it can copy more. This means that the call will hold the task&apos;s execution,
until such time that the entire input stream has been consumed, and enqueued in the sink.

This operation cannot be cancelled. If you&apos;d like to have finer control of the playback, you should instead consider
using `Stream#ReadAsync()` and `VoiceTransmitSink#WriteAsync()` to manually copy small portions of PCM data to the
transmit sink.

### Disconnect
Similar to joining, leaving a voice channel is rather straightforward.
```cs
var vnext = discord.GetVoiceNext();
var connection = vnext.GetConnection();

connection.Disconnect();
```

## Example Commands
```cs
[Command(&quot;join&quot;)]
public async Task JoinCommand(CommandContext ctx, DiscordChannel channel = null)
{
    channel ??= ctx.Member.VoiceState?.Channel;
    await channel.ConnectAsync();
}

[Command(&quot;play&quot;)]
public async Task PlayCommand(CommandContext ctx, string path)
{
    var vnext = ctx.Client.GetVoiceNext();
    var connection = vnext.GetConnection(ctx.Guild);

    var transmit = connection.GetTransmitSink();

    var pcm = ConvertAudioToPcm(path);
    await pcm.CopyToAsync(transmit);
    await pcm.DisposeAsync();
}

[Command(&quot;leave&quot;)]
public async Task LeaveCommand(CommandContext ctx)
{
    var vnext = ctx.Client.GetVoiceNext();
    var connection = vnext.GetConnection(ctx.Guild);

    connection.Disconnect();
}

private Stream ConvertAudioToPcm(string filePath)
{
    var ffmpeg = Process.Start(new ProcessStartInfo
    {
        FileName = &quot;ffmpeg&quot;,
        Arguments = $@&quot;-i &quot;&quot;{filePath}&quot;&quot; -ac 2 -f s16le -ar 48000 pipe:1&quot;,
        RedirectStandardOutput = true,
        UseShellExecute = false
    });

    return ffmpeg.StandardOutput.BaseStream;
}
```</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/command_attributes.md">---
uid: modules_commandsnext_command_attributes
title: Command Attributes
author: DisCatSharp Team
hasDiscordComponents: true
---

## Built-In Attributes

CommandsNext has a variety of built-in attributes to enhance your commands and provide some access control.
The majority of these attributes can be applied to your command methods and command groups.

-   @DisCatSharp.CommandsNext.Attributes.AliasesAttribute
-   @DisCatSharp.CommandsNext.Attributes.DescriptionAttribute
-   @DisCatSharp.CommandsNext.Attributes.DontInjectAttribute
-   @DisCatSharp.CommandsNext.Attributes.HiddenAttribute
-   @DisCatSharp.CommandsNext.Attributes.ModuleLifespanAttribute
-   @DisCatSharp.CommandsNext.Attributes.PriorityAttribute
-   @DisCatSharp.CommandsNext.Attributes.RemainingTextAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireBotPermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireCommunityAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireDirectMessageAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireGuildAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireGuildOwnerAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireMemberVerificationGateAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireNsfwAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireOwnerAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireOwnerOrIdAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequirePermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequirePrefixesAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireRolesAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireUserPermissionsAttribute
-   @DisCatSharp.CommandsNext.Attributes.RequireWelcomeScreenAttribute

## Custom Attributes

If the above attributes don&apos;t meet your needs, CommandsNext also gives you the option of writing your own!
Simply create a new class which inherits from `CheckBaseAttribute` and implement the required method.

Our example below will only allow a command to be ran during a specified year.

```cs
public class RequireYearAttribute : CheckBaseAttribute
{
    public int AllowedYear { get; private set; }

    public RequireYearAttribute(int year)
    {
        AllowedYear = year;
    }

    public override Task&lt;bool&gt; ExecuteCheckAsync(CommandContext ctx, bool help)
    {
        return Task.FromResult(AllowedYear == DateTime.Now.Year);
    }
}
```

You&apos;ll also need to apply the `AttributeUsage` attribute to your attribute.
For our example attribute, we&apos;ll set it to only be usable once on methods.

```cs
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class RequireYearAttribute : CheckBaseAttribute
{
    // ...
}
```

You can provide feedback to the user using the `CommandsNextExtension#CommandErrored` event.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();
	var commands = discord.UseCommandsNext();

	commands.CommandErrored += CmdErroredHandler;
}

private async Task CmdErroredHandler(CommandsNextExtension _, CommandErrorEventArgs e)
{
    var failedChecks = ((ChecksFailedException)e.Exception).FailedChecks;
    foreach (var failedCheck in failedChecks)
    {
        if (failedCheck is RequireYearAttribute)
        {
            var yearAttribute = (RequireYearAttribute)failedCheck;
            await e.Context.RespondAsync($&quot;Only usable during year {yearAttribute.AllowedYear}.&quot;);
        }
    }
}
```

Once you&apos;ve got all of that completed, you&apos;ll be able to use it on a command!

```cs
[Command(&quot;generic&quot;), RequireYear(2030)]
public async Task GenericCommand(CommandContext ctx, string generic)
{
    await ctx.RespondAsync(&quot;Generic response.&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !generic
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Only usable during the year 2030!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/cooldowns.md">---
uid: modules_commandsnext_cooldowns
title: Cooldowns
author: DisCatSharp Team
hasDiscordComponents: true
---

## Cooldown Attribute

You can apply cooldowns to your text commands with the @DisCatSharp.CommandsNext.Attributes.CooldownAttribute.

The cooldown attribute consists of three required parameters and one optional parameter.

-   `int maxUses` - The number of times a command can be used during the definied time before being put on cooldown.
-   `double resetAfter` - After how many seconds the cooldown resets.
-   `CooldownBucketType bucketType` - The [type](xref:DisCatSharp.Enums.Core.CooldownBucketType) of bucket to use. Can be combined.

## Usage

```cs
// We create a text command which sends a meow to the channel. This command can be executed twice every 40 seconds per channel.
[Command(&quot;meow&quot;), Description(&quot;Meow at chat&quot;), Cooldown(2, 40, CooldownBucketType.Channel)]
public async Task MeowAsync(CommandContext ctx)
{
    await context.RespondAsync(&quot;Meow!&quot;);
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot;&gt;
        !meow
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;false&quot; name=&quot;:x:&quot; emoji=&quot;https://cdn.aitsys.dev/file/data/z5xj4bzraybavtu72in7/PHID-FILE-3rkjxmtwinuysdnwumm7/d22e8c77c1aa9e5a69a2.png&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Customizing the cooldown hit response

You can customize the response that is sent when a user hits a cooldown by creating a custom class which inherits from [ICooldownResponder](xref:DisCatSharp.CommandsNext.Entities.ICooldownResponder).

```cs
public sealed class CooldownResponse : ICooldownResponder
{
    /// &lt;inheritdoc /&gt;
    public async Task Responder(BaseContext context)
    {
        await context.Message.CreateReactionAsync(DiscordEmoji.FromGuildEmote(context.Client, 972904417005293609));
        // or send a message
        // await context.Member.SendMessageAsync(&quot;You hit a cooldown! Try again later.&quot;);

    }
}
```

You can then apply this to your command by using the `cooldownResponderType` property on the attribute.

```cs
[Command(&quot;meow&quot;), Description(&quot;Meow at chat&quot;), Cooldown(2, 40, CooldownBucketType.Channel, typeof(CooldownResponse)))]
public async Task MeowAsync(CommandContext ctx)
{
    await context.RespondAsync(&quot;Meow!&quot;);
}
```

### Visual Example

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;dcs_owner&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !meow
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;!meow&lt;/discord-reply&gt;
        Meow!
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot;&gt;
        !meow
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;false&quot; name=&quot;:hasiscared:&quot; emoji=&quot;https://cdn.discordapp.com/emojis/972904417005293609.png&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/argument_converters.md">---
uid: modules_commandsnext_customization_argument_converters
title: Argument Converter
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Argument Converter

Writing your own argument converter will enable you to convert custom types and replace the functionality of existing converters.
Like many things in DisCatSharp, doing this is straightforward and simple.

First, create a new class which implements `IArgumentConverter&lt;T&gt;` and its method `ConvertAsync`.
Our example will be a boolean converter, so we&apos;ll also pass `bool` as the type parameter for `IArgumentConverter`.

```cs
public class CustomArgumentConverter : IArgumentConverter&lt;bool&gt;
{
    public Task&lt;Optional&lt;bool&gt;&gt; ConvertAsync(string value, CommandContext ctx)
    {
        if (bool.TryParse(value, out var boolean))
        {
            return Task.FromResult(Optional.Some&lt;bool&gt;(boolean));
        }

        switch (value.ToLower())
        {
            case &quot;yes&quot;:
            case &quot;y&quot;:
            case &quot;t&quot;:
                return Task.FromResult(Optional.Some&lt;bool&gt;(true));

            case &quot;no&quot;:
            case &quot;n&quot;:
            case &quot;f&quot;:
                return Task.FromResult(Optional.Some&lt;bool&gt;(false));

            default:
                return Task.FromResult(Optional.None);
        }
    }
}
```

Then register the argument converter with CommandContext.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.RegisterConverter(new CustomArgumentConverter());
```

Once the argument converter is written and registered, we&apos;ll be able to use it:

```cs
[Command(&quot;boolean&quot;)]
public async Task BooleanCommand(CommandContext ctx, bool boolean)
{
    await ctx.RespondAsync($&quot;Converted to {boolean} :3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !boolean yes
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Converted to True :3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/command_handler.md">---
uid: modules_commandsnext_customization_command_handler
title: Custom Command Handler
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Command Handler

&gt;[!IMPORTANT]
 &gt; Writing your own handler logic should only be done if *you know what you&apos;re doing*.
 &gt; You will be responsible for command execution and preventing deadlocks.

### Disable Default Handler

To begin, we&apos;ll need to disable the default command handler provided by CommandsNext.
This is done by setting the `UseDefaultCommandHandler` configuration property to `false`.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
{
    UseDefaultCommandHandler = false
});
```

### Create Event Handler

We&apos;ll then write a new handler for the `MessageCreated` event fired from `DiscordClient`.

```cs
discord.MessageCreated += CommandHandler;

// ...

private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e)
{
    // See below ...
}
```
This event handler will be our command handler, and you&apos;ll need to write the logic for it.

### Handle Commands

Start by parsing the message content for a prefix and command string

```cs
var cnext = client.GetCommandsNext();
var msg = e.Message;

// Check if message has valid prefix.
var cmdStart = msg.GetStringPrefixLength(&quot;!&quot;);
if (cmdStart == -1) return;

// Retrieve prefix.
var prefix = msg.Content.Substring(0, cmdStart);

// Retrieve full command string.
var cmdString = msg.Content.Substring(cmdStart);
```

Then provide the command string to `CommandsNextExtension#FindCommand`

```cs
var command = cnext.FindCommand(cmdString, out var args);
```

Create a command context using our message and prefix, along with the command and its arguments

```cs
var ctx = cnext.CreateContext(msg, prefix, command, args);
```

And pass the context to `CommandsNextExtension#ExecuteCommandAsync` to execute the command.

```cs
_ = Task.Run(async () =&gt; await cnext.ExecuteCommandAsync(ctx));
// Wrapped in Task.Run() to prevent deadlocks.
```


### Finished Product

Altogether, your implementation should function similarly to the following:

```cs
private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e)
{
    var cnext = client.GetCommandsNext();
    var msg = e.Message;

    var cmdStart = msg.GetStringPrefixLength(&quot;!&quot;);
    if (cmdStart == -1) return Task.CompletedTask;

    var prefix = msg.Content.Substring(0, cmdStart);
    var cmdString = msg.Content.Substring(cmdStart);

    var command = cnext.FindCommand(cmdString, out var args);
    if (command == null) return Task.CompletedTask;

    var ctx = cnext.CreateContext(msg, prefix, command, args);
    Task.Run(async () =&gt; await cnext.ExecuteCommandAsync(ctx));

    return Task.CompletedTask;
}
```</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/customization/help_formatter.md">---
uid: modules_commandsnext_customization_help_formatter
title: Help Formatter
author: DisCatSharp Team
hasDiscordComponents: true
---

## Custom Help Formatter

The built-in help command provided by CommandsNext is generated with a _help formatter_.
This simple mechanism is given a command and its subcommands then returns a formatted help message.
If you&apos;re not happy with the default help formatter, you&apos;re able to write your own and customize the output to your liking.

Simply inherit from `BaseHelpFormatter` and provide an implementation for each of the required methods.

```cs
public class CustomHelpFormatter : BaseHelpFormatter
{
	// protected DiscordEmbedBuilder _embed;
	// protected StringBuilder _strBuilder;

	public CustomHelpFormatter(CommandContext ctx) : base(ctx)
	{
		// _embed = new DiscordEmbedBuilder();
		// _strBuilder = new StringBuilder();

		// Help formatters do support dependency injection.
		// Any required services can be specified by declaring constructor parameters.

		// Other required initialization here ...
	}

	public override BaseHelpFormatter WithCommand(Command command)
	{
		// _embed.AddField(new DiscordEmbedField(command.Name, command.Description));
		// _strBuilder.AppendLine($&quot;{command.Name} - {command.Description}&quot;);

		return this;
	}

	public override BaseHelpFormatter WithSubcommands(IEnumerable&lt;Command&gt; cmds)
	{
		foreach (var cmd in cmds)
		{
			// _embed.AddField(new DiscordEmbedField(cmd.Name, cmd.Description));
			// _strBuilder.AppendLine($&quot;{cmd.Name} - {cmd.Description}&quot;);
		}

		return this;
	}

	public override CommandHelpMessage Build()
	{
		// return new CommandHelpMessage(embed: _embed);
		// return new CommandHelpMessage(content: _strBuilder.ToString());
	}
}
```

Alternatively, if you&apos;re only wanting to make a few small tweaks to the default help, you can write a simple help formatter which inherits from `DefaultHelpFormatter` and modify the inherited `EmbedBuilder` property.

```cs
public class CustomHelpFormatter : DefaultHelpFormatter
{
	public CustomHelpFormatter(CommandContext ctx) : base(ctx) { }

	public override CommandHelpMessage Build()
	{
		EmbedBuilder.Color = DiscordColor.SpringGreen;
		return base.Build();
	}
}
```

Your final step is to register your help formatter with CommandsNext.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.SetHelpFormatter&lt;CustomHelpFormatter&gt;();
```

That&apos;s all there is to it.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-embed slot=&quot;embeds&quot; color=&quot;#00FF7F&quot; embed-title=&quot;Commands&quot;&gt;
            &lt;discord-embed-description slot=&quot;description&quot;&gt;All available commands will be listed below.&lt;/discord-embed-description&gt;
            &lt;discord-embed-fields slot=&quot;fields&quot;&gt;
                &lt;discord-embed-field field-title=&quot;!help&quot;&gt;Sends you a list of all available commands, their usage and their description.&lt;/discord-embed-field&gt;
                &lt;discord-embed-field field-title=&quot;!whois [@User]&quot;&gt;Displays information the bot knows about you or the mentioned user.&lt;/discord-embed-field&gt;
                &lt;discord-embed-field field-title=&quot;!avatar [@User]&quot;&gt;Displays your or the mentioned user&apos;s avatar as an embedded image.&lt;/discord-embed-field&gt;
            &lt;/discord-embed-fields&gt;
        &lt;/discord-embed&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/dependency_injection.md">---
uid: modules_commandsnext_dependency_injection
title: Dependency Injection
author: DisCatSharp Team
hasDiscordComponents: true
---

## Dependency Injection
As you begin to write more complex commands, you&apos;ll find that you need a way to get data in and out of them.
Although you *could* use `static` fields to accomplish this, the preferred solution would be *dependency injection*.

This would involve placing all required object instances and types (referred to as *services*) in a container, then providing that container to CommandsNext.
Each time a command module is instantiated, CommandsNext will then attempt to populate constructor parameters, `public` properties, and `public` fields exposed by the module with instances of objects from the service container.


We&apos;ll go through a simple example of this process to help you understand better.

### Create a Service Provider
To begin, we&apos;ll need to create a service provider; this will act as the container for the services you need for your commands.
Create a new variable just before you register CommandsNext with your `DiscordClient` and assign it a new instance of `ServiceCollection`.
```cs
var discord = new DiscordClient();
var services = new ServiceCollection();	// Right here!
var commands = discord.UseCommandsNext();
```

We&apos;ll use `.AddSingleton` to add type `Random` to the collection, then chain that call with the `.BuildServiceProvider()` extension method.
The resulting type will be `ServiceProvider`.
```cs
var services = new ServiceCollection()
    .AddSingleton&lt;Random&gt;()
	.BuildServiceProvider();
```

Then we&apos;ll need to provide CommandsNext with our services.
```cs
var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
{
    Services = services
});
```

### Using Your Services
Now that we have our services set up, we&apos;re able to use them in commands.&lt;br/&gt;
We&apos;ll be tweaking our [random number command](xref:modules_commandsnext_intro#argument-converters) to demonstrate.

Add a new property to the command module named *Rng*. Make sure it has a `public` setter.
```cs
public class MyFirstModule : BaseCommandModule
{
    public Random Rng { private get; set; } // Implied public setter.

    // ...
}
```

Modify the *random* command to use our property.
```cs
[Command(&quot;random&quot;)]
public async Task RandomCommand(CommandContext ctx, int min, int max)
{
    await ctx.RespondAsync($&quot;Your number is: {Rng.Next(min, max)}&quot;);
}
```

Then we can give it a try!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !random 1 500
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Your number is: 420
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;br/&gt;
CommandsNext has automatically injected our singleton `Random` instance into the `Rng` property when our command module was instantiated.
Now, for any command that needs `Random`, we can simply declare one as a property, field, or in the module constructor and CommandsNext will take care of the rest.
Ain&apos;t that neat?


## Lifespans

### Modules
By default, all command modules have a singleton lifespan; this means each command module is instantiated once for the lifetime of the CommandsNext instance.
However, if the reuse of a module instance is undesired, you also have the option to change the lifespan of a module to *transient* using the `ModulesLifespan` attribute.
```cs
[ModuleLifespan(ModuleLifespan.Transient)]
public class MyFirstModule : BaseCommandModule
{
    // ...
}
```
Transient command modules are instantiated each time one of its containing commands is executed.


### Services
In addition to the `.AddSingleton()` extension method, you&apos;re also able to use the `.AddScoped()` and `.AddTransient()` extension methods to add services to the collection.
The extension method chosen will affect when and how often the service is instantiated.
Scoped and transient services should only be used in transient command modules, as singleton modules will always have their services injected once.

Lifespan|Instantiated
:---:|:---
Singleton|One time when added to the collection.
Scoped|Once for each command module.
Transient|Each time its requested.</file><file path="DisCatSharp.Docs/articles/modules/commandsnext/intro.md">---
uid: modules_commandsnext_intro
title: CommandsNext Introduction
author: DisCatSharp Team
hasDiscordComponents: true
---

&gt; [!NOTE]
&gt; This article assumes you&apos;ve recently read the article on _[writing your first bot](xref:getting_started_first_bot)_.

# Introduction to CommandsNext

This article will introduce you to some basic concepts of our native command framework: _CommandsNext_.&lt;br/&gt;
Be sure to install the `DisCatSharp.CommandsNext` package from NuGet before continuing.

![CommandsNext NuGet Package](/images/commands_intro_01.png)

## Writing a Basic Command

### Create a Command Module

A command module is simply a class which acts as a container for your command methods. Instead of registering individual commands,
you&apos;d register a single command module which contains multiple commands. There&apos;s no limit to the amount of modules you can have,
and no limit to the amount of commands each module can contain. For example: you could have a module for moderation commands and
a separate module for image commands. This will help you keep your commands organized and reduce the clutter in your project.

Our first demonstration will be simple, consisting of one command module with a simple command.&lt;br/&gt;
We&apos;ll start by creating a new folder named `Commands` which contains a new class named `MyFirstModule`.

![Solution Explorer](/images/commands_intro_02.png)

Give this new class `public` access and have it inherit from `BaseCommandModule`.

```cs
public class MyFirstModule : BaseCommandModule { }
```

### Create a Command Method

Within our new module, create a method named `GreetCommand` marked as `async` with a `Task` return type.
The first parameter of your method _must_ be of type `CommandContext`, as required by CommandsNext.

```cs
public async Task GreetCommand(CommandContext ctx) { }
```

In the body of our new method, we&apos;ll use `CommandContext#RespondAsync` to send a simple message.

```cs
await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
```

Finally, mark your command method with the `Command` attribute so CommandsNext will know to treat our method as a command method.
This attribute takes a single parameter: the name of the command.

We&apos;ll name our command _greet_ to match the name of the method.

```cs
[Command(&quot;greet&quot;)]
public async Task GreetCommand(CommandContext ctx)
{
    await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
}
```

Your command module should now resemble this:

```cs
using System.Threading.Tasks;
using DisCatSharp.CommandsNext;
using DisCatSharp.CommandsNext.Attributes;

public class MyFirstModule : BaseCommandModule
{
    [Command(&quot;greet&quot;)]
    public async Task GreetCommand(CommandContext ctx)
    {
        await ctx.RespondAsync(&quot;Greetings! UwU&quot;);
    }
}
```

### Cleanup and Configuration

Before we can run our new command, we&apos;ll need modify our main method.&lt;br/&gt;
Start by removing the event handler we created [previously](xref:getting_started_first_bot#spicing-up-your-bot).

```cs
var discord = new DiscordClient();

discord.MessageCreated += async (s, e) =&gt;               // REMOVE
{                                                       // ALL
    if (e.Message.Content.ToLower().StartsWith(&quot;ping&quot;)) // OF
        await e.Message.RespondAsync(&quot;pong!&quot;);          // THESE
};                                                      // LINES

await discord.ConnectAsync();
```

Next, call the `UseCommandsNext` extension method on your `DiscordClient` instance and pass it a new `CommandsNextConfiguration` instance.
Assign the resulting `CommandsNextExtension` instance to a new variable named _commands_. This important step will enable CommandsNext for your Discord client.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext(new CommandsNextConfiguration());
```

Create an object initializer for `CommandsNextConfiguration` and assign the `StringPrefixes` property a new `string` array containing your desired prefixes.
Our example below will only define a single prefix: `!`.

```cs
new CommandsNextConfiguration()
{
    StringPrefixes = new List&lt;string&gt;() { &quot;!&quot; }
}
```

Now we&apos;ll register our command module.
Call the `RegisterCommands` method on our `CommandsNextExtension` instance and provide it with your command module.

```cs
var discord = new DiscordClient();
var commands = discord.UseCommandsNext();

commands.RegisterCommands&lt;MyFirstModule&gt;();

await discord.ConnectAsync();
```

Alternatively, you can pass in your assembly to register commands from all modules in your program.

```cs
commands.RegisterCommands(Assembly.GetExecutingAssembly());
```

Your main method should look similar to the following:

```cs
internal static async Task MainAsync()
{
    var discord = new DiscordClient(new DiscordConfiguration());
    var commands = discord.UseCommandsNext(new CommandsNextConfiguration()
    {
        StringPrefixes = new List&lt;string&gt;() { &quot;!&quot; }
    });

    commands.RegisterCommands&lt;MyFirstModule&gt;();

    await discord.ConnectAsync();
    await Task.Delay(-1);
}
```

### Running Your Command

It&apos;s now the moment of truth; all your blood, sweat, and tears have lead to this moment.
Hit `F5` on your keyboard to compile and run your bot, then execute your command in any channel that your bot account has access to.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Greetings! UwU
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Taking User Input

### Command Arguments

Now that we have a basic command down, let&apos;s spice it up a bit by defining _arguments_ to accept user input.

Defining an argument is simple; just add additional parameters to your signature of your command method.
CommandsNext will automatically parse user input and populate the parameters of your command method with those arguments.
To demonstrate, we&apos;ll modify our _greet_ command to greet a user with a given name.

Head back to `MyFirstModule` and add a parameter of type `string` to the `GreetCommand` method.

```cs
[Command(&quot;greet&quot;)]
public async Task GreetCommand(CommandContext ctx, string name)
```

CommandsNext will now interpret this as a command named _greet_ that takes one argument.

Next, replace our original response message with an [interpolated string](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)
which uses our new parameter.

```cs
public async Task GreetCommand(CommandContext ctx, string name)
{
    await ctx.RespondAsync($&quot;Greetings, {name}! You&apos;re cute OwO!&quot;);
}
```

That&apos;s all there is to it. Smack `F5` and test it out in a channel your bot account has access to.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet Drac
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Greetings, Drac! You&apos;re cute OwO!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Now, you may have noticed that providing more than one word simply does not work.
For example, `!greet Luke Smith` will result in no response from your bot.

This fails because a valid [overload](#command-overloads) could not be found for your command.

CommandsNext will split arguments by whitespace. This means `Luke Smith` is counted as two separate arguments; `Luke` and `Smith`.
In addition to this, CommandsNext will attempt to find and execute an overload of your command that has the _same number_ of provided arguments.
Together, this means that any additional arguments will prevent CommandsNext from finding a valid overload to execute.

The simplest way to get around this would be to wrap your input with double quotes.
CommandsNext will parse this as one argument, allowing your command to be executed.

```
!greet &quot;Lala Sabathil&quot;
```

If you would prefer not to use quotes, you can use the `RemainingText` attribute on your parameter.
This attribute will instruct CommandsNext to parse all remaining arguments into that parameter.

```cs
public async Task GreetCommand(CommandContext ctx, [RemainingText] string name)
```

Alternatively, you can use the `params` keyword to have all remaining arguments parsed into an array.

```cs
public async Task GreetCommand(CommandContext ctx, params string[] names)
```

A more obvious solution is to add additional parameters to the method signature of your command method.&lt;br/&gt;

```cs
public async Task GreetCommand(CommandContext ctx, string firstName, string lastName)
```

Each of these has their own caveats; it&apos;ll be up to you to choose the best solution for your commands.

### Argument Converters

CommandsNext can convert arguments, which are natively `string`, to the type specified by a command method parameter.
This functionality is powered by _argument converters_, and it&apos;ll help to eliminate the boilerplate code needed to parse and convert `string` arguments.

CommandsNext has built-in argument converters for the following types:

|    Category    | Types                                                                                                                                 |
| :------------: | :------------------------------------------------------------------------------------------------------------------------------------ |
|    Discord     | `DiscordGuild`, `DiscordChannel`, `DiscordMember`, `DiscordUser`,&lt;br/&gt;`DiscordRole`, `DiscordMessage`, `DiscordEmoji`, `DiscordColor` |
|    Integral    | `byte`, `short`, `int`, `long`, `sbyte`, `ushort`, `uint`, `ulong`                                                                    |
| Floating-Point | `float`, `double`, `decimal`                                                                                                          |
|      Date      | `DateTime`, `DateTimeOffset`, `TimeSpan`                                                                                              |
|   Character    | `string`, `char`                                                                                                                      |
|    Boolean     | `bool`                                                                                                                                |

You&apos;re also able to create and provide your own [custom argument converters](xref:modules_commandsnext_customization_argument_converters), if desired.

Let&apos;s do a quick demonstration of the built-in converters.

Create a new command method above our `GreetCommand` method named `RandomCommand` and have it take two integer arguments.
As the method name suggests, this command will be named _random_.

```cs
[Command(&quot;random&quot;)]
public async Task RandomCommand(CommandContext ctx, int min, int max) { }
```

Make a variable with a new instance of `Random`.

```cs
var random = new Random();
```

Finally, we&apos;ll respond with a random number within the range provided by the user.

```cs
await ctx.RespondAsync($&quot;Your number is: {random.Next(min, max)}&quot;);
```

Run your bot once more with `F5` and give this a try in a text channel.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !random 1 100
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Your number is: 69
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

CommandsNext converted the two arguments from `string` into `int` and passed them to the parameters of our command,
removing the need to manually parse and convert the arguments yourself.

We&apos;ll do one more to drive the point home. Head back to our old `GreetCommand` method, remove our
`name` parameter, and replace it with a new parameter of type `DiscordMember` named `member`.

```cs
public async Task GreetCommand(CommandContext ctx, DiscordMember member)
```

Then modify the response to mention the provided member with the `Mention` property on `DiscordMember`.

```cs
public async Task GreetCommand(CommandContext ctx, DiscordMember member)
{
    await ctx.RespondAsync($&quot;Heywo, {member.Mention}! Enjoy the mention!&quot;);
}
```

Go ahead and give that a test run.

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet &lt;discord-mention&gt;Discord User&lt;/discord-mention&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet Discord User
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;
        !greet 666339628613107725
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Heywo, &lt;discord-mention highlight&gt;Discord User&lt;/discord-mention&gt;! Enjoy the mention!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

The argument converter for `DiscordMember` is able to parse mentions, usernames, nicknames, and user IDs then look for a matching member within the guild the command was executed from.
Ain&apos;t that neat?

## Command Overloads

Command method overloading allows you to create multiple argument configurations for a single command.

```cs
[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, string bar, int baz) { }

[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, DiscordUser bar) { }
```

Executing `!foo green 5` will run the first method, and `!foo @SecondUser` will run the second method.

Additionally, all check attributes are shared between overloads.&lt;br/&gt;

```cs
[Command(&quot;foo&quot;), Aliases(&quot;bar&quot;, &quot;baz&quot;)]
[RequireGuild, RequireBotPermissions(Permissions.AttachFiles)]
public Task FooCommand(CommandContext ctx, int bar, int baz, string qux = &quot;agony&quot;) { }

[Command(&quot;foo&quot;)]
public Task FooCommand(CommandContext ctx, DiscordChannel bar, TimeSpan baz) { }
```

The additional attributes and checks applied to the first method will also be applied to the second method.

## Further Reading

Now that you&apos;ve gotten an understanding of CommandsNext, it&apos;d be a good idea check out the following:

-   [Command Attributes](xref:modules_commandsnext_command_attributes)
-   [Help Formatter](xref:modules_commandsnext_customization_help_formatter)
-   [Dependency Injection](xref:modules_commandsnext_dependency_injection)</file><file path="DisCatSharp.Docs/articles/modules/interactivity/interactivity.md">---
uid: modules_interactivity_introduction
title: Interactivity Introduction
hasDiscordComponents: true
---

# Introduction to Interactivity

Interactivity will enable you to write commands which the user can interact with through reactions and messages.
The goal of this article is to introduce you to the general flow of this extension.

Make sure to install the `DisCatSharp.Interactivity` package from NuGet before continuing.

![Interactivity NuGet](/images/interactivity_01.png)

## Enabling Interactivity

Interactivity can be registered using the `DiscordClient#UseInteractivity()` extension method.&lt;br/&gt;
Optionally, you can also provide an instance of `InteractivityConfiguration` to modify default behaviors.

```cs
var discord = new DiscordClient();

discord.UseInteractivity(new InteractivityConfiguration()
{
    PollBehaviour = PollBehaviour.KeepEmojis,
    Timeout = TimeSpan.FromSeconds(30)
});
```

## Using Interactivity

There are two ways available to use interactivity:

-   Extension methods available for `DiscordChannel`, `DiscordMessage`, `DiscordClient` and `DiscordInteraction`.
-   [Instance methods](xref:DisCatSharp.Interactivity.InteractivityExtension#methods) available from `InteractivityExtension`.

We&apos;ll have a quick look at a few common interactivity methods along with an example of use for each.

The first (and arguably most useful) extension method is `SendPaginatedMessageAsync` for `DiscordChannel`.

This method displays a collection of _&apos;pages&apos;_ which are selected one-at-a-time by the user through reaction buttons.
Each button click will move the page view in one direction or the other until the timeout is reached.

You&apos;ll need to create a collection of pages before you can invoke this method.
This can be done easily using the `GeneratePagesInEmbed` and `GeneratePagesInContent` instance methods from `InteractivityExtension`.

Alternatively, for pre-generated content, you can create and add individual instances of `Page` to a collection.

This example will use the `GeneratePagesInEmbed` method to generate the pages.

```cs
public async Task PaginationCommand(CommandContext ctx)
{
    var reallyLongString = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing ...&quot;

    var interactivity = ctx.Client.GetInteractivity();
    var pages = interactivity.GeneratePagesInEmbed(reallyLongString);

    await ctx.Channel.SendPaginatedMessageAsync(ctx.Member, pages);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-embed slot=&quot;embeds&quot;&gt;
            &lt;discord-embed-description slot=&quot;description&quot;&gt;Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero&lt;/discord-embed-description&gt;
        &lt;/discord-embed&gt;
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏮️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;◀️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏹️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;▶️&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;⏭️&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Next we&apos;ll look at the `WaitForReactionAsync` extension method for `DiscordMessage`.
This method waits for a reaction from a specific user and returns the emoji that was used.

An overload of this method also enables you to wait for a _specific_ reaction, as shown in the example below.

```cs
public async Task ReactionCommand(CommandContext ctx, DiscordMember member)
{
    var emoji = DiscordEmoji.FromName(ctx.Client, &quot;:ok_hand:&quot;);
    var message = await ctx.RespondAsync($&quot;Hey {member.Mention}, react with {emoji}!&quot;);

    var result = await message.WaitForReactionAsync(member, emoji);

    if (!result.TimedOut) await ctx.RespondAsync(&quot;Thanks :3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
         Hey &lt;discord-mention highlight profile=&quot;user&quot;&gt;Discord User&lt;/discord-mention&gt;, react with 👌!
         &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction name=&quot;👌&quot; emoji=&quot;/images/ok_hand.svg&quot; count=&quot;1&quot; reacted&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
         Thanks :3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Another reaction extension method for `DiscordMessage` is `CollectReactionsAsync`.
As the name implies, this method collects all reactions on a message until the timeout is reached.

```cs
public async Task CollectionCommand(CommandContext ctx)
{
    var message = await ctx.RespondAsync(&quot;React here!&quot;);
    var reactions = await message.CollectReactionsAsync();

    var stringBuilder = new StringBuilder();
    foreach (var reaction in reactions)
        stringBuilder.AppendLine($&quot;{reaction.Emoji}: {reaction.Total}&quot;);

    await ctx.RespondAsync(stringBuilder.ToString());
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        React here!
        &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction name=&quot;uwu&quot; emoji=&quot;https://cdn.discordapp.com/emojis/859022252372787241.png&quot; count=&quot;3&quot; reacted&gt;&lt;/discord-reaction&gt;
            &lt;discord-reaction name=&quot;👌&quot; emoji=&quot;/images/ok_hand.svg&quot; count=&quot;1&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        👌: 1&lt;br/&gt;
        &lt;discord-custom-emoji name=&quot;uwu&quot; url=&quot;https://cdn.discordapp.com/emojis/859022252372787241.png&quot;&gt;&lt;/discord-custom-emoji&gt;: 3
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

The final one we&apos;ll take a look at is the `GetNextMessageAsync` extension method for `DiscordMessage`.

This method will return the next message sent from the author of the original message.
Our example here will use its alternate overload which accepts an additional predicate.

```cs
public async Task ActionCommand(CommandContext ctx)
{
    await ctx.RespondAsync(&quot;Respond with `confirm` to continue.&quot;);
    var result = await ctx.Message.GetNextMessageAsync(m =&gt;
    {
        return m.Content.ToLower() == &quot;confirm&quot;;
    });

    if (!result.TimedOut)
        await ctx.RespondAsync(&quot;OwO, thanks for confirming &lt;3&quot;);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;Respond with &lt;discord-inline-code&gt;confirm&lt;/discord-inline-code&gt; to continue.&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;confirm&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;OwO, thanks for confirming &lt;3&lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/modules/oauth2/oauth2_client.md">---
uid: modules_oauth2_oauth2_client
title: Discord OAuth2 Client
author: DisCatSharp Team
---

# DiscordOAuth2Client

We support integrating discords OAuth2 directly into DisCatSharp bots.
For this we&apos;ve added the [DiscordOAuth2Client](xref:DisCatSharp.DiscordOAuth2Client).

Additionally, we provide a new extension called [OAuth2WebExtention](xref:DisCatSharp.Extensions.OAuth2Web.OAuth2WebExtension) in the package `DisCatSharp.Extensions.OAuth2Web`, which provides you with a web server implementation and certain events.

## Example

```cs
// Client registration
internal DiscordClient Client { get; private set; } // We assume you registered it somewhere
internal static DiscordOAuth2Client OAuth2Client { get; private set; }
internal static Uri RequestUri { get; set; }

// ...
OAuth2Client = new(3218382190382813, &quot;thisistotallylegitsecret&quot;, &quot;http://127.0.0.1:42069/oauth/&quot;);

// Event registration
OAuth2Client.OAuth2ClientErrored += (sender, args) =&gt;
{
	Client.Logger.LogError(args.Exception, &quot;OAuth2 Client error in {Event}. Exception: {Exception}&quot;, args.EventName, args.Exception.Message);
	return Task.CompletedTask;
};

// Some command class
[SlashCommand(&quot;test_oauth2&quot;, &quot;Tests OAuth2&quot;)]
public static async Task TestOAuth2Async(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Please wait..&quot;));

	var state = OAuth2Client.GenerateState();

    RequestUri = OAuth2Client.GenerateOAuth2Url(&quot;identify connections&quot;, state);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(RequestUri.AbsoluteUri));
}

// Somewhere were you handle web stuff
var uri; // we assume you got the uri in your http handler

if (!OAuth2Client.ValidateState(RequestUri, uri)) // Validate the state
	return;

var token = await OAuth2Client.ExchangeAccessTokenAsync(OAuth2Client.GetCodeFromUri(uri)); // Exchange the code for an access token
var user = await OAuth2Client.GetCurrentUserAsync(token); // Get the user

// Work with your token. I.e. get the users connections
var connections = await OAuth2Client.GetCurrentUserConnectionsAsync(token);

```

## Example with OAuth2Web Extension

```cs
// Client registration
internal DiscordClient Client { get; private set; } // We assume you registered it somewhere
internal OAuth2WebExtension OAuth2WebService { get; private set; }

// ...
this.OAuth2WebService = this.Client.UseOAuth2Web(new OAuth2WebConfiguration()
{
	ClientId = 3218382190382813, // Your client id
	ClientSecret = &quot;thisistotallylegitsecret&quot;, // Your client secret
	RedirectUri = &quot;http://127.0.0.1:42069/oauth/&quot;, // The redirect url, must be public accessible. Possible proxy it.
	ListenAll = true,
	SecureStates = true
});

// Event registration
var oauth2 = this.Client.GetOAuth2Web();
oauth2.AuthorizationCodeReceived += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Auth code received for {State}&quot;, args.ReceivedState);
	return Task.CompletedTask;
};
oauth2.AuthorizationCodeExchanged += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Auth code exchanged for {User} with state {State}&quot;, args.UserId, args.ReceivedState);
	return Task.CompletedTask;
};
oauth2.AccessTokenRefreshed += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Access token refresh for {User}&quot;, args.UserId);
	return Task.CompletedTask;
};
oauth2.AccessTokenRevoked += (sender, args) =&gt;
{
	Client.Logger.LogDebug(&quot;Access token revoked for {User}&quot;, args.UserId);
	return Task.CompletedTask;
};
oauth2.OAuth2Client.OAuth2ClientErrored += (sender, args) =&gt;
{
	Client.Logger.LogError(args.Exception, &quot;OAuth2 Client error in {Event}. Exception: {Exception}&quot;, args.EventName, args.Exception.Message);
	return Task.CompletedTask;
};

// Client start
await this.Client.ConnectAsync();
this.Client.Logger.LogInformation(&quot;Starting OAuth2 Web&quot;);
this.OAuth2WebService.StartAsync();

// Some command class
[SlashCommand(&quot;test_oauth2&quot;, &quot;Tests OAuth2&quot;)]
public static async Task TestOAuth2Async(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Please wait..&quot;));

	var web = ctx.Client.GetOAuth2Web();

	var uri = web.OAuth2Client.GenerateOAuth2Url(&quot;identify connections&quot;, web.OAuth2Client.GenerateSecureState(ctx.User.Id));
	web.SubmitPendingOAuth2Url(uri);

	await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(uri.AbsoluteUri));

	var res = await web.WaitForAccessTokenAsync(ctx.User, uri, TimeSpan.FromMinutes(1));
	if (!res.TimedOut)
	{
		var testData = await web.OAuth2Client.GetCurrentUserConnectionsAsync(res.Result.DiscordAccessToken);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent($&quot;{testData.Count} total connections. First connection username: {testData.First().Name}&quot;));
		await web.RevokeAccessTokenAsync(ctx.User);
	}
	else
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Timed out :(&quot;));
}
```

## Limitations

We only implemented methods and routes which all users can use.
You can use the access token and build calls yourself if needed.</file><file path="DisCatSharp.Docs/articles/sec_comp/sentry.md">---
uid: sec_comp_sentry
title: Sentry Safety Report
author: DisCatSharp Team
---

# Recent Claims about the Sentry Integration and Measures Taken

## Overview

Recently, claims were made regarding the logging of tokens within our Sentry integration in the DisCatSharp library. These claims were taken seriously and thoroughly investigated. This document outlines our findings and the steps taken to further ensure the security and privacy of our users.

## Claims and Investigation

The claims suggested that our Sentry integration was logging sensitive information, including tokens. After a comprehensive review, including chasing the logs through a proxy, it was confirmed that no sensitive information such as tokens was being transmitted.

### Validation Process

1. **Proxy Analysis**: Logs sent to Sentry were inspected using a proxy to ensure no sensitive data was being transmitted.
2. **Code Review**: The relevant sections of the code were reviewed to verify that no tokens or sensitive information were included in the logs.

## Measures Taken

Despite the validation that no sensitive data was being logged, additional measures have been implemented to further enhance security:

1. **StripTokens Utility**: A utility function to remove any Discord-based tokens from strings before they are sent to Sentry.
   ```csharp
   public static string? StripTokens(string? str)
   {
      if (string.IsNullOrWhiteSpace(str))
         return str;

      str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
      str = Regex.Replace(str, @&quot;(mfa\\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);

      return str;
   }
   ```

2. **Breadcrumb Filter**: Filters out sensitive information from breadcrumb logs before sending them to Sentry.
   ```csharp
   options.SetBeforeBreadcrumb(b
      =&gt; new Breadcrumb(Utilities.StripTokens(b.Message),
         b.Type,
         b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripTokens(x.Value)))
         .ToDictionary(x =&gt; x.Key, x =&gt; x.Value),
         b.Category,
         b.Level));
   ```

3. **Transaction Filter**: Ensures that sensitive information is not included in transaction data sent to Sentry.
   ```csharp
   options.SetBeforeSendTransaction(tr =&gt;
   {
      if (tr.Request.Data is string str)
         tr.Request.Data = Utilities.StripTokens(str);

      return tr;
   });
   ```

## Conclusion

The initial claims were found to be unsubstantiated. However, we have taken this opportunity to enhance our security measures further to ensure the safety and privacy for our users. We appreciate the community&apos;s vigilance and remain committed to maintaining a secure and reliable library.

For more details on the specific pull requests and discussions related to these measures, please refer to the following links:
- [Pull Request 494](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/494)
- [Pull Request 493](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/493)
- [Pull Request 495](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/495)
- [Pull Request 501](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/501)

Thank you for your continued support and understanding.</file><file path="DisCatSharp.Docs/articles/topics/components/select_menus.md">---
uid: topics_components_select_menus
title: Select Menus
author: DisCatSharp Team
---

# Introduction

The select menus, like the [buttons](xref:topics_components_buttons), are message components.
You will want to familarize yourself with the [message builder](xref:topics_messagebuilder) as it and similar builder objects will be used throughout this article.

A row can only have one select menu. An row containing a select menu cannot also contain buttons.
Since a message can have up to 5 rows, you can add up to 5 select menus to a message.

# Select Menus

&gt; [!WARNING]
&gt; Component Ids and option values should be unique, as this is what&apos;s sent back when a user selects one (or more) option.

Select menus consist of five parts:

-   Id
-   Placeholder
-   Options
-   MinOptions
-   MaxOptions
-   Disabled

The id of the select menu is a settable string, and is specified by the developer. Discord sends this id back in the [interaction object](https://discord.dev/interactions/slash-commands#interaction).

**Placeholder** is a settable string that appears in the select menu when nothing is selected.

**Options** is an array of options for the user to select. Their maximum number in one select menu is 25.
You can let users choose 1 or more options using **MinOptions** and **MaxOptions**.

Options consist of five parts:

-   Label
-   Value
-   Description
-   IsDefault
-   Emoji

Menu creation, for easier understanding, can be divided into two stages:

```cs
// First, create an array of options.
var options = new DiscordSelectComponentOption[]
{
    new DiscordSelectComponentOption(&quot;First option&quot;, &quot;first_option&quot;, &quot;This is the first option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😀&quot;)),
    new DiscordSelectComponentOption(&quot;Second option&quot;, &quot;second_option&quot;, &quot;This is the second option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😎&quot;))
};

// Now let&apos;s create a select menu with the options created above.
var selectMenu = new DiscordSelectComponent(&quot;my_select_menu&quot;, &quot;Please select one of the options&quot;, options);
```

This will create a select menu with two options and the text &quot;Please select one of the options&quot;.
When a user select **one** option, `&quot;my_select_menu&quot;` will be sent back as the `Id` property on the event.
This is expanded on in the [how to respond to select menus](#responding-to-select-menus).

You can increase the maximum/minimum number of selections in the select menu constructor. You can also block the select menu, or options.

Description and emoji of options are optional. The label, value and description can be up to 100 characters in length.
The emoji of a option is a [partial emoji object](https://discord.dev/interactions/message-components#component-object), which means that **any valid emoji is usable**, even if your bot does not have access to it&apos;s origin server.

## Adding Select Menu

Adding a select menu is no different than adding a button.
We have already created the select menu above, now we will just create a new message builder add the select menu to it.

```cs
var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has select menu! Pretty neat innit?&quot;)
    .AddComponents(selectMenu);
```

Now you have a message with a select menu. Congratulations! It&apos;s important to note that `.AddComponents()` will create a new row with each call, so **add everything you want on one row in one call!**

Lets also add a second row with select menu with the ability to choose any number of options.

```cs
var secondOptions = new DiscordSelectComponentOption[]
{
    new DiscordSelectComponentOption(&quot;First option&quot;, &quot;first_option&quot;, &quot;This is the first option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😀&quot;)),
    new DiscordSelectComponentOption(&quot;Second option&quot;, &quot;second_option&quot;, &quot;This is the second option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😎&quot;))
    new DiscordSelectComponentOption(&quot;Third option&quot;, &quot;third_option&quot;, &quot;This is the third option, you can add your description of it here.&quot;, false, new DiscordComponentEmoji(&quot;😘&quot;))
};

var secondSelectMenu = new DiscordSelectComponent(&quot;my_second_select_menu&quot;, &quot;Please select up to 3 options&quot;, secondOptions, 1, 3);

builder.AddComponents(secondSelectMenu);
```

And you&apos;re done! The select menu will now be sent when the user closes the select menu with 1 to 3 options selected.

## Responding to select menus

When any select menu is pressed, it will fire the [ComponentInteractionCreated](xref:DisCatSharp.DiscordClient.ComponentInteractionCreated) event.

In the event args, `Id` will be the id of the select menu you specified. There&apos;s also an `Interaction` property, which contains the interaction the event created. It&apos;s important to respond to an interaction within 3 seconds, or it will time out. Responding after this period will throw a `NotFoundException`.

With select menus, there are two new response types: `DeferedMessageUpdate` and `UpdateMessage`.
using `DeferredMessageUpdate` lets you create followup messages via the [followup message builder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder).

You have 15 minutes from that point to make followup messages. Responding to that interaction looks like this:

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferedMessageUpdate);
    // Do things.. //
}
```

If you would like to update the message when an select menu option selected, however, you&apos;d use `UpdateMessage` instead, and pass a `DiscordInteractionResponseBuilder` with the new content you&apos;d like.

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.UpdateMessage, new DiscordInteractionResponseBuilder().WithContent(&quot;No more select menu for you &gt;:)&quot;));
}
```

This will update the message, and without the infamous &lt;sub&gt;(edited)&lt;/sub&gt; next to it. Nice.

# Interactivity

Along with the typical `WaitForMessageAsync` and `WaitForReactionAsync` methods provided by interactivity, there are also select menus implementations as well.

More information about how interactivity works can be found in [the interactivity article](xref:modules_interactivity_introduction)

Since select menus create interactions, there are also two additional properties in the configuration:

-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior
-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseMessage

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior is what interactivity will do when handling something that isn&apos;t a valid valid select menu, in the context of waiting for a specific select menu. It defaults to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ignore, which will cause the interaction fail.

Alternatively, setting it to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ack will acknowledge the select menu, and continue waiting.

@DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Respond will reply with an ephemeral message with the aforementioned response message.

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior only applies to the overload accepting a string id of the select menu to wait for.</file><file path="DisCatSharp.Docs/articles/topics/events.md">---
uid: topics_events
title: DisCatSharp Events
author: DisCatSharp Team
---

# Events In DisCatSharp

## Consuming Events

DisCatSharp makes use of _asynchronous events_ which will execute each handler asynchronously in sequential order.
This event system will require event handlers have a `Task` return type and take two parameters.

The first parameter will contain an instance of the object which fired the event.&lt;br/&gt;
The second parameter will contain an arguments object for the specific event you&apos;re handling.

Below is a snippet demonstrating this with a lambda expression.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += async (s, e) =&gt;
    {
        if (e.Message.Content.ToLower().Contains(&quot;spiderman&quot;))
            await e.Message.RespondAsync(&quot;I want pictures of Spiderman!&quot;);
    };

	discord.GuildMemberAdded += (s, e) =&gt;
    {
        // Non asynchronous code here.
        return Task.CompletedTask;
    };
}
```

Alternatively, you can create a new method to consume an event.

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();

    discord.MessageCreated += MessageCreatedHandler;
	discord.GuildMemberAdded += MemberAddedHandler;
}

private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    if (e.Guild?.Id == 379378609942560770 &amp;&amp; e.Author.Id == 168548441939509248)
        await e.Message.DeleteAsync();
}

private Task MemberAddedHandler(DiscordClient s, GuildMemberAddEventArgs e)
{
    // Non asynchronous code here.
    return Task.CompletedTask;
}
```

## Using automatic event registration

Instead of having to manually register each event, the attributes `Event` and `EventHandler` can be utilized to semi-automatically register events in a multitude of ways.

By attributing all classes that constitute event handlers with `EventHandler` and all methods within those classes that are intended to handle events with `Event` you can register all of those events with a single call to `DiscordClient.RegisterEventHandlers(Assembly)`

```cs
[EventHandler]
public class MyEventHandler
{
    [Event]
    private async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }

    [Event(DiscordEvent.MessageCreated)] // You can specify the event name in the attribute, instead of via the method name!
    public static async Task MySecondaryHandler(DiscordClient s, MessageCreateEventArgs e) { /* ... */ }
}
```

```cs
private async Task MainAsync()
{
    var discord = new DiscordClient();
    discord.RegisterEventHandlers(Assembly.GetExecutingAssembly());
}
```

If an event handler class is not `abstract` (which also means not `static`) it will be instantiated, optionally with the help of an `IServiceProvider`, if one has been provided to the `DiscordConfig`. The inability to instantiate an event handler type constitutes an error.

```cs
public class SomeClass { }

[EventHandler]
public class MyOtherEventHandler
{
    private SomeClass some;

    public MyOtherEventHandler(SomeClass some) { this.some = some; }

    [Event]
    public async Task MessageCreated(DiscordClient s, MessageCreateEventArgs e) { /* do something with some */ }
}
```

In the above example an instance of `SomeClass` will need to be provided to the `DiscordContext`&apos;s `IServiceProvider`, read the next chapter to see how to accomplish that!

You can also register individual types, and even individual objects as event handlers using the overloaded method `DiscordClient.RegisterEventHandler`. In both of those cases the attribute `EventHandler` is not required.

When registering an object as a handler, by default the type&apos;s static methods will _not_ be considered as event handling methods.
This allows for registering multiple instances of the same type without registering their static event handling methods multiple times.
To register the static methods exclusively, use `DiscordClient.RegisterStaticEventHandler` with the type in question.

## Dependency Injection

Often, you need a way to get data in and out of your event handlers.
Although you _could_ use `static` fields to accomplish this, the preferred solution would be _dependency injection_.

First, you need to register the services that you can use in the event handlers in the future.

You can do this in DiscordConfiguration:

```cs
var config = new DiscordConfiguration()
{
    Token = &quot;Token here&quot;,
    TokenType = TokenType.Bot,
    ServiceProvider = new ServiceCollection()
        .AddScoped&lt;YourService&gt;()
        .AddSingleton&lt;YourSecondService&gt;()
        .BuildServiceProvider()
};
```

In this case, we have registered two services: `YourService` as Scoped and` YourSecondService` as Singleton.

Now you can use them in your event handlers.

```cs
private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e)
{
    var service = e.ServiceProvider.GetRequiredService&lt;YourService&gt;();
    var secondService = e.ServiceProvider.GetRequiredService&lt;YourSecondService&gt;();
}
```

### Services

| Lifespan  | Instantiated                           |
| :-------: | :------------------------------------- |
| Singleton | One time when added to the collection. |
|  Scoped   | Once for each event handler.           |
| Transient | Every request to the ServiceProvider.  |

## Avoiding Deadlocks

Despite the fact that your event handlers are executed asynchronously, they are also executed one at a time on the gateway thread for consistency.
This means that each handler must complete its execution before others can be dispatched.

Because of this, executing code in your event handlers that runs for an extended period of time may inadvertently
create brief unresponsiveness or, even worse, cause a [deadlock](https://en.wikipedia.org/wiki/Deadlock).
To prevent such issues, any event handler that has the potential to take more than 2 seconds to execute should have its logic offloaded to a `Task.Run`.

```cs
discord.MessageCreated += (s, e) =&gt;
{
    _ = Task.Run(async () =&gt;
    {
        // Pretend this takes many, many seconds to execute.
        var response = await QuerySlowWebServiceAsync(e.Message.Content);

        if (response.Status == HttpStatusCode.OK)
        {
            await e.Guild?.BanMemberAsync((DiscordMember)e.Author);
        }
    });

	return Task.CompletedTask;
};
```

Doing this will allow the handler to complete its execution quicker, which will in turn allow other handlers to be executed and prevent the gateway thread from being blocked.</file><file path="DisCatSharp.Docs/articles/topics/intents.md">---
uid: topics_intents
title: Intents
author: DisCatSharp Team
---

# Intents

Intents were added to Discord to help the service not have to push so many events to the bots that were not using them. If you are going to be needing to subscribe to any type of event, they are going to have to be defined **BOTH** within the
[Discord Application under the Bot Page](https://discord.com/developers/applications) on Discords Site and also within the @DisCatSharp.DiscordConfiguration.

## Discord Application

On the [Discord Application under the Bot Page](https://discord.com/developers/applications) you will have to specify if your bot requires Privileged Intents. We recommend having these all enabled at first to ensure the most stability when building your first bot, otherwise you may run into issues when retrieving entities from the library&apos;s cache.

![Bot Page](/images/Intents.png)

&gt; [!WARNING]
&gt; These privileged intents may not be available for you to toggle on immediately.
&gt;
&gt; Due to their nature of sensitive data, Discord requires you to go through a verification process once your bot is in a certain amount of servers.
&gt; Please read this [blog post](https://support.discord.com/hc/en-us/articles/360040720412) for more information and how to apply.

## Discord Configuration

Within your `DiscordConfiguration` you will have to specify all the intents you will need. Here is a list of all the
[Intents](xref:DisCatSharp.Enums.DiscordIntents) DisCatSharp Supports. By default, the configuration will use `DiscordIntents.AllUnprivileged` as the default value. Like above however, we recommend having all intents enabled at first, so you should specify `DiscordIntents.All` in your configuration which will include the privileged intents you enabled in your application:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.All
};
```

When you become more advanced, you can try experimenting with turning off intents you do not need in order to save resources. In your `DiscordConfiguration` you can specify one or many.

Here is an example of just specifying one:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.GuildBans
};
```

Here is an example of specifying many:

```csharp
var config = new DiscordConfiguration()
{
    Intents = DiscordIntents.DirectMessageReactions
    | DiscordIntents.DirectMessages
    | DiscordIntents.GuildBans
    | DiscordIntents.GuildEmojis
    | DiscordIntents.GuildInvites
    | DiscordIntents.GuildMembers
    | DiscordIntents.GuildMessages
    | DiscordIntents.Guilds
    | DiscordIntents.GuildVoiceStates
    | DiscordIntents.GuildWebhooks,
};
```

Please Note, if you specify a privileged intent within your `DiscordConfiguration` that you have not signed up for on the Discord Application page, an error will be thrown on the connection.</file><file path="DisCatSharp.Docs/articles/topics/logging/default.md">---
uid: topics_logging_default
title: The Default Logger
author: DisCatSharp Team
---

# The Default Logger

DisCatSharp ships with a default logging implementation which is **enabled automatically** with **no setup required**.

![Info Level Logging](/images/topics_logging_default_01.png)

This is a basic implementation that only sends log messages to the console.

## Minimum Logging Level

You&apos;re able to adjust the verbosity of log messages via `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    MinimumLogLevel = LogLevel.Debug
};
```

The example above will display level log messages that are higher than or equal to `Debug`.

![Debug Level Logging](/images/topics_logging_default_02.png)

## Timestamp Format

You&apos;re also able to change the format of the log timestamp; this is also set through `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    LogTimestampFormat = &quot;MMM dd yyyy - hh:mm:ss tt&quot;
};
```

![The Real Timestamp Format](/images/topics_logging_default_03.png)

For a list of all available format specifiers, check out the MSDN page for [custom date and time format strings](https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings#day-d-format-specifier).

## Log Levels

Below is a table of all log levels and the kind of messages you can expect from each.
Name|Position|Description
:---:|:---:|:---
`Critical`|5|Fatal error which may require a restart.
`Error`|4| A failure of an operation or request.
`Warning`|3|Non-fatal errors and abnormalities.
`Information`|2|Session startup and resume messages.
`Debug`|1| Ratelimit buckets and related information.
`Trace`|0| Websocket &amp; REST traffic.

&gt; [!WARNING]
&gt; The `Trace` log level is _not_ recommended for use in production.
&gt;
&gt; It is intended for debugging DisCatSharp and may display tokens and other sensitive data.</file><file path="DisCatSharp.Docs/articles/topics/logging/di.md">---
uid: topics_logging_di
title: Dependency Injection Logging
author: DisCatSharp Team
---

# Default Logger

By default, when using DI, you will be using Microsoft&apos;s implementation of `ILogger` and `ILoggerFactory`. This requires no additional setup.

# Third Party Logger

If you wish to use a different logging service/implementation you simply install the appropriate nuget package, or create your own which have implementations for `ILoggerFactory` and `ILogger`.

You need to register either this third party implementation or your own via the `IServiceCollection` which becomes `IServiceProvider` at runtime.

If we are using the DisCatSharp ProjectTemplates there will be a project with a `.Web`. Inside is a `Program.cs` file.

###WebHost: Serilog

-   Serilog.AspNetCore
-   Serilog.Extensions.Hosting -- Gives us the `UseSerilog` extension
-   Serilog.Sinks.Console -- Sinks are used to direct where logs go. In this case we need it for outputting to console

```cs
using Serilog;

// unrelated code not shown for brevity
builder.Host.UseSerilog( (context, lc) =&gt; lc.WriteTo.Console()); // Our logs are directed to the console

var app = builder.Build();
app.Run();
```</file><file path="DisCatSharp.Docs/articles/topics/logging/third_party.md">---
uid: topics_logging_third_party
title: Third Party Logging
author: DisCatSharp Team
---

# Using a Third Party Logger

While the default logging implementation will meet the needs of most, some may desire to make use of a more robust implementation which provides more features.
Thankfully, DisCatSharp allows you to use any logging library which has an implementation for the [logging abstractions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging) provided by Microsoft.

[Serilog](https://serilog.net/), one of the more popular logging libraries, will be used to demonstrate.
This will simply be a brief demo, so we won&apos;t go into the configuration of Serilog.
You&apos;ll want to head on over to their [wiki page](https://github.com/serilog/serilog/wiki/Configuration-Basics) to learn about that!

We&apos;ll need to install both the `Serilog` and `Serilog.Extensions.Logging` packages from NuGet, along with at least one of the many available
[sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks). Our example here will only use the `Serilog.Sinks.Console` sink.

&lt;br/&gt;
Start off by creating a new `LoggerConfiguration` instance, slap `.WriteTo.Console().CreateLogger()` onto the end of it, then directly assign that to the static `Logger` property on the `Log` class.

```cs
Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .CreateLogger();
```

This will make a new Serilog logger instance which will write to the console sink.

&lt;br/&gt;
Next, create a new variable and assign it a new `LoggerFactory` instance which calls `AddSerilog()`.

```cs
var logFactory = new LoggerFactory().AddSerilog();
```

Then assign that variable to the `LoggerFactory` property of your of `DiscordConfiguration`.

```cs
new DiscordConfiguration()
{
    LoggerFactory = logFactory
}
```

&lt;br/&gt;
Altogether, you&apos;ll have something similar to this:

```cs
using Microsoft.Extensions.Logging;
using Serilog;

public async Task MainAsync()
{
    Log.Logger = new LoggerConfiguration()
        .WriteTo.Console()
        .CreateLogger();

    var logFactory = new LoggerFactory().AddSerilog();
    var discord = new DiscordClient(new DiscordConfiguration()
    {
        LoggerFactory = logFactory
    });
}
```

And that&apos;s it! If you now run your bot, you&apos;ll see DisCatSharp log messages formatted and displayed by Serilog.

![Console](/images/topics_logging_third_party_01.png)</file><file path="DisCatSharp.Docs/articles/topics/messagebuilder.md">---
uid: topics_messagebuilder
title: Message Builder
author: DisCatSharp Team
hasDiscordComponents: true
---

# Message Builder

## Background

Before the message builder was put into place, we had one large method for sending messages along with 3 additional methods for sending files. This was becoming a major code smell and it was hard to maintain and add more parameters onto it. Now we support just sending a simple message, an embed, a simple message with an embed, or a message builder.

## Using the Message Builder

The API Documentation for the message builder can be found [there](xref:DisCatSharp.Entities.DiscordMessageBuilder),
but here we&apos;ll go over some of the concepts of using the message builder:

### Adding a File

For sending files, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
 using (var fs = new FileStream(&quot;global_name.cs&quot;, FileMode.Open, FileAccess.Read))
 {
    var msg = await new DiscordMessageBuilder()
        .WithContent(&quot;Here&apos;s a code snippet for you!&quot;)
        .WithFiles(new Dictionary&lt;string, Stream&gt;() { { &quot;global_name.cs&quot;, fs } })
        .SendAsync(ctx.Channel);
}
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        Here&apos;s a code snippet for you!
        &lt;discord-attachments slot=&quot;attachments&quot;&gt;
            &lt;discord-attachment type=&quot;file&quot; alt=&quot;global_name.cs&quot; size=&quot;1.2 MB&quot;  url=&quot;/snippets/global_name.cs&quot;&gt;&lt;/discord-attachment&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

### Adding Mentions

For sending mentions, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;✔ UserMention(user): Hey, {user.Mention}! Listen!&quot;)
    .WithAllowedMentions(new IMention[] { new UserMention(user) })
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        ✔ UserMention(user): Hey, &lt;discord-mention highlight profile=&quot;user&quot;&gt;Discord User&lt;/discord-mention&gt;! Listen!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

### Sending TTS Messages

For sending a TTS message, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;This is a test message&quot;)
    .HasTTS(true)
    .SendAsync(ctx.Channel);
```

### Sending an Inline Reply

For sending an inline reply, you&apos;ll have to use the MessageBuilder to construct your message, see example below:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;I&apos;m talking to *you*!&quot;)
    .WithReply(ctx.Message.Id)
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Who you talking to?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Who you talking to?&lt;/discord-reply&gt;
        I&apos;m talking to &lt;discord-bold&gt;you&lt;/discord-bold&gt;!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

&lt;br/&gt;
By default, replies do not mention. To make a reply mention, simply pass true as the second parameter:

```cs
var msg = await new DiscordMessageBuilder()
    .WithContent($&quot;I&apos;m talking to *you*!&quot;)
    .WithReply(ctx.Message.Id, true)
    .SendAsync(ctx.Channel);
```

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Who you talking to?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Who you talking to?&lt;/discord-reply&gt;
        I&apos;m talking to &lt;discord-bold&gt;you&lt;/discord-bold&gt;!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;</file><file path="DisCatSharp.Docs/articles/topics/sharding.md">---
uid: topics_sharding
title: Sharding
author: DisCatSharp Team
---

# Sharding

As your bot joins more guilds, your poor `DiscordClient` will be hit with an increasing number of events.
Thankfully, Discord allows you to establish multiple connections to split the event workload; this is called _sharding_ and each individual connection is referred to as a _shard_.
Each shard handles a separate set of servers and will _only_ receive events from those servers. However, all direct messages will be handled by your first shard.

Sharding is recommended once you reach 1,000 servers, and is a _requirement_ when you hit 2,500 servers.

## Automated Sharding

DisCatSharp provides a built-in sharding solution: `DiscordShardedClient`.
This client will _automatically_ spawn shards for you and manage their events.
Each DisCatSharp extension (e.g. CommandsNext, Interactivity) also supplies an extension method to register themselves automatically on each shard.

```cs
var discord = new DiscordShardedClient(new DiscordConfiguration
{
    Token = &quot;My First Token&quot;,
    TokenType = TokenType.Bot
});

await discord.UseCommandsNextAsync(new CommandsNextConfiguration()
{
    StringPrefixes = new[] { &quot;!&quot; }
});
```

## Manual Sharding

For most looking to shard, the built-in `DiscordShardedClient` will work well enough.
However, those looking for more control over the sharding process may want to handle it manually.

This would involve creating new `DiscordClient` instances, assigning each one an appropriate shard ID number, and handling the events from each instance.
Considering the potential complexity imposed by this process, you should only do this if you have a valid reason to do so and _know what you are doing_.</file><file path="DisCatSharp.Docs/articles/topics/workarounds.md">---
uid: topics_workarounds
title: Workarounds
author: DisCatSharp Team
---

# Workarounds

Here is a collection of common workarounds for minor problems.

## Thread warns with _.. take too long to execute_

This warning happens from time to time if you&apos;re doing big tasks on events.
A quick workaround for this warning is the following method:

```cs
discordClient.VoiceStateUpdated += (sender, args) =&gt;
{
    Task.Run(async () =&gt; await DiscordClientOnVoiceStateUpdated(sender, args));
    return Task.CompletedTask;
};
```

With this you start a new non-blocking thread.

Another alternative is:

```cs
new Thread(Method).Start()
```

## A messages components field type is changed suddenly

Let me quote something about that:

&gt; Going forward, you should be exceedingly prepared to handle new components not wrapped in action rows
&gt; - Discord Team

We&apos;ve had to introduce a breaking change due to this.
[DiscordMessage.Components](xref:DisCatSharp.Entities.DiscordMessage.Components) is now of the type `IReadOnlyList&lt;`[DiscordComponent](xref:DisCatSharp.Entities.DiscordComponent)`&gt;` instead of `IReadOnlyList&lt;`[DiscordActionRowComponent](xref:DisCatSharp.Entities.DiscordActionRowComponent)`&gt;`.

To get components in action rows (because bots can only create such component hierarchies) reliable, you&apos;d have to do [DiscordMessage.Components.OfType&lt;DiscordActionRowComponent&gt;](xref:System.Linq.Enumerable.OfType*) to get a `IReadOnlyList&lt;`[DiscordActionRowComponent](xref:DisCatSharp.Entities.DiscordActionRowComponent)`&gt;` again.</file><file path="DisCatSharp.Docs/changelogs/index.md">---
uid: changelogs
title: Changelogs
author: DisCatSharp Team
---

# Changelogs

Please select the changelog you want to view from the left side.

Current: [v10.7.0](xref:changelogs_v10_10_7_0)</file><file path="DisCatSharp.Docs/changelogs/v10/10_0_0.md">---
uid: changelogs_v10_10_0_0
title: Version 10.0.0
author: DisCatSharp Team
---

# Upgrade from **9.9.0** to **10.0.0**

## What is new in DisCatSharp?

-   Advanced dependency injection system
-   Support for API v10
-   Message content intent
-   Properly working application command localization
-   Optimized lib code
-   Pre-implementation of upcoming things
-   Support for [Channel Type](xref:DisCatSharp.Enums.ChannelType) `Forum` (WIP)

## What changed?

To get message content with API v10, you have to enable the message content intent in the developer portal AND specify the [DiscordIntent](xref:DisCatSharp.Enums.DiscordIntents) `MessageContent`.
Otherwise you won&apos;t receive message contents from guild messages where the bot isn&apos;t mentioned.

## Backwards Compatibility

You can always choose to use a previous API version.
I.e. if you want to use API V9, you can use `DiscordIntents.AllV9Less` to enable all intents that are valid for this version.</file><file path="DisCatSharp.Docs/changelogs/v10/10_1_0.md">---
uid: changelogs_v10_10_1_0
title: Version 10.1.0
author: DisCatSharp Team
---

# Upgrade from **10.0.0** to **10.1.0**

## What is new in DisCatSharp?

-   Rework of [ApplicationCommands](xref:api_discatsharp_applicationcommands_index)
-   Support for [DiscordGuild.DisableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableInvitesAsync*)
-   Full support for [Forum](xref:DisCatSharp.Enums.ChannelType) [Channels](xref:DisCatSharp.Entities.DiscordChannel)
-   Support for [Spotify](xref:DisCatSharp.Lavalink.Enums.LavalinkSearchType) and [Apple Music](xref:DisCatSharp.Lavalink.Enums.LavalinkSearchType) in [DisCatSharp.Lavalink](xref:api_discatsharp_lavalink_index). See [Lavalink Advanced Usage](xref:modules_audio_lavalink_v4_advanced) for more information.
-   Documentation has a bunch of new and reworked articles!

---

## What changed?

&gt; [!WARNING]
&gt; This release contains breaking changes. Please read the changelog carefully.
&gt; Some bug fixes aren&apos;t noted here.

### All packages

NuGet packages now support [Source Link](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) &amp; [Deterministic Builds](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation).

-   Updated the NuGet specs to be compatible with NuGet Gallery.
-   Changed PackageLicenseUrl to PackageLicenseFile and included the top-level [LICENSE.md](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/LICENSE.md)
-   Changed PackageIconUrl to PackageIcon and included [DisCatSharp.Logos/logobig.png](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/DisCatSharp.Logos/logobig.png)

&gt; [!CAUTION]
&gt; We&apos;ve fixed various namespaces. Please make sure to update your code accordingly.

### DisCatSharp

-   Implemented Forum Channels
    -   Added fields to [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel):
        -   [PostCreateUserRateLimit](xref:DisCatSharp.Entities.DiscordChannel.PostCreateUserRateLimit)
        -   [DefaultReactionEmoji](xref:DisCatSharp.Entities.DiscordChannel.DefaultReactionEmoji) with the type of [ForumReactionEmoji](xref:DisCatSharp.Entities.ForumReactionEmoji)
        -   [AvailableTags](xref:DisCatSharp.Entities.DiscordChannel.AvailableTags)
    -   Added fields to [DiscordThreadChannel](xref:DisCatSharp.Entities.DiscordThreadChannel):
        -   [TotalMessagesSent](xref:DisCatSharp.Entities.DiscordThreadChannel.TotalMessagesSent)
        -   [AppliedTags](xref:DisCatSharp.Entities.DiscordThreadChannel.AppliedTags)
    -   Added entity [ForumPostTag](xref:DisCatSharp.Entities.ForumPostTag)
    -   Added function to create a forum through the guild entity [CreateForumChannelAsync](xref:DisCatSharp.Entities.DiscordGuild.CreateForumChannelAsync*)
    -   Added functions to modify a forum channel [ModifyForumAsync](xref:DisCatSharp.Entities.DiscordChannel.ModifyForumAsync*)
    -   Added forum post tag operations on threads
-   Added disable invites for [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild)
    -   Added new function [EnableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.EnableInvitesAsync*)
    -   Added new function [DisableInvitesAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableInvitesAsync*)
-   The ordered channel methods and fields in [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) now include Forum Channels
-   Added [DiscordMember.DisconnectFromVoiceAsync](xref:DisCatSharp.Entities.DiscordMember.DisconnectFromVoiceAsync*)
-   Added [Avatar Decorations](xref:DisCatSharp.Entities.DiscordUser.AvatarDecorationUrl)
-   Added [Theme Colors](xref:DisCatSharp.Entities.DiscordUser.ThemeColors)
-   Added support for the `X-Discord-Locale` Header in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration.Locale)
-   Added support for sending component-only messages
-   Implemented `ResumeGatewayUrl`
-   Added [GuildFeatures](xref:DisCatSharp.Entities.GuildFeatures):
    -   [GuildHomeTest](xref:DisCatSharp.Entities.GuildFeaturesEnum) (Experimental)
    -   [InvitesDisabled](xref:DisCatSharp.Entities.GuildFeaturesEnum)
-   Implemented DiscordWebhookBuilder.WithThreadName to create forum posts via a webhook
-   Added [ApplicationFlags.ApplicationCommandBadge](xref:DisCatSharp.Enums.ApplicationFlags)
-   Added a bypassCache option to [DiscordChannel.GetMessageAsync](xref:DisCatSharp.Entities.DiscordChannel.GetMessageAsync*)
-   Added the new field `AppPermissions` to the interaction entity and the context entities.
-   Added function [DiscordGuild.EnableMfaAsync](xref:DisCatSharp.Entities.DiscordGuild.EnableMfaAsync*)
-   Added function [DiscordGuild.DisableMfaAsync](xref:DisCatSharp.Entities.DiscordGuild.DisableMfaAsync*)
-   Reworked component result for modal submits [\*DC1](xref:changelogs_v10_10_1_0#dc1)
-   Reworked [DiscordIntegration](xref:DisCatSharp.Entities.DiscordIntegration) to include the new fields
    -   Added [SubscriberCount](xref:DisCatSharp.Entities.DiscordIntegration.SubscriberCount)
    -   Added [Revoked](xref:DisCatSharp.Entities.DiscordIntegration.Revoked)
    -   Added [Application](xref:DisCatSharp.Entities.DiscordIntegration.Application)
    -   Added [Scopes](xref:DisCatSharp.Entities.DiscordIntegration.Scopes)
    -   Removed int ExpireBehavior
    -   Added [ExpireBehavior](xref:DisCatSharp.Entities.DiscordIntegration.ExpireBehavior) as new enum [IntegrationExpireBehavior](xref:DisCatSharp.Enums.IntegrationExpireBehavior)
-   Reworked [DiscordConnection](xref:DisCatSharp.Entities.DiscordConnection) to include the new fields
    -   Removed int Visibility
    -   Added [Visibility](xref:DisCatSharp.Entities.DiscordConnection.Visibility) as new enum [ConnectionVisibilityType](xref:DisCatSharp.Enums.ConnectionVisibilityType)
    -   Added [TwoWayLink](xref:DisCatSharp.Entities.DiscordConnection.TwoWayLink)
-   [DiscordClient.ReconnectAsync](xref:DisCatSharp.DiscordClient.ReconnectAsync*) param startNewSession now defaults to `true`
-   Moved guild related enums from the [DisCatSharp](xref:DisCatSharp) to the [DisCatSharp.Enums](xref:DisCatSharp.Enums) namespace
-   Fixed webhooks for threads
-   Dropped support for channel banners, it sadly never made its way into discord

### DisCatSharp.ApplicationCommands

-   Added support for slash commands in shards
-   Added Translation Generator &amp; Exporter (see [here](xref:DisCatSharp.ApplicationCommands.ApplicationCommandsConfiguration.GenerateTranslationFilesOnly))
-   Added [DiscordClient.RemoveGlobalApplicationCommandsAsync](xref:DisCatSharp.DiscordClient.RemoveGlobalApplicationCommandsAsync*)
-   Implemented support for minimum_length and maximum_length for application command options
    -   Added [MinimumLengthAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumLengthAttribute). Minimum `int` if set: 0. Valid for: `string`
    -   Added [MaximumLengthAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumLengthAttribute). Minimum `int` if set: 1. Valid for: `string`
-   Changed namespaces
    -   [DisCatSharp.ApplicationCommands](xref:DisCatSharp.ApplicationCommands)
    -   [DisCatSharp.ApplicationCommands.Attributes](xref:DisCatSharp.ApplicationCommands.Attributes)
    -   [DisCatSharp.ApplicationCommands.Context](xref:DisCatSharp.ApplicationCommands.Context)
    -   [DisCatSharp.ApplicationCommands.Exceptions](xref:DisCatSharp.ApplicationCommands.Exceptions)
-   Renamed MinimumAttribute to [MinimumValueAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MinimumValueAttribute). Valid for: `int`, `long` &amp; `double`
-   Renamed MaximumAttribute &amp; [MaximumValueAttribute](xref:DisCatSharp.ApplicationCommands.Attributes.MaximumValueAttribute). Valid for: `int`, `long` &amp; `double`
-   Proper exception log when registering app commands fails
-   Reworked [translation](xref:modules_application_commands_translations_using) for application commands
-   Reworked application command registration
-   Fixed `DmPermissions` check for Application Commands on registration
-   Fixed double interaction bug
-   Fixed `int` &gt; `long` cast exception
-   Fixed a bug where the default help command would not work if auto defer was enabled
-   Various bug fixes
-   Removed `ApplicationCommandsExtension.CleanGuildCommandsAsync()`
-   Removed `ApplicationCommandsExtension.CleanGlobalCommandsAsync()`

### DisCatSharp.Lavalink

-   Added support for apple music &amp; spotify search

---

## Other changes

Please compare the commits on [GitHub](https://github.com/Aiko-IT-Systems/DisCatSharp/compare/10.0.0...v10.1.0)

## Information to other [Discord Features](https://discord.com/developers/docs/change-log)

-   We won&apos;t implement AutoMod for a while, as it takes a lot of time to implement and we don&apos;t have the time for it right now.
-   DiscordMember Timeout Events are still buggy, we have it on our list of bugs to fix, but it&apos;s not a priority right now.

## Diff Changes

### DC1

DiscordInteractionData:

Pulled up the component results from modal submits for easier access

```diff
- IEnumerable&lt;DiscordInteractionDataOption&gt; Options
+ IReadOnlyList&lt;DiscordInteractionDataOption&gt; Options
- IEnumerable&lt;DiscordActionRowComponentResult&gt; Components
+ IReadOnlyList&lt;DiscordComponentResult&gt; Components
```

DiscordActionRowComponentResult:

```diff
- List&lt;DiscordComponentResult&gt; Components
+ IReadOnlyList&lt;DiscordComponentResult&gt; Components
```</file><file path="DisCatSharp.Docs/changelogs/v10/10_2_0.md">---
uid: changelogs_v10_10_2_0
title: Version 10.2.0
author: DisCatSharp Team
---

# Upgrade from **10.1.0** to **10.2.0**

## What is new in DisCatSharp?

This release contains changes from Hacktoberfest tasks.

## What changed?

We worked hard during hacktober to make the lib better. Here&apos;s what we did:

---

### 10.2.0-hacktober-001

#### Changelog

```diff
+ Added stickers to guild preview (Task 3)
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/206

#### Contributors

-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-002

```diff
* Reworked activity invite creation
* Fixed forum channel creation, it now actually creates a forum (type 15) channel
+ Added article for available activities *1
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/208
-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/209

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)
-   [Lulalaby](https://github.com/Lulalaby)

#### New Articles

-   [Voice Activities](xref:misc_voice_activities)

---

### 10.2.0-hacktober-003

```diff
* Reworked various thinks like lists, arrays, namespaces
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/210

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)

---

### 10.2.0-hacktober-004

```diff
+ Added DiscordClient.GetGuildWidgetAsync
+ Added DiscordClient.TryGetGuildWidgetAsync
* Fixed a bug in guild widgets
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/211
-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/212

#### Contributors

-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-005

```diff
* Fixed the presence update event
- Removed PresenceUpdateEventArgs.UserBefore
- Removed PresenceUpdateEventArgs.UserAfter
```

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)

---

### 10.2.0-hacktober-006

```diff
* Fixed ModifyCommunitySettingsAsync (channels are now required to set when modifying the community state)
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/213

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)

---

### 10.2.0-hacktober-007

```diff
* Reworked guild features
* Changed the HasXy methods to flags (Enums)
+ Created a method for the enum named HasFeature(GuildFeatureFlag)
+ Created a method for the guild features to dynamically generate a string list of features
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/214

#### Contributors

-   [Sh1be](https://github.com/xMaxximum)

---

### 10.2.0-hacktober-008

&gt; [!WARNING]
&gt; This version contains breaking changes

#### Note

This version adds support for user, role, channel &amp; mentionable selects in both the main lib as well in interactivity.

```diff
- DiscordSelectComponent was removed and replaced by
+ DiscordStringSelectComponent + DiscordStringSelectComponentOption
+ Select component types have the base class DiscordBaseSelect from now on
* Interactivity for selects where changed in the InteractivityExtension, as well in the MessageExtension to have an additional required parameter before the timeout override called selectType. You need to specify for which select type you&apos;re waiting for
```

#### Documentation

##### DisCatSharp Package

Entities:

-   [DiscordBaseSelectComponent](xref:DisCatSharp.Entities.DiscordBaseSelectComponent) &gt; and the sub classes
    [DiscordStringSelectComponentOption](xref:DisCatSharp.Entities.DiscordStringSelectComponentOption) (Replaces `DiscordSelectComponentOption`)

Enums

-   [ComponentType](xref:DisCatSharp.Enums.ComponentType)

##### DisCatSharp.Interactivity

InteractivityExtension:

-   [WaitForSelectAsync](xref:DisCatSharp.Interactivity.InteractivityExtension.WaitForSelectAsync*) and additional functions

Message Extension:

-   [WaitForSelectAsync](xref:DisCatSharp.Interactivity.Extensions.MessageExtensions.WaitForSelectAsync*) and additional functions

#### Example

```cs
[SlashCommand(name: &quot;test_select&quot;, description: &quot;Testing select&quot;)]
public static async Task TestSelectAsync(InteractionContext ctx)
{
	await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral());
	DiscordWebhookBuilder builder = new();
	builder.WithContent(content: &quot;Testing user select&quot;);
	builder.AddComponents(new DiscordUserSelectComponent(label: &quot;User to select&quot;, custom_id: &quot;select_test_001&quot;, min_options: 1, max_options: 2, disabled: false));
	var msg = await ctx.EditResponseAsync(builder);
	var inter = await ctx.Client.GetInteractivity().WaitForSelectAsync(message: msg, id: &quot;select_test_001&quot;, selectType: ComponentType.UserSelect, timespan: TimeSpan.FromSeconds(30));
	if (!inter.TimedOut)
	{
		await inter.Result.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate);
		await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(content: $&quot;Selected {string.Join(&quot; &amp; &quot;, inter.Result.Values)}&quot;));
		await ctx.Channel.SendMessageAsync(content: $&quot;Ping pong {string.Join(&quot; &amp; &quot;, inter.Result.Interaction.Data.Resolved.Users.Values.Select(x =&gt; x.Mention))}&quot;);
	}
}
```

#### Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/218

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)
-   [Mira](https://github.com/TheXorog)

---

### 10.2.0-hacktober-010

```diff
+ Added method to look up additional infos about applications (rpc endpoint)
```

#### Documentation

-   [DiscordRpcApplication](xref:DisCatSharp.Entities.DiscordRpcApplication)
-   [DiscordClient.GetRpcApplicationAsync](xref:DisCatSharp.DiscordClient.GetRpcApplicationAsync*)
-   [DiscordUser.GetRpcInfoAsync](xref:DisCatSharp.Entities.DiscordUser.GetRpcInfoAsync*)

#### Contributors

-   [Lulalaby](https://github.com/Lulalaby)</file><file path="DisCatSharp.Docs/changelogs/v10/10_3_0.md">---
uid: changelogs_v10_10_3_0
title: Version 10.3.0
author: DisCatSharp Team
---

# Upgrade from **10.2.0** to **10.3.0**

## What is new in DisCatSharp?

Full support for [Auto Moderation](https://support.discord.com/hc/en-us/articles/4421269296535)

## What changed?

-   We fixed a bug with [DiscordChannelSelectComponent](xref:DisCatSharp.Entities.DiscordChannelSelectComponent) where the `channelTypes` property threw a null exception because incorrect array conversion.
-   Added support for new [UserFlags](xref:DisCatSharp.Enums.UserFlags) and [ApplicationFlags](xref:DisCatSharp.Enums.ApplicationFlags).
-   Application Commands support now the [`nsfw`](https://support.discord.com/hc/en-us/articles/10123937946007) parameter.

### Flags

#### Added user flags

-   `ActiveDeveloper`
-   `HighGlobalRateLimit`
-   `Deleted`
-   `DisabledSuspiciousActivity`
-   `SelfDeleted`

#### Renamed user flags

-   `PartnerOrVerificationApplication` was renamed to `InternalApplication`

#### Added application flags

-   `Active`

### Auto Moderation

-   The events for automoderation rules and executions are fully implemented.
-   Support for creating, updating and deleting rules.
-   Support for fetching rules.
-   Support for automod regex rules.
-   Intents for automod.

## Pull Requests

-   https://github.com/Aiko-IT-Systems/DisCatSharp/pull/224

## Contributors

-   [Sh1be](https://github.com/xMaxximum)
-   [Lulalaby](https://github.com/Lulalaby)
-   [Mira](https://github.com/TheXorog)</file><file path="DisCatSharp.Docs/changelogs/v10/10_4_0.md">---
uid: changelogs_v10_10_4_0
title: Version 10.4.0
author: DisCatSharp Team
---

# Upgrade from **10.3.0** to **10.4.0**

&lt;br/&gt;

&gt; [!NOTE]
&gt; DisCatSharp is now compiled with .NET 7.0.

&gt; [!IMPORTANT]
&gt; The namespaces were adjusted to fit the actual location.

---

## What Is New In DisCatSharp?

&lt;br/&gt;

🆕 **Added [DisCatSharp Analyzer](xref:vs) to help you write better code**

🆕 Support for the new [Username System](https://dis.gd/usernames)

🆕 Support for [Linked Roles](https://discord.com/build/linked-roles)

🆕 Support for [Application Subscriptions](https://discord.com/build/apply-now) aka Premium Apps

🆕 Support for [Voice Messages](https://support.discord.com/hc/en-us/articles/13091096725527)

🆕 Support for sending [`@silent`](https://discord.com/blog/discord-update-february-20-2023-changelog#heading-1) messages

🧪 Partial support for role subscriptions

🧪 Partial support for burst reactions

🧪 Partial support for onboarding

🛠️ Fixed a bug where various flag enums were missing the `[Flags]` annotation.

---

## What Changed?

&lt;br/&gt;

### DisCatSharp

#### [DiscordClient](xref:DisCatSharp.DiscordClient)

➕ Added [GenerateInAppOauthFor](xref:DisCatSharp.DiscordClient.GenerateInAppOauthFor*) to generate an oauth link for other apps.

➕ Added [GetCurrentApplicationInfoAsync](xref:DisCatSharp.DiscordClient.GetCurrentApplicationInfoAsync*) to get the current application info.

➕ Added the [GuildAuditLogEntryCreated](xref:DisCatSharp.DiscordClient.GuildAuditLogEntryCreated) to the [DiscordClient](xref:DisCatSharp.DiscordClient). The implementation is currently unstable.

➕ Added `AutoModerationConfiguration` and `AutoModerationExecution` to [DiscordIntent](xref:DisCatSharp.Enums.DiscordIntents). This is included in `AllUnprivileged` and `All`.

➕ Added TryGetPublishedListings to get the published premium sku listings for an application.

⚠️ Removed `GuildBans` from [DiscordIntents](xref:DisCatSharp.Enums.DiscordIntents) and replaced it with `GuildModeration`.

#### [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration)

⚠️ Deprecated `UseCanary` &amp; `UsePtb`.

➕ Added [ApiChannel](xref:DisCatSharp.DiscordConfiguration.ApiChannel).

`UseCanary` &amp; `UsePtb` temporarily set `ApiChannel` internally:
[!code-csharp[](../../../DisCatSharp/DiscordConfiguration.cs#L220-L229)]

#### [DiscordApplication](xref:DisCatSharp.Entities.DiscordApplication)

➕ Added [ApproximateGuildCount](xref:DisCatSharp.Entities.DiscordApplication.ApproximateGuildCount) to get the approximate guild count.

➕ Added [InteractionsEndpointUrl](xref:DisCatSharp.Entities.DiscordApplication.InteractionsEndpointUrl) to get the interactions endpoint url set in the developer portal.

➕ Added [RedirectUris](xref:DisCatSharp.Entities.DiscordApplication.RedirectUris) to get the redirect uris set in the developer portal.

➕ Added [Guild](xref:DisCatSharp.Entities.DiscordApplication.Guild) to get the guild this application is linked to as support server.

➕ Added support for application subscriptions. See [this](#application-subscription) for more information.

➕ Added enum `DisCatSharp.Enums.ApplicationCommandContexts`. This field isn&apos;t added for now.

#### [DiscordInteraction](xref:DisCatSharp.Entities.DiscordInteraction)

➕ Added the options `AsSilentMessage` and `SuppressEmbeds` to [DiscordFollowupMessageBuilder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder), [DiscordInteractionResponseBuilder](xref:DisCatSharp.Entities.DiscordInteractionResponseBuilder) and [DiscordWebhookBuilder](xref:DisCatSharp.Entities.DiscordWebhookBuilder).

➕ Added [Entitlements](xref:DisCatSharp.Entities.DiscordInteraction.Entitlements) to get the entitlements for premium apps.

➕ Added [InteractionResponseType](xref:DisCatSharp.Enums.InteractionResponseType) `InteractionRequireEntitlement`.

#### [DiscordRole](xref:DisCatSharp.Entities.DiscordRole)

➕ Added `IsLinkedRole` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to check whether this role is a linked role.

➕ Added `SubscriptionListingId` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to get the subscription listing id.

➕ Added `AvailableForPurchase` to [DiscordRole.Tags](xref:DisCatSharp.Entities.DiscordRole.Tags) to check whether this role is available for purchase.

#### [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild)

➕ Added [SafetyAlertsChannel](xref:DisCatSharp.Entities.DiscordGuild.SafetyAltersChannel) to get the safety alerts channel and the corresponding function [ModifySafetyAlertsSettingsAsync](xref:DisCatSharp.Entities.DiscordGuild.ModifySafetyAlertsSettingsAsync*) to modify the safety alerts settings.

#### [AutomodRule](xref:DisCatSharp.Entities.AutomodRule)

➕ Added [MentionRaidProtectionEnabled](xref:DisCatSharp.Entities.AutomodTriggerMetadata.MentionRaidProtectionEnabled) to [AutomodTriggerMetadata](xref:DisCatSharp.Entities.AutomodTriggerMetadata).

➕ Added `TriggerType` `EnforceServerRules`. This is currently in alpha.

#### [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel)

➕ Added `scheduledEventId` to [DiscordChannel.OpenStageAsync](xref:DisCatSharp.Entities.DiscordChannel.OpenStageAsync*) to create a stage channel bound to a scheduled event.

➕ Added new [ChannelFlags](xref:DisCatSharp.Enums.ChannelFlags):

-   `IsBroadcasting`
-   `IsRoleSubscriptionTemplatePreviewChannel`
-   `ApplicationShelfConsent`
-   `SummariesDisabled`
-   `IsMediaChannel`
-   `IsScheduledForDeletion`
-   `ClydeAi`
-   `IsGuildResourceChannel`
-   `IsSpam`

⚠️ Removed `privacyLevel` from [DiscordChannel.OpenStageAsync](xref:DisCatSharp.Entities.DiscordChannel.OpenStageAsync*) as it&apos;s no longer supported by discord.

#### [DiscordThreadChannel](xref:DisCatSharp.Entities.DiscordThreadChannel)

➕ Added [LockAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.LockAsync*) to lock a thread.

➕ Added [UnlockAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.UnlockAsync*) to unlock a thread.

➕ You can now pin posts in forum channels.

❕ [Thread members](xref:DisCatSharp.Entities.DiscordThreadChannel.GetMembersAsync*) are now paginated.

⚠️ Deprecated parameter `locked` from [ArchiveAsync](xref:DisCatSharp.Entities.DiscordThreadChannel.ArchiveAsync*) as it&apos;s no longer supported by discord.

#### [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage)

➕ Added support for voice messages. Flag `IsVoiceMessage` is set to represented if the message is a voice message.

➕ Added new [MessageTypes](xref:DisCatSharp.Enums.MessageType):

-   `PrivateChannelIntegrationAdded`
-   `PrivateChannelIntegrationRemoved`
-   `PremiumReferral`

#### [DiscordAttachment](xref:DisCatSharp.Entities.DiscordAttachment)

➕ Added [DurationSecs](xref:DisCatSharp.Entities.DiscordAttachment.DurationSecs) to get the duration of a voice message.

➕ Added [WaveForm](xref:DisCatSharp.Entities.DiscordAttachment.WaveForm) to get the waveform of a voice message. This is a base64 encoded byte-array representing a sampled waveform.

#### [DiscordReaction](xref:DisCatSharp.Entities.DiscordReaction)

&gt; [!WARNING]
&gt; Reactions are undergoing a rework which is not covered in this release.

🧪 Partial support for burst reactions.

#### [DiscordUser](xref:DisCatSharp.Entities.DiscordUser)

➕ Added [CreateDmChannelAsync](xref:DisCatSharp.Entities.DiscordUser.CreateDmChannelAsync*) to create a dm channel with this user.

➕ Added [SendMessageAsync](xref:DisCatSharp.Entities.DiscordUser.SendMessageAsync*) to send a message to this user.

➕ Added `Collaborator` and `RestrictedCollaborator` to [UserFlags](xref:DisCatSharp.Entities.DiscordUser.Flags) to check whether this user is a collaborator.

➕ Added support for the new [Username System](https://dis.gd/usernames). See [this](#username-system-change) for more information.

➕ Added [GlobalName](xref:DisCatSharp.Entities.DiscordUser.GlobalName) to get the global name of this user.

➕ Added [UsernameWithGlobalName](xref:DisCatSharp.Entities.DiscordUser.UsernameWithGlobalName) to get the username with the global name of this user.

➕ Added [IsMigrated](xref:DisCatSharp.Entities.DiscordUser.IsMigrated) to check whether this user is migrated to the new [Username System](https://dis.gd/usernames).

🛠️ Fixed a bug causing `Locale` to be null.

⚠️ Deprecated [UsernameWithDiscriminator](xref:DisCatSharp.Entities.DiscordUser.UsernameWithDiscriminator).

⚠️ Deprecated [Discriminator](xref:DisCatSharp.Entities.DiscordUser.Discriminator).

#### [DiscordMember](xref:DisCatSharp.Entities.DiscordMember)

➕ Added method [VerifyAsync](xref:DisCatSharp.Entities.DiscordMember.VerifyAsync*) to verify a member. This skips the verification requirements when onboarding is enabled.

➕ Added method [UnverifyAsync](xref:DisCatSharp.Entities.DiscordMember.UnverifyAsync*) to unverify a member.

➕ Added new [MemberFlags](xref:DisCatSharp.Enums.MemberFlags):

-   `BypassesVerification`
-   `StartedOnboarding`
-   `CompletedOnboarding`
-   `IsGuest`
-   `StartedHomeActions`
-   `CompletedHomeActions`
-   `AutomodQuarantinedUsernameOrGuildNickname`
-   `AutomodQuarantinedBio`

#### [DiscordInvite](xref:DisCatSharp.Entities.DiscordInvite)

➕ Added new [TargetType](xref:DisCatSharp.Enums.TargetType)s.

➕ Added new [InviteFlags](xref:DisCatSharp.Enums.InviteFlags).

#### [Permissions](xref:DisCatSharp.Enums.Permissions)

➕ Added `CreateGuildExpressions`

➕ Added `CreateEvents`

➕ Added `UseSoundboard`

➕ Added `UseExternalSounds`

➕ Added `SendVoiceMessages`

⚠️ Renamed `ManageExpressions` to `ManageGuildExpressions`

⚠️ Removed `ManageEmojisAndStickers`

#### [Formatter](xref:DisCatSharp.Formatter)

🛠️ All methods are now extension methods.

➕ Added support for extended markdown.

### DisCatSharp.ApplicationCommands

➕ You can now register guild commands via assembly. This doesn&apos;t support translations tho.

➕ Added [Entitlements](xref:DisCatSharp.ApplicationCommands.Context.BaseContext.Entitlements) to BaseContext.

➕ Added support for application subscriptions.

➕ Added ApplicationCommandRequireEntitlementAttribute to require an entitlement to execute a command.

🛠️ Fixed a bug preventing you to set `DmPermission` for ContextMenu commands.

### DisCatSharp.VoiceNext

🛠️ Fixed the ip discovery used to connect to discord voice servers.

Discord changed this suddenly without heads up.

Thanks to [disgo](https://github.com/disgoorg/disgo/) for helping out.

---

## Username System Change

&lt;br/&gt;

### [Preamble](#tab/username-sys-pre)

Official resources:

-   https://dis.gd/usernames
-   https://dis.gd/app-usernames
-   https://discord.com/blog/usernames

### [The Discord Announcement](#tab/username-sys-discord)

#### Impact of Unique Usernames on Apps and Bots

Discord announced that Discord’s username system is changing. Discriminators are being removed and new, unique usernames (`@name`) and display names are being introduced. These changes will make it easier for users to connect with their friends and give more control over identity on Discord. You can visit https://discord.com/blog/usernames to hear from one of their founders about why usernames are changing, or read more details about how changes to the username system affects non-bot users at https://dis.gd/usernames.

#### More details for developers (including an FAQ) are in the Help Center article:

-   https://dis.gd/app-usernames

Below is an overview of how apps and bots will be affected by the username change. More details for developers, including exact dates, will be communicated soon.

#### Changes to bot users on Discord

1. They recently made a change to add bot users to all newly-created apps. During the username migration, all apps without a bot user created before April 14 will have a bot user automatically added. If your app doesn’t require a bot user, you can skip adding the `bot` scope during installation.

2. After migration, developers will no longer be able to directly set bot usernames or bot icons. The bot user’s icon will _always_ be the same as the App Icon. Bot usernames will be determined differently for verified and unverified apps:

-   **Verified apps**: Bot usernames will be determined by the Application Name. When an unverified app goes through the verification process, a username created from the Application Name will be given to the bot user.
-   **Unverified apps**: Bot usernames will be randomized for new and existing unverified apps. This does not affect the Application Name.

3. Application Names (the `Name` field on the **General Overview** page within the app’s settings) will be used as the Display Name for an app’s bot user. This means developers cannot manually update the Display Name for a bot user without updating the Application Name. Server nicknames are unaffected by this change.

4. The Discord client will be updated to only display Application Names in most surfaces, including the bot profile and in the search interface. The client changes will allow all Discord apps, verified and unverified, to use their Application Name as the identity for their app (and bot) across Discord.

#### Migration of verified app usernames

Most verified apps with Application Names which can be automatically migrated to the new username system have been reserved. No user will be able to claim the reserved username, and during migration the reserved name will be automatically given to the app&apos;s bot user.

Verified apps that cannot be automatically migrated or wish to change their Application Name for another reason will be able to make a one-time change at the time of migration.

#### Identifying migrated users

To keep clients backwards-compatible, users that are migrated to the new username system will have a single zero (`#0`) discriminator. This will not appear in the client, but will be in payloads your app receives. After the migration to the new username system is complete, the `0` discriminator will be removed.

#### Preparing your app for username changes

-   Remove any logic that depends on discriminators for Discord users. Apps should continue using user IDs to uniquely identify Discord users in their code. Make sure to account for the temporary `#0` discriminator that updated users will have when updating your code.
-   Be prepared for your username change. That includes in code, or anywhere else you may reference your bot username.
-   If your app is verified, stay tuned for details about migration dates and how to perform a one-time update for your Application Name/bot username.

### [DisCatSharps Info](#tab/username-sys-discatsharp)

#### Developer take on the username change for bots

Bots having `Username#Discrim` is pretty useless imo.
`Username#Discrim`s only purpose is to add friends, but you can&apos;t add bots as friends.

A single `@username` makes more sense for bots because it acts as a vanity identifier.

Now you could argue about the fact that non-verified bots usernames are randomized.
That might be true, but users see the application name anyways in the UI, and this field is changeable.
Upon verification you can choose your custom `@username`.

I think this helps fighting scams and impersionations even more.

#### Transition to global name

We&apos;ve deprecated `Discriminator` &amp; `DiscriminatorInt` on the [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) &amp; [DiscordMember](xref:DisCatSharp.Entities.DiscordMember) entities.

Due to global name not being rolled out yet, `GlobalName` is marked as experimental for now.

During the rollout we&apos;ll remove the experimental mark from `GlobalName`.

You should update to this new field as soon as possible when the rollout begins.

As an example how to handle both cases:

[!code-csharp[](../../snippets/global_name.cs?highlight=13)]

#### New, changed and deprecated fields

These changes apply both for [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) &amp; [DiscordMember](xref:DisCatSharp.Entities.DiscordMember).

| Change Type | Field or Function         | Type            | Change Description                                                                     |
| ----------- | ------------------------- | --------------- | -------------------------------------------------------------------------------------- |
| Deprecated  | Discriminator             | @System.String  |                                                                                        |
| Deprecated  | DiscriminatorInt          | @System.Int32   |                                                                                        |
| Deprecated  | UsernameWithDiscriminator | @System.String  | This falls back to `UsernameWithGlobalName` for a while if a user is already migrated. |
| Added       | UsernameWithGlobalName    | @System.String  |                                                                                        |
| Added       | GlobalName                | @System.String  |                                                                                        |
| Added       | IsMigrated                | @System.Boolean | Helper function to detect whether a user has is enrolled in the new system.            |
| Changed     | ToString()\*              | @System.String  | Function was updated to return the correct info based on `IsMigrated`                  |

\*This was also changed for [DiscordTeamMember.ToString()](xref:DisCatSharp.Entities.DiscordTeamMember.ToString)

#### Automatic Mapping

To help you transition to this change, we automatically map the old username with discriminator to the new username with global name.

```mermaid
flowchart LR

A([UsernameWithDiscriminator]) --&gt; B{IsMigrated}
B --&gt;|True| C([Using UsernameWithGlobalName])
B --&gt;|False| D([Using Username#Discriminator])
```

---

---

## Application Subscription

&lt;br/&gt;

### [Preamble](#tab/appsub-pre)

We would like to announce that we have added partial support for Discord&apos;s Premium Apps feature. However, please note that this feature is currently in alpha and may not be fully supported by our library as library developers don&apos;t get access to the documentation for it.

Premium Apps allow developers to provide premium commands for which users can subscribe via in-app purchases. If a user is not subscribed, bots will respond with a message asking them to subscribe. If they are subscribed, the command payload from Discord to the bot will have a SKU ID set, indicating that the user or server is subscribed.

Although our library has implemented support for this feature, you might need to make adjustments to your code to fully utilize it. If you encounter any issues or require assistance, please inform us so that we can address the issue within the library.

### [Premium Apps](#tab/appsub-pa)

![premium_app_popout_profile](/images/premium_app_popout_profile.png)

![premium_app_popout_description](/images/premium_app_popout_description.png)

![premium_app_app_discovery](/images/premium_app_app_discovery.png)

### [Implementation](#tab/appsub-impl)

#### DisCatSharp

We&apos;ve added the field [Entitlements](xref:DisCatSharp.Entities.DiscordInteraction.Entitlements) to get the entitlements for premium apps.
It is a list of sku ids.

[InteractionResponseType](xref:DisCatSharp.Enums.InteractionResponseType) was extended by type `10` called `InteractionRequireEntitlement`. This is used to tell Discord that the user is not entitled to use the command and requests the user to buy the premium subscription.

Additionally we&apos;ve added the function TryGetPublishedListings to get the published premium sku listings for an application.
You can use it to check dynamically for your sku ids.

#### DisCatSharp.ApplicationCommands

Application commands got a new @System.Attribute called ApplicationCommandRequireEntitlementAttribute to require an entitlement to execute a command.

BaseContext now has the field [Entitlements](xref:DisCatSharp.ApplicationCommands.Context.BaseContext.Entitlements).

---

---

## Pull Requests

-   [feat: Paginated thread members](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/253)
-   [feat: Add guild audit log entry create event](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/256)
-   [fix: ip discovery](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/274)
-   [feat: Application rework](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/275)
-   [fix: speaking is flags not bool](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/276)
-   [fix(readme): minor grammar mistake](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/280)
-   [fix: DiscordEmoji operator == add compare name](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/284)
-   [DisCatSharp v10.4.0 Stable Release](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/295)

[Full Changes](https://github.com/Aiko-IT-Systems/DisCatSharp/compare/v10.3.2...v10.4.0)

---

## Contributors

-   [JustaSqu1d](https://github.com/JustaSqu1d)
-   [tonnac](https://github.com/tonnac)
-   [Lulalaby](https://github.com/Lulalaby)
-   [TheXorog](https://github.com/TheXorog)
-   [TopiSenpai](https://github.com/TopiSenpai)
-   [quinchs](https://github.com/quinchs)
-   [JuliaJJ](https://github.com/JuliaJJ/)

---

## Special Thanks

This release special thanks go to:

-   [snek](https://github.com/devsnek) for helping out with details about the premium apps implementation 😝
-   [TopiSenpai](https://github.com/TopiSenpai) for helping out with fixing the ip discovery
-   [quinchs](https://github.com/quinchs) for advising a good change I (Lala) totally forgot about
-   [JuliaJJ](https://github.com/JuliaJJ/) for helping out with design choice

---</file><file path="DisCatSharp.Docs/natives/index.md">---
uid: natives
title: Native Libraries
author: DisCatSharp Team
---

# Downloads

| Operating System   | Download                                           |
| ------------------ | -------------------------------------------------- |
| 64-bit Windows     | [Click Here](/natives/vnext_natives_win32_x64.zip) |
| 32-bit Windows     | [Click Here](/natives/vnext_natives_win32_x86.zip) |

# Licenses

| Library   | License                                                   |
| --------- | --------------------------------------------------------- |
| Opus      | https://opus-codec.org/license/                           |
| libsodium | https://github.com/jedisct1/libsodium/blob/master/LICENSE |</file><file path="DisCatSharp.Docs/snippets/global_name.cs">internal class SlashCommand : ApplicationCommandsModule
⋮----
internal static async Task ExecuteCommandAsync(InteractionContext ctx)
⋮----
await ctx.CreateResponseAsync(
⋮----
new DiscordInteractionResponseBuilder().WithContent($&quot;Your name: {name}&quot;)</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0001.md">---
uid: vs_analyzer_dcs_0001
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0001

You try to use an experimental field, function or similar.

This is mostly not stable and can change at any time.

It&apos;s recommended to not use this in production.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0002.md">---
uid: vs_analyzer_dcs_0002
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0002

You try to use an deprecated field, function or similar.

This will be removed in the next release(s).

It&apos;s recommended to update your code to use the new field, function or similar.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0101.md">---
uid: vs_analyzer_dcs_0101
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0101

You try to use an field, function or similar which is in experiment by discord.

Most experiments aren&apos;t stable and subject to change at any time.

Use carefully and at your own risk.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0102.md">---
uid: vs_analyzer_dcs_0102
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0102

You try to use an field, function or similar which is deprecated by discord.

Don&apos;t use this anymore. It will be removed in the future.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0103.md">---
uid: vs_analyzer_dcs_0103
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0103

You try to use an field, function or similar which isn&apos;t released yet by discord.

Use carefully and at your own risk.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0200.md">---
uid: vs_analyzer_dcs_0200
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0200

This needs special features to be enabled / set.</file><file path="DisCatSharp.Docs/vs/analyzer/dcs/0201.md">---
uid: vs_analyzer_dcs_0201
title: Visual Studio Tools
author: DisCatSharp Team
---

# DisCatSharp Analyzer Rule DCS0201

This needs a special override, otherwise it will not work.

We provide a override value, which is known to work.

But you can use newer ones, if you want to.

We provide a codefix for this, which tries to set the best possible `Override` value to your [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).</file><file path="DisCatSharp.Docs/vs/index.md">---
uid: vs
title: Visual Studio Tools
author: DisCatSharp Team
---

# Visual Studio Tools

This section contains information on how to use the Visual Studio tools for developing bots with DisCatSharp.

## Analyzers &amp; Code Fixes

DisCatSharp can be extended with a set of analyzers that can help you write better code. These analyzers will warn you about common mistakes and bad practices.

### DisCatSharp Analyzer

#### Installation

To use the DisCatSharp Analyzer, you need to install the [DisCatSharp.Analyzer](https://www.nuget.org/packages/DisCatSharp.Analyzer) NuGet package.

##### Visual Studio Code

Enable `omnisharp.enableRoslynAnalyzers` in your settings.

##### JetBrains Rider

See https://www.jetbrains.com/help/rider/Settings_Roslyn_Analyzers.html

#### Included Rules

| Rule ID                              | Category | Severity | Notes                                  |
| ------------------------------------ | -------- | -------- | -------------------------------------- |
| [DCS0001](xref:vs_analyzer_dcs_0001) | Usage    | Info     | Experimental Attribute Analyzer        |
| [DCS0002](xref:vs_analyzer_dcs_0002) | Usage    | Error    | Deprecated Attribute Analyzer          |
| [DCS0101](xref:vs_analyzer_dcs_0101) | Usage    | Warning  | DiscordInExperiment Attribute Analyzer |
| [DCS0102](xref:vs_analyzer_dcs_0102) | Usage    | Error    | DiscordDeprecated Attribute Analyzer   |
| [DCS0103](xref:vs_analyzer_dcs_0103) | Usage    | Warning  | DiscordUnreleased Attribute Analyzer   |
| [DCS0200](xref:vs_analyzer_dcs_0200) | Usage    | Info     | RequiresFeature Attribute Analyzer     |
| [DCS0201](xref:vs_analyzer_dcs_0201) | Usage    | Warning  | RequiresOverride Attribute Analyzer    |</file><file path="DisCatSharp.Experimental/AudioHelper.cs">/// &lt;summary&gt;
///     Represents various &lt;see cref=&quot;AudioHelper&quot; /&gt;s.
/// &lt;/summary&gt;
public static class AudioHelper
⋮----
///     Gets the audio duration in seconds.
⋮----
/// &lt;param name=&quot;opusStream&quot;&gt;The audio stream.&lt;/param&gt;
/// &lt;returns&gt;The duration in seconds.&lt;/returns&gt;
public static (Stream Stream, float DurationSeconds) GetOpusAudioDurationInSeconds(this Stream opusStream)
⋮----
opusStream.Seek(0, SeekOrigin.Begin);
⋮----
using var decoder = OpusCodecFactory.CreateDecoder(48000, 1);
var oggIn = new OpusOggReadStream(decoder, opusStream);
⋮----
var packet = oggIn.DecodeNextPacket();
⋮----
? throw new InvalidOperationException(&quot;Voice message duration exceeds the maximum allowed length of 20 minutes.&quot;)
⋮----
///     Generates the waveform data.
⋮----
/// &lt;param name=&quot;maxWaveformSize&quot;&gt;The maximal waveform size.&lt;/param&gt;
/// &lt;returns&gt;The waveform as a byte array.&lt;/returns&gt;
public static (Stream Stream, byte[] Waveform) GenerateWaveformBytes(this Stream opusStream, int maxWaveformSize = 200)
⋮----
: Math.Abs(t);
⋮----
///     Generates the waveform bytes and calculates the duration in seconds.
⋮----
/// &lt;returns&gt;The generated data.&lt;/returns&gt;
public static (float DurationSeconds, byte[] Waveform) GetDurationAndWaveformBytes(this Stream opusStream)
⋮----
///     Converts an input stream to Discord&apos;s expected voice message format.
⋮----
/// &lt;param name=&quot;inputStream&quot;&gt;The audio source stream.&lt;/param&gt;
/// &lt;returns&gt;The audio result stream.&lt;/returns&gt;
public static async Task&lt;Stream&gt; ConvertToOggOpusAsync(this Stream inputStream)
⋮----
inputStream.Seek(0, SeekOrigin.Begin);
var outputStream = new MemoryStream();
var tempFileName = Path.GetTempFileName();
await using (var fileStream = new FileStream(tempFileName, FileMode.Create, FileAccess.Write))
⋮----
await inputStream.CopyToAsync(fileStream);
⋮----
var ffmpeg = new ProcessStartInfo
⋮----
Console.WriteLine(&quot;Starting FFmpeg process...&quot;);
var process = Process.Start(ffmpeg) ?? throw new InvalidOperationException(&quot;Failed to start FFmpeg process&quot;);
⋮----
if (!string.IsNullOrWhiteSpace(e.Data))
Console.WriteLine($&quot;FFmpeg error: {e.Data}&quot;);
⋮----
Console.WriteLine(&quot;Copying input stream to FFmpeg...&quot;);
await inputStream.CopyToAsync(process.StandardInput.BaseStream);
process.StandardInput.Close();
⋮----
Console.WriteLine(&quot;Reading output stream from FFmpeg...&quot;);
await process.StandardOutput.BaseStream.CopyToAsync(outputStream);
process.StandardOutput.Close();
⋮----
Console.WriteLine(&quot;Waiting for FFmpeg process to exit...&quot;);
var processTask = process.WaitForExitAsync();
if (await Task.WhenAny(processTask, Task.Delay(TimeSpan.FromMinutes(5))) == processTask)
Console.WriteLine(&quot;FFmpeg process completed successfully.&quot;);
⋮----
process.Kill();
throw new TimeoutException(&quot;FFmpeg process timed out.&quot;);
⋮----
throw new InvalidOperationException($&quot;FFmpeg process failed with exit code {process.ExitCode}.&quot;);
⋮----
Console.WriteLine($&quot;An error occurred during the FFmpeg process: {ex.Message}&quot;);
⋮----
outputStream.Seek(0, SeekOrigin.Begin);
process.Dispose();
await inputStream.DisposeAsync();
File.Delete(tempFileName);</file><file path="DisCatSharp.Experimental/DisCatSharpExtensions.cs">/// &lt;summary&gt;
///     Represents experimental extension methods for DisCatSharp.
/// &lt;/summary&gt;
public static class DisCatSharpExtensions
⋮----
/// This is a test method to test the functionality of DisCatSharp.Experimental and the DisCatSharp.Analyzer.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;id&quot;&gt;The id of the user to get the username of.&lt;/param&gt;
/// &lt;returns&gt;The username of the user with the given id.&lt;/returns&gt;
⋮----
public static async Task&lt;string&gt; GetUsernameAsync(this DiscordClient client, ulong id)
⋮----
var user = await client.ApiClient.GetUserAsync(id);
⋮----
///     Gets the clyde profile for the given &lt;paramref name=&quot;profileId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;profileId&quot;&gt;The profile id to get.&lt;/param&gt;
⋮----
internal static async Task&lt;ClydeProfile&gt; GetClydeProfileAsync(this DiscordClient client, ulong profileId)
⋮----
DiscordApiClientHook hook = new(client.ApiClient);
return await hook.GetClydeProfileAsync(profileId);
⋮----
///     Gets the clyde settings for the given &lt;paramref name=&quot;guild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild to get clyde&apos;s settings for.&lt;/param&gt;
⋮----
internal static async Task&lt;ClydeSettings&gt; GetClydeSettingsAsync(this DiscordGuild guild)
⋮----
DiscordApiClientHook hook = new(guild.Discord.ApiClient);
return await hook.GetClydeSettingsAsync(guild.Id);
⋮----
///     Modifies the clyde settings for the given &lt;paramref name=&quot;guild&quot; /&gt; by applying a &lt;paramref name=&quot;profileId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild to modify clyde&apos;s settings for.&lt;/param&gt;
/// &lt;param name=&quot;profileId&quot;&gt;The profile id to apply.&lt;/param&gt;
⋮----
internal static async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(this DiscordGuild guild, ulong profileId)
⋮----
return await hook.ModifyClydeSettingsAsync(guild.Id, profileId);
⋮----
///     Modifies the clyde settings for the given &lt;paramref name=&quot;guild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The new name.&lt;/param&gt;
/// &lt;param name=&quot;personality&quot;&gt;The new basePersonality.&lt;/param&gt;
/// &lt;param name=&quot;avatar&quot;&gt;The new avatar.&lt;/param&gt;
/// &lt;param name=&quot;banner&quot;&gt;The new banner.&lt;/param&gt;
/// &lt;param name=&quot;themeColors&quot;&gt;The new theme colors.&lt;/param&gt;
⋮----
internal static async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(
⋮----
return await hook.ModifyClydeSettingsAsync(guild.Id, name, personality, MediaTool.Base64FromStream(avatar), MediaTool.Base64FromStream(banner),
⋮----
? themeColors.Value.Select(x =&gt; x.Value).ToList()
⋮----
///     Generates a basePersonality for clyde based on the given &lt;paramref name=&quot;basePersonality&quot; /&gt;.
⋮----
/// &lt;param name=&quot;basePersonality&quot;&gt;The base base personality to generate a new one from.&lt;/param&gt;
⋮----
internal static async Task&lt;string&gt; GenerateClydePersonalityAsync(this DiscordClient client, string? basePersonality = null)
⋮----
return await hook.GenerateClydePersonalityAsync(basePersonality);</file><file path="DisCatSharp.Experimental/DiscordApiClientHook.cs">/// &lt;summary&gt;
///     Represents a hook for the discord api client.
/// &lt;/summary&gt;
internal sealed class DiscordApiClientHook
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApiClientHook&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;apiClient&quot;&gt;The api client.&lt;/param&gt;
⋮----
///     Gets the api client.
⋮----
///     Gets the clyde profile for the given &lt;paramref name=&quot;profileId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;profileId&quot;&gt;The profile id to get.&lt;/param&gt;
⋮----
internal async Task&lt;ClydeProfile&gt; GetClydeProfileAsync(ulong profileId)
⋮----
var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.GET, route, new
⋮----
var url = Utilities.GetApiUriFor(path, this.ApiClient.Discord.Configuration);
var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.GET, route).ConfigureAwait(false);
⋮----
///     Gets the clyde settings for the given &lt;paramref name=&quot;guildId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to get clyde&apos;s settings for.&lt;/param&gt;
⋮----
internal async Task&lt;ClydeSettings&gt; GetClydeSettingsAsync(ulong guildId)
⋮----
///     Modifies the clyde settings for the given &lt;paramref name=&quot;guildId&quot; /&gt; by applying a &lt;paramref name=&quot;profileId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to modify clyde&apos;s settings for.&lt;/param&gt;
/// &lt;param name=&quot;profileId&quot;&gt;The profile id to apply.&lt;/param&gt;
⋮----
internal async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(ulong guildId, ulong profileId)
⋮----
ClydeSettingsProfileIdOnlyUpdatePayload pld = new()
⋮----
var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.PATCH, route, new
⋮----
var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
var obj = JObject.Parse(res.Response);
var settingsString = obj.GetValue(&quot;settings&quot;)!.ToString();
⋮----
///     Modifies the clyde settings for the given &lt;paramref name=&quot;guildId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The new name.&lt;/param&gt;
/// &lt;param name=&quot;personality&quot;&gt;The new basePersonality.&lt;/param&gt;
/// &lt;param name=&quot;avatarBase64&quot;&gt;The new avatar.&lt;/param&gt;
/// &lt;param name=&quot;bannerBase64&quot;&gt;The new banner.&lt;/param&gt;
/// &lt;param name=&quot;themeColors&quot;&gt;The new theme colors.&lt;/param&gt;
⋮----
internal async Task&lt;ClydeSettings&gt; ModifyClydeSettingsAsync(
⋮----
ClydeSettingsProfileUpdatePayload pld = new()
⋮----
///     Generates a basePersonality for clyde based on the given &lt;paramref name=&quot;basePersonality&quot; /&gt;.
⋮----
/// &lt;param name=&quot;basePersonality&quot;&gt;The base base personality to generate a new one from.&lt;/param&gt;
⋮----
internal async Task&lt;string&gt; GenerateClydePersonalityAsync(string? basePersonality = null)
⋮----
PersonalityGenerationPayload pld = new()
⋮----
var bucket = this.ApiClient.Rest.GetBucket(RestRequestMethod.POST, route, new
⋮----
var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Searches the guild members asynchronously based on the provided search parameters.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The ID of the guild.&lt;/param&gt;
/// &lt;param name=&quot;searchParams&quot;&gt;The search parameters.&lt;/param&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotIndexedException&quot;&gt;Thrown if the elastisearch endpoint has not finished indexing yet.&lt;/exception&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
/// &lt;returns&gt;A list of supplemental guild members that match the search criteria.&lt;/returns&gt;
internal async Task&lt;DiscordSearchGuildMembersResponse&gt; SearchGuildMembersAsync(ulong guildId, DiscordGuildMemberSearchParams searchParams)
⋮----
var (isValid, errorMessage) = searchParams.Validate();
⋮----
throw new ValidationException(
⋮----
var pld = DiscordJson.SerializeObject(searchParams);
⋮----
var res = await this.ApiClient.DoRequestAsync(this.ApiClient.Discord, bucket, url, RestRequestMethod.POST, route, payload: pld).ConfigureAwait(false);
⋮----
throw new NotIndexedException(res);
⋮----
var usr = new DiscordUser(supplementalMember.TransportMember.User)
⋮----
this.ApiClient.Discord.UserCache.AddOrUpdate(supplementalMember.TransportMember.User.Id, usr, (id, old) =&gt;
⋮----
internal async Task&lt;GcpAttachmentsResponse&gt; RequestFileUploadAsync(ulong channelId, GcpAttachment attachment)
⋮----
var pld = new RestGcpAttachmentsPayload
⋮----
internal void UploadGcpFile(GcpAttachmentUploadInformation target, Stream file)
⋮----
HttpRequestMessage request = new(HttpMethod.Put, target.UploadUrl)
⋮----
Content = new StreamContent(file)
⋮----
this.ApiClient.Rest.HttpClient.Send(request);</file><file path="DisCatSharp.Experimental/Entities/Channel/DiscordChannelMethodHooks.cs">/// &lt;summary&gt;
///     Adds methods to &lt;see cref=&quot;DiscordChannel&quot; /&gt;
/// &lt;/summary&gt;
public static class DiscordChannelMethodHooks
⋮----
///     Uploads a file to the channel for later use in a &lt;see cref=&quot;DiscordMessageBuilder&quot; /&gt;.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to upload the file to.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the file to upload.&lt;/param&gt;
/// &lt;param name=&quot;stream&quot;&gt;The stream of the file to upload.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the file to upload.&lt;/param&gt;
/// &lt;returns&gt;The upload information.&lt;/returns&gt;
public static async Task&lt;GcpAttachmentUploadInformation&gt; UploadFileAsync(this DiscordChannel channel, string name, Stream stream, string? description = null)
⋮----
DiscordApiClientHook hook = new(channel.Discord.ApiClient);
GcpAttachment attachment = new(name, stream);
var response = await hook.RequestFileUploadAsync(channel.Id, attachment).ConfigureAwait(false);
var target = response.Attachments.First();
hook.UploadGcpFile(target, stream);</file><file path="DisCatSharp.Experimental/Entities/Channel/GcpAttachment.cs">/// &lt;summary&gt;
///     Represents a gcp attachment.
/// &lt;/summary&gt;
public sealed class GcpAttachment : ObservableApiObject
⋮----
///     Constructs a new &lt;see cref=&quot;GcpAttachment&quot; /&gt;.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;The file name.&lt;/param&gt;
/// &lt;param name=&quot;fileSize&quot;&gt;The file size.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;file&quot;&gt;The file stream.&lt;/param&gt;
/// &lt;exception cref=&quot;FileLoadException&quot;&gt;&lt;/exception&gt;
⋮----
this.FileSize = int.TryParse(file.Length.ToString(), out var size)
⋮----
: throw new FileLoadException(&quot;File size too big&quot;, filename);
⋮----
///     Gets the file size.
⋮----
///     Gets the filename.</file><file path="DisCatSharp.Experimental/Entities/Channel/GcpAttachmentsResponse.cs">/// &lt;summary&gt;
///     Represents a gcp attachments response.
/// &lt;/summary&gt;
public sealed class GcpAttachmentsResponse : ObservableApiObject
⋮----
///     Gets the attachments.</file><file path="DisCatSharp.Experimental/Entities/Channel/GcpAttachmentUploadInformation.cs">/// &lt;summary&gt;
///     Represents a gcp attachment upload information.
/// &lt;/summary&gt;
public sealed class GcpAttachmentUploadInformation : NullableSnowflakeObject
⋮----
///     Gets or sets the upload url.
⋮----
///     Gets the upload filename.
⋮----
///     Gets the filename.
⋮----
///     Gets the description.</file><file path="DisCatSharp.Experimental/Entities/Clyde/ClydeProfile.cs">/// &lt;summary&gt;
///     Represents a clyde profile.
/// &lt;/summary&gt;
⋮----
internal sealed class ClydeProfile : ObservableApiObject
⋮----
///     Gets clyde&apos;s profile name.
⋮----
///     Gets clyde&apos;s profile personality.
⋮----
///     Gets clyde&apos;s profile avatar hash.
⋮----
///     Gets clyde&apos;s profile banner hash.
⋮----
///     Gets clyde&apos;s profile bio.
⋮----
///     Gets the user who authored this clyde profile.
⋮----
///     Gets clyde&apos;s profile theme color ints.
⋮----
///     Gets the clyde&apos;s profile theme colors, if set.
⋮----
: this.ThemeColorsInternal.Select(x =&gt; new DiscordColor(x)).ToList();
⋮----
///     Gets clyde&apos;s profile id.</file><file path="DisCatSharp.Experimental/Entities/Clyde/ClydeSettings.cs">/// &lt;summary&gt;
///     Represents a clyde settings object in guilds.
/// &lt;/summary&gt;
⋮----
internal sealed class ClydeSettings : ObservableApiObject
⋮----
///     Gets the guild id.
⋮----
///     Gets the personality.
⋮----
///     Gets the id of the last user who edited the settings, if applicable.
⋮----
///     Gets the clyde profile id.
///     Use &lt;see cref=&quot;DisCatSharpExtensions.GetClydeProfileAsync&quot; /&gt; to fetch details about this profile.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchParams.cs">/// &lt;summary&gt;
///     Represents guild member search params.
/// &lt;/summary&gt;
public sealed class DiscordGuildMemberSearchParams
⋮----
///     Max number of members to return (&lt;c&gt;1&lt;/c&gt;-&lt;c&gt;1000&lt;/c&gt;, default &lt;c&gt;25&lt;/c&gt;).
⋮----
///     The sorting algorithm to use (default &lt;see cref=&quot;MemberSortType.JoinedAtDesc&quot; /&gt;).
⋮----
///     The filter criteria to match against members using OR logic.
⋮----
///     The filter criteria to match against members using AND logic.
⋮----
///     Get members before this member.
⋮----
///     Get members after this member.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMemberSearchValidator.cs">/// &lt;summary&gt;
///     Provides a validator for &lt;see cref=&quot;DiscordGuildMemberSearchParams&quot; /&gt;.
/// &lt;/summary&gt;
public static class DiscordGuildMemberSearchValidator
⋮----
///     Gets the max OR query item count.
⋮----
///     Gets the max AND query item count.
⋮----
///     Gets the max limit count.
⋮----
///     Gets the min limit count.
⋮----
///     Gets the max query length.
⋮----
///     Validates the guild member search parameters.
⋮----
/// &lt;param name=&quot;searchParams&quot;&gt;The search parameters to validate.&lt;/param&gt;
/// &lt;returns&gt;A tuple containing a boolean indicating validity and an optional error message.&lt;/returns&gt;
public static (bool IsValid, string? ErrorMessage) Validate(this DiscordGuildMemberSearchParams searchParams)
⋮----
var orQueryCheck = searchParams.OrQuery.ValidateQuery(&quot;OR&quot;, true);
⋮----
var andQueryCheck = searchParams.AndQuery.ValidateQuery(&quot;AND&quot;, false);
⋮----
///     Validates a DiscordMemberFilter query.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateQuery(this DiscordMemberFilter filter, string queryType, bool validateOrQuery)
⋮----
var result = filter.UserId.ValidateQueryConditions(queryType, &quot;UserId&quot;, ValidateSnowflakeType, allowRange: true);
⋮----
var result = filter.Usernames.ValidateQueryConditions(queryType, &quot;Usernames&quot;, ValidateStringType, true);
⋮----
var result = filter.RoleIds.ValidateQueryConditions(queryType, &quot;RoleIds&quot;, ValidateSnowflakeType, true, true);
⋮----
var result = filter.GuildJoinedAt.ValidateQueryConditions(queryType, &quot;GuildJoinedAt&quot;, ValidateIntegerType, allowRange: true);
⋮----
var result = filter.JoinSourceType.ValidateQueryConditions(queryType, &quot;JoinSourceType&quot;, ValidateIntegerType, true);
⋮----
var result = filter.SourceInviteCode.ValidateQueryConditions(queryType, &quot;SourceInviteCode&quot;, ValidateStringType, true);
⋮----
///     Validates the conditions and types of an individual query within a filter.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateQueryConditions(this DiscordQuery query, string queryType, string fieldName, Func&lt;string, bool&gt; validateType, bool allowOr = false, bool allowAnd = false, bool allowRange = false)
⋮----
///     Validates safety signals queries.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateSafetySignals(this DiscordSafetySignals safetySignals)
⋮----
var result = safetySignals.UnusualDmActivityUntil.ValidateQueryConditions(&quot;SafetySignals&quot;, &quot;UnusualDmActivityUntil&quot;, ValidateIntegerType, allowRange: true);
⋮----
var result = safetySignals.CommunicationDisabledUntil.ValidateQueryConditions(&quot;SafetySignals&quot;, &quot;CommunicationDisabledUntil&quot;, ValidateIntegerType, allowRange: true);
⋮----
///     Validates that the query type is snowflake.
⋮----
private static bool ValidateSnowflakeType(this string query)
=&gt; ulong.TryParse(query, out _);
⋮----
///     Validates that the query type is integer.
⋮----
private static bool ValidateIntegerType(this string query)
=&gt; int.TryParse(query, out _);
⋮----
///     Validates that the query type is string.
⋮----
private static bool ValidateStringType(this string query)
=&gt; !string.IsNullOrWhiteSpace(query);</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordGuildMethodsHook.cs">/// &lt;summary&gt;
///     Adds methods to &lt;see cref=&quot;DiscordGuild&quot; /&gt;.
/// &lt;/summary&gt;
public static class DiscordGuildMethodsHook
⋮----
///     Searches the guild for members through elasticsearch.
///     If the guild isn&apos;t indexed yet, it&apos;ll return a 202 accepted response, we&apos;re gonna throw at this point.
///     Access the &lt;see cref=&quot;NotIndexedException&quot; /&gt;&apos;s &lt;see cref=&quot;NotIndexedException.RetryAfter&quot; /&gt; field to know when to
///     retry this request.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
/// &lt;param name=&quot;searchParams&quot;&gt;The guild member search params&lt;/param&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotIndexedException&quot;&gt;Thrown if the elasticsearch endpoint has not finished indexing yet.&lt;/exception&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public static async Task&lt;DiscordSearchGuildMembersResponse&gt; SearchMembersAsync(this DiscordGuild guild, DiscordGuildMemberSearchParams searchParams)
⋮----
DiscordApiClientHook hook = new(guild.Discord.ApiClient);
return await hook.SearchGuildMembersAsync(guild.Id, searchParams);</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordMemberFilter.cs">/// &lt;summary&gt;
///     Represents a member filter.
/// &lt;/summary&gt;
public sealed class DiscordMemberFilter
⋮----
///     Query to match member IDs against.
///     Possible query types: &lt;see cref=&quot;DiscordQuery.OrQuery&quot; /&gt; or &lt;see cref=&quot;DiscordQuery.RangeQuery&quot; /&gt;.
⋮----
///     Query to match display name(s), username(s), and nickname(s) against.
///     Possible query types: &lt;see cref=&quot;DiscordQuery.OrQuery&quot; /&gt;.
⋮----
///     IDs of roles to match members against.
///     Possible query types: &lt;see cref=&quot;DiscordQuery.OrQuery&quot; /&gt; or &lt;see cref=&quot;DiscordQuery.AndQuery&quot; /&gt;.
⋮----
///     When the user joined the guild.
///     Possible query types: &lt;see cref=&quot;DiscordQuery.RangeQuery&quot; /&gt;.
⋮----
///     Safety signals to match members against.
⋮----
///     Whether the member has not yet passed the guild&apos;s member verification requirements.
⋮----
///     Whether the member left and rejoined the guild.
⋮----
///     How the user joined the guild.
⋮----
///     The invite code or vanity used to join the guild.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordMemberPaginationFilter.cs">/// &lt;summary&gt;
///     Represents a member pagination filter.
/// &lt;/summary&gt;
public sealed class DiscordMemberPaginationFilter
⋮----
///     The ID of the user to paginate past.
⋮----
///     When the user to paginate past joined the guild.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordQueries.cs">/// &lt;summary&gt;
///     Represents a search query.
/// &lt;/summary&gt;
public sealed class DiscordQuery
⋮----
///     Builds a OR query.
///     Array of ulongs, strings, or integers.
⋮----
///     Builds a AND query
⋮----
///     Builds a RANGE query.
⋮----
///     Represents a range query.
⋮----
public sealed class DiscordRangeQuery
⋮----
///     Inclusive lower bound value to match.
///     Ulong or integer.
⋮----
///     Inclusive upper bound value to match.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSafetySignals.cs">/// &lt;summary&gt;
///     Represents safety signal queries.
/// &lt;/summary&gt;
public sealed class DiscordSafetySignals
⋮----
///     When the member&apos;s unusual DM activity flag will expire.
///     Possible query types: &lt;see cref=&quot;DiscordQuery.RangeQuery&quot; /&gt;.
⋮----
///     When the member&apos;s timeout will expire.
⋮----
///     Whether unusual account activity is detected.
⋮----
///     Whether the member has been indefinitely quarantined by an AutoMod Rule for their username, display name, or
///     nickname.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSearchGuildMembersResponse.cs">/// &lt;summary&gt;
///     Represents a search guild members response.
/// &lt;/summary&gt;
public sealed class DiscordSearchGuildMembersResponse : ObservableApiObject
⋮----
///     The ID of the guild searched.
⋮----
///     The resulting members.
⋮----
///     The number of results returned.
⋮----
///     The total number of results found.</file><file path="DisCatSharp.Experimental/Entities/Guild/DiscordSupplementalGuildMember.cs">/// &lt;summary&gt;
///     Represents supplemental information about a user&apos;s join source in a guild.
/// &lt;/summary&gt;
public sealed class DiscordSupplementalGuildMember : ObservableApiObject
⋮----
///     Gets the associated guild member.
⋮----
///     Gets the associated transport member.
⋮----
///     Gets how the user joined the guild.
⋮----
///     Gets the invite code or vanity used to join the guild, if applicable.
⋮----
///     Gets the ID of the user who invited the user to the guild, if applicable.
⋮----
///     Gets the type of integration that added the user to the guild, if applicable.
///     I.e. integration type (twitch, youtube, discord, or guild_subscription).</file><file path="DisCatSharp.Experimental/Enums/Guild/MemberSortType.cs">/// &lt;summary&gt;
///     Represents the sorting algorithm used when searching for guild members.
/// &lt;/summary&gt;
⋮----
///     Sort by when the user joined the guild descending (default).
⋮----
///     Sort by when the user joined the guild ascending.
⋮----
///     Sort by when the user joined Discord descending.
⋮----
///     Sort by when the user joined Discord ascending.</file><file path="DisCatSharp.Experimental/GlobalSuppressions.cs"></file><file path="DisCatSharp.Experimental/Payloads/ClydeSettingsPayloads.cs">/// &lt;summary&gt;
///     Represents a clyde settings update payload with a profile id.
/// &lt;/summary&gt;
⋮----
internal sealed class ClydeSettingsProfileIdOnlyUpdatePayload : ObservableApiObject
⋮----
///     Sets clyde&apos;s profile id.
⋮----
///     Sets clyde&apos;s personality preset.
⋮----
///     Represents a clyde settings update payload.
⋮----
internal sealed class ClydeSettingsProfileUpdatePayload : ObservableApiObject
⋮----
///     Sets clyde&apos;s avatar.
⋮----
///     Sets clyde&apos;s banner.
⋮----
///     Sets clyde&apos;s nick.
⋮----
///     Sets clyde&apos;s personality.
⋮----
///     Sets clyde&apos;s theme colors.
⋮----
///     Represents a personality generation payload.
⋮----
internal sealed class PersonalityGenerationPayload : ObservableApiObject
⋮----
///     Sets the base personality to generate a new one from.</file><file path="DisCatSharp.Experimental/Payloads/RestGcpAttachmentsPayload.cs">/// &lt;summary&gt;
///     Represents a gcp attachment payload.
/// &lt;/summary&gt;
internal sealed class RestGcpAttachmentsPayload
⋮----
///     Sets the files.</file><file path="DisCatSharp.Hosting.DependencyInjection/ServiceCollectionExtensions.cs">/// &lt;summary&gt;
///     The service collection extensions.
/// &lt;/summary&gt;
public static class ServiceCollectionExtensions
⋮----
///     Adds your bot as a BackgroundService, registered in Dependency Injection as &lt;typeparamref name=&quot;TService&quot; /&gt;
⋮----
/// &lt;remarks&gt;
///     &lt;see cref=&quot;IDiscordHostedService&quot; /&gt; is scoped to ServiceLifetime.Singleton. &lt;br /&gt;
///     Maps to Implementation of &lt;typeparamref name=&quot;TService&quot; /&gt;
/// &lt;/remarks&gt;
/// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt;
/// &lt;typeparam name=&quot;TService&quot;&gt;&lt;/typeparam&gt;
/// &lt;returns&gt;Reference to &lt;paramref name=&quot;services&quot; /&gt; for chaining purposes&lt;/returns&gt;
public static IServiceCollection AddDiscordHostedService&lt;TService&gt;(this IServiceCollection services)
where TService : class, IDiscordHostedService
⋮----
services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;TService&gt;());
⋮----
///     &lt;see cref=&quot;IDiscordHostedShardService&quot; /&gt; is scoped to ServiceLifetime.Singleton. &lt;br /&gt;
⋮----
public static IServiceCollection AddDiscordHostedShardService&lt;TService&gt;(this IServiceCollection services)
where TService : class, IDiscordHostedShardService
⋮----
///     Add &lt;typeparamref name=&quot;TService&quot; /&gt; as a background service which derives from
///     &lt;typeparamref name=&quot;TInterface&quot; /&gt; and &lt;see cref=&quot;IDiscordHostedService&quot; /&gt;
⋮----
///     To retrieve your bot via Dependency Injection you can reference it via &lt;typeparamref name=&quot;TInterface&quot; /&gt;
⋮----
/// &lt;typeparam name=&quot;TInterface&quot;&gt;Interface which &lt;typeparamref name=&quot;TService&quot; /&gt; inherits from&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TService&quot;&gt;Your custom bot&lt;/typeparam&gt;
⋮----
public static IServiceCollection AddDiscordHostedService&lt;TInterface, TService&gt;(this IServiceCollection services)
where TInterface : class, IDiscordHostedService
where TService : class, TInterface, IDiscordHostedService
⋮----
services.AddHostedService(provider =&gt; provider.GetRequiredService&lt;TInterface&gt;());
⋮----
///     &lt;typeparamref name=&quot;TInterface&quot; /&gt; and &lt;see cref=&quot;IDiscordHostedShardService&quot; /&gt;
⋮----
public static IServiceCollection AddDiscordHostedShardService&lt;TInterface, TService&gt;(
⋮----
where TInterface : class, IDiscordHostedShardService
where TService : class, TInterface, IDiscordHostedShardService</file><file path="DisCatSharp.Hosting/BaseHostedService.cs">/// &lt;summary&gt;
///     Contains the common logic between having a &lt;see cref=&quot;DiscordClient&quot; /&gt; or
///     &lt;see cref=&quot;DiscordShardedClient&quot; /&gt; as a Hosted Service
/// &lt;/summary&gt;
public abstract class BaseHostedService : BackgroundService
⋮----
protected readonly IHostApplicationLifetime ApplicationLifetime;
⋮----
protected readonly IConfiguration Configuration;
⋮----
protected readonly IServiceProvider ServiceProvider;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;BaseHostedService&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;The logger.&lt;/param&gt;
/// &lt;param name=&quot;serviceProvider&quot;&gt;The service provider.&lt;/param&gt;
/// &lt;param name=&quot;applicationLifetime&quot;&gt;The application lifetime.&lt;/param&gt;
/// &lt;param name=&quot;configBotSection&quot;&gt;The config bot section.&lt;/param&gt;
⋮----
///     When the bot(s) fail to start, this method will be invoked. (Default behavior is to shutdown)
⋮----
/// &lt;param name=&quot;ex&quot;&gt;The exception/reason for not starting&lt;/param&gt;
protected virtual void OnInitializationError(Exception ex) =&gt; this.ApplicationLifetime.StopApplication();
⋮----
///     Connect your client(s) to Discord
⋮----
/// &lt;returns&gt;Task&lt;/returns&gt;
protected abstract Task ConnectAsync();
⋮----
///     Dynamically load extensions by using &lt;see cref=&quot;Configuration&quot; /&gt; and
///     &lt;see cref=&quot;ServiceProvider&quot; /&gt;
⋮----
/// &lt;param name=&quot;client&quot;&gt;Client to add extension method(s) to&lt;/param&gt;
⋮----
protected Task InitializeExtensions(DiscordClient client)
⋮----
var typeMap = this.Configuration.FindImplementedExtensions(this.BotSection);
⋮----
this.Logger.LogDebug($&quot;Found the following config types: {string.Join(&quot;\n\t&quot;, typeMap.Keys)}&quot;);
⋮----
/*
                        If section is null --&gt; utilize the default constructor
                        This means the extension was explicitly added in the &apos;Using&apos; array,
                        but user did not wish to override any value(s) in the extension&apos;s config
                     */
⋮----
? typePair.Value.Section.Value.ExtractConfig(() =&gt;
ActivatorUtilities.CreateInstance(this.ServiceProvider, typePair.Value.ConfigType))
: ActivatorUtilities.CreateInstance(this.ServiceProvider, typePair.Value.ConfigType);
⋮----
/*
                        Explanation for bindings

                        Internal Constructors --&gt; NonPublic
                        Public Constructors --&gt; Public
                        Constructors --&gt; Instance
                     */
⋮----
var ctors = typePair.Value.ImplementationType.GetConstructors(flags);
⋮----
var instance = ctors.Any(x =&gt; x.GetParameters().Length == 1 &amp;&amp; x.GetParameters().First().ParameterType == typePair.Value.ConfigType)
? Activator.CreateInstance(typePair.Value.ImplementationType, flags, null,
⋮----
: Activator.CreateInstance(typePair.Value.ImplementationType, true);
⋮----
/*
                       Certain extensions do not require a configuration argument
                       Those who do -- pass config instance in,
                       Those who don&apos;t -- simply instantiate

                       ActivatorUtilities requires a public constructor, anything with internal breaks
                     */
⋮----
this.Logger.LogError($&quot;Unable to instantiate &apos;{typePair.Value.ImplementationType.Name}&apos;&quot;);
⋮----
// Add an easy reference to our extensions for later use
client.AddExtension((BaseExtension)instance);
⋮----
this.Logger.LogError($&quot;Unable to register &apos;{typePair.Value.ImplementationType.Name}&apos;: \n\t{ex.Message}&quot;);
this.OnInitializationError(ex);
⋮----
///     Configure / Initialize the &lt;see cref=&quot;DiscordClient&quot; /&gt; or
///     &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
protected abstract Task ConfigureAsync();
⋮----
///     Configure the extensions for your &lt;see cref=&quot;DiscordShardedClient&quot; /&gt; or
///     &lt;see cref=&quot;DiscordClient&quot; /&gt;
⋮----
protected abstract Task ConfigureExtensionsAsync();
⋮----
///     Runs just prior to &lt;see cref=&quot;ConnectAsync&quot; /&gt;.
⋮----
protected virtual Task PreConnectAsync() =&gt; Task.CompletedTask;
⋮----
///     Runs immediately after &lt;see cref=&quot;ConnectAsync&quot; /&gt;.
⋮----
protected virtual Task PostConnectAsync() =&gt; Task.CompletedTask;
⋮----
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
⋮----
await this.ConfigureAsync();
await this.PreConnectAsync();
await this.ConnectAsync();
await this.ConfigureExtensionsAsync();
await this.PostConnectAsync();
⋮----
/*
			 * Anything before DOTNET 6 will
			 * fail silently despite throwing an exception in this method
			 * So to overcome this obstacle we need to log what happens and
			 * manually exit
			 */
this.Logger.LogError($&quot;Was unable to start {this.GetType().Name} Bot as a Hosted Service&quot;);
⋮----
// Power given to developer for handling exception
⋮----
// Wait indefinitely -- but use stopping token so we can properly cancel if needed
await Task.Delay(-1, stoppingToken);</file><file path="DisCatSharp.Hosting/ConfigurationExtensions.cs">/// &lt;summary&gt;
///     Gets or sets the section.
/// &lt;/summary&gt;
⋮----
///     Gets or sets the config type.
⋮----
///     Gets or sets the implementation type.
⋮----
///     The configuration extensions.
⋮----
internal static class ConfigurationExtensions
⋮----
///     Find assemblies that match the names provided via &lt;paramref name=&quot;names&quot; /&gt;.
⋮----
/// &lt;remarks&gt;
///     In some cases the assembly the user is after could be used in the application but
///     not appear within the &lt;see cref=&quot;AppDomain&quot; /&gt;. &lt;br /&gt;
///     The workaround for this is to check the assemblies in the &lt;see cref=&quot;AppDomain&quot; /&gt;, as well as referenced
///     assemblies. If the targeted assembly is a reference, we need to load it into our workspace to get more info.
/// &lt;/remarks&gt;
/// &lt;param name=&quot;names&quot;&gt;Names of assemblies to look for&lt;/param&gt;
/// &lt;returns&gt;Assemblies which meet the given names. No duplicates&lt;/returns&gt;
public static List&lt;Assembly&gt; FindAssemblies(IEnumerable&lt;string&gt;? names)
⋮----
/*
              There is a possibility that an assembly can be referenced in multiple assemblies.
              To alleviate duplicates we need to shrink our queue as we find things
             */
⋮----
var queue = names.ToList();
foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
⋮----
var loadedAssemblyName = assembly.GetName().Name;
⋮----
// Kinda need the name to do our thing
⋮----
// Is this something we&apos;re looking for?
if (queue.Remove(loadedAssemblyName))
results.Add(assembly);
⋮----
// Time to check if one of the referenced assemblies is something we&apos;re looking for
foreach (var referencedAssembly in assembly.GetReferencedAssemblies()
.Where(x =&gt; x.Name != null &amp;&amp; queue.Contains(x.Name)))
⋮----
// Must load the assembly into our workspace so we can do stuff with it later
results.Add(Assembly.Load(referencedAssembly));
queue.Remove(referencedAssembly.Name);
⋮----
Console.Error.WriteLine($&quot;Unable to load referenced assembly: &apos;{referencedAssembly.Name}&apos; \n\t{ex.Message}&quot;);
⋮----
///     Easily identify which configuration types have been added to the &lt;paramref name=&quot;configuration&quot; /&gt; &lt;br /&gt;
///     This way we can dynamically load extensions without explicitly doing so
⋮----
/// &lt;param name=&quot;configuration&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;rootName&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;Dictionary where Key -&gt; Name of implemented type&lt;br /&gt;Value -&gt; &lt;see cref=&quot;ExtensionConfigResult&quot; /&gt;&lt;/returns&gt;
public static Dictionary&lt;string, ExtensionConfigResult&gt; FindImplementedExtensions(
⋮----
if (string.IsNullOrEmpty(rootName))
throw new ArgumentNullException(nameof(rootName), &quot;Root name must be provided&quot;);
⋮----
// Has the user defined a using section within the root name?
if (!configuration.HasSection(rootName, &quot;Using&quot;))
⋮----
/*
               There are 2 ways a user could list which assemblies are used
               &quot;Using&quot;: &quot;[\&quot;Assembly.Name\&quot;]&quot;
               &quot;Using&quot;: [&quot;Assembly.Name&quot;]

               JSON or as Text.
             */
assemblyNames = string.IsNullOrEmpty(configuration[configuration.ConfigPath(rootName, &quot;Using&quot;)])
? configuration.GetSection(configuration.ConfigPath(rootName, &quot;Using&quot;)).Get&lt;string[]&gt;()
⋮----
configuration[configuration.ConfigPath(rootName, &quot;Using&quot;)]);
foreach (var assembly in FindAssemblies(assemblyNames.Select(x =&gt; x.StartsWith(Constants.LibName, StringComparison.Ordinal) ? x : $&quot;{Constants.LibName}.{x}&quot;)))
⋮----
ExtensionConfigResult result = new();
⋮----
.Where(x =&gt; x.Name.EndsWith(Constants.ConfigSuffix, StringComparison.Ordinal) &amp;&amp; x is { IsAbstract: false, IsInterface: false }))
⋮----
var prefix = type.Name.Replace(Constants.ConfigSuffix, &quot;&quot;);
⋮----
// Does a section exist with the classname? (DiscordConfiguration - for instance)
if (configuration.HasSection(rootName, sectionName))
result.Section = new ConfigSection(ref configuration, type.Name, rootName);
⋮----
// Does a section exist with the classname minus Configuration? (Discord - for Instance)
else if (configuration.HasSection(rootName, prefix))
result.Section = new ConfigSection(ref configuration, prefix, rootName);
⋮----
// IF THE SECTION IS NOT PROVIDED --&gt; WE WILL USE DEFAULT CONFIG IMPLEMENTATION
⋮----
/*
                        Now we need to find the type which should consume our config

                        In the event a user has some &quot;fluff&quot; between prefix and suffix we&apos;ll
                        just check for beginning and ending values.

                        Type should not be an interface or abstract, should also be assignable to BaseExtension
                     */
⋮----
var implementationType = assembly.ExportedTypes.FirstOrDefault(x =&gt;
x is { IsAbstract: false, IsInterface: false } &amp;&amp; x.Name.StartsWith(prefix, StringComparison.Ordinal) &amp;&amp;
x.Name.EndsWith(Constants.ExtensionSuffix, StringComparison.Ordinal) &amp;&amp; x.IsAssignableTo(typeof(BaseExtension)));
⋮----
// If the implementation type was found we can add it to our result set
⋮----
results.Add(implementationType.Name, result);</file><file path="DisCatSharp.Hosting/Constants.cs">/// &lt;summary&gt;
///     The constants.
/// &lt;/summary&gt;
internal static class Constants
⋮----
///     Gets the lib name.
⋮----
///     Gets the config suffix.
⋮----
///     Gets the extension suffix.</file><file path="DisCatSharp.Hosting/DiscordHostedService.cs">/// &lt;summary&gt;
///     Simple implementation for &lt;see cref=&quot;DiscordClient&quot; /&gt; to work as a
///     &lt;see cref=&quot;Microsoft.Extensions.Hosting.BackgroundService&quot; /&gt;
/// &lt;/summary&gt;
public abstract class DiscordHostedService : BaseHostedService, IDiscordHostedService
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordHostedService&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;config&quot;&gt;IConfiguration provided via Dependency Injection. Aggregate method to access configuration files &lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;An ILogger to work with, provided via Dependency Injection&lt;/param&gt;
/// &lt;param name=&quot;serviceProvider&quot;&gt;
///     ServiceProvider reference which contains all items currently registered for Dependency
///     Injection
/// &lt;/param&gt;
/// &lt;param name=&quot;applicationLifetime&quot;&gt;
///     Contains the appropriate methods for disposing / stopping BackgroundServices during
///     runtime
⋮----
/// &lt;param name=&quot;configBotSection&quot;&gt;
///     The name of the JSON/Config Key which contains the configuration for this Discord
///     Service
⋮----
/// &lt;inheritdoc /&gt;
⋮----
protected override Task ConfigureAsync()
⋮----
this.Client = this.Configuration.BuildClient(this.ServiceProvider, this.BotSection);
⋮----
this.Logger.LogError($&quot;Was unable to build {nameof(DiscordClient)} for {this.GetType().Name}&quot;);
this.OnInitializationError(ex);
⋮----
protected sealed override async Task ConnectAsync() =&gt; await this.Client.ConnectAsync();
⋮----
protected override Task ConfigureExtensionsAsync()
⋮----
this.InitializeExtensions(this.Client);</file><file path="DisCatSharp.Hosting/DiscordSharedHostedService.cs">/// &lt;summary&gt;
///     Simple Implementation for &lt;see cref=&quot;DiscordShardedClient&quot; /&gt; to work as a
///     &lt;see cref=&quot;Microsoft.Extensions.Hosting.BackgroundService&quot; /&gt;
/// &lt;/summary&gt;
public abstract class DiscordShardedHostedService : BaseHostedService, IDiscordHostedShardService
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordShardedHostedService&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;The logger.&lt;/param&gt;
/// &lt;param name=&quot;serviceProvider&quot;&gt;The service provider.&lt;/param&gt;
/// &lt;param name=&quot;applicationLifetime&quot;&gt;The application lifetime.&lt;/param&gt;
/// &lt;param name=&quot;configBotSection&quot;&gt;The config bot section.&lt;/param&gt;
⋮----
protected override Task ConfigureAsync()
⋮----
this.Logger.LogError($&quot;Was unable to build {nameof(DiscordShardedClient)} for {this.GetType().Name}&quot;);
this.OnInitializationError(ex);
⋮----
protected sealed override async Task ConnectAsync() =&gt; await this.ShardedClient.StartAsync();
⋮----
protected override Task ConfigureExtensionsAsync()
⋮----
this.InitializeExtensions(client);</file><file path="DisCatSharp.Hosting/GlobalSuppressions.cs"></file><file path="DisCatSharp.Hosting/IDiscordHostedService.cs">/// &lt;summary&gt;
///     Contract required for &lt;see cref=&quot;DiscordClient&quot; /&gt; to work in a web hosting environment
/// &lt;/summary&gt;
public interface IDiscordHostedService : IHostedService
⋮----
///     Reference to connected client
⋮----
///     Contract required for &lt;see cref=&quot;DiscordShardedClient&quot; /&gt; to work in a web hosting environment
⋮----
public interface IDiscordHostedShardService : IHostedService</file><file path="DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Interactivity/Enums/ButtonPaginationBehavior.cs">/// &lt;summary&gt;
///     Represents options of how to handle pagination timing out.
/// &lt;/summary&gt;
⋮----
///     The buttons should be disabled when pagination times out.
⋮----
///     The buttons should be left as is when pagination times out.
⋮----
///     The entire message should be deleted when pagination times out.
⋮----
///     The buttons should be removed entirely when pagination times out.</file><file path="DisCatSharp.Interactivity/Enums/InteractionResponseBehavior.cs">/// &lt;summary&gt;
///     The interaction response behavior.
/// &lt;/summary&gt;
⋮----
///     Indicates that invalid input should be ignored when waiting for interactions. This will cause the interaction to
///     fail.
⋮----
///     Indicates that invalid input should be ACK&apos;d. The interaction will succeed, but nothing will happen.
⋮----
///     Indicates that invalid input should warrant an ephemeral error message.</file><file path="DisCatSharp.Interactivity/Enums/PaginationBehaviour.cs">/// &lt;summary&gt;
///     Specifies how pagination will handle advancing past the first and last pages.
/// &lt;/summary&gt;
⋮----
///     Going forward beyond the last page will loop back to the first page.
///     Likewise, going back from the first page will loop around to the last page.
⋮----
///     Attempting to go beyond the first or last page will be ignored.</file><file path="DisCatSharp.Interactivity/Enums/PaginationDeletion.cs">/// &lt;summary&gt;
///     Specifies what should be done once pagination times out.
/// &lt;/summary&gt;
⋮----
///     Reaction emojis will be deleted on timeout.
⋮----
///     Reaction emojis will not be deleted on timeout.
⋮----
///     The message will be completely deleted on timeout.</file><file path="DisCatSharp.Interactivity/Enums/PollBehaviour.cs">/// &lt;summary&gt;
///     Specifies what should be done when a poll times out.
/// &lt;/summary&gt;
⋮----
///     Reaction emojis will not be deleted.
⋮----
///     Reaction emojis will be deleted.</file><file path="DisCatSharp.Interactivity/Enums/SplitType.cs">/// &lt;summary&gt;
///     Specifies how to split a string.
/// &lt;/summary&gt;
⋮----
///     Splits string per 500 characters.
⋮----
///     Splits string per 15 lines.</file><file path="DisCatSharp.Interactivity/EventHandling/Components/ComponentEventWaiter.cs">/// &lt;summary&gt;
///     A component-based version of &lt;see cref=&quot;EventWaiter{T}&quot; /&gt;
/// &lt;/summary&gt;
internal class ComponentEventWaiter : IDisposable
⋮----
private readonly DiscordClient _client;
⋮----
private readonly InteractivityConfiguration _config;
⋮----
private readonly DiscordFollowupMessageBuilder _message;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentEventWaiter&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
⋮----
///     Disposes the waiter.
⋮----
public void Dispose()
⋮----
this._matchRequests.Clear();
this._collectRequests.Clear();
⋮----
///     Waits for a specified &lt;see cref=&quot;ComponentMatchRequest&quot; /&gt;&apos;s predicate to be fulfilled.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to wait for.&lt;/param&gt;
/// &lt;returns&gt;The returned args, or null if it timed out.&lt;/returns&gt;
public async Task&lt;ComponentInteractionCreateEventArgs?&gt; WaitForMatchAsync(ComponentMatchRequest request)
⋮----
this._matchRequests.Add(request);
⋮----
return await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, e, &quot;An exception was thrown while waiting for components.&quot;);
⋮----
this._matchRequests.TryRemove(request);
⋮----
///     Collects reactions and returns the result when the &lt;see cref=&quot;ComponentMatchRequest&quot; /&gt;&apos;s cancellation token is
///     canceled.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to wait on.&lt;/param&gt;
/// &lt;returns&gt;The result from request&apos;s predicate over the period of time leading up to the token&apos;s cancellation.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;ComponentInteractionCreateEventArgs&gt;&gt; CollectMatchesAsync(ComponentCollectRequest request)
⋮----
this._collectRequests.Add(request);
⋮----
await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityCollectorError, e, &quot;There was an error while collecting component event args.&quot;);
⋮----
this._collectRequests.TryRemove(request);
⋮----
return request.Collected.ToArray();
⋮----
///     Handles the waiter.
⋮----
/// &lt;param name=&quot;_&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The args.&lt;/param&gt;
private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs args)
⋮----
if (mreq.Message == args.Message &amp;&amp; mreq.IsMatch(args))
mreq.Tcs.TrySetResult(args);
⋮----
await args.Interaction.CreateFollowupMessageAsync(this._message).ConfigureAwait(false);
⋮----
foreach (var creq in this._collectRequests.Where(creq =&gt; creq.Message == args.Message &amp;&amp; creq.IsMatch(args)))
⋮----
await args.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate).ConfigureAwait(false);
⋮----
if (creq.IsMatch(args))
creq.Collected.Add(args);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/ComponentPaginator.cs">/// &lt;summary&gt;
///     The component paginator.
/// &lt;/summary&gt;
internal class ComponentPaginator : IPaginator
⋮----
private readonly DiscordMessageBuilder _builder = new();
private readonly DiscordClient _client;
private readonly InteractivityConfiguration _config;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentPaginator&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
⋮----
///     Does the pagination async.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
public async Task DoPaginationAsync(IPaginationRequest request)
⋮----
var id = (await request.GetMessageAsync().ConfigureAwait(false)).Id;
this._requests.Add(id, request);
⋮----
var tcs = await request.GetTaskCompletionSourceAsync().ConfigureAwait(false);
await tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;There was an exception while paginating.&quot;);
⋮----
this._requests.Remove(id);
⋮----
await request.DoCleanupAsync().ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;There was an exception while cleaning up pagination.&quot;);
⋮----
///     Disposes the paginator.
⋮----
public void Dispose() =&gt; this._client.ComponentInteractionCreated -= this.Handle;
⋮----
///     Handles the pagination event.
⋮----
/// &lt;param name=&quot;_&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The event arguments.&lt;/param&gt;
private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs e)
⋮----
if (!this._requests.TryGetValue(e.Message.Id, out var req))
⋮----
if (!this._config.PaginationButtons.ButtonArray.Select(x =&gt; x.CustomId).Contains(e.Id))
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate).ConfigureAwait(false);
⋮----
if (await req.GetUserAsync().ConfigureAwait(false) != e.User)
⋮----
await e.Interaction.CreateFollowupMessageAsync(new()
⋮----
}).ConfigureAwait(false);
⋮----
ipr.RegenerateCts(e.Interaction); // Necessary to ensure we don&apos;t prematurely yeet the CTS //
⋮----
await this.HandlePaginationAsync(req, e).ConfigureAwait(false);
⋮----
///     Handles the pagination async.
⋮----
/// &lt;param name=&quot;args&quot;&gt;The arguments.&lt;/param&gt;
private async Task HandlePaginationAsync(IPaginationRequest request, ComponentInteractionCreateEventArgs args)
⋮----
var msg = await request.GetMessageAsync().ConfigureAwait(false);
⋮----
_ when id == buttons.SkipLeft.CustomId =&gt; request.SkipLeftAsync(),
_ when id == buttons.SkipRight.CustomId =&gt; request.SkipRightAsync(),
_ when id == buttons.Stop.CustomId =&gt; Task.FromResult(tcs.TrySetResult(true)),
_ when id == buttons.Left.CustomId =&gt; request.PreviousPageAsync(),
_ when id == buttons.Right.CustomId =&gt; request.NextPageAsync(),
_ =&gt; throw new ArgumentOutOfRangeException(nameof(args), &quot;Id was out of range&quot;)
⋮----
await paginationTask.ConfigureAwait(false);
⋮----
var page = await request.GetPageAsync().ConfigureAwait(false);
⋮----
var bts = await request.GetButtonsAsync().ConfigureAwait(false);
⋮----
var builder = new DiscordWebhookBuilder();
⋮----
builder.WithContent(page.Content);
⋮----
builder.AddEmbed(page.Embed);
builder.AddComponents(bts);
⋮----
await (await ipr.GetLastInteractionAsync()).EditOriginalResponseAsync(builder).ConfigureAwait(false);
⋮----
this._builder.Clear();
⋮----
this._builder.WithContent(page.Content);
⋮----
this._builder.AddEmbed(page.Embed);
this._builder.AddComponents(bts);
⋮----
await this._builder.ModifyAsync(msg).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/ModalEventWaiter.cs">/// &lt;summary&gt;
///     A modal-based version of &lt;see cref=&quot;EventWaiter{T}&quot; /&gt;
/// &lt;/summary&gt;
internal class ModalEventWaiter : IDisposable
⋮----
private readonly DiscordClient _client;
private readonly InteractivityConfiguration _config;
⋮----
private readonly DiscordFollowupMessageBuilder _message;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentEventWaiter&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
⋮----
///     Disposes the waiter.
⋮----
public void Dispose()
⋮----
this._modalMatchRequests.Clear();
⋮----
///     Waits for a specified &lt;see cref=&quot;ModalMatchRequest&quot; /&gt;&apos;s predicate to be fulfilled.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to wait for.&lt;/param&gt;
/// &lt;returns&gt;The returned args, or null if it timed out.&lt;/returns&gt;
public async Task&lt;ComponentInteractionCreateEventArgs?&gt; WaitForModalMatchAsync(ModalMatchRequest request)
⋮----
this._modalMatchRequests.Add(request);
⋮----
return await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, e, &quot;An exception was thrown while waiting for modals.&quot;);
⋮----
this._modalMatchRequests.TryRemove(request);
⋮----
///     Handles the waiter.
⋮----
/// &lt;param name=&quot;_&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The args.&lt;/param&gt;
private async Task Handle(DiscordClient _, ComponentInteractionCreateEventArgs args)
⋮----
if (mreq.CustomId == args.Interaction.Data.CustomId &amp;&amp; mreq.IsMatch(args))
mreq.Tcs.TrySetResult(args);
⋮----
await args.Interaction.CreateFollowupMessageAsync(this._message).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/PaginationButtons.cs">/// &lt;summary&gt;
///     The pagination buttons.
/// &lt;/summary&gt;
public class PaginationButtons
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PaginationButtons&quot; /&gt; class.
⋮----
this.SkipLeft = new(ButtonStyle.Secondary, &quot;leftskip&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏮&quot;)));
this.Left = new(ButtonStyle.Secondary, &quot;left&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;◀&quot;)));
this.Stop = new(ButtonStyle.Secondary, &quot;stop&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏹&quot;)));
this.Right = new(ButtonStyle.Secondary, &quot;right&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;▶&quot;)));
this.SkipRight = new(ButtonStyle.Secondary, &quot;rightskip&quot;, null, false, new(DiscordEmoji.FromUnicode(&quot;⏭&quot;)));
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other &lt;see cref=&quot;PaginationButtons&quot; /&gt;.&lt;/param&gt;
⋮----
///     Gets or sets the skip left button.
⋮----
///     Gets or sets the left button.
⋮----
///     Gets or sets the stop button.
⋮----
///     Gets or sets the right button.
⋮----
///     Gets or sets the skip right button.
⋮----
///     Gets the button array.</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentCollectRequest.cs">/// &lt;summary&gt;
///     Represents a component event that is being waited for.
/// &lt;/summary&gt;
internal sealed class ComponentCollectRequest : ComponentMatchRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentCollectRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
/// &lt;param name=&quot;cancellation&quot;&gt;The cancellation token.&lt;/param&gt;
⋮----
///     Gets the collected.</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ComponentMatchRequest.cs">/// &lt;summary&gt;
///     Represents a match that is being waited for.
/// &lt;/summary&gt;
internal class ComponentMatchRequest
⋮----
protected readonly CancellationToken Cancellation;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentMatchRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
/// &lt;param name=&quot;cancellation&quot;&gt;The cancellation token.&lt;/param&gt;
⋮----
this.Cancellation.Register(() =&gt; this.Tcs.TrySetResult(null)); // TrySetCancelled would probably be better but I digress ~Velvet //
⋮----
///     The id to wait on. This should be uniquely formatted to avoid collisions.
⋮----
///     The completion source that represents the result of the match.
⋮----
///     Whether it is a match.
⋮----
/// &lt;param name=&quot;args&quot;&gt;The arguments.&lt;/param&gt;
public bool IsMatch(ComponentInteractionCreateEventArgs args) =&gt; this.Predicate(args);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ModalMatchRequest.cs">/// &lt;summary&gt;
///     Represents a match that is being waited for.
/// &lt;/summary&gt;
internal class ModalMatchRequest
⋮----
protected readonly CancellationToken Cancellation;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ModalMatchRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
/// &lt;param name=&quot;cancellation&quot;&gt;The cancellation token.&lt;/param&gt;
⋮----
this.Cancellation.Register(() =&gt; this.Tcs.TrySetResult(null)); // TrySetCancelled would probably be better but I digress ~Velvet //
⋮----
///     The id to wait on. This should be uniquely formatted to avoid collisions.
⋮----
///     The completion source that represents the result of the match.
⋮----
///     Whether it is a match.
⋮----
/// &lt;param name=&quot;args&quot;&gt;The arguments.&lt;/param&gt;
public bool IsMatch(ComponentInteractionCreateEventArgs args) =&gt; this.Predicate(args);</file><file path="DisCatSharp.Interactivity/EventHandling/EventWaiter.cs">/// &lt;summary&gt;
///     EventWaiter is a class that serves as a layer between the InteractivityExtension
///     and the DiscordClient to listen to an event and check for matches to a predicate.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
internal class EventWaiter&lt;T&gt; : IDisposable where T : AsyncEventArgs
⋮----
private DiscordClient _client;
⋮----
///     Creates a new EventWaiter object.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Your DiscordClient&lt;/param&gt;
⋮----
var tinfo = this._client.GetType().GetTypeInfo();
var handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, T&gt;));
⋮----
this._event = (AsyncEvent&lt;DiscordClient, T&gt;)handler.GetValue(this._client);
⋮----
this._event.Register(this._handler);
⋮----
///     Disposes this EventWaiter
⋮----
public void Dispose()
⋮----
GC.SuppressFinalize(this);
⋮----
///     Waits for a match to a specific request, else returns null.
⋮----
/// &lt;param name=&quot;request&quot;&gt;Request to match&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public async Task&lt;T?&gt; WaitForMatchAsync(MatchRequest&lt;T&gt; request)
⋮----
this._matchRequests.Add(request);
⋮----
result = await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, ex, &quot;An exception occurred while waiting for {0}&quot;, typeof(T).Name);
⋮----
request.Dispose();
this._matchRequests.TryRemove(request);
⋮----
///     Collects the matches async.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
public async Task&lt;ReadOnlyCollection&lt;T&gt;&gt; CollectMatchesAsync(CollectRequest&lt;T&gt; request)
⋮----
this._collectRequests.Add(request);
⋮----
await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityWaitError, ex, &quot;An exception occurred while collecting from {0}&quot;, typeof(T).Name);
⋮----
result = new(new HashSet&lt;T&gt;(request.Collected).ToList());
⋮----
this._collectRequests.TryRemove(request);
⋮----
///     Handles the event.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event&apos;s arguments.&lt;/param&gt;
private Task HandleEvent(DiscordClient client, T eventArgs)
⋮----
if (req.Predicate(eventArgs))
req.Tcs.TrySetResult(eventArgs);
⋮----
req.Collected.Add(eventArgs);
⋮----
this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/IPaginator.cs">/// &lt;summary&gt;
///     The paginator.
/// &lt;/summary&gt;
internal interface IPaginator
⋮----
///     Paginates.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to paginate.&lt;/param&gt;
/// &lt;returns&gt;A task that completes when the pagination finishes or times out.&lt;/returns&gt;
Task DoPaginationAsync(IPaginationRequest request);
⋮----
///     Disposes this EventWaiter
⋮----
void Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Paginator.cs">/// &lt;summary&gt;
///     The paginator.
/// &lt;/summary&gt;
internal class Paginator : IPaginator
⋮----
private DiscordClient _client;
⋮----
///     Creates a new EventWaiter object.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client&lt;/param&gt;
⋮----
///     Dos the pagination async.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
public async Task DoPaginationAsync(IPaginationRequest request)
⋮----
await this.ResetReactionsAsync(request).ConfigureAwait(false);
this._requests.Add(request);
⋮----
var tcs = await request.GetTaskCompletionSourceAsync().ConfigureAwait(false);
await tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityPaginationError, ex, &quot;Exception occurred while paginating&quot;);
⋮----
this._requests.TryRemove(request);
⋮----
await request.DoCleanupAsync().ConfigureAwait(false);
⋮----
///     Disposes this EventWaiter
⋮----
public void Dispose()
⋮----
this._requests.Clear();
⋮----
///     Handles the reaction add.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event&apos;s arguments.&lt;/param&gt;
private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
⋮----
_ = Task.Run(async () =&gt;
⋮----
var emojis = await req.GetEmojisAsync().ConfigureAwait(false);
var msg = await req.GetMessageAsync().ConfigureAwait(false);
var usr = await req.GetUserAsync().ConfigureAwait(false);
⋮----
await this.PaginateAsync(req, eventArgs.Emoji).ConfigureAwait(false);
⋮----
await msg.DeleteReactionAsync(eventArgs.Emoji, eventArgs.User).ConfigureAwait(false);
⋮----
///     Handles the reaction remove.
⋮----
private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
⋮----
///     Handles the reaction clear.
⋮----
/// &lt;param name=&quot;eventArgs&quot;&gt;The eventArgs.&lt;/param&gt;
private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
⋮----
await this.ResetReactionsAsync(req).ConfigureAwait(false);
⋮----
///     Resets the reactions async.
⋮----
/// &lt;param name=&quot;p&quot;&gt;The p.&lt;/param&gt;
private async Task ResetReactionsAsync(IPaginationRequest p)
⋮----
var msg = await p.GetMessageAsync().ConfigureAwait(false);
var emojis = await p.GetEmojisAsync().ConfigureAwait(false);
⋮----
if (mbr is not null &amp;&amp; (chn.PermissionsFor(mbr) &amp; Permissions.ManageMessages) != 0)
await msg.DeleteAllReactionsAsync(&quot;Pagination&quot;).ConfigureAwait(false);
⋮----
await msg.CreateReactionAsync(emojis.SkipLeft).ConfigureAwait(false);
⋮----
await msg.CreateReactionAsync(emojis.Left).ConfigureAwait(false);
⋮----
await msg.CreateReactionAsync(emojis.Right).ConfigureAwait(false);
⋮----
await msg.CreateReactionAsync(emojis.SkipRight).ConfigureAwait(false);
⋮----
await msg.CreateReactionAsync(emojis.Stop).ConfigureAwait(false);
⋮----
///     Paginates the async.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
private async Task PaginateAsync(IPaginationRequest p, DiscordEmoji emoji)
⋮----
await p.SkipLeftAsync().ConfigureAwait(false);
⋮----
await p.PreviousPageAsync().ConfigureAwait(false);
⋮----
await p.NextPageAsync().ConfigureAwait(false);
⋮----
await p.SkipRightAsync().ConfigureAwait(false);
⋮----
var tcs = await p.GetTaskCompletionSourceAsync().ConfigureAwait(false);
tcs.TrySetResult(true);
⋮----
var page = await p.GetPageAsync().ConfigureAwait(false);
var builder = new DiscordMessageBuilder();
⋮----
builder.WithContent(page.Content);
⋮----
builder.AddEmbed(page.Embed);
⋮----
await builder.ModifyAsync(msg).ConfigureAwait(false);
⋮----
/// &lt;inheritdoc /&gt;
⋮----
this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Poller.cs">/// &lt;summary&gt;
///     The poller.
/// &lt;/summary&gt;
internal class Poller
⋮----
private DiscordClient _client;
⋮----
///     Creates a new EventWaiter object.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Your DiscordClient&lt;/param&gt;
⋮----
///     Dos the poll async.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public async Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(PollRequest request)
⋮----
this._requests.Add(request);
⋮----
await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityPollError, ex, &quot;Exception occurred while polling&quot;);
⋮----
result = new(new HashSet&lt;PollEmoji&gt;(request.Collected).ToList());
request.Dispose();
this._requests.TryRemove(request);
⋮----
///     Handles the reaction add.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event&apos;s arguments.&lt;/param&gt;
⋮----
private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
⋮----
_ = Task.Run(async () =&gt;
⋮----
// match message
⋮----
if (req.Emojis.Contains(eventArgs.Emoji) &amp;&amp; !req.Collected.Any(x =&gt; x.Voted.Contains(eventArgs.User)))
⋮----
req.AddReaction(eventArgs.Emoji, eventArgs.User);
⋮----
var member = await eventArgs.Channel.Guild.GetMemberAsync(client.CurrentUser.Id).ConfigureAwait(false);
if (eventArgs.Channel.PermissionsFor(member).HasPermission(Permissions.ManageMessages))
await eventArgs.Message.DeleteReactionAsync(eventArgs.Emoji, eventArgs.User).ConfigureAwait(false);
⋮----
///     Handles the reaction remove.
⋮----
private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
⋮----
req.RemoveReaction(eventArgs.Emoji, eventArgs.User);
⋮----
///     Handles the reaction clear.
⋮----
private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
⋮----
req.ClearCollected();
⋮----
this.Dispose();
⋮----
///     Disposes this EventWaiter
⋮----
public void Dispose()
⋮----
this._requests.Clear();</file><file path="DisCatSharp.Interactivity/EventHandling/ReactionCollector.cs">/// &lt;summary&gt;
///     EventWaiter is a class that serves as a layer between the InteractivityExtension
///     and the DiscordClient to listen to an event and check for matches to a predicate.
/// &lt;/summary&gt;
internal class ReactionCollector : IDisposable
⋮----
private DiscordClient _client;
⋮----
///     Creates a new EventWaiter object.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Your DiscordClient&lt;/param&gt;
⋮----
var tinfo = this._client.GetType().GetTypeInfo();
⋮----
// Grabbing all three events from client
var handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionAddEventArgs&gt;));
⋮----
this._reactionAddEvent = (AsyncEvent&lt;DiscordClient, MessageReactionAddEventArgs&gt;)handler.GetValue(this._client);
⋮----
this._reactionAddEvent.Register(this._reactionAddHandler);
⋮----
handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionRemoveEventArgs&gt;));
⋮----
this._reactionRemoveEvent = (AsyncEvent&lt;DiscordClient, MessageReactionRemoveEventArgs&gt;)handler.GetValue(this._client);
⋮----
this._reactionRemoveEvent.Register(this._reactionRemoveHandler);
⋮----
handler = tinfo.DeclaredFields.First(x =&gt; x.FieldType == typeof(AsyncEvent&lt;DiscordClient, MessageReactionsClearEventArgs&gt;));
⋮----
this._reactionClearEvent = (AsyncEvent&lt;DiscordClient, MessageReactionsClearEventArgs&gt;)handler.GetValue(this._client);
⋮----
this._reactionClearEvent.Register(this._reactionClearHandler);
⋮----
///     Disposes this EventWaiter
⋮----
public void Dispose()
⋮----
this._reactionAddEvent.Unregister(this._reactionAddHandler);
this._reactionRemoveEvent.Unregister(this._reactionRemoveHandler);
this._reactionClearEvent.Unregister(this._reactionClearHandler);
⋮----
this._requests.Clear();
⋮----
GC.SuppressFinalize(this);
⋮----
///     Collects the async.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public async Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectAsync(ReactionCollectRequest request)
⋮----
this._requests.Add(request);
⋮----
await request.Tcs.Task.ConfigureAwait(false);
⋮----
this._client.Logger.LogError(InteractivityEvents.InteractivityCollectorError, ex, &quot;Exception occurred while collecting reactions&quot;);
⋮----
result = new(new HashSet&lt;Reaction&gt;(request.Collected).ToList());
request.Dispose();
this._requests.TryRemove(request);
⋮----
///     Handles the reaction add.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event&apos;s arguments.&lt;/param&gt;
⋮----
private Task HandleReactionAdd(DiscordClient client, MessageReactionAddEventArgs eventArgs)
⋮----
// foreach request add
⋮----
if (req.Collected.Any(x =&gt; x.Emoji == eventArgs.Emoji &amp;&amp; x.Users.Any(y =&gt; y.Id == eventArgs.User.Id)))
⋮----
var reaction = req.Collected.First(x =&gt; x.Emoji == eventArgs.Emoji &amp;&amp; x.Users.Any(y =&gt; y.Id == eventArgs.User.Id));
req.Collected.TryRemove(reaction);
reaction.Users.Add(eventArgs.User);
req.Collected.Add(reaction);
⋮----
req.Collected.Add(new()
⋮----
///     Handles the reaction remove.
⋮----
private Task HandleReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs eventArgs)
⋮----
// foreach request remove
⋮----
reaction.Users.TryRemove(eventArgs.User);
⋮----
///     Handles the reaction clear.
⋮----
private Task HandleReactionClear(DiscordClient client, MessageReactionsClearEventArgs eventArgs)
⋮----
req.Collected.Clear();
⋮----
this.Dispose();
⋮----
///     The reaction collect request.
⋮----
public class ReactionCollectRequest : IDisposable
⋮----
internal CancellationTokenSource Ct;
internal DiscordMessage Message;
⋮----
internal TimeSpan Timeout;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ReactionCollectRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;msg&quot;&gt;The msg.&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;The timeout.&lt;/param&gt;
⋮----
this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(null));
⋮----
///     Disposes the.
⋮----
this.Ct.Dispose();
⋮----
///     The reaction.
⋮----
public class Reaction
⋮----
///     Gets the emoji.
⋮----
///     Gets the users.
⋮----
///     Gets the total.</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/CollectRequest.cs">/// &lt;summary&gt;
///     CollectRequest is a class that serves as a representation of
///     EventArgs that are being collected within a specific time frame.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
internal class CollectRequest&lt;T&gt; : IDisposable where T : AsyncEventArgs
⋮----
internal CancellationTokenSource Ct;
⋮----
internal TimeSpan Timeout;
⋮----
///     Creates a new CollectRequest object.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;Predicate to match&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;Timeout time&lt;/param&gt;
⋮----
this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(true));
⋮----
///     Disposes this CollectRequest.
⋮----
public void Dispose()
⋮----
this.Ct.Dispose();
⋮----
this.Collected.Clear();
⋮----
GC.SuppressFinalize(this);
⋮----
this.Dispose();
⋮----
/*
              ^  ^
( Quack! )&gt; (ﾐචᆽචﾐ)


(somewhere on twitter I read amazon had a duck
that said meow so I had to add a cat that says quack)

*/</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/MatchRequest.cs">/// &lt;summary&gt;
///     MatchRequest is a class that serves as a representation of a
///     match that is being waited for.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
internal class MatchRequest&lt;T&gt; : IDisposable where T : AsyncEventArgs
⋮----
internal CancellationTokenSource Ct;
⋮----
internal TimeSpan Timeout;
⋮----
///     Creates a new MatchRequest object.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;Predicate to match&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;Timeout time&lt;/param&gt;
⋮----
this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(null));
⋮----
///     Disposes this MatchRequest.
⋮----
public void Dispose()
⋮----
this.Ct.Dispose();
⋮----
GC.SuppressFinalize(this);
⋮----
this.Dispose();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/PollRequest.cs">/// &lt;summary&gt;
///     The poll request.
/// &lt;/summary&gt;
public class PollRequest
⋮----
internal CancellationTokenSource Ct;
⋮----
internal DiscordMessage Message;
⋮----
internal TimeSpan Timeout;
⋮----
/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;emojis&quot;&gt;&lt;/param&gt;
⋮----
this.Ct.Token.Register(() =&gt; this.Tcs.TrySetResult(true));
⋮----
this.Emojis = emojis.ToList();
⋮----
this.Collected.Add(new(e));
⋮----
///     Clears the collected.
⋮----
internal void ClearCollected()
⋮----
this.Collected.Clear();
⋮----
///     Removes the reaction.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
/// &lt;param name=&quot;member&quot;&gt;The member.&lt;/param&gt;
internal void RemoveReaction(DiscordEmoji emoji, DiscordUser member)
⋮----
if (this.Collected.Any(x =&gt; x.Emoji == emoji))
if (this.Collected.Any(x =&gt; x.Voted.Contains(member)))
⋮----
var e = this.Collected.First(x =&gt; x.Emoji == emoji);
this.Collected.TryRemove(e);
e.Voted.TryRemove(member);
this.Collected.Add(e);
⋮----
///     Adds the reaction.
⋮----
internal void AddReaction(DiscordEmoji emoji, DiscordUser member)
⋮----
if (!this.Collected.Any(x =&gt; x.Voted.Contains(member)))
⋮----
e.Voted.Add(member);
⋮----
this.Dispose();
⋮----
///     Disposes this PollRequest.
⋮----
public void Dispose()
⋮----
this.Ct.Dispose();
⋮----
///     The poll emoji.
⋮----
public class PollEmoji
⋮----
public DiscordEmoji Emoji;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PollEmoji&quot; /&gt; class.
⋮----
///     Gets the total.</file><file path="DisCatSharp.Interactivity/Extensions/ClientExtensions.cs">/// &lt;summary&gt;
///     Interactivity extension methods for &lt;see cref=&quot;DiscordClient&quot; /&gt; and &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
/// &lt;/summary&gt;
public static class ClientExtensions
⋮----
///     Enables interactivity for this &lt;see cref=&quot;DiscordClient&quot; /&gt; instance.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client to enable interactivity for.&lt;/param&gt;
/// &lt;param name=&quot;configuration&quot;&gt;A configuration instance. Default configuration values will be used if none is provided.&lt;/param&gt;
/// &lt;returns&gt;A brand new &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instance.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if interactivity has already been enabled for the client instance.&lt;/exception&gt;
public static InteractivityExtension UseInteractivity(this DiscordClient client, InteractivityConfiguration configuration = null)
⋮----
if (client.GetExtension&lt;InteractivityExtension&gt;() != null) throw new InvalidOperationException($&quot;Interactivity is already enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);
⋮----
var extension = new InteractivityExtension(configuration);
client.AddExtension(extension);
⋮----
///     Enables interactivity for each shard.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The shard client to enable interactivity for.&lt;/param&gt;
/// &lt;param name=&quot;configuration&quot;&gt;
///     Configuration to use for all shards. If one isn&apos;t provided, default configuration values
///     will be used.
/// &lt;/param&gt;
/// &lt;returns&gt;A dictionary containing new &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instances for each shard.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, InteractivityExtension&gt;&gt; UseInteractivityAsync(this DiscordShardedClient client, InteractivityConfiguration configuration = null)
⋮----
await client.InitializeShardsAsync().ConfigureAwait(false);
⋮----
foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
⋮----
var extension = shard.GetExtension&lt;InteractivityExtension&gt;() ?? shard.UseInteractivity(configuration);
extensions.Add(shard.ShardId, extension);
⋮----
///     Retrieves the registered &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instance for this client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client to retrieve an &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instance from.&lt;/param&gt;
/// &lt;returns&gt;
///     An existing &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instance, or &lt;see langword=&quot;null&quot; /&gt; if interactivity is not
///     enabled for the &lt;see cref=&quot;DiscordClient&quot; /&gt; instance.
/// &lt;/returns&gt;
public static InteractivityExtension GetInteractivity(this DiscordClient client)
⋮----
///     Retrieves a &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instance for each shard.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The shard client to retrieve interactivity instances from.&lt;/param&gt;
/// &lt;returns&gt;A dictionary containing &lt;see cref=&quot;InteractivityExtension&quot; /&gt; instances for each shard.&lt;/returns&gt;
public static async Task&lt;ReadOnlyDictionary&lt;int, InteractivityExtension&gt;&gt; GetInteractivityAsync(this DiscordShardedClient client)
⋮----
extensions.Add(shard.ShardId, shard.GetExtension&lt;InteractivityExtension&gt;());</file><file path="DisCatSharp.Interactivity/Extensions/MessageExtensions.cs">/// &lt;summary&gt;
///     Interactivity extension methods for &lt;see cref=&quot;DisCatSharp.Entities.DiscordMessage&quot; /&gt;.
/// &lt;/summary&gt;
public static class MessageExtensions
⋮----
///     Waits for the next message that has the same author and channel as this message.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Original message.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Overrides the timeout set in &lt;see cref=&quot;InteractivityConfiguration.Timeout&quot; /&gt;&lt;/param&gt;
public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
=&gt; message.Channel.GetNextMessageAsync(message.Author, timeoutOverride);
⋮----
///     Waits for the next message with the same author and channel as this message, which also satisfies a predicate.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;A predicate that should return &lt;see langword=&quot;true&quot; /&gt; if a message matches.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordMessage message, Func&lt;DiscordMessage, bool&gt; predicate, TimeSpan? timeoutOverride = null)
=&gt; message.Channel.GetNextMessageAsync(msg =&gt; msg.Author.Id == message.Author.Id &amp;&amp; message.ChannelId == msg.ChannelId &amp;&amp; predicate(msg), timeoutOverride);
⋮----
///     Waits for any button to be pressed on the specified message.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to wait on.&lt;/param&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message)
=&gt; GetInteractivity(message).WaitForButtonAsync(message);
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, timeoutOverride);
⋮----
/// &lt;param name=&quot;token&quot;&gt;A custom cancellation token that can be cancelled at any point.&lt;/param&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, CancellationToken token)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, token);
⋮----
///     Waits for a button with the specified Id to be pressed on the specified message.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the button to wait for.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, string id, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, id, timeoutOverride);
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, string id, CancellationToken token)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, id, token);
⋮----
///     Waits for any button to be pressed on the specified message by the specified user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to wait for button input from.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, user, timeoutOverride);
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, DiscordUser user, CancellationToken token)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, user, token);
⋮----
///     Waits for any button to be interacted with.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;The predicate to filter interactions by.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override the timeout specified in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;&lt;/param&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, predicate, timeoutOverride);
⋮----
/// &lt;param name=&quot;token&quot;&gt;
///     A token to cancel interactivity with at any time. Pass &lt;see cref=&quot;CancellationToken.None&quot; /&gt; to
///     wait indefinitely.
/// &lt;/param&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, CancellationToken token)
=&gt; GetInteractivity(message).WaitForButtonAsync(message, predicate, token);
⋮----
///     Waits for any dropdown to be interacted with.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to wait for.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;A filter predicate.&lt;/param&gt;
/// &lt;param name=&quot;selectType&quot;&gt;The &lt;see cref=&quot;ComponentType&quot;&gt;type&lt;/see&gt; of the select menu.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override the timeout period specified in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the message doesn&apos;t contain any dropdowns&lt;/exception&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, predicate, selectType, timeoutOverride);
⋮----
///     A token that can be used to cancel interactivity. Pass &lt;see cref=&quot;CancellationToken.None&quot; /&gt; to
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, CancellationToken token)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, predicate, selectType, token);
⋮----
///     Waits for a dropdown to be interacted with.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the dropdown to wait for.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, id, selectType, timeoutOverride);
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, string id, ComponentType selectType, CancellationToken token)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, id, selectType, token);
⋮----
///     Waits for a dropdown to be interacted with by the specified user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to wait for.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;timeoutOverride&quot;&gt;&lt;/param&gt;
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, DiscordUser user, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, user, id, selectType, timeoutOverride);
⋮----
public static Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(this DiscordMessage message, DiscordUser user, string id, ComponentType selectType, CancellationToken token)
=&gt; GetInteractivity(message).WaitForSelectAsync(message, user, id, selectType, token);
⋮----
///     Waits for a reaction on this message from a specific user.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Target message.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The target user.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
///     Thrown if interactivity is not enabled for the client associated with the
///     message.
/// &lt;/exception&gt;
public static Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(this DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForReactionAsync(message, user, timeoutOverride);
⋮----
///     Waits for a specific reaction on this message from the specified user.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The target emoji.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(this DiscordMessage message, DiscordUser user, DiscordEmoji emoji, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).WaitForReactionAsync(e =&gt; e.Emoji == emoji, message, user, timeoutOverride);
⋮----
///     Collects all reactions on this message within the timeout duration.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to collect reactions from.&lt;/param&gt;
⋮----
public static Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectReactionsAsync(this DiscordMessage message, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).CollectReactionsAsync(message, timeoutOverride);
⋮----
///     Begins a poll using this message.
⋮----
/// &lt;param name=&quot;emojis&quot;&gt;Options for this poll.&lt;/param&gt;
/// &lt;param name=&quot;behaviorOverride&quot;&gt;
///     Overrides the action set in
///     &lt;see cref=&quot;InteractivityConfiguration.PaginationBehaviour&quot; /&gt;
⋮----
public static Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(this DiscordMessage message, IEnumerable&lt;DiscordEmoji&gt; emojis, PollBehaviour? behaviorOverride = null, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(message).DoPollAsync(message, emojis, behaviorOverride, timeoutOverride);
⋮----
///     Retrieves an interactivity instance from a message instance.
⋮----
internal static InteractivityExtension GetInteractivity(DiscordMessage message)
⋮----
var interactivity = client.GetInteractivity();
⋮----
return interactivity ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);</file><file path="DisCatSharp.Interactivity/GlobalSuppressions.cs"></file><file path="DisCatSharp.Interactivity/InteractivityEvents.cs">/// &lt;summary&gt;
///     Contains well-defined event IDs used by the Interactivity extension.
/// &lt;/summary&gt;
public static class InteractivityEvents
⋮----
///     Miscellaneous events, that do not fit in any other category.
⋮----
///     Events pertaining to errors that happen during waiting for events.
⋮----
///     Events pertaining to pagination.
⋮----
///     Events pertaining to polling.
⋮----
///     Events pertaining to event collection.</file><file path="DisCatSharp.Interactivity/InteractivityResult.cs">/// &lt;summary&gt;
///     Interactivity result
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of result&lt;/typeparam&gt;
⋮----
///     Whether interactivity was timed out
⋮----
///     Result
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InteractivityResult{T}&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;timedOut&quot;&gt;If true, timed out.&lt;/param&gt;
/// &lt;param name=&quot;result&quot;&gt;The result.&lt;/param&gt;</file><file path="DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.Lavalink/Entities/DefaultQueueEntry.cs">/// &lt;summary&gt;
///     Represents a default queue entry.
/// &lt;/summary&gt;
public sealed class DefaultQueueEntry : IQueueEntry
⋮----
/// &lt;inheritdoc /&gt;
⋮----
public Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player)
=&gt; Task.FromResult(true);
⋮----
public Task AfterPlayingAsync(LavalinkGuildPlayer player)</file><file path="DisCatSharp.Lavalink/Entities/Filters/IPluginFilter.cs">/// &lt;summary&gt;
///     Represents an plugin filter.
/// &lt;/summary&gt;
public interface IPluginFilter</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkChannelMix.cs">/// &lt;summary&gt;
///     Mixes both channels (left and right), with a configurable factor on how much each channel affects the other. With
///     the defaults, both channels are kept independent of each other. Setting all factors to 0.5 means both channels get
///     the same audio.
/// &lt;/summary&gt;
public sealed class LavalinkChannelMix
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkChannelMix&quot; /&gt;
/// &lt;param name=&quot;leftToLeft&quot;&gt;The left to left channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)&lt;/param&gt;
/// &lt;param name=&quot;leftToRight&quot;&gt;The left to right channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)&lt;/param&gt;
/// &lt;param name=&quot;rightToLeft&quot;&gt;The right to left channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)&lt;/param&gt;
/// &lt;param name=&quot;rightToRight&quot;&gt;
///     The right to right channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no
///     effect)
/// &lt;/param&gt;
⋮----
///     Gets or sets the left to left channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)
⋮----
///     Gets or sets the left to right channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)
⋮----
///     Gets or sets the right to left channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)
⋮----
///     Gets or sets the right to right channel mix factor (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.5&lt;/c&gt; is no effect)</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkDisortion.cs">/// &lt;summary&gt;
///     Distortion effect. It can generate some pretty unique audio effects.
/// &lt;/summary&gt;
public sealed class LavalinkDisortion
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkDisortion&quot; /&gt;
/// &lt;param name=&quot;sinOffset&quot;&gt;The sin offset&lt;/param&gt;
/// &lt;param name=&quot;sinScale&quot;&gt;The sin scale&lt;/param&gt;
/// &lt;param name=&quot;cosOffset&quot;&gt;The cos offset&lt;/param&gt;
/// &lt;param name=&quot;cosScale&quot;&gt;The cos scale&lt;/param&gt;
/// &lt;param name=&quot;tanOffset&quot;&gt;The tan offset&lt;/param&gt;
/// &lt;param name=&quot;tanScale&quot;&gt;The tan scale&lt;/param&gt;
/// &lt;param name=&quot;offset&quot;&gt;The offset&lt;/param&gt;
/// &lt;param name=&quot;scale&quot;&gt;The scale&lt;/param&gt;
⋮----
///     The sin offset
⋮----
///     The sin scale
⋮----
///     The cos offset
⋮----
///     The cos scale
⋮----
///     The tan offset
⋮----
///     The tan scale
⋮----
///     The offset
⋮----
///     The scale</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkEqualizer.cs">/// &lt;summary&gt;
///     There are 15 bands (0-14) that can be changed. &quot;gain&quot; is the multiplier for the given band. The default value is 0.
///     Valid values range from -0.25 to 1.0, where -0.25 means the given band is completely muted, and 0.25 means it is
///     doubled. Modifying the gain could also change the volume of the output.
/// &lt;/summary&gt;
public sealed class LavalinkEqualizer
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkEqualizer&quot; /&gt;
/// &lt;param name=&quot;band&quot;&gt;The band&lt;/param&gt;
/// &lt;param name=&quot;gain&quot;&gt;The gain (&lt;c&gt;-0.25&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt;)&lt;/param&gt;
⋮----
///     The band.
⋮----
///     The gain (&lt;c&gt;-0.25&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt;)</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkFilters.cs">/// &lt;summary&gt;
///     Represents various lavalink filters.
/// &lt;/summary&gt;
public sealed class LavalinkFilters
⋮----
///     Gets or sets the player volume from &lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;5.0&lt;/c&gt;, where &lt;c&gt;1.0&lt;/c&gt; is 100%. Values &gt;&lt;c&gt;1.0&lt;/c&gt; may
///     cause clipping.
⋮----
///     Gets or sets the equalizer.
⋮----
///     Gets or sets the karaoke.
⋮----
///     Gets or sets the timescale.
⋮----
///     Gets or sets the tremolo.
⋮----
///     Gets or sets the vibrato.
⋮----
///     Gets or sets the rotation.
⋮----
///     Gets or sets the disortion.
⋮----
///     Gets or sets the channel-mix.
⋮----
///     Gets or sets the low-pass.
⋮----
///     Gets a dictionary of custom plugin filters.
///     &lt;para&gt;&lt;c&gt;Key&lt;/c&gt; is plugin name.&lt;/para&gt;
///     &lt;para&gt;&lt;c&gt;Value&lt;/c&gt; is plugin object.&lt;/para&gt;</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkKaraoke.cs">/// &lt;summary&gt;
///     Uses equalization to eliminate part of a band, usually targeting vocals.
/// &lt;/summary&gt;
public sealed class LavalinkKaraoke
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkKaraoke&quot; /&gt;
/// &lt;param name=&quot;level&quot;&gt;The level&lt;/param&gt;
/// &lt;param name=&quot;monoLevel&quot;&gt;The mono level&lt;/param&gt;
/// &lt;param name=&quot;filterBand&quot;&gt;The filter band in Hz.&lt;/param&gt;
/// &lt;param name=&quot;filterWidth&quot;&gt;The filter width.&lt;/param&gt;
⋮----
///     Gets or sets the level (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.0&lt;/c&gt; is no effect and &lt;c&gt;1.0&lt;/c&gt; is full effect).
⋮----
///     Gets or sets the mono level (&lt;c&gt;0.0&lt;/c&gt; to &lt;c&gt;1.0&lt;/c&gt; where &lt;c&gt;0.0&lt;/c&gt; is no effect and &lt;c&gt;1.0&lt;/c&gt; is full effect).
⋮----
///     Gets or sets the filter band in Hz.
⋮----
///     Gets or sets the filter width.</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkLowPass.cs">/// &lt;summary&gt;
///     Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass.
/// &lt;/summary&gt;
public sealed class LavalinkLowPass
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkLowPass&quot; /&gt;
/// &lt;param name=&quot;smoothing&quot;&gt;The smoothing factor&lt;/param&gt;
⋮----
///     The smoothing factor (&lt;c&gt;&gt;1.0&lt;/c&gt;, Any smoothing values equal to or less than 1.0 will disable the filter)</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkRotation.cs">/// &lt;summary&gt;
///     Rotates the sound around the stereo channels/user headphones (aka Audio Panning).
/// &lt;/summary&gt;
public sealed class LavalinkRotation
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkRotation&quot; /&gt;
/// &lt;param name=&quot;rotationHz&quot;&gt;The frequency of the audio rotating around the listener in Hz.&lt;/param&gt;
⋮----
///     The frequency of the audio rotating around the listener in Hz.</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkTimescale.cs">/// &lt;summary&gt;
///     Changes the speed, pitch, and rate.
/// &lt;/summary&gt;
public sealed class LavalinkTimescale
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkTimescale&quot; /&gt;
/// &lt;param name=&quot;speed&quot;&gt;The playback speed. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)&lt;/param&gt;
/// &lt;param name=&quot;pitch&quot;&gt;The pitch. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)&lt;/param&gt;
/// &lt;param name=&quot;rate&quot;&gt;The rate. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)&lt;/param&gt;
⋮----
///     The playback speed. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)
⋮----
///     The pitch. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)
⋮----
///     The rate. (&lt;c&gt;&gt;0.0&lt;/c&gt; where &lt;c&gt;1.0&lt;/c&gt; is default)</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkTremolo.cs">/// &lt;summary&gt;
///     Uses amplification to create a shuddering effect, where the volume quickly oscillates.
/// &lt;/summary&gt;
public sealed class LavalinkTremolo
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkTremolo&quot; /&gt;
/// &lt;param name=&quot;frequency&quot;&gt;The frequency. (&lt;c&gt;&gt;0.0&lt;/c&gt;)&lt;/param&gt;
/// &lt;param name=&quot;depth&quot;&gt;The tromelo depth. (&lt;c&gt;&gt;0.0&lt;/c&gt;)&lt;/param&gt;
⋮----
///     The frequency. (&lt;c&gt;&gt;0.0&lt;/c&gt;)
⋮----
///     The tromelo depth. (&lt;c&gt;&gt;0.0&lt;/c&gt;)</file><file path="DisCatSharp.Lavalink/Entities/Filters/LavalinkVibrato.cs">/// &lt;summary&gt;
///     Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch.
/// &lt;/summary&gt;
public sealed class LavalinkVibrato
⋮----
/// &lt;inheritdoc cref=&quot;LavalinkVibrato&quot; /&gt;
/// &lt;param name=&quot;frequency&quot;&gt;The frequency. (&lt;c&gt;&gt;0.0&lt;/c&gt;)&lt;/param&gt;
/// &lt;param name=&quot;depth&quot;&gt;The vibrato depth. (&lt;c&gt;&gt;0.0&lt;/c&gt;)&lt;/param&gt;
⋮----
///     The frequency. (&lt;c&gt;&gt;0.0&lt;/c&gt;)
⋮----
///     The vibrato depth. (&lt;c&gt;&gt;0.0&lt;/c&gt;)</file><file path="DisCatSharp.Lavalink/Entities/IQueueEntry.cs">/// &lt;summary&gt;
///     Represents an interface for using the built-in DisCatSharp Lavalink queue.
/// &lt;/summary&gt;
public interface IQueueEntry
⋮----
///     The lavalink track to play.
⋮----
///     Adds a track.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to add.&lt;/param&gt;
/// &lt;returns&gt;The queue entry.&lt;/returns&gt;
public IQueueEntry AddTrack(LavalinkTrack track)
⋮----
///     Actions to execute before this queue entry gets played.
///     Return &lt;see langword=&quot;false&quot; /&gt; if entry shouldn&apos;t be played.
⋮----
/// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
Task&lt;bool&gt; BeforePlayingAsync(LavalinkGuildPlayer player);
⋮----
///     Actions to execute after this queue entry was played.
⋮----
Task AfterPlayingAsync(LavalinkGuildPlayer player);</file><file path="DisCatSharp.Lavalink/Entities/LavalinkException.cs">/// &lt;summary&gt;
///     Represents a lavalink exception.
/// &lt;/summary&gt;
public sealed class LavalinkException
⋮----
///     Gets message of the exception.
⋮----
///     Gets the severity of the exception
⋮----
///     Gets the cause of the exception.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkInfo.cs">/// &lt;summary&gt;
///     Represents lavalink server information.
/// &lt;/summary&gt;
public sealed class LavalinkInfo
⋮----
///     Gets the timestamp when this version was built.
⋮----
///     Gets the lavalink version object.
⋮----
///     Gets the datetime offset when this version was built.
⋮----
public DateTimeOffset BuildTime =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._buildTime);
⋮----
///     Gets the git information.
⋮----
///     Gets the jvm version.
⋮----
///     Gets the lavaplayer version.
⋮----
///     Gets a &lt;see cref=&quot;List{T}&quot; /&gt; of available source managers.
⋮----
///     Gets a &lt;see cref=&quot;List{T}&quot; /&gt; of available folters.
⋮----
///     Gets a &lt;see cref=&quot;List{T}&quot; /&gt; of available plugins.
⋮----
///     Represents git information
⋮----
public sealed class Git
⋮----
///     Gets the millisecond unix timestamp for when the commit was created.
⋮----
///     Gets the branch this Lavalink server was build on.
⋮----
///     Gets the commit hash this Lavalink server was build on.
⋮----
///     Gets the commit time as datetime offset when this Lavalink server was build.
⋮----
public DateTimeOffset CommitTime =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._commitTime);
⋮----
///     Represents a plugin.
⋮----
public sealed class Plugin
⋮----
///     Gets the plugin name.
⋮----
///     Gets the plugin version.
⋮----
///     Represents a version object.
⋮----
public sealed class Version
⋮----
///     Gets the full version string of the Lavalink server.
⋮----
///     Gets the major version of the Lavalink server.
⋮----
///     Gets the minor version of the Lavalink server.
⋮----
///     Gets the patch version of the Lavalink server.
⋮----
///     Gets the pre-release version according to semver as a &lt;c&gt;.&lt;/c&gt; separated list of identifiers.
⋮----
///     The build metadata according to semver as a &lt;c&gt;.&lt;/c&gt; separated list of identifiers</file><file path="DisCatSharp.Lavalink/Entities/LavalinkLyricsResult.cs">/// &lt;summary&gt;
///     Represents a lavalink lyrics result.
/// &lt;/summary&gt;
public sealed class LavalinkLyricsResult
⋮----
///     Gets the name of the source where the lyrics were fetched from.
⋮----
///     Gets the name of the provider the lyrics was fetched from on the source.
⋮----
///     Gets the lyrics text.
⋮----
///     Gets the lyrics lines.
⋮----
///     Gets additional plugin specific data.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlayer.cs">/// &lt;summary&gt;
///     Represents a lavalink player.
/// &lt;/summary&gt;
public sealed class LavalinkPlayer
⋮----
///     Gets the guild id this player belongs to.
⋮----
///     Gets the currently loaded track.
⋮----
///     Gets the volume of this player.
⋮----
///     Gets whether this player is paused.
⋮----
///     Gets the player state.
⋮----
///     Gets the player voice state.
⋮----
///     Gets the player filters.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlayerState.cs">/// &lt;summary&gt;
///     Represents a lavalink player state.
/// &lt;/summary&gt;
public sealed class LavalinkPlayerState
⋮----
///     Gets the position of the track in milliseconds.
⋮----
///     Gets the unix timestamp in milliseconds.
⋮----
///     Gets the current datetime offset.
⋮----
public DateTimeOffset Time =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._time);
⋮----
///     Gets the position of the track as &lt;see cref=&quot;TimeSpan&quot; /&gt;.
⋮----
public TimeSpan Position =&gt; TimeSpan.FromMilliseconds(this._position);
⋮----
///     Gets whether Lavalink is connected to the voice gateway.
⋮----
///     Gets the ping of the node to the Discord voice server in milliseconds (&lt;c&gt;-1&lt;/c&gt; if not connected).</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlaylist.cs">/// &lt;summary&gt;
///     Represents a lavalink playlist result.
/// &lt;/summary&gt;
public sealed class LavalinkPlaylist
⋮----
///     Gets the lavalink playlist info.
⋮----
///     Gets the lavalink plugin info.
⋮----
///     Gets the loaded tracks.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkPlaylistInfo.cs">/// &lt;summary&gt;
///     Represents a lavalink playlist info.
/// &lt;/summary&gt;
public sealed class LavalinkPlaylistInfo
⋮----
///     Gets the name of the playlist.
⋮----
///     Gets the selected track.
///     &lt;para&gt;&lt;c&gt;-1&lt;/c&gt; if none is selected.&lt;/para&gt;</file><file path="DisCatSharp.Lavalink/Entities/LavalinkRestResponse.cs">/// &lt;summary&gt;
///     Represents a response sent by the remote HTTP party.
/// &lt;/summary&gt;
internal sealed class LavalinkRestResponse
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkRestResponse&quot; /&gt; class.
⋮----
///     Gets the response code sent by the remote party.
⋮----
///     Gets the headers of the response send by the remote party.
⋮----
///     Gets the contents of the response sent by the remote party.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkSessionConfiguration.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;LavalinkSessionConfiguration&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class LavalinkSessionConfiguration
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkSessionConfiguration&quot; /&gt;.
⋮----
/// &lt;param name=&quot;resuming&quot;&gt;Whether resuming is enabled for this session or not.&lt;/param&gt;
/// &lt;param name=&quot;timeoutSeconds&quot;&gt;The timeout in seconds.&lt;/param&gt;
⋮----
///     Whether resuming is enabled for this session or not.
⋮----
///     The timeout in seconds (default is 60s)</file><file path="DisCatSharp.Lavalink/Entities/LavalinkStats.cs">/// &lt;summary&gt;
///     Represents lavalink server statistics.
/// &lt;/summary&gt;
public sealed class LavalinkStats
⋮----
///     Gets the uptime of the lavalink server.
⋮----
///     Constructs an empty &lt;see cref=&quot;LavalinkStats&quot; /&gt; object.
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkStats&quot; /&gt; object from a &lt;see cref=&quot;StatsOp&quot; /&gt; received via websocket.
///     &lt;para&gt;This includes &lt;see cref=&quot;Frames&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;websocketStats&quot;&gt;The gateway stats.&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkStats&quot; /&gt; object from a &lt;see cref=&quot;LavalinkStats&quot; /&gt; received via rest.
///     &lt;para&gt;
///         Pulls &lt;see cref=&quot;Frames&quot; /&gt; from existing &lt;see cref=&quot;LavalinkStats&quot; /&gt; received via gateway as
///         &lt;see cref=&quot;StatsOp&quot; /&gt;.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;restStats&quot;&gt;The rest stats object.&lt;/param&gt;
/// &lt;param name=&quot;websocketStats&quot;&gt;The gateway stats object (previous stats object).&lt;/param&gt;
⋮----
///     Gets the total count of players.
⋮----
///     Gets the count of playing (active) players.
⋮----
///     Gets the uptime &lt;see cref=&quot;TimeSpan&quot; /&gt; of the lavalink server.
⋮----
public TimeSpan Uptime =&gt; TimeSpan.FromMilliseconds(this._uptime);
⋮----
///     Gets the memory stats.
⋮----
///     Gets the cpu stats.
⋮----
///     Gets or sets the frames.
⋮----
///     Represents memory stats.
⋮----
public sealed class MemoryStats
⋮----
///     Gets the reservable memory.
⋮----
///     Gets the used memory.
⋮----
///     Gets the free memory.
⋮----
///     Gets the allocated memory.
⋮----
///     Represents cpu stats.
⋮----
public sealed class CpuStats
⋮----
///     Gets the cores.
⋮----
///     Gets the system load.
⋮----
///     Gets the lavalink load.
⋮----
///     Represents frame stats.
⋮----
public sealed class FrameStats
⋮----
///     Gets the sent frames count.
⋮----
///     Gets the nulled frames count.
⋮----
///     Gets the deficit.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkTrack.cs">/// &lt;summary&gt;
///     Represents a lavalink track.
/// &lt;/summary&gt;
public sealed class LavalinkTrack
⋮----
///     Gets the encoded track.
⋮----
///     Gets the lavalink track info.
⋮----
// This can be dynamic
⋮----
///     Gets the lavalink plugin info.
⋮----
///     Gets the user info.
⋮----
///     Represents lavalink plugin information.
⋮----
public sealed class LavalinkPluginInfo
⋮----
///     Gets additional json properties that are not known to the deserializing object.
⋮----
///     Lets JsonConvert set the unknown properties.
⋮----
///     Represents track information.
⋮----
public sealed class LavalinkTrackInfo
⋮----
///     Gets the track identifier.
⋮----
///     Gets whether the track is seekable.
⋮----
///     Gets the track author.
⋮----
///     Gets the track length.
⋮----
public TimeSpan Length =&gt; !this.IsStream ? TimeSpan.FromMilliseconds(this.LengthInternal) : TimeSpan.Zero;
⋮----
///     Gets whether the track is a stream.
⋮----
///     Gets the current position.
⋮----
public TimeSpan Position =&gt; TimeSpan.FromMilliseconds(this.PositionInternal);
⋮----
///     Gets the track title.
⋮----
///     Gets the track url.
⋮----
///     Gets the tracks artwork url.
⋮----
///     Gets the tracks isrc.
⋮----
///     Gets the tracks source name.</file><file path="DisCatSharp.Lavalink/Entities/LavalinkTrackLoadingResult.cs">/// &lt;summary&gt;
///     Represents a loading result when looking up tracks with
///     &lt;see cref=&quot;LavalinkSession.LoadTracksAsync(LavalinkSearchType, string)&quot; /&gt; or
///     &lt;see cref=&quot;LavalinkGuildPlayer.LoadTracksAsync(string)&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class LavalinkTrackLoadingResult
⋮----
///     Gets the load result type.
⋮----
///     Gets the raw result string.
⋮----
///     Gets the load result.
///     &lt;para&gt;You need to convert the &lt;see langword=&quot;object&quot; /&gt; to the corresponding type based on &lt;see cref=&quot;LoadType&quot; /&gt;.&lt;/para&gt;
///     &lt;example&gt;
///         &lt;code&gt;var track = (LavalinkTrack)LavalinkTrackLoadingResult.Result;&lt;/code&gt;
///     &lt;/example&gt;
///     &lt;list type=&quot;table&quot;&gt;
///         &lt;listheader&gt;
///             &lt;term&gt;
///                 &lt;see cref=&quot;LoadType&quot; /&gt;
///             &lt;/term&gt;
///             &lt;description&gt;Convert to&lt;/description&gt;
///         &lt;/listheader&gt;
///         &lt;item&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkLoadResultType.Track&quot; /&gt;
⋮----
///             &lt;description&gt;
///                 &lt;see cref=&quot;LavalinkTrack&quot; /&gt;
///             &lt;/description&gt;
///         &lt;/item&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkLoadResultType.Playlist&quot; /&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkPlaylist&quot; /&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkLoadResultType.Search&quot; /&gt;
⋮----
///             &lt;description&gt;&lt;see cref=&quot;List{T}&quot; /&gt; of &lt;see cref=&quot;LavalinkTrack&quot; /&gt;&lt;/description&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkLoadResultType.Empty&quot; /&gt;
⋮----
///                 &lt;see langword=&quot;null&quot; /&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkLoadResultType.Error&quot; /&gt;
⋮----
///                 &lt;see cref=&quot;LavalinkException&quot; /&gt;
⋮----
///     &lt;/list&gt;
⋮----
///     Gets the result as a specific type.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to convert to.&lt;/typeparam&gt;
/// &lt;returns&gt;Result as the specified type.&lt;/returns&gt;
public T GetResultAs&lt;T&gt;()</file><file path="DisCatSharp.Lavalink/Entities/LavalinkVoiceState.cs">/// &lt;summary&gt;
///     Represents a lavalink voice state with credentials to connect to discord voice servers.
/// &lt;/summary&gt;
public sealed class LavalinkVoiceState
⋮----
///     The token for the voice connection.
⋮----
///     The voice server to connect to.
⋮----
///     The session id for the voice connection.</file><file path="DisCatSharp.Lavalink/Entities/LyricsLine.cs">/// &lt;summary&gt;
///     Represents a lyric line.
/// &lt;/summary&gt;
public sealed class LyricsLine
⋮----
///     Gets the timestamp of the line in milliseconds.
⋮----
///     Gets the duration of the line in milliseconds.
⋮----
///     Gets the lyrics line.
⋮----
///     Gets additional plugin specific data.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/EventOP.cs">/// &lt;summary&gt;
///     Represents an event op.
/// &lt;/summary&gt;
internal class EventOp : LavalinkOp
⋮----
///     Gets the op type of event.
⋮----
///     Gets the related guild id.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/LavalinkOp.cs">/// &lt;summary&gt;
///     Represents a lavalink op.
/// &lt;/summary&gt;
internal class LavalinkOp
⋮----
///     Gets the op type.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/PlayerUpdateOp.cs">/// &lt;summary&gt;
///     Represents a player update op.
/// &lt;/summary&gt;
internal sealed class PlayerUpdateOp : LavalinkOp
⋮----
///     Gets the related guild id.
⋮----
///     Gets the updated player state.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/ReadyOp.cs">/// &lt;summary&gt;
///     Represents a ready op.
/// &lt;/summary&gt;
internal sealed class ReadyOp : LavalinkOp
⋮----
///     Gets whether the session was resumed.
⋮----
///     Gets the lavalink session id.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/StatsOp.cs">/// &lt;summary&gt;
///     Represents lavalink server statistics received via websocket.
/// &lt;/summary&gt;
internal sealed class StatsOp : LavalinkOp
⋮----
///     Gets or sets the uptime.
⋮----
///     Gets the total count of players.
⋮----
///     Gets the count of playing (active) players.
⋮----
///     Gets or sets the memory stats.
⋮----
///     Gets or sets the cpu stats.
⋮----
///     Gets or sets the frame stats.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackEndEvent.cs">/// &lt;summary&gt;
///     Represents a track end event.
/// &lt;/summary&gt;
internal sealed class TrackEndEvent : EventOp
⋮----
///     Gets the lavalink track.
⋮----
///     Gets the end reason.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackException.cs">/// &lt;summary&gt;
///     Represents a lavalink exception received via websocket.
/// &lt;/summary&gt;
internal sealed class TrackException
⋮----
///     Gets message of the exception.
⋮----
///     Gets the severity of the exception
⋮----
///     Gets the cause of the exception.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackExceptionEvent.cs">/// &lt;summary&gt;
///     Represents a track exception.
/// &lt;/summary&gt;
internal sealed class TrackExceptionEvent : EventOp
⋮----
///     Gets the lavalink track.
⋮----
///     Gets the track exception.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackStartEvent.cs">/// &lt;summary&gt;
///     Represents a track start event.
/// &lt;/summary&gt;
internal sealed class TrackStartEvent : EventOp
⋮----
///     Gets the lavalink track.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/TrackStuckEvent.cs">/// &lt;summary&gt;
///     Represents a track stuck event.
/// &lt;/summary&gt;
internal sealed class TrackStuckEvent : EventOp
⋮----
///     Gets the lavalink track.
⋮----
///     Gets the threshold in milliseconds that was exceeded.</file><file path="DisCatSharp.Lavalink/Entities/Websocket/WebSocketClosedEvent.cs">/// &lt;summary&gt;
///     Represents a websocket close event.
/// &lt;/summary&gt;
internal sealed class WebSocketClosedEvent : EventOp
⋮----
///     Gets the Discord close event code.
⋮----
///     Gets the close reason.
⋮----
///     Gets whether the connection was closed by Discord.</file><file path="DisCatSharp.Lavalink/Enums/Filters/LavalinkFilterBand.cs">/// &lt;summary&gt;
///     Represents the different filter bands.
/// &lt;/summary&gt;
⋮----
///     25 Hz
⋮----
///     40 Hz
⋮----
///     63 Hz
⋮----
///     100 Hz
⋮----
///     160 Hz
⋮----
///     250 Hz
⋮----
///     400 Hz
⋮----
///     630 Hz
⋮----
///     1.000 Hz
⋮----
///     1.600 Hz
⋮----
///     2.500 Hz
⋮----
///     4.000 Hz
⋮----
///     6.300 Hz
⋮----
///     10.000 Hz
⋮----
///     16.000 Hz</file><file path="DisCatSharp.Lavalink/Enums/LavalinkEvents.cs">/// &lt;summary&gt;
///     Contains well-defined event IDs used by the Lavalink extension.
/// &lt;/summary&gt;
public static class LavalinkEvents
⋮----
///     Miscellaneous events, that do not fit in any other category.
⋮----
///     Events pertaining to Lavalink node connection errors.
⋮----
///     Events emitted for clean disconnects from Lavalink.
⋮----
///     Events emitted for successful connections made to Lavalink.
⋮----
///     Events emitted when the Lavalink REST API responds with an error.
⋮----
///     Events containing raw payloads, received from Lavalink nodes.
⋮----
///     Events emitted when the Lavalink WebSocket connection sends invalid data.
⋮----
///     Events pertaining to Gateway Intents. Typically diagnostic information.</file><file path="DisCatSharp.Lavalink/Enums/LavalinkLoadResultType.cs">/// &lt;summary&gt;
///     Represents Lavalink track loading results.
/// &lt;/summary&gt;
⋮----
///     Specifies that track was loaded successfully.
⋮----
///     Specifies that playlist was loaded successfully.
⋮----
///     Specifies that the result set contains search results.
⋮----
///     Specifies that the search yielded no results.
⋮----
///     Specifies that the track failed to load.</file><file path="DisCatSharp.Lavalink/Enums/LavalinkRestEndpoints.cs">/// &lt;summary&gt;
///     Represents the lavalink endpoints.
/// &lt;/summary&gt;
internal static class Endpoints
⋮----
///     The version endpoint.
⋮----
///     The websocket endpoint.
⋮----
///     The v4 endpoint.
⋮----
///     The info endpoint.
⋮----
///     The stats endpoint.
⋮----
// Players
⋮----
///     THe sessions endpoint.
⋮----
///     The players endpoint.
⋮----
// Track loading
⋮----
///     The load tracks endpoint.
⋮----
///     The decode track endpoint.
⋮----
///     The decode tracks endpoint.
⋮----
//Route Planner
⋮----
///     The route planner endpoint.
⋮----
///     The status endpoint.
⋮----
///     The free address endpoint.
⋮----
///     The free all endpoint.
⋮----
///     The lyrics endpoint.
⋮----
///     The track endpoint.</file><file path="DisCatSharp.Lavalink/Enums/LavalinkSearchType.cs">/// &lt;summary&gt;
///     The lavalink search type.
/// &lt;/summary&gt;
⋮----
///     Search on SoundCloud
⋮----
///     Search on Youtube.
⋮----
///     Provide Lavalink with a plain URL.
⋮----
/*
	// This does not support search. Keeping it for reference tho.
	/// &lt;summary&gt;
	/// Search on Band Camp.
	/// &lt;/summary&gt;
	BandCamp,

	/// &lt;summary&gt;
	/// Search on Twitch.
	/// &lt;/summary&gt;
	Twitch,

	/// &lt;summary&gt;
	/// Search on Vimeo.
	/// &lt;/summary&gt;
	Vimeo,*/
⋮----
// Requires: https://github.com/topiSenpai/LavaSrc
⋮----
///     Search on Apple Music.
⋮----
///     Search on Deezer.
⋮----
///     Search on Deezer with ISRC.
⋮----
///     Search on Yandex Music.
⋮----
///     Search on Spotify.
⋮----
///     Search on Spotify with recommendation seed.</file><file path="DisCatSharp.Lavalink/Enums/LavalinkTrackEndReason.cs">/// &lt;summary&gt;
///     Represents reasons why a &lt;see cref=&quot;LavalinkTrack&quot; /&gt; ended.
/// &lt;/summary&gt;
⋮----
///     The track was finished.
⋮----
///     The track was failed to load.
⋮----
///     The track was stopped.
⋮----
///     The track was replaced.
⋮----
///     The track was cleaned up.</file><file path="DisCatSharp.Lavalink/Enums/RepeatMode.cs">/// &lt;summary&gt;
/// Represents the repeat mode for the Lavalink player.
/// &lt;/summary&gt;
⋮----
/// No repeat mode. The queue operates normally and does not repeat.
⋮----
/// Repeat all mode. The entire queue repeats once it ends.
⋮----
/// Repeat current mode. The current track is played over and over again.</file><file path="DisCatSharp.Lavalink/Enums/Severity.cs">/// &lt;summary&gt;
///     Represents the severity for exceptions.
/// &lt;/summary&gt;
⋮----
///     The cause is known and expected, indicates that there is nothing wrong with the library itself.
⋮----
///     &lt;para&gt;The cause might not be exactly known, but is possibly caused by outside factors.&lt;/para&gt;
///     &lt;para&gt;For example when an outside service responds in a format that we do not expect.&lt;/para&gt;
⋮----
///     &lt;para&gt;The probable cause is an issue with the library or there is no way to tell what the cause might be.&lt;/para&gt;
///     &lt;para&gt;
///         This is the default level and other levels are used in cases where the thrower has more in-depth knowledge
///         about the error.
///     &lt;/para&gt;</file><file path="DisCatSharp.Lavalink/Enums/Websocket/EventOpType.cs">/// &lt;summary&gt;
///     Represents various event op types.
/// &lt;/summary&gt;
⋮----
///     Event indicates that a track started. Fires &lt;see cref=&quot;LavalinkGuildPlayer.TrackStarted&quot; /&gt;.
⋮----
///     Event indicates that a track ended. Fires &lt;see cref=&quot;LavalinkGuildPlayer.TrackEnded&quot; /&gt;.
⋮----
///     Event indicates that a track encountered an exception. Fires &lt;see cref=&quot;LavalinkGuildPlayer.TrackException&quot; /&gt;.
⋮----
///     Event indicates that a track got stuck. Fires &lt;see cref=&quot;LavalinkGuildPlayer.TrackStuck&quot; /&gt;.
⋮----
///     Event indicates that a track started. Executes &lt;see cref=&quot;LavalinkSession.Lavalink_WebSocket_Disconnected&quot; /&gt;.</file><file path="DisCatSharp.Lavalink/Enums/Websocket/OpType.cs">/// &lt;summary&gt;
///     Represents various lavalink op types.
/// &lt;/summary&gt;
⋮----
///     Indicates that the lavalink session is ready. Fires &lt;see cref=&quot;LavalinkSession.LavalinkSessionConnected&quot; /&gt;.
⋮----
///     Indicates that a &lt;see cref=&quot;LavalinkPlayer&quot; /&gt; got updated. Fires &lt;see cref=&quot;LavalinkSession.StatsReceived&quot; /&gt;.
⋮----
///     Indicates that the session stats got updated. Fires &lt;see cref=&quot;LavalinkSession.StatsReceived&quot; /&gt;.
⋮----
///     Indicates that the op contains further information about an event.</file><file path="DisCatSharp.Lavalink/EventArgs/GuildPlayerDestroyedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for guild player destroy events.
/// &lt;/summary&gt;
public sealed class GuildPlayerDestroyedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildPlayerDestroyedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the destroyed guild player.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.Player.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkPlayerStateUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink player state updates.
/// &lt;/summary&gt;
public sealed class LavalinkPlayerStateUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildPlayerDestroyedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the player state.</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkSessionConnectedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink session connection.
/// &lt;/summary&gt;
public sealed class LavalinkSessionConnectedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkSessionConnectedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;session&quot;&gt;The session.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the session that was connected.</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkSessionDisconnectedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink session disconnection.
/// &lt;/summary&gt;
public sealed class LavalinkSessionDisconnectedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkSessionDisconnectedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;session&quot;&gt;The session.&lt;/param&gt;
/// &lt;param name=&quot;isClean&quot;&gt;If true, is clean.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the session that was disconnected.
⋮----
///     Gets whether disconnect was clean.</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkStatsReceivedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink stats events .
/// &lt;/summary&gt;
public sealed class LavalinkStatsReceivedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkTrackEndedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;stats&quot;&gt;The received statistics.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the updated statistics.</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackEndedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for  lavalink track ended events.
/// &lt;/summary&gt;
public sealed class LavalinkTrackEndedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkTrackEndedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
⋮----
this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
⋮----
///     Gets the discord client.
⋮----
///     Gets the related lavalink track.
⋮----
///     Gets the track end reason.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackExceptionEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink track exceptions.
/// &lt;/summary&gt;
public sealed class LavalinkTrackExceptionEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkTrackExceptionEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
⋮----
this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
⋮----
///     Gets the discord client.
⋮----
///     Gets the related lavalink track.
⋮----
///     Gets the exception.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackStartedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink track started event.
/// &lt;/summary&gt;
public sealed class LavalinkTrackStartedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkTrackStartedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
⋮----
this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
⋮----
///     Gets the discord client.
⋮----
///     Gets the related lavalink track.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkTrackStuckEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink track stuck events.
/// &lt;/summary&gt;
public sealed class LavalinkTrackStuckEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkTrackStuckEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
⋮----
this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
⋮----
///     Gets the discord client.
⋮----
///     Gets the related lavalink track.
⋮----
///     Gets the threshold in milliseconds that was exceeded as &lt;see cref=&quot;TimeSpan&quot; /&gt;.
⋮----
public TimeSpan ThresholdMs =&gt; TimeSpan.FromMilliseconds(this.ThresholdMilliseconds);
⋮----
///     Gets the threshold in milliseconds that was exceeded.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;</file><file path="DisCatSharp.Lavalink/EventArgs/LavalinkWebsocketClosedEventArgs.cs">/// &lt;summary&gt;
///     Represents event arguments for lavalink websocket closed events.
/// &lt;/summary&gt;
public sealed class LavalinkWebsocketClosedEventArgs : SocketCloseEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkWebsocketClosedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The discord client.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
⋮----
this.GuildId = Convert.ToUInt64(eventArgs.GuildId);
⋮----
///     Gets the discord client.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.GuildsInternal.TryGetValue(this.GuildId, out var guild) ? guild : null!;
⋮----
///     Whether the websocket was closed by discord.</file><file path="DisCatSharp.Lavalink/Exceptions/LavalinkRestException.cs">/// &lt;summary&gt;
///     Represents a lavalink rest exception.
/// &lt;/summary&gt;
public sealed class LavalinkRestException : Exception
⋮----
///     Gets the datetime offset when the exception was thrown.
⋮----
public DateTimeOffset Timestamp =&gt; Utilities.GetDateTimeOffsetFromMilliseconds(this._timestamp);
⋮----
///     Gets the response http status code.
⋮----
///     Gets the error message.
⋮----
///     Gets the exception message.
⋮----
///     Gets the path where the exception was thrown.
⋮----
///     Gets the trace information to this exception.
///     &lt;para&gt;Requires &lt;see cref=&quot;LavalinkConfiguration.EnableTrace&quot; /&gt; to set to &lt;see langword=&quot;true&quot; /&gt;.&lt;/para&gt;
⋮----
///     Gets the response header.
⋮----
///     Gets the response json.</file><file path="DisCatSharp.Lavalink/ExtensionMethods.cs">/// &lt;summary&gt;
///     The discord client extensions.
/// &lt;/summary&gt;
public static class ExtensionMethods
⋮----
///     Creates a new Lavalink client with specified settings.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client to create Lavalink instance for.&lt;/param&gt;
/// &lt;returns&gt;Lavalink client instance.&lt;/returns&gt;
public static LavalinkExtension UseLavalink(this DiscordClient client)
⋮----
throw new InvalidOperationException(&quot;Lavalink is already enabled for that client.&quot;);
⋮----
if (!client.Configuration.Intents.HasIntent(DiscordIntents.GuildVoiceStates))
client.Logger.LogCritical(LavalinkEvents.Intents, &quot;The Lavalink extension is registered but the guild voice states intent is not enabled. It is highly recommended to enable it.&quot;);
⋮----
var lava = new LavalinkExtension();
client.AddExtension(lava);
⋮----
///     Creates new Lavalink clients on all shards in a given sharded client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord sharded client to create Lavalink instances for.&lt;/param&gt;
/// &lt;returns&gt;A dictionary of created Lavalink clients.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, LavalinkExtension&gt;&gt; UseLavalinkAsync(this DiscordShardedClient client)
⋮----
await client.InitializeShardsAsync().ConfigureAwait(false);
⋮----
foreach (var shard in client.ShardClients.Select(shardClient =&gt; shardClient.Value))
⋮----
lava ??= shard.UseLavalink();
⋮----
///     Gets the active instance of the Lavalink client for the DiscordClient.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client to get Lavalink instance for.&lt;/param&gt;
⋮----
public static LavalinkExtension GetLavalink(this DiscordClient client)
⋮----
///     Retrieves a &lt;see cref=&quot;LavalinkExtension&quot; /&gt; instance for each shard.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The shard client to retrieve &lt;see cref=&quot;LavalinkExtension&quot; /&gt; instances from.&lt;/param&gt;
/// &lt;returns&gt;A dictionary containing &lt;see cref=&quot;LavalinkExtension&quot; /&gt; instances for each shard.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, LavalinkExtension&gt;&gt; GetLavalinkAsync(this DiscordShardedClient client)
⋮----
extensions.Add(shard.ShardId, shard.GetExtension&lt;LavalinkExtension&gt;());
⋮----
///     Connects to this voice channel using Lavalink.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to connect to.&lt;/param&gt;
/// &lt;param name=&quot;session&quot;&gt;Lavalink session to connect through.&lt;/param&gt;
/// &lt;returns&gt;If successful, the Lavalink client.&lt;/returns&gt;
public static Task ConnectAsync(this DiscordChannel channel, LavalinkSession session)
⋮----
throw new NullReferenceException();
⋮----
throw new InvalidOperationException(&quot;Lavalink can only be used with guild channels.&quot;);
⋮----
throw new InvalidOperationException(&quot;You can only connect to voice and stage channels.&quot;);
⋮----
var lava = discord.GetLavalink();
⋮----
? throw new InvalidOperationException(&quot;Lavalink is not initialized for this Discord client.&quot;)
: session.ConnectAsync(channel);</file><file path="DisCatSharp.Lavalink/GlobalSuppressions.cs"></file><file path="DisCatSharp.Lavalink/LavalinkConfiguration.cs">/// &lt;summary&gt;
///     Lavalink connection configuration.
/// &lt;/summary&gt;
public sealed class LavalinkConfiguration
⋮----
///     Creates a new instance of &lt;see cref=&quot;LavalinkConfiguration&quot; /&gt;.
⋮----
///     Creates a new instance of &lt;see cref=&quot;LavalinkConfiguration&quot; /&gt;, copying the properties of another configuration.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Config the properties of which are to be copied.&lt;/param&gt;
⋮----
///     Sets the endpoint for Lavalink REST.
///     &lt;para&gt;Defaults to &lt;c&gt;127.0.0.1&lt;/c&gt; on port &lt;c&gt;2333&lt;/c&gt;.&lt;/para&gt;
⋮----
///     Sets the endpoint for the Lavalink Websocket connection.
⋮----
///     &lt;para&gt;Sets the proxy to use for HTTP and WebSocket connections to Lavalink.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the timeout for HTTP requests.&lt;/para&gt;
///     &lt;para&gt;Set to &lt;see cref=&quot;System.Threading.Timeout.InfiniteTimeSpan&quot; /&gt; to disable timeouts.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;c&gt;20&lt;/c&gt; seconds.&lt;/para&gt;
⋮----
public TimeSpan HttpTimeout { internal get; set; } = TimeSpan.FromMinutes(2);
⋮----
///     Sets whether the connection wrapper should attempt automatic reconnects should the connection drop.
///     &lt;para&gt;Defaults to true.&lt;/para&gt;
⋮----
///     Sets the password for the Lavalink connection.
///     &lt;para&gt;Defaults to &lt;c&gt;youshallnotpass&lt;/c&gt;.&lt;/para&gt;
⋮----
///     Sets the resume key for the Lavalink connection.
///     &lt;para&gt;This will allow existing voice sessions to continue for a certain time after the client is disconnected.&lt;/para&gt;
⋮----
///     Sets the time in seconds when all voice sessions are closed after the client disconnects.
///     &lt;para&gt;Defaults to &lt;c&gt;60&lt;/c&gt; seconds.&lt;/para&gt;
⋮----
///     Sets the time in milliseconds to wait for Lavalink&apos;s voice WebSocket to close after leaving a voice channel.
///     &lt;para&gt;This will be the delay before the guild connection is removed.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;c&gt;3000&lt;/c&gt; milliseconds.&lt;/para&gt;
⋮----
///     Sets the voice region ID for the Lavalink connection.
///     &lt;para&gt;
///         This should be used if nodes should be filtered by region with
///         &lt;see cref=&quot;LavalinkExtension.GetIdealSession(DiscordVoiceRegion)&quot; /&gt;.
///     &lt;/para&gt;
⋮----
///     Sets whether the built in queue system should be used.
///     &lt;para&gt;Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/para&gt;
⋮----
///     Sets a factory function that creates queue entry objects.
///     This allows you to customize the type of queue entry used by the LavalinkGuildPlayer when
///     &lt;see cref=&quot;EnableBuiltInQueueSystem&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.
///     If set to &lt;see langword=&quot;null&quot; /&gt;, the default queue entry type (&lt;see cref=&quot;DefaultQueueEntry&quot; /&gt;) will be used.
⋮----
///     Gets a new instance of a queue entry object.
///     The type of the object is determined by the &lt;see cref=&quot;QueueEntryFactory&quot; /&gt;.
///     If &lt;see cref=&quot;QueueEntryFactory&quot; /&gt; is &lt;see langword=&quot;null&quot; /&gt;, a &lt;see cref=&quot;DefaultQueueEntry&quot; /&gt; instance is
///     returned.
///     This property is only used when &lt;see cref=&quot;EnableBuiltInQueueSystem&quot; /&gt; is set to &lt;see langword=&quot;true&quot; /&gt;.
⋮----
=&gt; (this.QueueEntryFactory ?? (() =&gt; new DefaultQueueEntry()))();
⋮----
///     Sets whether trace should be enabled for more detailed error responses.
⋮----
///     Sets the default volume level players will be created with.
///     &lt;para&gt;Defaults to &lt;c&gt;70&lt;/c&gt; percent.&lt;/para&gt;
///     &lt;para&gt;Min &lt;c&gt;0&lt;/c&gt;, max &lt;c&gt;1000&lt;/c&gt;.&lt;/para&gt;</file><file path="DisCatSharp.Lavalink/LavalinkExtension.cs">/// &lt;summary&gt;
///     Represents the lavalink extension.
/// &lt;/summary&gt;
public sealed class LavalinkExtension : BaseExtension
⋮----
///     The internal dictionary of connected Lavalink sessions.
⋮----
///     Triggers when a Lavalink session connects.
⋮----
///     Triggers when a Lavalink session disconnects.
⋮----
///     Creates a new instance of this Lavalink extension.
⋮----
///     Gets a dictionary of connected Lavalink sessions for the extension.
⋮----
///     Gets the rest client used to communicate with the lavalink server.
⋮----
///     Gets the lavalink configuration.
⋮----
///     Triggered whenever a session disconnects.
⋮----
add =&gt; this._sessionDisconnected.Register(value);
remove =&gt; this._sessionDisconnected.Unregister(value);
⋮----
///     Triggered whenever a session connects.
⋮----
add =&gt; this._sessionConnected.Register(value);
remove =&gt; this._sessionConnected.Unregister(value);
⋮----
///     DO NOT USE THIS MANUALLY.
⋮----
/// &lt;param name=&quot;client&quot;&gt;DO NOT USE THIS MANUALLY.&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when a developer tries to manually initialize it.&lt;/exception&gt;
protected internal override void Setup(DiscordClient client)
⋮----
throw new InvalidOperationException(&quot;What did I tell you?&quot;);
⋮----
///     Connect to a Lavalink session.
⋮----
/// &lt;param name=&quot;config&quot;&gt;Lavalink client configuration.&lt;/param&gt;
/// &lt;returns&gt;The established Lavalink connection.&lt;/returns&gt;
public async Task&lt;LavalinkSession&gt; ConnectAsync(LavalinkConfiguration config)
⋮----
if (this._connectedSessions.TryGetValue(config.SocketEndpoint, out var session))
⋮----
var versionInfo = await this.REST.GetVersionAsync().ConfigureAwait(false);
if (!versionInfo.Headers.Contains(&quot;Lavalink-Api-Version&quot;))
⋮----
if (versionInfo.Headers.TryGetValues(&quot;Lavalink-Api-Version&quot;, out var headerValues))
if (headerValues.First() != &quot;4&quot;)
⋮----
var con = new LavalinkSession(this.Client, this, config);
⋮----
await con.EstablishConnectionAsync().ConfigureAwait(false);
⋮----
this.LavalinkSessionDisconnect(con);
⋮----
///     Gets the Lavalink session connection for the specified endpoint.
⋮----
/// &lt;param name=&quot;endpoint&quot;&gt;Endpoint at which the session resides.&lt;/param&gt;
/// &lt;returns&gt;Lavalink session connection.&lt;/returns&gt;
public LavalinkSession? GetSession(ConnectionEndpoint endpoint)
=&gt; this._connectedSessions.GetValueOrDefault(endpoint);
⋮----
///     Gets a Lavalink session connection based on load balancing and an optional voice region.
⋮----
/// &lt;param name=&quot;region&quot;&gt;The region to compare with the session&apos;s &lt;see cref=&quot;LavalinkConfiguration.Region&quot; /&gt;, if any.&lt;/param&gt;
/// &lt;returns&gt;The least load affected session connection, or null if no sessions are present.&lt;/returns&gt;
public LavalinkSession? GetIdealSession(DiscordVoiceRegion? region = null)
⋮----
return this._connectedSessions.Values.FirstOrDefault()!;
⋮----
var nodes = this._connectedSessions.Values.ToArray();
⋮----
return this.FilterByLoad(nodes);
⋮----
if (nodes.Any(regionPredicate))
nodes = [.. nodes.Where(regionPredicate)];
⋮----
return nodes.Length &lt;= 1 ? nodes.FirstOrDefault()! : this.FilterByLoad(nodes);
⋮----
///     Gets a Lavalink guild player from a &lt;see cref=&quot;DiscordGuild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild the player is on.&lt;/param&gt;
/// &lt;returns&gt;The found guild player, or null if one could not be found.&lt;/returns&gt;
public LavalinkGuildPlayer? GetGuildPlayer(DiscordGuild guild)
⋮----
var node = nodes.FirstOrDefault(x =&gt; x.ConnectedPlayersInternal.ContainsKey(guild.Id));
⋮----
///     Filters the by load.
⋮----
/// &lt;param name=&quot;sessions&quot;&gt;The sessions.&lt;/param&gt;
private LavalinkSession FilterByLoad(LavalinkSession[] sessions)
⋮----
Array.Sort(sessions, (a, b) =&gt;
⋮----
//player count
⋮----
//cpu load
aPenaltyCount += (int)Math.Pow(1.05d, (100 * (a.Statistics.Cpu.SystemLoad / a.Statistics.Cpu.Cores) * 10) - 10);
bPenaltyCount += (int)Math.Pow(1.05d, (100 * (b.Statistics.Cpu.SystemLoad / a.Statistics.Cpu.Cores) * 10) - 10);
⋮----
//frame load
⋮----
//deficit frame load
aPenaltyCount += (int)((Math.Pow(1.03d, 500f * (a.Statistics.Frames.Deficit / 3000f)) * 600) - 600);
⋮----
//null frame load
aPenaltyCount += (int)((Math.Pow(1.03d, 500f * (a.Statistics.Frames.Deficit / 3000f)) * 300) - 300);
⋮----
bPenaltyCount += (int)((Math.Pow(1.03d, 500f * (b.Statistics.Frames.Deficit / 3000f)) * 600) - 600);
⋮----
bPenaltyCount += (int)((Math.Pow(1.03d, 500f * (b.Statistics.Frames.Deficit / 3000f)) * 300) - 300);
⋮----
///     Fired when a session connects and adds it to &lt;see cref=&quot;ConnectedSessions&quot; /&gt;.
⋮----
/// &lt;param name=&quot;session&quot;&gt;The disconnected session.&lt;/param&gt;
private async void LavalinkSessionConnect(LavalinkSession session)
⋮----
if (this._connectedSessions.TryAdd(session.NodeEndpoint, session))
await session.EstablishConnectionAsync().ConfigureAwait(false);
⋮----
///     Fired when a session disconnected and removes it from &lt;see cref=&quot;ConnectedSessions&quot; /&gt;.
⋮----
private void LavalinkSessionDisconnect(LavalinkSession session)
=&gt; this._connectedSessions.TryRemove(session.NodeEndpoint, out _);
⋮----
///     Fired when a session disconnected.
⋮----
/// &lt;param name=&quot;args&quot;&gt;The event args.&lt;/param&gt;
private Task LavalinkSessionDisconnected(LavalinkSession session, LavalinkSessionDisconnectedEventArgs args)
=&gt; this._sessionDisconnected.InvokeAsync(this, args);
⋮----
///     Fired when a session connected.
⋮----
/// &lt;param name=&quot;session&quot;&gt;The connected session.&lt;/param&gt;
⋮----
private Task LavalinkSessionConnected(LavalinkSession session, LavalinkSessionConnectedEventArgs args)
=&gt; this._sessionConnected.InvokeAsync(this, args);</file><file path="DisCatSharp.Lavalink/LavalinkGuildPlayer.cs">/// &lt;summary&gt;
///     Represents a guild player based on a &lt;see cref=&quot;LavalinkPlayer&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class LavalinkGuildPlayer
⋮----
///     Gets the list of tracks that have been played.
⋮----
///     Triggers when the voice state gets updated.
⋮----
///     Gets the internal list of users.
⋮----
///     Triggers when the player state is updated.
⋮----
///     Triggers when a track ends.
⋮----
///     Triggers when a track throws an exception.
⋮----
///     Triggers when a track starts.
⋮----
///     Triggers when a track gets stuck.
⋮----
///     Gets or sets the current track being played.
⋮----
///     Gets whether this player is disposed.
⋮----
///     &lt;see cref=&quot;TaskCompletionSource&quot; /&gt; for the queue.
⋮----
///     Gets or sets the repeat mode for the queue.
⋮----
private RepeatMode _repeatMode = RepeatMode.None;
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkGuildPlayer&quot; /&gt;.
⋮----
/// &lt;param name=&quot;session&quot;&gt;The session this guild player is registered on.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id the player is registered for.&lt;/param&gt;
/// &lt;param name=&quot;player&quot;&gt;The registered lavalink player.&lt;/param&gt;
⋮----
this.Discord.VoiceStateUpdated += async (sender, args) =&gt; await this._voiceStateUpdated.InvokeAsync(sender, args).ConfigureAwait(false);
⋮----
this.CurrentUsersInternal.Add(this.Discord.CurrentUser.Id, this.Discord.CurrentUser);
⋮----
QueueInternal.TryAdd(guildId, new());
⋮----
///     Gets the internal queue of tracks for each guild.
⋮----
///     Gets the queue.
⋮----
public IReadOnlyList&lt;LavalinkTrack&gt; Queue =&gt; [.. QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;())];
⋮----
///     Gets whether the built-in queue system is enabled.
⋮----
///     Gets the current guild id.
⋮----
///     Gets the current channel id.
⋮----
///     Gets the session this player is attached to.
⋮----
///     Gets the guild this player is attached to.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild)
⋮----
///     Gets the discord client.
⋮----
///     Gets the current channel this player is in.
⋮----
///     Gets the lavalink player.
⋮----
///     Gets the current track.
⋮----
///     Gets the current track position.
⋮----
///     Gets the current ping.
⋮----
///     Gets a list of current user in the &lt;see cref=&quot;Channel&quot; /&gt;.
⋮----
///     Gets whether this player is currently connected.
⋮----
public bool IsConnected =&gt; !Volatile.Read(ref this._isDisposed) &amp;&amp; this.Channel != null!;
⋮----
add =&gt; this._voiceStateUpdated.Register(value);
remove =&gt; this._voiceStateUpdated.Unregister(value);
⋮----
///     Triggers when a track started.
⋮----
add =&gt; this.TrackStartedEvent.Register(value);
remove =&gt; this.TrackStartedEvent.Unregister(value);
⋮----
///     Triggers when a track ended.
⋮----
add =&gt; this.TrackEndedEvent.Register(value);
remove =&gt; this.TrackEndedEvent.Unregister(value);
⋮----
add =&gt; this.TrackExceptionEvent.Register(value);
remove =&gt; this.TrackExceptionEvent.Unregister(value);
⋮----
add =&gt; this.TrackStuckEvent.Register(value);
remove =&gt; this.TrackStuckEvent.Unregister(value);
⋮----
///     Triggers when a player state updated.
⋮----
add =&gt; this.StateUpdatedEvent.Register(value);
remove =&gt; this.StateUpdatedEvent.Unregister(value);
⋮----
///     Fired when a track ended.
///     &lt;para&gt;Used to control the built-in queue.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The guild player.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The event args.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private Task OnTrackEnded(LavalinkGuildPlayer sender, LavalinkTrackEndedEventArgs args)
⋮----
this.PlayNextInQueue();
⋮----
///     Decodes encoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;s.
///     &lt;para&gt;Might not work with pre 4.0 tracks.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;tracks&quot;&gt;The tracks to decode.&lt;/param&gt;
/// &lt;returns&gt;A &lt;see cref=&quot;List{T}&quot; /&gt; of decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;s.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; tracks)
=&gt; await this.Session.DecodeTracksAsync(tracks).ConfigureAwait(false);
⋮----
///     Decodes an encoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;.
///     &lt;para&gt;Might not work with some pre 4.0 tracks.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to decode.&lt;/param&gt;
/// &lt;returns&gt;The decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string track)
=&gt; await this.Session.DecodeTrackAsync(track).ConfigureAwait(false);
⋮----
///     Loads tracks by &lt;paramref name=&quot;identifier&quot; /&gt;.
///     Returns a dynamic object you have to parse with (Type)Result.
⋮----
/// &lt;param name=&quot;identifier&quot;&gt;The identifier to load.&lt;/param&gt;
/// &lt;returns&gt;A track loading result.&lt;/returns&gt;
public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
=&gt; await this.Session.LoadTracksAsync(identifier).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;searchType&quot;&gt;The search type to use. Some types need additional setup.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(LavalinkSearchType searchType, string identifier)
=&gt; await this.Session.LoadTracksAsync(searchType, identifier).ConfigureAwait(false);
⋮----
///     Gets the lyrics for the currently playing track.
⋮----
/// &lt;param name=&quot;skipTrackSource&quot;&gt;Whether to skip the current track source and fetch from highest priority source.&lt;/param&gt;
/// &lt;returns&gt;The &lt;see cref=&quot;LavalinkLyricsResult&quot; /&gt; or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(bool skipTrackSource = false)
=&gt; await this.Session.Rest.GetLyricsForCurrentTrackAsync(this.Session.Config.SessionId!, this.GuildId, skipTrackSource).ConfigureAwait(false);
⋮----
///     Updates the &lt;see cref=&quot;LavalinkPlayer&quot; /&gt;.
⋮----
/// &lt;param name=&quot;action&quot;&gt;The action to perform on the player.&lt;/param&gt;
/// &lt;returns&gt;The updated guild player.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when both &lt;c&gt;EncodedTrack&lt;/c&gt; and &lt;c&gt;Identifier&lt;/c&gt; are set.&lt;/exception&gt;
public async Task&lt;LavalinkGuildPlayer&gt; UpdateAsync(Action&lt;LavalinkPlayerUpdateModel&gt; action)
⋮----
var mdl = new LavalinkPlayerUpdateModel();
⋮----
if (mdl.EncodedTrack.HasValue &amp;&amp; !string.IsNullOrEmpty(mdl.EncodedTrack.Value) &amp;&amp; mdl.Identifier.HasValue)
throw new InvalidOperationException($&quot;Cannot set both {nameof(mdl.EncodedTrack)} &amp; {mdl.Identifier}. Only one at a time.&quot;);
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(
⋮----
).ConfigureAwait(false);
⋮----
///     Plays a song partially by its identifier with a start and end-time.
⋮----
/// &lt;param name=&quot;identifier&quot;&gt;The identifier to play.&lt;/param&gt;
/// &lt;param name=&quot;startTime&quot;&gt;The start time.&lt;/param&gt;
/// &lt;param name=&quot;endTime&quot;&gt;The end time.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialAsync(string identifier, TimeSpan startTime, TimeSpan endTime)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: identifier, position: (int)startTime.TotalMilliseconds,
endTime: (int)endTime.TotalMilliseconds).ConfigureAwait(false);
⋮----
///     Plays a track partially with a start and end-time.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to play.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialAsync(LavalinkTrack track, TimeSpan startTime, TimeSpan endTime)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: track.Info.Uri.ToString(),
position: (int)startTime.TotalMilliseconds, endTime: (int)endTime.TotalMilliseconds).ConfigureAwait(false);
⋮----
///     Plays a song by its encoded track string with a start and end-time.
⋮----
/// &lt;param name=&quot;encodedTrack&quot;&gt;The encoded track to play.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayPartialEncodedAsync(string encodedTrack, TimeSpan startTime, TimeSpan endTime)
⋮----
.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, encodedTrack, position: (int)startTime.TotalMilliseconds, endTime: (int)endTime.TotalMilliseconds)
.ConfigureAwait(false);
⋮----
///     Plays a song by its identifier.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayAsync(string identifier)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: identifier).ConfigureAwait(false);
⋮----
///     Plays a track.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayAsync(LavalinkTrack track)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: track.Info.Uri.ToString()).ConfigureAwait(false);
⋮----
///     Plays a song by its encoded track string.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PlayEncodedAsync(string encodedTrack)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, encodedTrack).ConfigureAwait(false);
⋮----
///     Seeks the player to the position in &lt;paramref name=&quot;seconds&quot; /&gt;.
⋮----
/// &lt;param name=&quot;seconds&quot;&gt;The seconds to seek to.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; SeekAsync(int seconds)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, position: seconds * 1000).ConfigureAwait(false);
⋮----
///     Seeks the player to the position.
⋮----
/// &lt;param name=&quot;position&quot;&gt;The position to seek to.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; SeekAsync(TimeSpan position)
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, position: (int)position.TotalMilliseconds).ConfigureAwait(false);
⋮----
///     Modifies the volume of the player.
⋮----
/// &lt;param name=&quot;volume&quot;&gt;The volume of the player, range &lt;c&gt;0&lt;/c&gt;-&lt;c&gt;1000&lt;/c&gt;, in percentage.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the &lt;paramref name=&quot;volume&quot; /&gt; is out of range.&lt;/exception&gt;
public async Task&lt;LavalinkGuildPlayer&gt; SetVolumeAsync(int volume)
⋮----
throw new ArgumentException(&quot;Volume can only be between 0 and 1000&quot;, nameof(volume));
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, volume: volume).ConfigureAwait(false);
⋮----
///     Pauses the player.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; PauseAsync()
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, paused: true).ConfigureAwait(false);
⋮----
///     Resumes the player.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; ResumeAsync()
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, true, paused: false).ConfigureAwait(false);
⋮----
///     Stops the player.
⋮----
public async Task&lt;LavalinkGuildPlayer&gt; StopAsync()
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, false, null).ConfigureAwait(false);
⋮----
///     Skips the current track.
⋮----
public Task&lt;LavalinkGuildPlayer&gt; SkipAsync()
=&gt; this.StopAsync();
⋮----
///     Directly plays a song by url.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The url to play.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;NotSupportedException&quot;&gt;Thrown when the &lt;paramref name=&quot;url&quot; /&gt; is a pure youtube playlist.&lt;/exception&gt;
public async Task&lt;LavalinkGuildPlayer&gt; PlayDirectUrlAsync(string url)
⋮----
if (CommonRegEx.AdvancedYoutubeRegex().IsMatch(url))
⋮----
if (url.Contains(&quot;playlist&quot;))
throw new NotSupportedException(&quot;Lavalink is unable to play a playlist directly.&quot;);
⋮----
var match = CommonRegEx.AdvancedYoutubeRegex().Match(url);
if (match.Groups[&quot;list&quot;] != null! &amp;&amp; !string.IsNullOrEmpty(match.Groups[&quot;list&quot;].Value))
⋮----
this.Session.Discord.Logger.LogTrace(LavalinkEvents.Misc, null, &quot;Removed list from playlist url. Not supported&quot;);
url = url.Replace($&quot;list={match.Groups[&quot;list&quot;].Value}&quot;, null);
⋮----
if (match.Groups[&quot;index&quot;] != null! &amp;&amp; !string.IsNullOrEmpty(match.Groups[&quot;index&quot;].Value))
⋮----
this.Session.Discord.Logger.LogTrace(LavalinkEvents.Misc, null, &quot;Removed index from playlist url. Not supported&quot;);
url = url.Replace($&quot;index={match.Groups[&quot;index&quot;].Value}&quot;, null);
⋮----
this.Player = await this.Session.Rest.UpdatePlayerAsync(this.Session.Config.SessionId!, this.GuildId, identifier: url).ConfigureAwait(false);
⋮----
///     Switches the player to a new channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The new channel to switch to.&lt;/param&gt;
/// &lt;param name=&quot;deafened&quot;&gt;Whether to join deafened.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the target channel is not of the base type voice.&lt;/exception&gt;
public async Task SwitchChannelAsync(DiscordChannel channel, bool deafened = true)
⋮----
throw new ArgumentException(&quot;Cannot switch to a non-voice channel&quot;, nameof(channel));
⋮----
var vsd = new DiscordDispatchPayload
⋮----
Payload = new VoiceStateUpdatePayload
⋮----
await this.Session.Discord.WsSendAsync(LavalinkJson.SerializeObject(vsd)).ConfigureAwait(false);
⋮----
///     Updates the player state.
⋮----
/// &lt;param name=&quot;state&quot;&gt;The player state to update with.&lt;/param&gt;
internal void UpdatePlayerState(LavalinkPlayerState state)
⋮----
///     Updates the voice state.
⋮----
/// &lt;param name=&quot;voiceState&quot;&gt;The voice state to update with.&lt;/param&gt;
internal void UpdateVoiceState(LavalinkVoiceState voiceState)
⋮----
///     Disconnect the guild player from the channel.
⋮----
public async Task DisconnectAsync()
⋮----
await this.Session.Rest.DestroyPlayerAsync(this.Session.Config.SessionId!, this.GuildId).ConfigureAwait(false);
await this.DisconnectVoiceAsync().ConfigureAwait(false);
this.CurrentUsersInternal.Clear();
Volatile.Write(ref this._isDisposed, true);
await this.Session.GuildPlayerDestroyedEvent.InvokeAsync(this.Session, new(this)).ConfigureAwait(false);
⋮----
///     Informs discord to perform a voice disconnect.
⋮----
internal async Task DisconnectVoiceAsync()
⋮----
///     Handles the &lt;see cref=&quot;DiscordClient.VoiceStateUpdated&quot; /&gt; event.
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The discord client.&lt;/param&gt;
⋮----
private Task OnVoiceStateUpdated(DiscordClient sender, VoiceStateUpdateEventArgs args)
⋮----
this.CurrentUsersInternal.TryAdd(args.User.Id, args.User);
⋮----
this.CurrentUsersInternal.Remove(args.User.Id);
⋮----
///     Adds a Lavalink track to the queue.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to add.&lt;/param&gt;
public void AddToQueue(LavalinkTrack track)
⋮----
QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;()).Enqueue(track);
⋮----
///     Adds all tracks from a Lavalink playlist to the queue.
⋮----
/// &lt;param name=&quot;playlist&quot;&gt;The &lt;see cref=&quot;LavalinkPlaylist&quot; /&gt; containing the tracks to add.&lt;/param&gt;
public void AddToQueue(LavalinkPlaylist playlist)
⋮----
this.AddToQueue(track);
⋮----
///     Inserts a track at the specified index in the queue.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index at which the track should be inserted.&lt;/param&gt;
/// &lt;param name=&quot;track&quot;&gt;The track to insert.&lt;/param&gt;
public void AddToQueueAt(int index, LavalinkTrack track)
⋮----
if (QueueInternal.TryGetValue(this.GuildId, out var queue))
queue.InsertAt(index, track);
⋮----
///     Inserts a range of tracks at the specified index in the queue.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index at which the tracks should be inserted.&lt;/param&gt;
/// &lt;param name=&quot;tracks&quot;&gt;The tracks to insert.&lt;/param&gt;
public void AddToQueueAt(int index, IEnumerable&lt;LavalinkTrack&gt; tracks)
⋮----
queue.InsertRange(index, tracks);
⋮----
///     Attempts to retrieve the next track in the queue without removing it.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The next track in the queue, or null if the queue is empty.&lt;/param&gt;
/// &lt;returns&gt;True if a track was found, false otherwise.&lt;/returns&gt;
public bool TryPeekQueue([NotNullWhen(true)] out LavalinkTrack? track)
⋮----
if (QueueInternal.TryGetValue(this.GuildId, out var queue) &amp;&amp; queue.TryPeek(out var result))
⋮----
///     Shuffles the tracks in the queue.
⋮----
public void ShuffleQueue()
⋮----
queue.Shuffle();
⋮----
///     Reverses the order of the tracks in the queue.
⋮----
public void ReverseQueue()
⋮----
queue.Reverse();
⋮----
///     Removes the specified track from the queue.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to remove.&lt;/param&gt;
public void RemoveFromQueue(LavalinkTrack track)
⋮----
queue.Remove(track);
⋮----
///     Removes the track with the specified title (identifier) from the queue.
⋮----
/// &lt;param name=&quot;identifier&quot;&gt;The title (identifier) of the track to remove.&lt;/param&gt;
public void RemoveFromQueue(string identifier)
⋮----
if (!this.QUEUE_SYSTEM_ENABLED || !QueueInternal.TryGetValue(this.GuildId, out var queue))
⋮----
var trackToRemove = queue.FirstOrDefault(x =&gt; x.Info.Title == identifier);
⋮----
queue.Remove(trackToRemove);
⋮----
///     Removes the track at the specified index from the queue.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index of the track to remove.&lt;/param&gt;
public void RemoveFromQueueAt(int index)
⋮----
queue.RemoveAt(index);
⋮----
///     Removes a range of tracks from the queue.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index of the first track to remove.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;The number of tracks to remove.&lt;/param&gt;
public void RemoveFromQueueAtRange(int index, int count)
⋮----
queue.RemoveRange(index, count);
⋮----
///     Clears all tracks from the queue.
⋮----
public void ClearQueue()
⋮----
queue.Clear();
⋮----
///     Sets the repeat mode for the queue.
⋮----
/// &lt;param name=&quot;mode&quot;&gt;The repeat mode to set.&lt;/param&gt;
public void SetRepeatMode(RepeatMode mode)
⋮----
///     Starts playing the next track in the queue.
⋮----
public void PlayQueue()
⋮----
///     Plays the next track in the queue.
⋮----
private async void PlayNextInQueue()
⋮----
await Task.Delay(TimeSpan.FromSeconds(1));
⋮----
var queue = QueueInternal.GetOrAdd(this.GuildId, new LavalinkQueue&lt;LavalinkTrack&gt;());
⋮----
else if (queue.TryDequeue(out nextTrack))
⋮----
queue.Enqueue(track);
⋮----
this._playedTracks.Clear();
⋮----
if (queue.TryDequeue(out nextTrack))
⋮----
var queueEntry = this.Session.Config.QueueEntry.AddTrack(nextTrack);
⋮----
if (await queueEntry.BeforePlayingAsync(this).ConfigureAwait(false))
⋮----
await this.PlayAsync(queueEntry.Track).ConfigureAwait(false);
⋮----
await this._queueTsc.Task.ConfigureAwait(false);
⋮----
await queueEntry.AfterPlayingAsync(this).ConfigureAwait(false);
⋮----
this._playedTracks.Add(nextTrack);</file><file path="DisCatSharp.Lavalink/LavalinkQueue.cs">/// &lt;summary&gt;
///     Represents a queue of objects.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
public class LavalinkQueue&lt;T&gt; : IEnumerable&lt;T&gt;
⋮----
///     Gets the internal entries.
⋮----
///     Creates a new instance of &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
///     Gets the number of elements contained in the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;inheritdoc /&gt;
public IEnumerator&lt;T&gt; GetEnumerator()
⋮----
IEnumerator IEnumerable.GetEnumerator()
=&gt; this.GetEnumerator();
⋮----
///     Adds an object to the end of the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The object to add to the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;. The value cannot be null.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Thrown when the value is null.&lt;/exception&gt;
public void Enqueue(T value)
⋮----
ArgumentNullException.ThrowIfNull(value);
⋮----
this._list.AddLast(value);
⋮----
///     Attempts to remove and return the object at the beginning of the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;value&quot;&gt;
///     When this method returns, contains the object removed from the beginning of the
///     &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;, or the default value of &lt;typeparamref name=&quot;T&quot; /&gt; if the queue is empty.
/// &lt;/param&gt;
/// &lt;returns&gt;&lt;see langword=&quot;true&quot; /&gt; if an object was successfully removed; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&lt;/returns&gt;
public bool TryDequeue(out T value)
⋮----
this._list.RemoveFirst();
⋮----
///     Attempts to return the object at the beginning of the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt; without removing it.
⋮----
///     When this method returns, contains the object at the beginning of the
⋮----
/// &lt;returns&gt;
///     &lt;see langword=&quot;true&quot; /&gt; if there is an object at the beginning of the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;;
///     otherwise, &lt;see langword=&quot;false&quot; /&gt;.
/// &lt;/returns&gt;
public bool TryPeek([NotNullWhen(true)] out T? value)
⋮----
///     Removes the first occurrence of a specific object from the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The object to remove from the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;. The value cannot be null.&lt;/param&gt;
⋮----
public void Remove(T value)
⋮----
this._list.Remove(value);
⋮----
///     Removes all elements from the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
public void Clear()
⋮----
this._list.Clear();
⋮----
///     Shuffles the elements in the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt; randomly.
⋮----
public void Shuffle()
⋮----
var j = Random.Shared.Next(i + 1);
⋮----
///     Removes the element at the specified index of the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index of the element to remove.&lt;/param&gt;
/// &lt;returns&gt;The value of the element that was removed.&lt;/returns&gt;
/// &lt;exception cref=&quot;Exception&quot;&gt;Thrown when the node at the specified index is null.&lt;/exception&gt;
public T RemoveAt(int index)
⋮----
this._list.Remove(currentNode);
⋮----
///     Reverses the order of the elements in the entire &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
public void Reverse()
⋮----
reversedList.AddLast(node.Value);
⋮----
///     Removes a range of elements from the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index of the first element to remove.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;The number of elements to remove.&lt;/param&gt;
/// &lt;returns&gt;A collection containing the removed elements.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;Thrown when the index or count is out of range.&lt;/exception&gt;
public ICollection&lt;T&gt; RemoveRange(int index, int count)
⋮----
ArgumentOutOfRangeException.ThrowIfNegative(index);
ArgumentOutOfRangeException.ThrowIfNegative(count);
ArgumentOutOfRangeException.ThrowIfGreaterThan(count, this.Count - index);
⋮----
///     Inserts an object at the specified index in the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index at which the object should be inserted.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The object to insert. The value cannot be null.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;Thrown when the index is out of range.&lt;/exception&gt;
⋮----
public void InsertAt(int index, T value)
⋮----
ArgumentOutOfRangeException.ThrowIfGreaterThan(index, this.Count);
⋮----
throw new ArgumentOutOfRangeException(nameof(index), &quot;Index was out of range.&quot;);
⋮----
this._list.AddBefore(currentNode, value);
⋮----
///     Adds a range of objects at the specified index in the &lt;see cref=&quot;LavalinkQueue{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;index&quot;&gt;The zero-based index at which the objects should be inserted.&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;The objects to insert. The values cannot be null.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Thrown when the values are null.&lt;/exception&gt;
⋮----
public void InsertRange(int index, IEnumerable&lt;T&gt; values)
⋮----
ArgumentNullException.ThrowIfNull(values);</file><file path="DisCatSharp.Lavalink/LavalinkRestClient.cs">/// &lt;summary&gt;
///     Provides various rest methods to interact with the Lavalink API.
/// &lt;/summary&gt;
internal sealed class LavalinkRestClient
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkRestClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;configuration&quot;&gt;The lavalink configuration to use.&lt;/param&gt;
/// &lt;param name=&quot;client&quot;&gt;The discord client this rest client is attached to.&lt;/param&gt;
⋮----
var httpHandler = new HttpClientHandler
⋮----
BaseAddress = new($&quot;{configuration.RestEndpoint.ToHttpString()}&quot;),
⋮----
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;User-Agent&quot;, $&quot;DisCatSharp.Lavalink/{this.Discord.VersionString}&quot;);
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;Authorization&quot;, configuration.Password);
⋮----
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;User-Id&quot;, this.Discord.CurrentUser.Id.ToString(CultureInfo.InvariantCulture));
⋮----
///     Gets the discord client.
⋮----
///     Gets the http client.
⋮----
///     Gets whether trace is enabled.
⋮----
///     Builds the query string.
⋮----
/// &lt;param name=&quot;values&quot;&gt;The values.&lt;/param&gt;
/// &lt;param name=&quot;post&quot;&gt;Whether this query will be transmitted via POST.&lt;/param&gt;
private static string BuildQueryString(IDictionary&lt;string, string&gt; values, bool post = false)
⋮----
var valuesCollection = values.Select(xkvp =&gt;
$&quot;{WebUtility.UrlEncode(xkvp.Key)}={WebUtility.UrlEncode(xkvp.Value)}&quot;);
var valuesString = string.Join(&quot;&amp;&quot;, valuesCollection);
⋮----
///     Gets the path with its &lt;paramref name=&quot;routeParams&quot; /&gt; applied.
⋮----
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;routeParams&quot;&gt;The route params.&lt;/param&gt;
/// &lt;returns&gt;The generated route.&lt;/returns&gt;
private static string GetPath(string route, object routeParams)
⋮----
var routeParamsProperties = routeParams.GetType()
.GetTypeInfo()
⋮----
var val = xp.GetValue(routeParams);
⋮----
? dt.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture)
⋮----
? dto.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture)
⋮----
? xf.ToString(null, CultureInfo.InvariantCulture)
: val.ToString();
⋮----
return CommonRegEx.HttpRouteRegex().Replace(route, xm =&gt; extractedRouteParams[xm.Groups[1].Value]);
⋮----
private Dictionary&lt;string, string&gt; GetDefaultParams()
⋮----
[&quot;trace&quot;] = this.TRACE_ENABLED.ToString().ToLower()
⋮----
///     Executes a rest request.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;path&quot;&gt;The path.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;The headers.&lt;/param&gt;
/// &lt;param name=&quot;payload&quot;&gt;The payload.&lt;/param&gt;
private async Task&lt;LavalinkRestResponse&gt; DoRequestAsync(HttpMethod method, string path, IReadOnlyDictionary&lt;string, string&gt;? headers = null, string? payload = null)
⋮----
HttpRequestMessage request = new();
⋮----
request.Headers.TryAddWithoutValidation(header.Key, header.Value);
⋮----
request.Content = new StringContent(payload);
⋮----
var response = await this.HttpClient.SendAsync(request, HttpCompletionOption.ResponseContentRead).ConfigureAwait(false);
⋮----
var data = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
var ex = LavalinkJson.DeserializeObject&lt;LavalinkRestException?&gt;(data) ?? new LavalinkRestException();
⋮----
this.Discord.Logger.LogError(LavalinkEvents.LavalinkRestError, ex, &quot;Lavalink rest encountered an exception: {data}&quot;, data);
⋮----
var res = new LavalinkRestResponse
⋮----
Response = response.StatusCode != HttpStatusCode.NoContent ? await response.Content.ReadAsStringAsync().ConfigureAwait(false) : null,
⋮----
///     Requests Lavalink server version.
⋮----
/// &lt;returns&gt;The version &lt;see cref=&quot;string&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;LavalinkRestResponse&gt; GetVersionAsync()
⋮----
var queryDict = this.GetDefaultParams();
⋮----
return await this.DoRequestAsync(HttpMethod.Get, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
⋮----
///     Requests Lavalink server information.
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;LavalinkInfo&quot; /&gt; object.&lt;/returns&gt;
internal async Task&lt;LavalinkInfo&gt; GetInfoAsync()
⋮----
var res = await this.DoRequestAsync(HttpMethod.Get, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
⋮----
///     Requests Lavalink server statistics.
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;LavalinkStats&quot; /&gt; object.&lt;/returns&gt;
internal async Task&lt;LavalinkStats&gt; GetStatsAsync()
⋮----
///     Updates a session with the resuming state and timeout.
⋮----
/// &lt;param name=&quot;sessionId&quot;&gt;The session id.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The session config.&lt;/param&gt;
/// &lt;returns&gt;The updated &lt;see cref=&quot;LavalinkSessionConfiguration&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;LavalinkSessionConfiguration&gt; UpdateSessionAsync(string sessionId, LavalinkSessionConfiguration config)
⋮----
var res = await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(config)).ConfigureAwait(false);
⋮----
///     Returns a list of players for the given session id.
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;IReadOnlyList{T}&quot; /&gt; of &lt;see cref=&quot;LavalinkPlayer&quot; /&gt;s.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;LavalinkPlayer&gt;&gt; GetPlayersAsync(string sessionId)
⋮----
///     Creates a player.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id this player should be created for.&lt;/param&gt;
/// &lt;param name=&quot;defaultVolume&quot;&gt;The default volume level which should be used.&lt;/param&gt;
internal async Task CreatePlayerAsync(string sessionId, ulong guildId, int defaultVolume)
⋮----
queryDict.Add(&quot;noReplace&quot;, &quot;false&quot;);
var pld = new LavalinkRestPlayerCreatePayload(guildId.ToString(), defaultVolume);
⋮----
await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Returns the player for a guild for the given session id.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id this player should be created/updated for.&lt;/param&gt;
/// &lt;returns&gt;The &lt;see cref=&quot;LavalinkPlayer&quot; /&gt; for &lt;paramref name=&quot;guildId&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;LavalinkPlayer&gt; GetPlayerAsync(string sessionId, ulong guildId)
⋮----
///     Updates or creates the player for a guild if it doesn&apos;t already exist for the given session id.
⋮----
/// &lt;param name=&quot;noReplace&quot;&gt;Whether to replace the current track with the new track. Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;encodedTrack&quot;&gt;The encoded track to play.&lt;/param&gt;
/// &lt;param name=&quot;identifier&quot;&gt;The identifier to play&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The position to jump to or start from.&lt;/param&gt;
/// &lt;param name=&quot;endTime&quot;&gt;The time when the track should automatically end.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume.&lt;/param&gt;
/// &lt;param name=&quot;paused&quot;&gt;Whether to pause the track.&lt;/param&gt;
/// &lt;param name=&quot;filters&quot;&gt;The filters.&lt;/param&gt;
/// &lt;param name=&quot;userData&quot;&gt;The user data.&lt;/param&gt;
/// &lt;returns&gt;The updated &lt;see cref=&quot;LavalinkPlayer&quot; /&gt; object.&lt;/returns&gt;
internal async Task&lt;LavalinkPlayer&gt; UpdatePlayerAsync(
⋮----
queryDict.Add(&quot;noReplace&quot;, noReplace.ToString().ToLower());
var pld = new LavalinkRestPlayerUpdatePayload(guildId.ToString())
⋮----
? new PlayerWithEncoded
⋮----
? new PlayerWithIdentifier
⋮----
var res = await this.DoRequestAsync(HttpMethod.Patch, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Updates the players voice state.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id this player voice state should be updated for.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state to update with.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
internal async Task UpdatePlayerVoiceStateAsync(string sessionId, ulong guildId, LavalinkVoiceState state)
⋮----
queryDict.Add(&quot;noReplace&quot;, &quot;true&quot;);
var pld = new LavalinkRestVoiceStateUpdatePayload(state, guildId.ToString());
⋮----
///     Destroys the player for a guild for the given session id
⋮----
internal async Task DestroyPlayerAsync(string sessionId, ulong guildId)
⋮----
await this.DoRequestAsync(HttpMethod.Delete, $&quot;{path}{BuildQueryString(queryDict)}&quot;).ConfigureAwait(false);
⋮----
///     Resolves audio tracks for use with the &lt;see cref=&quot;UpdatePlayerAsync&quot; /&gt; method.
⋮----
/// &lt;param name=&quot;identifier&quot;&gt;The identifier to resolve tracks with.&lt;/param&gt;
/// &lt;returns&gt;
///     A &lt;see cref=&quot;LavalinkTrackLoadingResult&quot; /&gt; where &lt;see cref=&quot;LavalinkTrackLoadingResult.Result&quot; /&gt; is dynamic
///     based on &lt;see cref=&quot;LavalinkTrackLoadingResult.LoadType&quot; /&gt;.
/// &lt;/returns&gt;
internal async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
⋮----
queryDict.Add(&quot;identifier&quot;, identifier);
⋮----
var obj = JObject.Parse(res.Response!);
⋮----
LoadType = obj.GetValue(&quot;loadType&quot;)!.ToObject&lt;LavalinkLoadResultType&gt;(),
RawResult = LavalinkJson.SerializeObject(obj.GetValue(&quot;data&quot;))
⋮----
///     Gets the lyrics for a track.
⋮----
/// &lt;param name=&quot;encodedTrack&quot;&gt;The encoded track.&lt;/param&gt;
/// &lt;param name=&quot;skipTrackSource&quot;&gt;Whether to skip the current track source and fetch from highest priority source.&lt;/param&gt;
/// &lt;param name=&quot;sessionId&quot;&gt;The optional session id a player is associated with.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The optional guild id a player is associated with.&lt;/param&gt;
/// &lt;returns&gt;The &lt;see cref=&quot;LavalinkLyricsResult&quot; /&gt; or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(string encodedTrack, bool skipTrackSource, string? sessionId = null, ulong? guildId = null)
⋮----
queryDict.Add(&quot;track&quot;, encodedTrack);
queryDict.Add(&quot;skipTrackSource&quot;, skipTrackSource.ToString().ToLowerInvariant());
⋮----
///     Gets the lyrics for a currently playing track.
⋮----
/// &lt;param name=&quot;sessionId&quot;&gt;The session id a player is associated with.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id a player is associated with.&lt;/param&gt;
⋮----
internal async Task&lt;LavalinkLyricsResult?&gt; GetLyricsForCurrentTrackAsync(string sessionId, ulong guildId, bool skipTrackSource)
⋮----
///     Decode a single track into its info, where &lt;paramref name=&quot;base64Track&quot; /&gt; is the encoded base64 data.
⋮----
/// &lt;param name=&quot;base64Track&quot;&gt;The encoded track &lt;see cref=&quot;string&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;The decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string base64Track)
⋮----
queryDict.Add(&quot;encodedTrack&quot;, base64Track);
⋮----
///     Decodes multiple tracks into their info.
⋮----
/// &lt;param name=&quot;base64Tracks&quot;&gt;&lt;see cref=&quot;List{T}&quot; /&gt; of encoded track &lt;see cref=&quot;string&quot; /&gt;s.&lt;/param&gt;
/// &lt;returns&gt;A &lt;see cref=&quot;IReadOnlyList{T}&quot; /&gt; of decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;s.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; base64Tracks)
⋮----
var res = await this.DoRequestAsync(HttpMethod.Post, $&quot;{path}{BuildQueryString(queryDict)}&quot;, payload: LavalinkJson.SerializeObject(base64Tracks)).ConfigureAwait(false);</file><file path="DisCatSharp.Lavalink/LavalinkSession.cs">/// &lt;summary&gt;
///     Defines the event handler for &lt;see cref=&quot;LavalinkSessionDisconnectedEventArgs&quot; /&gt;.
/// &lt;/summary&gt;
/// &lt;param name=&quot;node&quot;&gt;The node.&lt;/param&gt;
⋮----
///     Defines the event handler for &lt;see cref=&quot;LavalinkSessionConnectedEventArgs&quot; /&gt;.
⋮----
///     Represents a &lt;see cref=&quot;LavalinkSession&quot; /&gt;.
⋮----
public sealed class LavalinkSession
⋮----
///     Gets the minimum backoff.
⋮----
///     Gets the maximum backoff.
⋮----
///     Triggers when the Lavalink session is connects.
⋮----
///     Triggers when the Lavalink session is disconnected.
⋮----
///     Triggers when a socket error occurs in the Lavalink session.
⋮----
///     Triggers when Lavalink stats are received.
⋮----
///     Gets the voice server updates.
⋮----
///     Gets the voice state updates.
⋮----
///     Triggers when the Lavalink websocket is closed.
⋮----
///     Triggers when a Lavalink guild player is destroyed.
⋮----
///     Gets the current backoff for reconnecting.
⋮----
///     Whether this &lt;see cref=&quot;LavalinkSession&quot; /&gt; is disposed.
⋮----
///     &lt;see cref=&quot;TaskCompletionSource&quot; /&gt; for the &lt;see cref=&quot;LavalinkConfiguration.SessionId&quot; /&gt;.
⋮----
///     Gets the web socket.
⋮----
private IWebSocketClient _webSocket;
⋮----
///     Gets the internal dictionary of connected players for each guild.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkSession&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;extension&quot;&gt;The extension.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The lavalink configuration.&lt;/param&gt;
⋮----
if (config.Region != null! &amp;&amp; this.Discord.VoiceRegions.Values.Contains(config.Region))
⋮----
Volatile.Write(ref this._isDisposed, false);
⋮----
///     Gets the remote endpoint of this Lavalink node connection.
⋮----
///     Gets whether the client is connected to Lavalink.
⋮----
public bool IsConnected =&gt; !Volatile.Read(ref this._isDisposed);
⋮----
///     Gets a dictionary of Lavalink guild connections for this node.
⋮----
///     Gets the REST client for this Lavalink connection.
⋮----
///     Gets the Discord client this node connection belongs to.
⋮----
///     Gets the parent &lt;see cref=&quot;LavalinkExtension&quot; /&gt;.
⋮----
///     Gets the &lt;see cref=&quot;LavalinkConfiguration&quot; /&gt;.
⋮----
///     Gets the voice region.
⋮----
///     Gets the current &lt;see cref=&quot;LavalinkStats&quot; /&gt;.
⋮----
///     Gets the current &lt;see cref=&quot;LavalinkSessionConfiguration&quot; /&gt;.
⋮----
///     Triggered whenever Lavalink WebSocket throws an exception.
⋮----
add =&gt; this._lavalinkSocketError.Register(value);
remove =&gt; this._lavalinkSocketError.Unregister(value);
⋮----
///     Triggered when this session disconnects.
⋮----
add =&gt; this._lavalinkSessionDisconnected.Register(value);
remove =&gt; this._lavalinkSessionDisconnected.Unregister(value);
⋮----
///     Triggered when this session connects.
⋮----
add =&gt; this._lavalinkSessionConnected.Register(value);
remove =&gt; this._lavalinkSessionConnected.Unregister(value);
⋮----
///     Triggered when a &lt;see cref=&quot;LavalinkStats&quot; /&gt; are received.
⋮----
add =&gt; this._statsReceived.Register(value);
remove =&gt; this._statsReceived.Unregister(value);
⋮----
///     Triggered when a &lt;see cref=&quot;LavalinkGuildPlayer&quot; /&gt; gets destroyed.
⋮----
add =&gt; this.GuildPlayerDestroyedEvent.Register(value);
remove =&gt; this.GuildPlayerDestroyedEvent.Unregister(value);
⋮----
///     Triggered when the websocket to discord gets closed.
⋮----
add =&gt; this._websocketClosed.Register(value);
remove =&gt; this._websocketClosed.Unregister(value);
⋮----
///     Fires when a &lt;see cref=&quot;LavalinkSession&quot; /&gt; disconnected.
⋮----
internal event SessionDisconnectedEventHandler SessionDisconnected;
⋮----
internal event SessionConnectedEventHandler SessionConnected;
⋮----
///     Gets the lavalink server information.
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;LavalinkInfo&quot; /&gt; object.&lt;/returns&gt;
public async Task&lt;LavalinkInfo&gt; GetLavalinkInfoAsync()
=&gt; await this.Rest.GetInfoAsync().ConfigureAwait(false);
⋮----
///     Gets the lavalink server version
⋮----
/// &lt;returns&gt;The version &lt;see langword=&quot;string&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;string&gt; GetLavalinkVersionAsync()
⋮----
var versionInfo = await this.Rest.GetVersionAsync().ConfigureAwait(false);
return versionInfo.Headers.TryGetValues(&quot;Lavalink-Api-Version&quot;, out var headerValues)
? headerValues.First()
⋮----
///     Gets the lavalink server statistics.
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;LavalinkStats&quot; /&gt; object.&lt;/returns&gt;
public async Task&lt;LavalinkStats&gt; GetLavalinkStatsAsync()
⋮----
var stats = await this.Rest.GetStatsAsync().ConfigureAwait(false);
⋮----
///     Destroys the current session, disconnecting all players.
⋮----
public async Task DestroyAsync()
⋮----
await this.DestroyGuildPlayersAsync().ConfigureAwait(false);
Volatile.Write(ref this._isDisposed, true);
await this._webSocket.DisconnectAsync(1000, &quot;Shutting down Lavalink Session&quot;).ConfigureAwait(false);
⋮----
///     Destroys all players.
⋮----
public async Task DestroyGuildPlayersAsync()
⋮----
await player.DisconnectAsync().ConfigureAwait(false);
this.ConnectedPlayersInternal.Clear();
⋮----
///     Fires when a &lt;see cref=&quot;LavalinkGuildPlayer&quot; /&gt; was destroyed.
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The lavalink session.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The guild player destroyed event args containing the destroyed &lt;see cref=&quot;LavalinkGuildPlayer&quot; /&gt;.&lt;/param&gt;
private Task LavalinkGuildPlayerDestroyed(LavalinkSession sender, GuildPlayerDestroyedEventArgs args)
⋮----
this.ConnectedPlayersInternal.Remove(args.Player.GuildId, out _);
⋮----
///     Connects to a &lt;see cref=&quot;DiscordChannel&quot; /&gt;.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to join.&lt;/param&gt;
/// &lt;param name=&quot;deafened&quot;&gt;Whether to join the channel deafened.&lt;/param&gt;
/// &lt;returns&gt;The created &lt;see cref=&quot;LavalinkGuildPlayer&quot; /&gt;.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;/exception&gt;
public async Task&lt;LavalinkGuildPlayer&gt; ConnectAsync(DiscordChannel channel, bool deafened = true)
⋮----
if (this.ConnectedPlayersInternal.TryGetValue(channel.Guild.Id, out var connectedGuild))
⋮----
throw new ArgumentException(&quot;Invalid channel specified.&quot;, nameof(channel));
⋮----
var vsd = new DiscordDispatchPayload
⋮----
Payload = new VoiceStateUpdatePayload
⋮----
await this.Rest.CreatePlayerAsync(this.Config.SessionId!, channel.Guild.Id, this.Config.DefaultVolume).ConfigureAwait(false);
await this.Discord.WsSendAsync(LavalinkJson.SerializeObject(vsd)).ConfigureAwait(false); // Send voice dispatch to trigger voice state &amp; voice server update
var vst = await vstut.Task.ConfigureAwait(false); // Wait for voice state update to get session_id
var vsr = await vsrut.Task.ConfigureAwait(false); // Wait for voice server update to get token, guild_id &amp; endpoint
await this.Rest.UpdatePlayerVoiceStateAsync(this.Config.SessionId!, channel.Guild.Id, new()
⋮----
.ConfigureAwait(false);
var player = await this.Rest.GetPlayerAsync(this.Config.SessionId!, channel.Guild.Id).ConfigureAwait(false);
⋮----
var con = new LavalinkGuildPlayer(this, channel.Guild.Id, player)
⋮----
///     Configures the current lavalink session.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config update to set.&lt;/param&gt;
/// &lt;returns&gt;The updated session.&lt;/returns&gt;
public async Task&lt;LavalinkSession&gt; ConfigureAsync(LavalinkSessionConfiguration config)
⋮----
var newConfig = await this.Rest.UpdateSessionAsync(this.Config.SessionId!, config).ConfigureAwait(false);
⋮----
///     Gets the guild player attached to &lt;paramref name=&quot;guild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild to get the player for.&lt;/param&gt;
/// &lt;returns&gt;The found player or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
public LavalinkGuildPlayer? GetGuildPlayer(DiscordGuild guild)
=&gt; this.ConnectedPlayersInternal.TryGetValue(guild.Id, out var lgp) &amp;&amp; lgp.IsConnected
⋮----
///     Gets all guild players.
⋮----
/// &lt;returns&gt;The found players or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
public IReadOnlyList&lt;LavalinkGuildPlayer&gt;? GetGuildPlayersAsync()
⋮----
? this.ConnectedPlayersInternal.Values.ToList()
⋮----
///     Gets the lavalink player attached to &lt;paramref name=&quot;guild&quot; /&gt;.
///     &lt;para&gt;Use &lt;see cref=&quot;GetGuildPlayer&quot; /&gt; if you want to interact with the actual player.&lt;/para&gt;
⋮----
public async Task&lt;LavalinkPlayer&gt; GetPlayerAsync(DiscordGuild guild)
=&gt; await this.Rest.GetPlayerAsync(this.Config.SessionId!, guild.Id).ConfigureAwait(false);
⋮----
///     Gets all lavalink players.
///     &lt;para&gt;Use &lt;see cref=&quot;GetGuildPlayersAsync&quot; /&gt; if you want to interact with the actual players.&lt;/para&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;LavalinkPlayer&gt;&gt; GetPlayersAsync()
=&gt; await this.Rest.GetPlayersAsync(this.Config.SessionId!).ConfigureAwait(false);
⋮----
///     Decodes encoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;s.
///     &lt;para&gt;Might not work with pre 3.0 tracks.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;tracks&quot;&gt;The tracks to decode.&lt;/param&gt;
/// &lt;returns&gt;A &lt;see cref=&quot;List{T}&quot; /&gt; of decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;s.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;LavalinkTrack&gt;&gt; DecodeTracksAsync(IEnumerable&lt;string&gt; tracks)
=&gt; await this.Rest.DecodeTracksAsync(tracks).ConfigureAwait(false);
⋮----
///     Decodes an encoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to decode.&lt;/param&gt;
/// &lt;returns&gt;The decoded &lt;see cref=&quot;LavalinkTrack&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;LavalinkTrack&gt; DecodeTrackAsync(string track)
=&gt; await this.Rest.DecodeTrackAsync(track).ConfigureAwait(false);
⋮----
///     Loads tracks by &lt;paramref name=&quot;identifier&quot; /&gt;.
///     Returns a dynamic object you have to parse with (Type)Result.
⋮----
/// &lt;param name=&quot;identifier&quot;&gt;The identifier to load.&lt;/param&gt;
/// &lt;returns&gt;A track loading result.&lt;/returns&gt;
public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(string identifier)
=&gt; await this.Rest.LoadTracksAsync(identifier).ConfigureAwait(false);
⋮----
///     Gets the lyrics for a track.
⋮----
/// &lt;param name=&quot;track&quot;&gt;The track to fetch the lyrics for.&lt;/param&gt;
/// &lt;param name=&quot;skipTrackSource&quot;&gt;Whether to skip the current track source and fetch from highest priority source.&lt;/param&gt;
/// &lt;returns&gt;The &lt;see cref=&quot;LavalinkLyricsResult&quot; /&gt; or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsAsync(LavalinkTrack track, bool skipTrackSource = false)
=&gt; await this.Rest.GetLyricsAsync(track.Encoded, skipTrackSource).ConfigureAwait(false);
⋮----
///     Gets the lyrics for a currently playing track.
⋮----
/// &lt;param name=&quot;sessionId&quot;&gt;The session id a player is associated with.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id a player is associated with.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkLyricsResult?&gt; GetLyricsForCurrentTrackAsync(string sessionId, ulong guildId, bool skipTrackSource)
=&gt; await this.Rest.GetLyricsForCurrentTrackAsync(sessionId, guildId, skipTrackSource).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;searchType&quot;&gt;The search type to use. Some types need additional setup.&lt;/param&gt;
⋮----
public async Task&lt;LavalinkTrackLoadingResult&gt; LoadTracksAsync(LavalinkSearchType searchType, string identifier)
⋮----
_ =&gt; throw new ArgumentOutOfRangeException(nameof(searchType), searchType, &quot;Invalid search type.&quot;)
⋮----
return await this.LoadTracksAsync($&quot;{type}{identifier}&quot;).ConfigureAwait(false);
⋮----
///     Establishes a connection to the lavalink server.
⋮----
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when the &lt;see cref=&quot;DiscordClient&quot; /&gt; is not fully initialized.&lt;/exception&gt;
internal async Task EstablishConnectionAsync()
⋮----
throw new InvalidOperationException(&quot;This operation requires the Discord client to be fully initialized.&quot;);
⋮----
this._webSocket = this.Discord.Configuration.WebSocketClientFactory(this.Discord.Configuration.Proxy, this.Discord.ServiceProvider);
⋮----
this._webSocket.AddDefaultHeader(CommonHeaders.AUTHORIZATION, this.Config.Password);
this._webSocket.AddDefaultHeader(&quot;Num-Shards&quot;, this.Discord.ShardCount.ToString(CultureInfo.InvariantCulture));
this._webSocket.AddDefaultHeader(&quot;User-Id&quot;, this.Discord.CurrentUser.Id.ToString(CultureInfo.InvariantCulture));
this._webSocket.AddDefaultHeader(&quot;Client-Name&quot;, $&quot;DisCatSharp.Lavalink/{this.Discord.VersionString}&quot;);
⋮----
if (this.Config.SessionId != null &amp;&amp; !this._webSocket.DefaultHeaders.ContainsKey(&quot;Session-Id&quot;))
this._webSocket.AddDefaultHeader(&quot;Session-Id&quot;, this.Config.SessionId);
⋮----
this._webSocket.RemoveDefaultHeader(&quot;Session-Id&quot;);
⋮----
await Task.Delay(this._backoff).ConfigureAwait(false);
this._backoff = Math.Min(this._backoff * 2, MAXIMUM_BACKOFF);
⋮----
await this._webSocket.ConnectAsync(new($&quot;{this.Config.SocketEndpoint.ToWebSocketString()}{Endpoints.V4}{Endpoints.WEBSOCKET}&quot;)).ConfigureAwait(false);
⋮----
var sessionId = await this._sessionIdReceived.Task.ConfigureAwait(false);
⋮----
this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, ex, &quot;Failed to connect to Lavalink .-.&quot;);
⋮----
this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, ex, &quot;Failed to connect to Lavalink, retrying in {count} ms.&quot;, this._backoff);
⋮----
///     Handles WebSocket messages from Lavalink.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The websocket client.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The event args.&lt;/param&gt;
private Task Lavalink_WebSocket_MessageReceived(IWebSocketClient client, SocketMessageEventArgs args)
⋮----
this.Discord.Logger.LogCritical(LavalinkEvents.LavalinkConnectionError, &quot;Lavalink sent binary data O.o - unable to process&quot;);
⋮----
_ = Task.Run(async () =&gt;
⋮----
var jsonData = JObject.Parse(json);
⋮----
this.Discord.Logger.LogTrace(LavalinkEvents.LavalinkWsRx, null,
⋮----
this._sessionIdReceived.SetResult(ready.SessionId);
⋮----
this.Discord.Logger.LogInformation(LavalinkEvents.LavalinkSessionConnected, null,
⋮----
if (this.ConnectedPlayersInternal.TryGetValue(playerUpdate.GuildId, out var value))
⋮----
await value.StateUpdatedEvent.InvokeAsync(value, new(this.Discord, playerUpdate.State)).ConfigureAwait(false);
⋮----
await this._statsReceived.InvokeAsync(this, new(this.Discord, this.Statistics)).ConfigureAwait(false);
⋮----
if (!string.IsNullOrEmpty(eventOp.GuildId) &amp;&amp;
this.ConnectedPlayersInternal.TryGetValue(Convert.ToUInt64(eventOp.GuildId),
⋮----
await player.TrackStartedEvent.InvokeAsync(player, new(this.Discord, startEvent)).ConfigureAwait(false);
⋮----
await player.TrackEndedEvent.InvokeAsync(player, new(this.Discord, endEvent)).ConfigureAwait(false);
⋮----
await player.TrackStuckEvent.InvokeAsync(player, new(this.Discord, stuckEvent)).ConfigureAwait(false);
⋮----
await player.TrackExceptionEvent.InvokeAsync(player,
new(this.Discord, exceptionEvent)).ConfigureAwait(false);
⋮----
await this._websocketClosed.InvokeAsync(this, new(this.Discord, websocketClosedEvent)).ConfigureAwait(false);
⋮----
var ex = new InvalidDataException(&quot;Lavalink send an unknown up&quot;);
this.Discord.Logger.LogTrace(LavalinkEvents.LavalinkWsException, ex,
⋮----
this.Discord.Logger.LogDebug(&quot;{message}&quot;, ex.Message);
this.Discord.Logger.LogDebug(&quot;{stacktrace}&quot;, ex.StackTrace);
⋮----
///     Handles exceptions thrown by the websocket.
⋮----
private Task Lavalink_WebSocket_ExceptionThrown(IWebSocketClient client, SocketErrorEventArgs args)
=&gt; this._lavalinkSocketError.InvokeAsync(this, new(client.ServiceProvider)
⋮----
///     Handles the event when the websocket disconnected.
⋮----
private async Task Lavalink_WebSocket_Disconnected(IWebSocketClient client, SocketCloseEventArgs args)
⋮----
this.Discord.Logger.LogWarning(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Connection broken :/ ({code}, &apos;{message}&apos;), reconnecting&quot;, args.CloseCode, args.CloseMessage);
await this._lavalinkSessionDisconnected.InvokeAsync(this, new(this, false)).ConfigureAwait(false);
⋮----
_ = Task.Run(this.EstablishConnectionAsync);
⋮----
this.Discord.Logger.LogInformation(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Connection closed ({code}, &apos;{message}&apos;)&quot;, args.CloseCode, args.CloseMessage);
⋮----
await this._lavalinkSessionDisconnected.InvokeAsync(this, new(this, true)).ConfigureAwait(false);
⋮----
this.Discord.Logger.LogWarning(LavalinkEvents.LavalinkSessionConnectionClosed, &quot;Lavalink died QwQ&quot;);
⋮----
await kvp.Value.DisconnectVoiceAsync().ConfigureAwait(false);
_ = Task.Run(async () =&gt; await this.GuildPlayerDestroyedEvent.InvokeAsync(this, new(kvp.Value)).ConfigureAwait(false));
_ = this.ConnectedPlayersInternal.TryRemove(kvp.Key, out _);
⋮----
await this.EstablishConnectionAsync().ConfigureAwait(false);
⋮----
///     Handles the event when the websocket connected.
⋮----
private async Task Lavalink_WebSocket_Connected(IWebSocketClient client, SocketEventArgs args)
⋮----
this.Discord.Logger.LogDebug(LavalinkEvents.LavalinkSessionConnected, &quot;Connection to Lavalink established UwU&quot;);
⋮----
await this._lavalinkSessionConnected.InvokeAsync(this, new(this)).ConfigureAwait(false);
⋮----
///     Handles when discord fires a voice state update.
⋮----
private Task Discord_VoiceStateUpdated(DiscordClient client, VoiceStateUpdateEventArgs args)
⋮----
if (args.After.Channel == null! &amp;&amp; this.IsConnected &amp;&amp; this.ConnectedPlayersInternal.TryGetValue(gld.Id, out var dGuildPlayer))
⋮----
await Task.Delay(this.Config.WebSocketCloseTimeout).ConfigureAwait(false);
await this.Rest.DestroyPlayerAsync(this.Config.SessionId!, dGuildPlayer.GuildId).ConfigureAwait(false);
⋮----
if (this.ConnectedPlayersInternal.TryRemove(gld.Id, out _))
await this.GuildPlayerDestroyedEvent.InvokeAsync(this, new(dGuildPlayer)).ConfigureAwait(false);
⋮----
else if (!string.IsNullOrWhiteSpace(args.SessionId) &amp;&amp; this.ConnectedPlayersInternal.TryGetValue(gld.Id, out var guildPlayer))
⋮----
var state = new LavalinkVoiceState
⋮----
guildPlayer.UpdateVoiceState(state);
await this.Rest.UpdatePlayerVoiceStateAsync(this.Config.SessionId!, guildPlayer.GuildId, state).ConfigureAwait(false);
⋮----
if (!string.IsNullOrWhiteSpace(args.SessionId) &amp;&amp; args.Channel != null! &amp;&amp; this._voiceStateUpdates.TryRemove(gld.Id, out var xe))
xe.SetResult(args);
⋮----
///     Handles when discord fires a voice server update.
⋮----
private Task Discord_VoiceServerUpdated(DiscordClient client, VoiceServerUpdateEventArgs args)
⋮----
if (this.ConnectedPlayersInternal.TryGetValue(args.Guild.Id, out var guildPlayer))
⋮----
if (this._voiceServerUpdates.TryRemove(gld.Id, out var xe))</file><file path="DisCatSharp.Lavalink/Models/LavalinkPlayerUpdateModel.cs">/// &lt;summary&gt;
///     Represents an easy-to-use model to update a &lt;see cref=&quot;LavalinkPlayer&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class LavalinkPlayerUpdateModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;LavalinkPlayerUpdateModel&quot; /&gt; class.
⋮----
///     Sets whether to replace the current track.
⋮----
///     Sets the encoded track.
⋮----
///     Sets the identifier.
⋮----
///     Sets the start or seek position.
⋮----
///     Sets the end time.
⋮----
///     Sets the volume.
⋮----
///     Sets whether the player is paused.
⋮----
///     Gets or sets the filters.
⋮----
///     Gets or sets the user data.</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerCreatePayload.cs">/// &lt;summary&gt;
///     The lavalink rest player create payload.
/// &lt;/summary&gt;
internal sealed class LavalinkRestPlayerCreatePayload
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkRestPlayerCreatePayload&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume.&lt;/param&gt;
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the volume.</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestPlayerUpdatePayload.cs">/// &lt;summary&gt;
///     The lavalink rest player update payload.
/// &lt;/summary&gt;
internal sealed class LavalinkRestPlayerUpdatePayload
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkRestPlayerUpdatePayload&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id.&lt;/param&gt;
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the start or seek position.
⋮----
///     Gets or sets the end time.
⋮----
///     Gets or sets the volume.
⋮----
///     Gets or sets whether the player is paused.
⋮----
///     Gets or sets the filters.
⋮----
///     Gets or sets the track.
⋮----
///     The lavalink rest player update player track payload.
⋮----
internal class PlayerBase
⋮----
///     Gets or sets the user data.
⋮----
internal sealed class PlayerWithIdentifier : PlayerBase
⋮----
///     Gets or sets the identifier.
⋮----
internal sealed class PlayerWithEncoded : PlayerBase
⋮----
///     Gets or sets the encoded track.</file><file path="DisCatSharp.Lavalink/Payloads/LavalinkRestVoiceStateUpdatePayload.cs">/// &lt;summary&gt;
///     The lavalink rest voice state update payload.
/// &lt;/summary&gt;
internal sealed class LavalinkRestVoiceStateUpdatePayload
⋮----
///     Constructs a new &lt;see cref=&quot;LavalinkRestVoiceStateUpdatePayload&quot; /&gt;.
⋮----
/// &lt;param name=&quot;voiceState&quot;&gt;The voice state.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id.&lt;/param&gt;
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the voice state.</file><file path="DisCatSharp.Logos/browserconfig.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;browserconfig&gt;&lt;msapplication&gt;&lt;tile&gt;&lt;square70x70logo src=&quot;/ms-icon-70x70.png&quot;/&gt;&lt;square150x150logo src=&quot;/ms-icon-150x150.png&quot;/&gt;&lt;square310x310logo src=&quot;/ms-icon-310x310.png&quot;/&gt;&lt;TileColor&gt;#ffffff&lt;/TileColor&gt;&lt;/tile&gt;&lt;/msapplication&gt;&lt;/browserconfig&gt;</file><file path="DisCatSharp.Targets/DisCatSharp.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;Authors&gt;AITSYS, DisCatSharp, DisCatSharp Contributors&lt;/Authors&gt;
		&lt;Company&gt;AITSYS&lt;/Company&gt;
		&lt;GeneratePackageOnBuild&gt;False&lt;/GeneratePackageOnBuild&gt;
		&lt;PackageProjectUrl&gt;https://docs.dcs.aitsys.dev&lt;/PackageProjectUrl&gt;
		&lt;RepositoryUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/RepositoryUrl&gt;
		&lt;RepositoryType&gt;Git&lt;/RepositoryType&gt;
		&lt;PackageIcon&gt;logo-pride.png&lt;/PackageIcon&gt;
		&lt;PackageLicenseExpression /&gt;
		&lt;PackageLicenseFile&gt;LICENSE.md&lt;/PackageLicenseFile&gt;
		&lt;PackageRequireLicenseAcceptance&gt;True&lt;/PackageRequireLicenseAcceptance&gt;
		&lt;RunAnalyzersDuringBuild&gt;False&lt;/RunAnalyzersDuringBuild&gt;
		&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\LICENSE.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\RELEASENOTES.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\DisCatSharp.Logos\logo-pride.png&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Library.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
		&lt;TargetFrameworks&gt;net8.0;net9.0;net10.0&lt;/TargetFrameworks&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;InvariantGlobalization&gt;false&lt;/InvariantGlobalization&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;AccelerateBuildsInVisualStudio&gt;true&lt;/AccelerateBuildsInVisualStudio&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;NETSDK1188;CS8600;CS8625;CS8601;CS8604;CS0219;CS8618;CS8619;CS8597;CS8603;CS8602;CS8765;CS8632;CS8633;CS8714;CS8629;CS8767;CS8620;CS0649&lt;/NoWarn&gt;
		&lt;GenerateDocumentationFile&gt;True&lt;/GenerateDocumentationFile&gt;
		&lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt;
		&lt;CodeAnalysisRuleSet&gt;$(MSBuildThisFileDirectory)..\DisCatSharp.Tools\DisCatSharp.ruleset&lt;/CodeAnalysisRuleSet&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/NuGet.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
		&lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;
		&lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;
		&lt;DebugType&gt;Portable&lt;/DebugType&gt;
		&lt;AllowedOutputExtensionsInPackageBuildOutputFolder&gt;$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb&lt;/AllowedOutputExtensionsInPackageBuildOutputFolder&gt;
		&lt;PackageReleaseNotes&gt;$([System.IO.File]::ReadAllText(&quot;$(MSBuildProjectDirectory)/../RELEASENOTES.md&quot;))&lt;/PackageReleaseNotes&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(TF_BUILD)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(CI)&apos; == &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;true&lt;/ContinuousIntegrationBuild&gt;
		&lt;DefineConstants&gt;$(DefineConstants);CI_BUILD&lt;/DefineConstants&gt;
		&lt;Deterministic&gt;true&lt;/Deterministic&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; != &apos;true&apos; And &apos;$(TF_BUILD)&apos; != &apos;true&apos; And &apos;$(CI)&apos; != &apos;True&apos;&quot;&gt;
		&lt;ContinuousIntegrationBuild&gt;false&lt;/ContinuousIntegrationBuild&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup
		Condition=&quot;&apos;$(GITHUB_ACTIONS)&apos; == &apos;true&apos; And &apos;$(SENTRY_AUTH_TOKEN)&apos; != &apos;&apos;&quot;&gt;
		&lt;SentryOrg&gt;aitsys&lt;/SentryOrg&gt;
		&lt;SentryProject&gt;discatsharp&lt;/SentryProject&gt;
		&lt;SentryUploadSymbols&gt;true&lt;/SentryUploadSymbols&gt;
		&lt;SentryUploadSources&gt;true&lt;/SentryUploadSources&gt;
		&lt;UseSentryCLI&gt;true&lt;/UseSentryCLI&gt;
		&lt;SentryCreateRelease&gt;true&lt;/SentryCreateRelease&gt;
		&lt;SentrySetCommits&gt;true&lt;/SentrySetCommits&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Package.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;NETSDK1188;CS8600;CS8625;CS8601;CS8604;CS0219;CS8618;CS8619;CS8597;CS8603;CS8602;CS8765;CS8632;CS8633;CS8714;CS8629;CS8767;CS8620&lt;/NoWarn&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Debug&apos;&quot;&gt;
		&lt;Optimize&gt;False&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(Configuration)&apos; == &apos;Release&apos;&quot;&gt;
		&lt;Optimize&gt;True&lt;/Optimize&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/TestProject.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Library&lt;/OutputType&gt;
		&lt;TargetFrameworks&gt;net8.0;net9.0;net10.0&lt;/TargetFrameworks&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup&gt;
		&lt;AccelerateBuildsInVisualStudio&gt;true&lt;/AccelerateBuildsInVisualStudio&gt;
		&lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
		&lt;GenerateDocumentationFile&gt;false&lt;/GenerateDocumentationFile&gt;
		&lt;NoWarn&gt;1591;NU5128;DV2001;CS0271;CS0414&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Targets/Version.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;PropertyGroup&gt;
		&lt;VersionPrefix&gt;10.7.0&lt;/VersionPrefix&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; != &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)-$(BuildNumber)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).$(BuildNumber)&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; != &apos;&apos; And &apos;$(BuildNumber)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)-$(VersionSuffix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
	&lt;PropertyGroup Condition=&quot;&apos;$(VersionSuffix)&apos; == &apos;&apos;&quot;&gt;
		&lt;Version&gt;$(VersionPrefix)&lt;/Version&gt;
		&lt;AssemblyVersion&gt;$(VersionPrefix).0&lt;/AssemblyVersion&gt;
		&lt;FileVersion&gt;$(VersionPrefix).0&lt;/FileVersion&gt;
	&lt;/PropertyGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/DisCatSharp.Analyzer.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Exe&lt;/OutputType&gt;
		&lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;LangVersion&gt;latest&lt;/LangVersion&gt;
		&lt;NoWarn&gt;DV2001;CS8618;IDE0060&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/Program.cs">// ReSharper disable ArrangeObjectCreationWhenTypeNotEvident
internal class Program
⋮----
private static void Main(string[] args)
⋮----
}); // DCS0201 should insert the property &quot;Override&quot; here
_ = Task.Run(Dcs0201.TestAsync);
Client = new DiscordClient(new DiscordConfiguration()</file><file path="DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/Tests/Dcs0201.cs">internal static class Dcs0201
⋮----
internal static async Task TestAsync()
⋮----
var invite = await Program.Client.GetInviteByCodeAsync(&quot;code&quot;);
var profile = invite.Profile; // This should trigger DCS0201</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/AppCommandSplitPartialTests.cs">public class AppCommandSplitPartialTests(ITestOutputHelper testOutputHelper)
⋮----
private readonly DiscordClient _client = new(new()
⋮----
internal readonly ReadOnlyDictionary&lt;ulong, DiscordGuild&gt; Guilds = new Dictionary&lt;ulong, DiscordGuild&gt;().AsReadOnly();
⋮----
public async Task TestSplitRegistrationAndProperLocalRegistration()
⋮----
var extension = this._client.UseApplicationCommands(new()
⋮----
await this._client.ReadyEv.InvokeAsync(this._client, new(null!));
⋮----
await Task.Delay(1);
⋮----
Assert.True(regFired);
var commands = extension.RegisteredCommands.ToList();
Assert.Single(commands);
Assert.NotNull(commands.FirstOrDefault(x =&gt; x.Key is null).Value);
Assert.Single(commands.FirstOrDefault(x =&gt; x.Key is null).Value);
var command = commands.First(x =&gt; x.Key is null).Value[0];
Assert.Equal(&quot;test&quot;, command.Name);
Assert.Equal(&quot;test&quot;, command.Description);
⋮----
Assert.NotNull(attributes);
Assert.Single(attributes);
Assert.NotNull(command.Options);
Assert.All(command.Options, x =&gt; Assert.True(x.Type is ApplicationCommandOptionType.SubCommand));
Assert.Contains(command.Options, x =&gt; x.Name is &quot;test_1&quot;);
Assert.Contains(command.Options, x =&gt; x.Name is &quot;test_2&quot;);
Assert.NotNull(command.Options.First(x =&gt; x.Name is &quot;test_2&quot;).Options);
var option = command.Options.First(x =&gt; x.Name is &quot;test_2&quot;).Options;
Assert.Contains(option!, y =&gt; y is { Name: &quot;user&quot;, Required: false, Type: ApplicationCommandOptionType.User });
testOutputHelper.WriteLine(&quot;Command registration successful&quot;);</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part0.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part1.cs">internal partial class TestCommand : ApplicationCommandsModule
⋮----
internal static async Task Test1Async(InteractionContext ctx)
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Meow&quot;));</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/SplitTest/TestCommand.Part2.cs">internal partial class TestCommand
⋮----
internal static async Task Test2Async(InteractionContext ctx, [Option(&quot;user&quot;, &quot;User to tag&quot;)] DiscordUser? user = null)
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Nya &quot; + user.Mention));</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/ConfigurationExtensionTests.cs">public class ConfigurationExtensionTests
⋮----
private class SampleClass
⋮----
private class ClassWithArray
⋮----
private class ClassWithEnumerable
⋮----
private class ClassWithList
⋮----
private class SampleClass2(string value)
⋮----
public TimeSpan Timeout { get; set; } = TimeSpan.FromMinutes(7);
⋮----
private IConfiguration EnumerableTestConfiguration() =&gt;
new ConfigurationBuilder()
.AddJsonFile(&quot;enumerable-test.json&quot;)
.Build();
⋮----
private IConfiguration HasSectionWithSuffixConfiguration() =&gt;
⋮----
.AddJsonFile(&quot;section-with-suffix.json&quot;)
⋮----
private IConfiguration HasSectionNoSuffixConfiguration() =&gt;
⋮----
.AddJsonFile(&quot;section-no-suffix.json&quot;)
⋮----
private IConfiguration BasicDiscordConfiguration() =&gt; new ConfigurationBuilder()
.AddJsonFile(&quot;default-discord.json&quot;)
⋮----
private IConfiguration DiscordIntentsConfig() =&gt; new ConfigurationBuilder()
.AddJsonFile(&quot;intents-discord.json&quot;)
⋮----
private IConfiguration DiscordHaphazardConfig() =&gt; new ConfigurationBuilder()
.AddJsonFile(&quot;haphazard-discord.json&quot;)
⋮----
private IConfiguration SampleConfig() =&gt; new ConfigurationBuilder()
.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;
⋮----
private IConfiguration SampleClass2Configuration_Default() =&gt; new ConfigurationBuilder()
⋮----
private IConfiguration SampleClass2Configuration_Change() =&gt; new ConfigurationBuilder()
⋮----
private IConfiguration SampleClass2EnumerableTest() =&gt; new ConfigurationBuilder()
⋮----
private IConfiguration SampleClass2ArrayTest() =&gt; new ConfigurationBuilder()
⋮----
private IConfiguration SampleClass2ListTest() =&gt; new ConfigurationBuilder()
⋮----
public void TestExtractDiscordConfig_Intents()
⋮----
var source = this.DiscordIntentsConfig();
⋮----
Assert.Equal(expected, config.Intents);
⋮----
public void TestExtractDiscordConfig_Haphazard()
⋮----
var source = this.DiscordHaphazardConfig();
⋮----
Assert.Equal(expectedIntents, config.Intents);
Assert.True(config.MobileStatus);
Assert.Equal(1000, config.LargeThreshold);
Assert.Equal(TimeSpan.FromHours(10), config.HttpTimeout);
⋮----
public void TestExtractDiscordConfig_Default()
⋮----
var source = this.BasicDiscordConfiguration();
⋮----
Assert.Equal(&quot;1234567890&quot;, config.Token);
Assert.Equal(TokenType.Bot, config.TokenType);
Assert.Equal(LogLevel.Information, config.MinimumLogLevel);
Assert.True(config.UseRelativeRatelimit);
Assert.Equal(&quot;yyyy-MM-dd HH:mm:ss zzz&quot;, config.LogTimestampFormat);
Assert.Equal(250, config.LargeThreshold);
Assert.True(config.AutoReconnect);
Assert.Equal(123123, config.ShardId);
Assert.Equal(GatewayCompressionLevel.Stream, config.GatewayCompressionLevel);
Assert.Equal(1024, config.MessageCacheSize);
Assert.Equal(TimeSpan.FromSeconds(20), config.HttpTimeout);
Assert.False(config.ReconnectIndefinitely);
Assert.True(config.AlwaysCacheMembers);
Assert.Equal(DiscordIntents.AllUnprivileged | DiscordIntents.MessageContent, config.Intents);
Assert.False(config.MobileStatus);
Assert.Equal(config.ApiChannel, ApiChannel.Stable);
Assert.False(config.AutoRefreshChannelCache);
⋮----
public void TestSection()
⋮----
var source = this.SampleConfig();
⋮----
Assert.Equal(200, config.Amount);
Assert.Equal(&quot;test@gmail.com&quot;, config.Email);
⋮----
public void TestExtractConfig_V2_Default()
⋮----
var source = this.SampleClass2Configuration_Default();
var config = (SampleClass2)source.ExtractConfig(&quot;SampleClass&quot;, () =&gt; new SampleClass2(&quot;Test&quot;), null);
Assert.Equal(TimeSpan.FromMinutes(7), config.Timeout);
Assert.Equal(&quot;Test&quot;, config.ConstructorValue);
Assert.Equal(&quot;Sample&quot;, config.Name);
⋮----
public void TestExtractConfig_V2_Change()
⋮----
var source = this.SampleClass2Configuration_Change();
var config = (SampleClass2)source.ExtractConfig(&quot;SampleClass&quot;, () =&gt; new SampleClass2(&quot;Test123&quot;), null);
var span = new TimeSpan(0, 1, 30, 0);
Assert.Equal(span, config.Timeout);
Assert.Equal(&quot;Test123&quot;, config.ConstructorValue);
⋮----
public void TestExtractConfig_V3_Default()
⋮----
(SampleClass2)new ConfigSection(ref source, &quot;SampleClass&quot;, null).ExtractConfig(() =&gt;
new SampleClass2(&quot;Meow&quot;));
⋮----
Assert.Equal(&quot;Meow&quot;, config.ConstructorValue);
⋮----
public void TestExtractConfig_V3_Change()
⋮----
public void TestExtractConfig_Enumerable()
⋮----
var source = this.EnumerableTestConfiguration();
⋮----
(ClassWithEnumerable)new ConfigSection(ref source, &quot;ClassWithEnumerable&quot;, null).ExtractConfig(() =&gt;
new ClassWithEnumerable());
⋮----
Assert.NotNull(config.Values);
Assert.Equal(3, config.Values.Count());
Assert.NotNull(config.Strings);
⋮----
public void TestExtractConfig_Array()
⋮----
(ClassWithArray)new ConfigSection(ref source, &quot;ClassWithArray&quot;, null).ExtractConfig(() =&gt;
new ClassWithArray());
⋮----
Assert.Equal(3, config.Values.Length);
⋮----
public void TestExtractConfig_List()
⋮----
(ClassWithList)new ConfigSection(ref source, &quot;ClassWithList&quot;, null).ExtractConfig(() =&gt;
new ClassWithList());
⋮----
Assert.Equal(3, config.Values.Count);
⋮----
public void TestHasSectionWithSuffix()
⋮----
var source = this.HasSectionWithSuffixConfiguration();
⋮----
Assert.True(source.HasSection(&quot;DiscordConfiguration&quot;));
Assert.False(source.HasSection(&quot;Discord&quot;));
Assert.False(source.HasSection(&quot;DiscordConfiguration&quot;, null));
⋮----
public void TestHasSectionNoSuffix()
⋮----
var source = this.HasSectionNoSuffixConfiguration();
⋮----
Assert.True(source.HasSection(&quot;Discord&quot;));
Assert.False(source.HasSection(&quot;DiscordConfiguration&quot;));
Assert.False(source.HasSection(&quot;Discord&quot;, null));</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/BasicEventHandlerTests.cs">public class BasicEventHandlerTests
⋮----
private readonly DiscordClient _client = new(new()
⋮----
public void TestUtility()
⋮----
Assert.False(this.IsEventRegistered(nameof(this._client.MessageCreated)));
⋮----
Assert.True(this.IsEventRegistered(nameof(this._client.MessageCreated)));
Assert.Throws&lt;ArgumentException&gt;(() =&gt; this.IsEventRegistered(&quot;&quot;));
Assert.Throws&lt;ArgumentException&gt;(() =&gt; this.IsEventRegistered(&quot;ThisEventDoesNotExist&quot;));
⋮----
public void TestUnregistrationWithoutRegistration()
⋮----
this._client.UnregisterEventHandlers(Assembly.GetExecutingAssembly());
⋮----
Assert.False(this.IsEventRegistered(nameof(this._client.MessageDeleted)));
⋮----
public void TestSimpleRegistration()
⋮----
Assert.True(this.IsEventRegistered(nameof(this._client.MessageDeleted)));
⋮----
Assert.False(this.IsEventRegistered(nameof(this._client.ChannelCreated)));
Assert.True(this.IsEventRegistered(nameof(this._client.ChannelDeleted)));
⋮----
Assert.False(this.IsEventRegistered(nameof(this._client.ChannelDeleted)));
⋮----
public void TestAssemblyRegistration()
⋮----
this._client.RegisterEventHandlers(Assembly.GetExecutingAssembly());
⋮----
public void TestInvalidHandlers()
⋮----
private bool IsEventRegistered(string name)
⋮----
// This is super hacky, but I think it should be good enough.
⋮----
throw new ArgumentException(&quot;name mustn&apos;t be empty&quot;);
⋮----
name = &quot;_&quot; + char.ToLower(name[0]) + name[1..];
var asyncEvent = typeof(DiscordClient).GetField(name, BindingFlags.NonPublic | BindingFlags.Instance)?.GetValue(this._client);
dynamic handlers = asyncEvent?.GetType().GetField(&quot;_handlers&quot;, BindingFlags.NonPublic | BindingFlags.Instance)?.GetValue(asyncEvent)
?? throw new ArgumentException($&quot;Unknown event \&quot;{name}\&quot;&quot;);
⋮----
private class HandlerA
⋮----
private class HandlerB
⋮----
public Task MessageCreated(DiscordClient sender, MessageCreateEventArgs args) =&gt; Task.CompletedTask;
⋮----
private static Task SomeEvent(DiscordClient sender, MessageDeleteEventArgs args) =&gt; Task.CompletedTask;
⋮----
private static class HandlerC
⋮----
public static Task MessageCreated(DiscordClient sender, MessageCreateEventArgs args) =&gt; Task.CompletedTask;
⋮----
public abstract class HandlerD
⋮----
public Task ChannelCreated(DiscordClient sender, ChannelCreateEventArgs args) =&gt; Task.CompletedTask;
⋮----
public static Task ChannelDeleted(DiscordClient sender, ChannelDeleteEventArgs args) =&gt; Task.CompletedTask;
⋮----
private class BadHandlerA
⋮----
public int MessageCreated(object? obj, dynamic dynamic) =&gt; 1;
⋮----
private abstract class BadHandlerB
⋮----
private static Task ThisEventDoesNotExist() =&gt; Task.CompletedTask;</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/EventsEnumIntegrityTests.cs">public class EventsEnumIntegrityTests
⋮----
private void TestEnumToEvent()
⋮----
foreach (var value in typeof(DiscordEvent).GetEnumValues())
Assert.NotNull(typeof(DiscordClient).GetEvent(value.ToString()!));
⋮----
private void TestEventToEnum()
⋮----
var enumNames = typeof(DiscordEvent).GetEnumNames().ToHashSet();
foreach (var evtn in typeof(DiscordClient).GetEvents())
Assert.Contains(evtn.Name, enumNames);</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/GlobalSuppressions.cs">// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/ServiceProviderTests.cs">public class ServiceProviderTests
⋮----
public void Test()
⋮----
var poorClient = new DiscordClient(new()
⋮----
var richClient = new DiscordClient(new()
⋮----
ServiceProvider = new ServiceCollection().AddSingleton&lt;Resource&gt;().BuildServiceProvider()
⋮----
richClient.RegisterEventHandler&lt;Handler&gt;(); // May not throw.
⋮----
private class Resource
⋮----
private class Handler</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/ExtensionTests.cs">public class HostExtensionTests
⋮----
private Dictionary&lt;string, string?&gt; DefaultDiscord() =&gt;
⋮----
public IConfiguration DiscordInteractivityConfiguration() =&gt; new ConfigurationBuilder()
.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;(this.DefaultDiscord())
⋮----
{ &quot;DisCatSharp:Using&quot;, &quot;[\&quot;DisCatSharp.Interactivity\&quot;]&quot; } // this should be enough to automatically add the extension
⋮----
.Build();
⋮----
public IConfiguration DiscordOnlyConfiguration() =&gt; new ConfigurationBuilder()
.AddInMemoryCollection(this.DefaultDiscord())
⋮----
public IConfiguration DiscordInteractivityAndLavaLinkConfiguration() =&gt; new ConfigurationBuilder()
.AddJsonFile(&quot;interactivity-lavalink.json&quot;)
⋮----
public void DiscoverExtensions_Interactivity()
⋮----
var source = this.DiscordInteractivityConfiguration();
var discovered = source.FindImplementedExtensions();
⋮----
// Remember that DiscordConfiguration does not have an implementation type which is assignable to BaseExtension
Assert.Single(discovered);
var item = discovered.First();
⋮----
Assert.Equal(typeof(InteractivityConfiguration), item.Value.ConfigType);
Assert.Equal(typeof(InteractivityExtension), item.Value.ImplementationType);
Assert.Equal(&quot;InteractivityExtension&quot;, item.Key);
⋮----
public void DiscoverExtensions_InteractivityAndLavaLink()
⋮----
var source = this.DiscordInteractivityAndLavaLinkConfiguration();
⋮----
Assert.Equal(2, discovered.Count);
var first = discovered.First();
var last = discovered.Last();
⋮----
Assert.Equal(typeof(InteractivityConfiguration), first.Value.ConfigType);
Assert.Equal(typeof(InteractivityExtension), first.Value.ImplementationType);
Assert.Equal(&quot;InteractivityExtension&quot;, first.Key, true);
⋮----
Assert.Equal(typeof(LavalinkConfiguration), last.Value.ConfigType);
Assert.Equal(typeof(LavalinkExtension), last.Value.ImplementationType);
Assert.Equal(&quot;LavalinkExtension&quot;, last.Key, true);</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/GlobalSuppressions.cs"></file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/HostTests.cs">public sealed class Bot : DiscordHostedService
⋮----
this.ConfigureAsync().GetAwaiter().GetResult();
this.ConfigureExtensionsAsync().GetAwaiter().GetResult();
⋮----
public sealed class MyCustomBot : DiscordHostedService
⋮----
public interface IBotTwoService : IDiscordHostedService
⋮----
string GiveMeAResponse();
⋮----
public sealed class BotTwoService : DiscordHostedService, IBotTwoService
⋮----
public string GiveMeAResponse() =&gt; &quot;I&apos;m working&quot;;
⋮----
public class HostTests
⋮----
private Dictionary&lt;string, string?&gt; DefaultDiscord() =&gt;
⋮----
public Dictionary&lt;string, string?&gt; DiscordInteractivity() =&gt; new(this.DefaultDiscord())
⋮----
public Dictionary&lt;string, string?&gt; DiscordInteractivityAndLavalink() =&gt; new(this.DefaultDiscord())
⋮----
private IHostBuilder Create(Dictionary&lt;string, string?&gt; configValues) =&gt;
Host.CreateDefaultBuilder()
.ConfigureLogging(logging =&gt;
⋮----
logging.ClearProviders();
logging.AddConsole();
⋮----
.ConfigureServices(services =&gt; services.AddSingleton&lt;IDiscordHostedService, Bot&gt;())
.ConfigureHostConfiguration(builder =&gt; builder.AddInMemoryCollection(configValues));
⋮----
private IHostBuilder Create(string filename) =&gt;
⋮----
.ConfigureServices(services =&gt; services.AddSingleton&lt;IDiscordHostedService, MyCustomBot&gt;())
.ConfigureHostConfiguration(builder =&gt; builder.AddJsonFile(filename));
⋮----
private IHostBuilder Create&lt;TInterface, TBot&gt;(string filename)
where TInterface : class, IDiscordHostedService
where TBot : class, TInterface, IDiscordHostedService =&gt;
⋮----
.ConfigureServices(services =&gt; services.AddSingleton&lt;TInterface, TBot&gt;())
⋮----
public void TestBotCustomInterface()
⋮----
host = this.Create&lt;IBotTwoService, BotTwoService&gt;(&quot;BotTwo.json&quot;).Build();
⋮----
Assert.NotNull(service);
⋮----
var response = service.GiveMeAResponse();
Assert.Equal(&quot;I&apos;m working&quot;, response);
⋮----
public void TestDifferentSection_InteractivityOnly()
⋮----
host = this.Create(&quot;interactivity-different-section.json&quot;).Build();
⋮----
Assert.NotNull(service.Client);
Assert.Null(service.Client.GetExtension&lt;LavalinkExtension&gt;());
⋮----
Assert.Equal(intents, service.Client.Intents);
⋮----
Assert.NotNull(interactivity);
⋮----
Assert.NotNull(host.Services);
Assert.NotNull(service.Client.ServiceProvider);
⋮----
public void TestDifferentSection_LavalinkOnly()
⋮----
host = this.Create(&quot;lavalink-different-section.json&quot;).Build();
⋮----
Assert.NotNull(service.Client.GetExtension&lt;LavalinkExtension&gt;());
Assert.Null(service.Client.GetExtension&lt;InteractivityExtension&gt;());
⋮----
public void TestNoExtensions()
⋮----
host = this.Create(this.DefaultDiscord()).Build();
⋮----
public void TestInteractivityExtension()
⋮----
host = this.Create(this.DiscordInteractivity()).Build();
⋮----
Assert.NotNull(service.Client.GetExtension&lt;InteractivityExtension&gt;());
⋮----
public void TestInteractivityLavalinkExtensions()
⋮----
host = this.Create(this.DiscordInteractivityAndLavalink()).Build();</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/CodeFixResources.Designer.cs">//------------------------------------------------------------------------------
// &lt;auto-generated&gt;
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// &lt;/auto-generated&gt;
⋮----
/// &lt;summary&gt;
///   A strongly-typed resource class, for looking up localized strings, etc.
/// &lt;/summary&gt;
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
⋮----
internal class CodeFixResources {
⋮----
///   Returns the cached ResourceManager instance used by this class.
⋮----
if (object.ReferenceEquals(resourceMan, null)) {
⋮----
///   Overrides the current thread&apos;s CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
⋮----
///   Looks up a localized string similar to Configure Override in DiscordConfiguration.
⋮----
return ResourceManager.GetString(&quot;DCS0201_CodeFixKey&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Configure Override in DiscordConfiguration (Use &amp;quot;Fix all in project&amp;quot;).
⋮----
return ResourceManager.GetString(&quot;DCS0201_CodeFixTitle&quot;, resourceCulture);</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/CodeFixResources.resx">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root&gt;
  &lt;!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers &amp; schema ...
    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
    &lt;/data&gt;
    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
        &lt;comment&gt;This is a comment&lt;/comment&gt;
    &lt;/data&gt;
                
    There are any number of &quot;resheader&quot; rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don&apos;t support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    --&gt;
  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
    &lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; /&gt;
    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
          &lt;xsd:element name=&quot;metadata&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;assembly&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;data&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;resheader&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
  &lt;/xsd:schema&gt;
  &lt;resheader name=&quot;resmimetype&quot;&gt;
    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;version&quot;&gt;
    &lt;value&gt;2.0&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;reader&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;writer&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;data name=&quot;DCS0201_CodeFixKey&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Configure Override in DiscordConfiguration&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;DCS0201_CodeFixTitle&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Configure Override in DiscordConfiguration (Use &quot;Fix all in project&quot;)&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/DisCatSharpRequiresOverrideCodeFix.cs">/// &lt;inheritdoc /&gt;
⋮----
public class DisCatSharpRequiresOverrideCodeFix : CodeFixProvider
⋮----
/// &lt;summary&gt;
///     Gets the diagnostic ID for which this provider can provide fixes.
/// &lt;/summary&gt;
⋮----
///     Gets the best available override value.
⋮----
///     Gets the formatting annotation.
⋮----
public static readonly SyntaxAnnotation FormattingAnnotation = new SyntaxAnnotation(&quot;Formatting&quot;);
⋮----
=&gt; ImmutableArray.Create(DIAGNOSTIC_ID);
⋮----
public sealed override FixAllProvider GetFixAllProvider()
=&gt; new MultiDocumentFixAllProvider();
⋮----
public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
⋮----
var diagnostics = context.Diagnostics.Where(x =&gt; x.Id == DIAGNOSTIC_ID).ToList();
⋮----
var diagnostic = diagnostics.First();
⋮----
if (!diag.Properties.TryGetValue(&quot;OverrideDate&quot;, out var date))
⋮----
if (!diag.Properties.TryGetValue(&quot;LastKnownOverride&quot;, out var prop))
⋮----
var parsedDate = DateTime.TryParse(date, out var dt) ? dt : DateTime.MinValue;
⋮----
context.RegisterCodeFix(
CodeAction.Create(
⋮----
///     Applies modifications to a document&apos;s syntax tree, specifically targeting object creation expressions for certain
///     types.
⋮----
/// &lt;param name=&quot;document&quot;&gt;The document to be modified based on the specified criteria.&lt;/param&gt;
/// &lt;param name=&quot;cancellationToken&quot;&gt;Used to signal cancellation of the operation if needed.&lt;/param&gt;
/// &lt;returns&gt;Returns the modified document if changes were made; otherwise, returns the original document.&lt;/returns&gt;
public static async Task&lt;Document&gt; ApplyFixToDocumentAsync(Document document, CancellationToken cancellationToken)
⋮----
var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);
⋮----
var configNodes = root.DescendantNodes()
.Where(node =&gt;
⋮----
var typeInfo = semanticModel.GetTypeInfo(node, cancellationToken);
⋮----
.ToList();
⋮----
var clientNodes = root.DescendantNodes()
.Where(node =&gt; node is ObjectCreationExpressionSyntax || node is AnonymousObjectCreationExpressionSyntax)
⋮----
.SelectMany(node =&gt;
⋮----
.Select(arg =&gt; arg.Expression)
.Where(expr =&gt; expr is ObjectCreationExpressionSyntax ||
⋮----
.Where(expr =&gt;
⋮----
var typeInfo = semanticModel.GetTypeInfo(expr, cancellationToken);
⋮----
configNodes.AddRange(clientNodes);
⋮----
var overrideAssignment = SyntaxFactory.AssignmentExpression(
⋮----
SyntaxFactory.IdentifierName(&quot;Override&quot;),
SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression,
SyntaxFactory.Literal(OverrideValue)));
⋮----
var newInitializer = SyntaxFactory.InitializerExpression(
⋮----
currentRoot = currentRoot.ReplaceNode(
⋮----
objectCreation.WithInitializer(newInitializer));
⋮----
var initializerProperties = initializer.Expressions.OfType&lt;AssignmentExpressionSyntax&gt;().ToList();
if (initializerProperties.Any(expr =&gt; IsOverrideProperty(expr.Left)))
⋮----
var newProperties = initializerProperties.ToList();
⋮----
newProperties.Add(overrideAssignment);
⋮----
var expressions = newProperties.Select(x =&gt; (ExpressionSyntax)x.WithAdditionalAnnotations(FormattingAnnotation));
⋮----
SyntaxFactory.SeparatedList(expressions));
⋮----
if (initializers.Any(init =&gt;
⋮----
var overrideAssignment = SyntaxFactory.AnonymousObjectMemberDeclarator(
SyntaxFactory.NameEquals(&quot;Override&quot;),
SyntaxFactory.LiteralExpression(
⋮----
var newInitializers = initializers.Add(overrideAssignment);
⋮----
anonymousCreation.WithInitializers(newInitializers));
⋮----
return document.WithSyntaxRoot(currentRoot);
⋮----
///     Applies the fix to a single project by locating all DiscordConfiguration initializations and adding the Override
///     property if missing.
⋮----
/// &lt;param name=&quot;project&quot;&gt;The project to be modified based on the specified criteria.&lt;/param&gt;
⋮----
/// &lt;returns&gt;Returns the modified project if changes were made; otherwise, returns the original project.&lt;/returns&gt;
public static async Task&lt;Solution&gt; ApplyFixToProjectAsync(Project project, CancellationToken cancellationToken)
⋮----
var fixedDocument = await ApplyFixToDocumentAsync(document, cancellationToken).ConfigureAwait(false);
⋮----
///     Checks if the given left-hand side expression represents an assignment to &quot;Override&quot;.
///     Supports both IdentifierNameSyntax and MemberAccessExpressionSyntax.
⋮----
public static bool IsOverrideProperty(ExpressionSyntax left)
⋮----
public sealed class MultiDocumentFixAllProvider : FixAllProvider
⋮----
public override IEnumerable&lt;FixAllScope&gt; GetSupportedFixAllScopes()
=&gt; ImmutableArray.Create(FixAllScope.Project);
⋮----
public override Task&lt;CodeAction&gt; GetFixAsync(FixAllContext fixAllContext)
⋮----
projectsToFix.Add(fixAllContext.Project);
⋮----
throw new NotSupportedException(&quot;This scope is not supported.&quot;);
⋮----
throw new ArgumentOutOfRangeException();
⋮----
return Task.FromResult(CodeAction.Create(
⋮----
///     Gets the title for the codefix.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The fix all context.&lt;/param&gt;
/// &lt;returns&gt;The generated title.&lt;/returns&gt;
public static string GetTitle(FixAllContext context)
⋮----
///     Applies fixes to a collection of projects and updates the provided solution accordingly.
⋮----
/// &lt;param name=&quot;projects&quot;&gt;A collection of projects that need fixes applied to them.&lt;/param&gt;
/// &lt;param name=&quot;solution&quot;&gt;The initial solution that will be updated based on the fixed projects.&lt;/param&gt;
/// &lt;param name=&quot;cancellationToken&quot;&gt;Used to signal if the operation should be canceled before completion.&lt;/param&gt;
/// &lt;returns&gt;The updated solution after all projects have been processed.&lt;/returns&gt;
public static async Task&lt;Solution&gt; FixAllAsync(IEnumerable&lt;Project&gt; projects, Solution solution, CancellationToken cancellationToken)
⋮----
var fixedProject = await ApplyFixToProjectAsync(project, cancellationToken).ConfigureAwait(false);</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Vsix/DisCatSharp.Analyzer.Vsix.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project&gt;
  &lt;Import Sdk=&quot;Microsoft.NET.Sdk&quot; Project=&quot;Sdk.props&quot; /&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net472&lt;/TargetFramework&gt;
    &lt;RootNamespace&gt;DisCatSharp.Analyzer.Vsix&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;DisCatSharp.Analyzer.Vsix&lt;/AssemblyName&gt;
  &lt;/PropertyGroup&gt;

  &lt;PropertyGroup&gt;
    &lt;GeneratePkgDefFile&gt;false&lt;/GeneratePkgDefFile&gt;
    &lt;IncludeAssemblyInVSIXContainer&gt;false&lt;/IncludeAssemblyInVSIXContainer&gt;
    &lt;IncludeDebugSymbolsInVSIXContainer&gt;false&lt;/IncludeDebugSymbolsInVSIXContainer&gt;
    &lt;IncludeDebugSymbolsInLocalVSIXDeployment&gt;false&lt;/IncludeDebugSymbolsInLocalVSIXDeployment&gt;
    &lt;CopyBuildOutputToOutputDirectory&gt;false&lt;/CopyBuildOutputToOutputDirectory&gt;
    &lt;CopyOutputSymbolsToOutputDirectory&gt;false&lt;/CopyOutputSymbolsToOutputDirectory&gt;
    &lt;VSSDKTargetPlatformRegRootSuffix&gt;Roslyn&lt;/VSSDKTargetPlatformRegRootSuffix&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Microsoft.VSSDK.BuildTools&quot; Version=&quot;16.8.3038&quot; PrivateAssets=&quot;all&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;PropertyGroup&gt;
    &lt;StartAction&gt;Program&lt;/StartAction&gt;
    &lt;StartProgram&gt;$(DevEnvDir)devenv.exe&lt;/StartProgram&gt;
    &lt;StartArguments&gt;/rootsuffix $(VSSDKTargetPlatformRegRootSuffix)&lt;/StartArguments&gt;
  &lt;/PropertyGroup&gt;

  &lt;Import Sdk=&quot;Microsoft.NET.Sdk&quot; Project=&quot;Sdk.targets&quot; /&gt;

  &lt;Import Project=&quot;$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets&quot; Condition=&quot;Exists(&apos;$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets&apos;)&quot; /&gt;

  &lt;ItemGroup&gt;
    &lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer.CodeFixes\DisCatSharp.Analyzer.CodeFixes.csproj&quot; /&gt;
    &lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;!-- https://github.com/dotnet/sdk/issues/433 --&gt;
    &lt;ProjectReference Update=&quot;@(ProjectReference)&quot; AdditionalProperties=&quot;TargetFramework=netstandard2.0&quot; /&gt;

    &lt;!-- https://github.com/Microsoft/extendvs/issues/57 --&gt;
    &lt;ProjectReference Update=&quot;@(ProjectReference)&quot; Name=&quot;%(Filename)&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Vsix/source.extension.vsixmanifest">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;PackageManifest Version=&quot;2.0.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/vsx-schema/2011&quot; xmlns:d=&quot;http://schemas.microsoft.com/developer/vsx-schema-design/2011&quot;&gt;
  &lt;Metadata&gt;
    &lt;Identity Id=&quot;DisCatSharp.Analyzer.d2f7a56c-81fe-418c-94bc-f873d26a4a88&quot; Version=&quot;1.0&quot; Language=&quot;en-US&quot; Publisher=&quot;pkmor&quot;/&gt;
    &lt;DisplayName&gt;DisCatSharp.Analyzer&lt;/DisplayName&gt;
    &lt;Description xml:space=&quot;preserve&quot;&gt;This is a sample diagnostic extension for the .NET Compiler Platform (&quot;Roslyn&quot;).&lt;/Description&gt;
  &lt;/Metadata&gt;
  &lt;Installation&gt;
    &lt;InstallationTarget Id=&quot;Microsoft.VisualStudio.Community&quot; Version=&quot;[15.0,)&quot; /&gt;
  &lt;/Installation&gt;
  &lt;Dependencies&gt;
    &lt;Dependency Id=&quot;Microsoft.Framework.NDP&quot; DisplayName=&quot;Microsoft .NET Framework&quot; d:Source=&quot;Manual&quot; Version=&quot;[4.5,)&quot; /&gt;
  &lt;/Dependencies&gt;
  &lt;Assets&gt;
    &lt;Asset Type=&quot;Microsoft.VisualStudio.MefComponent&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;DisCatSharp.Analyzer&quot; Path=&quot;|DisCatSharp.Analyzer|&quot;/&gt;
    &lt;Asset Type=&quot;Microsoft.VisualStudio.Analyzer&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;DisCatSharp.Analyzer&quot; Path=&quot;|DisCatSharp.Analyzer|&quot;/&gt;
    &lt;Asset Type=&quot;Microsoft.VisualStudio.MefComponent&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;DisCatSharp.Analyzer.CodeFixes&quot; Path=&quot;|DisCatSharp.Analyzer.CodeFixes|&quot;/&gt;
    &lt;Asset Type=&quot;Microsoft.VisualStudio.Analyzer&quot; d:Source=&quot;Project&quot; d:ProjectName=&quot;DisCatSharp.Analyzer.CodeFixes&quot; Path=&quot;|DisCatSharp.Analyzer.CodeFixes|&quot;/&gt;
  &lt;/Assets&gt;
  &lt;Prerequisites&gt;
    &lt;Prerequisite Id=&quot;Microsoft.VisualStudio.Component.CoreEditor&quot; Version=&quot;[15.0,)&quot; DisplayName=&quot;Visual Studio core editor&quot; /&gt;
    &lt;Prerequisite Id=&quot;Microsoft.VisualStudio.Component.Roslyn.LanguageServices&quot; Version=&quot;[15.0,)&quot; DisplayName=&quot;Roslyn Language Services&quot; /&gt;
  &lt;/Prerequisites&gt;
&lt;/PackageManifest&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharpAnalyzer.cs">/// &lt;inheritdoc /&gt;
⋮----
public class DisCatSharpAnalyzer : DiagnosticAnalyzer
⋮----
/// &lt;summary&gt;
///     The diagnostic ID prefix.
/// &lt;/summary&gt;
⋮----
///     The diagnostic category.
⋮----
/// &lt;inheritdoc cref=&quot;LocalizableString&quot; /&gt;
private static readonly LocalizableString s_titleExperimental = new LocalizableResourceString(nameof(Resources.AnalyzerTitleExperimental), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatExperimental = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatExperimental), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionExperimental = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionExperimental), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerTitleDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleDiscordInExperiment = new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatDiscordInExperiment = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionDiscordInExperiment = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordInExperiment), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleDiscordDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatDiscordDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionDiscordDeprecated = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordDeprecated), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleDiscordUnreleased = new LocalizableResourceString(nameof(Resources.AnalyzerTitleDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatDiscordUnreleased = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionDiscordUnreleased = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionDiscordUnreleased), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleRequiresFeature = new LocalizableResourceString(nameof(Resources.AnalyzerTitleRequiresFeature), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatRequiresFeature = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatRequiresFeature), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionRequiresFeature = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionRequiresFeature), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_titleRequiresOverride = new LocalizableResourceString(nameof(Resources.AnalyzerTitleRequiresOverride), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_messageFormatRequiresOverride = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormatRequiresOverride), Resources.ResourceManager, typeof(Resources));
⋮----
private static readonly LocalizableString s_descriptionRequiresOverride = new LocalizableResourceString(nameof(Resources.AnalyzerDescriptionRequiresOverride), Resources.ResourceManager, typeof(Resources));
⋮----
/// &lt;inheritdoc cref=&quot;DiagnosticDescriptor&quot; /&gt;
private static readonly DiagnosticDescriptor s_experimentalRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0001&quot;, s_titleExperimental, s_messageFormatExperimental, CATEGORY, DiagnosticSeverity.Info, true, s_descriptionExperimental, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0001&quot;);
⋮----
private static readonly DiagnosticDescriptor s_deprecatedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0002&quot;, s_titleDeprecated, s_messageFormatDeprecated, CATEGORY, DiagnosticSeverity.Error, true, s_descriptionDeprecated, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0002&quot;);
⋮----
private static readonly DiagnosticDescriptor s_discordInExperimentRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0101&quot;, s_titleDiscordInExperiment, s_messageFormatDiscordInExperiment, CATEGORY, DiagnosticSeverity.Warning, true, s_descriptionDiscordInExperiment, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0101&quot;);
⋮----
private static readonly DiagnosticDescriptor s_discordDeprecatedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0102&quot;, s_titleDiscordDeprecated, s_messageFormatDiscordDeprecated, CATEGORY, DiagnosticSeverity.Error, true, s_descriptionDiscordDeprecated, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0102&quot;);
⋮----
private static readonly DiagnosticDescriptor s_discordUnreleasedRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0103&quot;, s_titleDiscordUnreleased, s_messageFormatDiscordUnreleased, CATEGORY, DiagnosticSeverity.Warning, true, s_descriptionDiscordUnreleased, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0103&quot;);
⋮----
private static readonly DiagnosticDescriptor s_requiresFeatureRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0200&quot;, s_titleRequiresFeature, s_messageFormatRequiresFeature, CATEGORY, DiagnosticSeverity.Info, true, s_descriptionRequiresFeature, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0200&quot;);
⋮----
private static readonly DiagnosticDescriptor s_requiresOverrideRule = new DiagnosticDescriptor(DIAGNOSTIC_ID_PREFIX + &quot;0201&quot;, s_titleRequiresOverride, s_messageFormatRequiresOverride, CATEGORY, DiagnosticSeverity.Warning, true, s_descriptionRequiresOverride, &quot;https://docs.dcs.aitsys.dev/vs/analyzer/dcs/0201&quot;);
⋮----
=&gt; ImmutableArray.Create(s_experimentalRule, s_deprecatedRule, s_discordInExperimentRule, s_discordDeprecatedRule, s_discordUnreleasedRule, s_requiresFeatureRule, s_requiresOverrideRule);
⋮----
public override void Initialize(AnalysisContext context)
⋮----
context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
context.EnableConcurrentExecution();
⋮----
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Parameter);
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Property);
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Method);
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Field);
context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Event);
context.RegisterSyntaxNodeAction(AnalyzeSyntaxNode, SyntaxKind.InvocationExpression);
context.RegisterSyntaxNodeAction(AnalyzeSyntaxNode, SyntaxKind.ObjectCreationExpression);
context.RegisterSyntaxNodeAction(AnalyzeSyntaxNode, SyntaxKind.ElementAccessExpression);
context.RegisterSyntaxNodeAction(AnalyzeSyntaxNode, SyntaxKind.SimpleMemberAccessExpression);
⋮----
///     Analyzes the symbols.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The symbol analysis context.&lt;/param&gt;
private static void AnalyzeSymbol(SymbolAnalysisContext context)
⋮----
var attributes = declaration.GetAttributes();
⋮----
var model = context.Compilation.GetSemanticModel(syntaxTrees.First(), true);
⋮----
var experimentalAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(ExperimentalAttribute)));
var deprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DeprecatedAttribute)));
var discordInExperimentAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordInExperimentAttribute)));
var discordDeprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordDeprecatedAttribute)));
var discordUnreleasedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(DiscordUnreleasedAttribute)));
var requiresFeatureAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(RequiresFeatureAttribute)));
var requiresOverrideAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(model, attr, typeof(RequiresOverrideAttribute)));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_experimentalRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_deprecatedRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordInExperimentRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordDeprecatedRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordUnreleasedRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_requiresFeatureRule, context.Symbol.Locations.FirstOrDefault(), kind, name, message));
⋮----
var properties = ImmutableDictionary.Create&lt;string, string&gt;().Add(&quot;LastKnownOverride&quot;, GetOverrideValue(requiresOverrideAttributeData)).Add(&quot;OverrideDate&quot;, GetOverrideDate(requiresOverrideAttributeData));
context.ReportDiagnostic(Diagnostic.Create(s_requiresOverrideRule, context.Symbol.Locations.FirstOrDefault(), properties, kind, name, message));
⋮----
///     Analyzes the syntax nodes.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The syntac node analysis context.&lt;/param&gt;
private static void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context)
⋮----
var declaration = context.SemanticModel.GetSymbolInfo(invocation, context.CancellationToken).Symbol;
⋮----
var experimentalAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(ExperimentalAttribute)));
var deprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DeprecatedAttribute)));
var discordInExperimentAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordInExperimentAttribute)));
var discordDeprecatedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordDeprecatedAttribute)));
var discordUnreleasedAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(DiscordUnreleasedAttribute)));
var requiresFeatureAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(RequiresFeatureAttribute)));
var requiresOverrideAttributeData = attributes.FirstOrDefault(attr =&gt; IsRequiredAttribute(context.SemanticModel, attr, typeof(RequiresOverrideAttribute)));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_experimentalRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_deprecatedRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordInExperimentRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordDeprecatedRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_discordUnreleasedRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_requiresFeatureRule, invocation.GetLocation(), kind, name, message));
⋮----
context.ReportDiagnostic(Diagnostic.Create(s_requiresOverrideRule, invocation.GetLocation(), properties, kind, name, message));
⋮----
///     Checks if the attribute is the desired attribute.
⋮----
/// &lt;param name=&quot;semanticModel&quot;&gt;The current semantic model.&lt;/param&gt;
/// &lt;param name=&quot;attribute&quot;&gt;&gt;The current attribute data.&lt;/param&gt;
/// &lt;param name=&quot;desiredAttributeType&quot;&gt;The target attribute type to check for.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;paramref name=&quot;attribute&quot; /&gt; contains the &lt;paramref name=&quot;desiredAttributeType&quot; /&gt;.&lt;/returns&gt;
private static bool IsRequiredAttribute(SemanticModel semanticModel, AttributeData attribute, Type desiredAttributeType)
⋮----
var desiredTypeNamedSymbol = semanticModel.Compilation.GetTypeByMetadataName(desiredAttributeType.FullName);
⋮----
///     Gets the message from the attribute.
⋮----
/// &lt;param name=&quot;attributeData&quot;&gt;The current attribute data.&lt;/param&gt;
/// &lt;returns&gt;The message.&lt;/returns&gt;
private static string GetMessage(AttributeData attributeData)
⋮----
///     Retrieves a formatted message indicating the required override and additional information based on the provided
///     attribute data.
⋮----
/// &lt;param name=&quot;attributeData&quot;&gt;
///     An object containing data about an attribute, which may include constructor arguments for
///     processing.
/// &lt;/param&gt;
/// &lt;returns&gt;
///     A formatted string detailing the required override and any additional information or a default message if none is
///     provided.
/// &lt;/returns&gt;
private static string GetOverrideMessage(AttributeData attributeData)
⋮----
///     Retrieves the override value from the provided attribute data, returning a default value if the attribute is &lt;see langword=&quot;null&quot; /&gt;.
⋮----
/// &lt;param name=&quot;attributeData&quot;&gt;The attribute data from which to extract the override value.&lt;/param&gt;
/// &lt;param name=&quot;fallback&quot;&gt;Whether to return a default value if the attribute is &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;Returns the override value as a string or an empty string if the attribute is &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
private static string GetOverrideValue(AttributeData attributeData, bool fallback = false)
⋮----
///     Retrieves the override date from an attribute, returning a default value if the attribute is &lt;see langword=&quot;null&quot; /&gt;.
⋮----
/// &lt;param name=&quot;attributeData&quot;&gt;The attribute from which to extract the override date.&lt;/param&gt;
⋮----
/// &lt;returns&gt;Returns the override date as a string or an empty string if the attribute is &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
private static string GetOverrideDate(AttributeData attributeData, bool fallback = false)
⋮----
///     Gets the feature message from the attribute.
⋮----
private static string GetFeatureMessage(AttributeData attributeData)
⋮----
return $&quot;{featureReqEnum.ToFeaturesString()} | {description}&quot;;
⋮----
///     Represents a various helper methods.
⋮----
internal static class Helpers
⋮----
///     Initializes the &lt;see cref=&quot;Helpers&quot; /&gt; class.
⋮----
var ti = t.GetTypeInfo();
var vals = Enum.GetValues(t).Cast&lt;Features&gt;();
⋮----
var xsv = xv.ToString();
var xmv = ti.DeclaredMembers.FirstOrDefault(xm =&gt; xm.Name == xsv);
⋮----
///     Gets the feature strings.
⋮----
///     Converts a feature enum to a string.
⋮----
/// &lt;param name=&quot;features&quot;&gt;The feature enum to convert.&lt;/param&gt;
/// &lt;returns&gt;The string representation of the feature enum.&lt;/returns&gt;
public static string ToFeaturesString(this Features features)
⋮----
.Where(xkvp =&gt; (features &amp; xkvp.Key) == xkvp.Key)
.Select(xkvp =&gt; xkvp.Value);
⋮----
return string.Join(&quot;, &quot;, strs.OrderBy(xs =&gt; xs));</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.Designer.cs">//------------------------------------------------------------------------------
// &lt;auto-generated&gt;
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// &lt;/auto-generated&gt;
⋮----
/// &lt;summary&gt;
///   A strongly-typed resource class, for looking up localized strings, etc.
/// &lt;/summary&gt;
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
⋮----
internal class Resources {
⋮----
///   Returns the cached ResourceManager instance used by this class.
⋮----
if (object.ReferenceEquals(resourceMan, null)) {
⋮----
///   Overrides the current thread&apos;s CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
⋮----
///   Looks up a localized string similar to DisCatSharp considers this as deprecated. Update your code..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionDeprecated&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Discord deprecated this..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordDeprecated&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Discord has released it as experiment. Do not use in production..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordInExperiment&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Discord hasn&amp;apos;t released this yet. Do not use in production..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionDiscordUnreleased&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to DisCatSharp considers this as experimental. Do not use in production..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionExperimental&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to This needs special features to be enabled / set..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionRequiresFeature&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to This requires to modify the DiscordConfiguration to include an Override..
⋮----
return ResourceManager.GetString(&quot;AnalyzerDescriptionRequiresOverride&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to DisCatSharp Analyzer threw an exception: {0}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerException&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; is deprecated: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatDeprecated&quot;, resourceCulture);
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordDeprecated&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; is in experiment: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordInExperiment&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; is not released yet: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatDiscordUnreleased&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; is experimental: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatExperimental&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; needs features: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatRequiresFeature&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to {0} &amp;apos;{1}&amp;apos; needs override: {2}.
⋮----
return ResourceManager.GetString(&quot;AnalyzerMessageFormatRequiresOverride&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [DCS] Deprecated.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleDeprecated&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [Discord] Deprecated.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleDiscordDeprecated&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [Discord] InExperiment.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleDiscordInExperiment&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [Discord] Unreleased.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleDiscordUnreleased&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [DCS] Experimental.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleExperimental&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [Discord] Requires Feature.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleRequiresFeature&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to [Discord] Requires Override.
⋮----
return ResourceManager.GetString(&quot;AnalyzerTitleRequiresOverride&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Faulty.
⋮----
return ResourceManager.GetString(&quot;Faulty&quot;, resourceCulture);
⋮----
///   Looks up a localized string similar to Handling .
⋮----
return ResourceManager.GetString(&quot;Handling&quot;, resourceCulture);</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/Resources.resx">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root&gt;
  &lt;!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers &amp; schema ...
    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
    &lt;/data&gt;
    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
        &lt;comment&gt;This is a comment&lt;/comment&gt;
    &lt;/data&gt;
                
    There are any number of &quot;resheader&quot; rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don&apos;t support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    --&gt;
  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
    &lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; /&gt;
    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
          &lt;xsd:element name=&quot;metadata&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;assembly&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;data&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name=&quot;resheader&quot;&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
              &lt;/xsd:sequence&gt;
              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
  &lt;/xsd:schema&gt;
  &lt;resheader name=&quot;resmimetype&quot;&gt;
    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;version&quot;&gt;
    &lt;value&gt;2.0&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;reader&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;resheader name=&quot;writer&quot;&gt;
    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
  &lt;/resheader&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord deprecated this.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord has released it as experiment. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Discord hasn&apos;t released this yet. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;DisCatSharp considers this as experimental. Do not use in production.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is deprecated: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is in experiment: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is not released yet: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is experimental: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Deprecated&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordInExperiment&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] InExperiment&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDiscordUnreleased&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Unreleased&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleExperimental&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[DCS] Experimental&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[DCS] Deprecated&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; is deprecated: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionDeprecated&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;DisCatSharp considers this as deprecated. Update your code.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;This needs special features to be enabled / set.&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; needs features: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleRequiresFeature&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Requires Feature&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;Handling&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Handling &lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;Faulty&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;Faulty&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerException&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;DisCatSharp Analyzer threw an exception: {0}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerTitleRequiresOverride&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;[Discord] Requires Override&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerMessageFormatRequiresOverride&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;{0} &apos;{1}&apos; needs override: {2}&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name=&quot;AnalyzerDescriptionRequiresOverride&quot; xml:space=&quot;preserve&quot;&gt;
    &lt;value&gt;This requires to modify the DiscordConfiguration to include an Override.&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Tools.slnx">&lt;Solution&gt;
  &lt;Folder Name=&quot;/Solution Items/&quot;&gt;
    &lt;File Path=&quot;.editorconfig&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.ruleset&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Project Path=&quot;../DisCatSharp.Attributes/DisCatSharp.Attributes.csproj&quot; /&gt;
  &lt;Project Path=&quot;../DisCatSharp.Common/DisCatSharp.Common.csproj&quot; /&gt;
  &lt;Project Path=&quot;../DisCatSharp.Experimental/DisCatSharp.Experimental.csproj&quot;&gt;
    &lt;BuildDependency Project=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj&quot; /&gt;
  &lt;/Project&gt;
  &lt;Project Path=&quot;../DisCatSharp.Tests/DisCatSharp.Analyzer.Tests/DisCatSharp.Analyzer.Tests.csproj&quot; Id=&quot;c9b160c6-7f98-43f7-b084-9a09f45ce90a&quot;&gt;
    &lt;BuildDependency Project=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj&quot; /&gt;
  &lt;/Project&gt;
  &lt;Project Path=&quot;../DisCatSharp/DisCatSharp.csproj&quot;&gt;
    &lt;BuildDependency Project=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj&quot; /&gt;
  &lt;/Project&gt;
  &lt;Project Path=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/DisCatSharp.Analyzer.CodeFixes.csproj&quot; Id=&quot;4fa3a95a-8f21-48df-bb2b-fc5f3583ec68&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj&quot; Id=&quot;5fdbac77-b98b-4a72-bab6-31f5e7e01e68&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj&quot; Id=&quot;46069769-3fdc-45a1-8b62-d9cd3308efb4&quot; /&gt;
&lt;/Solution&gt;</file><file path="DisCatSharp.VoiceNext/AudioFormat.cs">/// &lt;summary&gt;
///     Defines the format of PCM data consumed or produced by Opus.
/// &lt;/summary&gt;
⋮----
///     Gets the collection of sampling rates (in Hz) the Opus encoder can use.
⋮----
///     Gets the collection of channel counts the Opus encoder can use.
⋮----
///     Gets the collection of sample durations (in ms) the Opus encoder can use.
⋮----
///     Gets the default audio format. This is a format configured for 48kHz sampling rate, 2 channels, with music quality
///     preset.
⋮----
///     Gets the audio sampling rate in Hz.
⋮----
///     Gets the audio channel count.
⋮----
///     Gets the voice application, which dictates the quality preset.
⋮----
///     Creates a new audio format for use with Opus encoder.
⋮----
/// &lt;param name=&quot;sampleRate&quot;&gt;Audio sampling rate in Hz.&lt;/param&gt;
/// &lt;param name=&quot;channelCount&quot;&gt;Number of audio channels in the data.&lt;/param&gt;
/// &lt;param name=&quot;voiceApplication&quot;&gt;Encoder preset to use.&lt;/param&gt;
⋮----
if (!AllowedSampleRates.Contains(sampleRate))
throw new ArgumentOutOfRangeException(nameof(sampleRate), &quot;Invalid sample rate specified.&quot;);
⋮----
if (!AllowedChannelCounts.Contains(channelCount))
throw new ArgumentOutOfRangeException(nameof(channelCount), &quot;Invalid channel count specified.&quot;);
⋮----
throw new ArgumentOutOfRangeException(nameof(voiceApplication), &quot;Invalid voice application specified.&quot;);
⋮----
///     Calculates a sample size in bytes.
⋮----
/// &lt;param name=&quot;sampleDuration&quot;&gt;Millisecond duration of a sample.&lt;/param&gt;
/// &lt;returns&gt;Calculated sample size in bytes.&lt;/returns&gt;
⋮----
public int CalculateSampleSize(int sampleDuration)
⋮----
if (!AllowedSampleDurations.Contains(sampleDuration))
throw new ArgumentOutOfRangeException(nameof(sampleDuration), &quot;Invalid sample duration specified.&quot;);
⋮----
// Sample size in bytes is a product of the following:
// - duration in milliseconds
// - number of channels
// - sample rate in kHz
// - size of data (in this case, sizeof(int16_t))
// which comes down to below:
⋮----
///     Gets the maximum buffer size for decoding. This method should be called when decoding Opus data to PCM, to ensure
///     sufficient buffer size.
⋮----
/// &lt;returns&gt;Buffer size required to decode data.&lt;/returns&gt;
⋮----
public int GetMaximumBufferSize()
=&gt; this.CalculateMaximumFrameSize();
⋮----
///     Calculates the sample duration.
⋮----
/// &lt;param name=&quot;sampleSize&quot;&gt;The sample size.&lt;/param&gt;
/// &lt;returns&gt;An int.&lt;/returns&gt;
⋮----
internal int CalculateSampleDuration(int sampleSize)
=&gt; sampleSize / (this.SampleRate / 1000) / this.ChannelCount / 2 /* sizeof(int16_t) */;
⋮----
///     Calculates the frame size.
⋮----
/// &lt;param name=&quot;sampleDuration&quot;&gt;The sample duration.&lt;/param&gt;
⋮----
internal int CalculateFrameSize(int sampleDuration)
⋮----
///     Calculates the maximum frame size.
⋮----
internal int CalculateMaximumFrameSize()
⋮----
///     Samples the count to sample size.
⋮----
/// &lt;param name=&quot;sampleCount&quot;&gt;The sample count.&lt;/param&gt;
⋮----
internal int SampleCountToSampleSize(int sampleCount)
=&gt; sampleCount * this.ChannelCount * 2 /* sizeof(int16_t) */;
⋮----
///     Are the valid.
⋮----
/// &lt;returns&gt;A bool.&lt;/returns&gt;
internal bool IsValid()
=&gt; AllowedSampleRates.Contains(this.SampleRate) &amp;&amp; AllowedChannelCounts.Contains(this.ChannelCount) &amp;&amp;</file><file path="DisCatSharp.VoiceNext/Codec/Helpers.cs">/// &lt;summary&gt;
///     The helpers.
/// &lt;/summary&gt;
internal static class Helpers
⋮----
///     Fills the buffer with 0.
⋮----
/// &lt;param name=&quot;buff&quot;&gt;The buffer.&lt;/param&gt;
⋮----
public static void ZeroFill(Span&lt;byte&gt; buff)
⋮----
MemoryMarshal.Write(buff, in zero);
⋮----
MemoryMarshal.Write(buff, ref zero);</file><file path="DisCatSharp.VoiceNext/Codec/Interop.cs">/// &lt;summary&gt;
///     This is an interop class. It contains wrapper methods for Opus and Sodium.
/// &lt;/summary&gt;
internal static class Interop
⋮----
///     The sodium library name.
⋮----
///     Gets the Sodium key size for xsalsa20_poly1305 algorithm.
⋮----
///     Gets the Sodium nonce size for xsalsa20_poly1305 algorithm.
⋮----
///     Gets the Sodium MAC size for xsalsa20_poly1305 algorithm.
⋮----
///     _S the sodium secret box key size.
⋮----
/// &lt;returns&gt;An UIntPtr.&lt;/returns&gt;
⋮----
private static extern UIntPtr _SodiumSecretBoxKeySize();
⋮----
///     _S the sodium secret box nonce size.
⋮----
private static extern UIntPtr _SodiumSecretBoxNonceSize();
⋮----
///     _S the sodium secret box mac size.
⋮----
private static extern UIntPtr _SodiumSecretBoxMacSize();
⋮----
///     _S the sodium secret box create.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;The buffer.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;messageLength&quot;&gt;The message length.&lt;/param&gt;
/// &lt;param name=&quot;nonce&quot;&gt;The nonce.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
/// &lt;returns&gt;An int.&lt;/returns&gt;
⋮----
private static extern unsafe int _SodiumSecretBoxCreate(byte* buffer, byte* message, ulong messageLength, byte* nonce, byte* key);
⋮----
///     _S the sodium secret box open.
⋮----
/// &lt;param name=&quot;encryptedMessage&quot;&gt;The encrypted message.&lt;/param&gt;
/// &lt;param name=&quot;encryptedLength&quot;&gt;The encrypted length.&lt;/param&gt;
⋮----
private static extern unsafe int _SodiumSecretBoxOpen(byte* buffer, byte* encryptedMessage, ulong encryptedLength, byte* nonce, byte* key);
⋮----
///     Encrypts supplied buffer using xsalsa20_poly1305 algorithm, using supplied key and nonce to perform encryption.
⋮----
/// &lt;param name=&quot;source&quot;&gt;Contents to encrypt.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;Buffer to encrypt to.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;Key to use for encryption.&lt;/param&gt;
/// &lt;param name=&quot;nonce&quot;&gt;Nonce to use for encryption.&lt;/param&gt;
/// &lt;returns&gt;Encryption status.&lt;/returns&gt;
public static unsafe int Encrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; nonce)
⋮----
fixed (byte* sourcePtr = &amp;source.GetPinnableReference())
fixed (byte* targetPtr = &amp;target.GetPinnableReference())
fixed (byte* keyPtr = &amp;key.GetPinnableReference())
fixed (byte* noncePtr = &amp;nonce.GetPinnableReference())
⋮----
///     Decrypts supplied buffer using xsalsa20_poly1305 algorithm, using supplied key and nonce to perform decryption.
⋮----
/// &lt;param name=&quot;source&quot;&gt;Buffer to decrypt from.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;Decrypted message buffer.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;Key to use for decryption.&lt;/param&gt;
/// &lt;param name=&quot;nonce&quot;&gt;Nonce to use for decryption.&lt;/param&gt;
/// &lt;returns&gt;Decryption status.&lt;/returns&gt;
public static unsafe int Decrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; nonce)
⋮----
///     The opus library name.
⋮----
///     _S the opus create encoder.
⋮----
/// &lt;param name=&quot;sampleRate&quot;&gt;The sample rate.&lt;/param&gt;
/// &lt;param name=&quot;channels&quot;&gt;The channels.&lt;/param&gt;
/// &lt;param name=&quot;application&quot;&gt;The application.&lt;/param&gt;
/// &lt;param name=&quot;error&quot;&gt;The error.&lt;/param&gt;
/// &lt;returns&gt;An IntPtr.&lt;/returns&gt;
⋮----
private static extern IntPtr _OpusCreateEncoder(int sampleRate, int channels, int application, out OpusError error);
⋮----
///     Opuses the destroy encoder.
⋮----
/// &lt;param name=&quot;encoder&quot;&gt;The encoder.&lt;/param&gt;
⋮----
public static extern void OpusDestroyEncoder(IntPtr encoder);
⋮----
///     _S the opus encode.
⋮----
/// &lt;param name=&quot;pcmData&quot;&gt;The pcm data.&lt;/param&gt;
/// &lt;param name=&quot;frameSize&quot;&gt;The frame size.&lt;/param&gt;
/// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
/// &lt;param name=&quot;maxDataBytes&quot;&gt;The max data bytes.&lt;/param&gt;
⋮----
private static extern unsafe int _OpusEncode(IntPtr encoder, byte* pcmData, int frameSize, byte* data, int maxDataBytes);
⋮----
///     _S the opus encoder control.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;returns&gt;An OpusError.&lt;/returns&gt;
⋮----
private static extern OpusError _OpusEncoderControl(IntPtr encoder, OpusControl request, int value);
⋮----
///     _S the opus create decoder.
⋮----
private static extern IntPtr _OpusCreateDecoder(int sampleRate, int channels, out OpusError error);
⋮----
///     Opuses the destroy decoder.
⋮----
/// &lt;param name=&quot;decoder&quot;&gt;The decoder.&lt;/param&gt;
⋮----
public static extern void OpusDestroyDecoder(IntPtr decoder);
⋮----
///     _S the opus decode.
⋮----
/// &lt;param name=&quot;opusData&quot;&gt;The opus data.&lt;/param&gt;
/// &lt;param name=&quot;opusDataLength&quot;&gt;The opus data length.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;decodeFec&quot;&gt;The decode fec.&lt;/param&gt;
⋮----
private static extern unsafe int _OpusDecode(IntPtr decoder, byte* opusData, int opusDataLength, byte* data, int frameSize, int decodeFec);
⋮----
///     _S the opus get packet channel count.
⋮----
private static extern unsafe int _OpusGetPacketChannelCount(byte* opusData);
⋮----
///     _S the opus get packet frame count.
⋮----
/// &lt;param name=&quot;length&quot;&gt;The length.&lt;/param&gt;
⋮----
private static extern unsafe int _OpusGetPacketFrameCount(byte* opusData, int length);
⋮----
///     _S the opus get packet sample per frame count.
⋮----
/// &lt;param name=&quot;samplingRate&quot;&gt;The sampling rate.&lt;/param&gt;
⋮----
private static extern unsafe int _OpusGetPacketSamplePerFrameCount(byte* opusData, int samplingRate);
⋮----
///     _S the opus decoder control.
⋮----
private static extern int _OpusDecoderControl(IntPtr decoder, OpusControl request, out int value);
⋮----
///     Opuses the create encoder.
⋮----
/// &lt;param name=&quot;audioFormat&quot;&gt;The audio format.&lt;/param&gt;
⋮----
public static IntPtr OpusCreateEncoder(AudioFormat audioFormat)
⋮----
///     Opuses the set encoder option.
⋮----
/// &lt;param name=&quot;option&quot;&gt;The option.&lt;/param&gt;
⋮----
public static void OpusSetEncoderOption(IntPtr encoder, OpusControl option, int value)
⋮----
///     Opuses the encode.
⋮----
/// &lt;param name=&quot;pcm&quot;&gt;The pcm.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;opus&quot;&gt;The opus.&lt;/param&gt;
public static unsafe void OpusEncode(IntPtr encoder, ReadOnlySpan&lt;byte&gt; pcm, int frameSize, ref Span&lt;byte&gt; opus)
⋮----
fixed (byte* pcmPtr = &amp;pcm.GetPinnableReference())
fixed (byte* opusPtr = &amp;opus.GetPinnableReference())
⋮----
///     Opuses the create decoder.
⋮----
public static IntPtr OpusCreateDecoder(AudioFormat audioFormat)
⋮----
///     Opuses the decode.
⋮----
/// &lt;param name=&quot;useFec&quot;&gt;If true, use fec.&lt;/param&gt;
⋮----
public static unsafe int OpusDecode(IntPtr decoder, ReadOnlySpan&lt;byte&gt; opus, int frameSize, Span&lt;byte&gt; pcm, bool useFec)
⋮----
public static unsafe int OpusDecode(IntPtr decoder, int frameSize, Span&lt;byte&gt; pcm)
⋮----
///     Opuses the get packet metrics.
⋮----
/// &lt;param name=&quot;frames&quot;&gt;The frames.&lt;/param&gt;
/// &lt;param name=&quot;samplesPerFrame&quot;&gt;The samples per frame.&lt;/param&gt;
⋮----
public static unsafe void OpusGetPacketMetrics(ReadOnlySpan&lt;byte&gt; opus, int samplingRate, out int channels, out int frames, out int samplesPerFrame, out int frameSize)
⋮----
///     Opuses the get last packet duration.
⋮----
/// &lt;param name=&quot;sampleCount&quot;&gt;The sample count.&lt;/param&gt;
public static void OpusGetLastPacketDuration(IntPtr decoder, out int sampleCount)</file><file path="DisCatSharp.VoiceNext/Codec/Opus.cs">/// &lt;summary&gt;
///     The opus.
/// &lt;/summary&gt;
// ReSharper disable once ClassCanBeSealed.Global - This class can be used by other projects.
public class Opus : IDisposable
⋮----
///     Gets the encoder.
⋮----
private readonly IntPtr _encoder;
⋮----
///     Gets the managed decoders.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Opus&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;audioFormat&quot;&gt;The audio format.&lt;/param&gt;
⋮----
if (!audioFormat.IsValid())
throw new ArgumentException(&quot;Invalid audio format specified.&quot;, nameof(audioFormat));
⋮----
this._encoder = Interop.OpusCreateEncoder(this.AudioFormat);
⋮----
// Set appropriate encoder options
⋮----
Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetSignal, (int)sig);
Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetPacketLossPercent, 15);
Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetInBandFec, 1);
Interop.OpusSetEncoderOption(this._encoder, OpusControl.SetBitrate, 131072);
⋮----
///     Gets the audio format.
⋮----
///     Disposes the Opus.
⋮----
public void Dispose()
⋮----
Interop.OpusDestroyEncoder(this._encoder);
⋮----
decoder.Dispose();
⋮----
GC.SuppressFinalize(this);
⋮----
///     Encodes the Opus.
⋮----
/// &lt;param name=&quot;pcm&quot;&gt;The pcm.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target.&lt;/param&gt;
public void Encode(ReadOnlySpan&lt;byte&gt; pcm, ref Span&lt;byte&gt; target)
⋮----
throw new ArgumentException(&quot;PCM and Opus buffer lengths need to be equal.&quot;, nameof(target));
⋮----
var duration = this.AudioFormat.CalculateSampleDuration(pcm.Length);
var frameSize = this.AudioFormat.CalculateFrameSize(duration);
var sampleSize = this.AudioFormat.CalculateSampleSize(duration);
⋮----
throw new ArgumentException(&quot;Invalid PCM sample size.&quot;, nameof(target));
⋮----
Interop.OpusEncode(this._encoder, pcm, frameSize, ref target);
⋮----
///     Decodes the Opus.
⋮----
/// &lt;param name=&quot;decoder&quot;&gt;The decoder.&lt;/param&gt;
/// &lt;param name=&quot;opus&quot;&gt;The opus.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;useFec&quot;&gt;If true, use fec.&lt;/param&gt;
/// &lt;param name=&quot;outputFormat&quot;&gt;The output format.&lt;/param&gt;
public void Decode(OpusDecoder decoder, ReadOnlySpan&lt;byte&gt; opus, ref Span&lt;byte&gt; target, bool useFec, out AudioFormat outputFormat)
⋮----
//if (target.Length != this.AudioFormat.CalculateMaximumFrameSize())
//    throw new ArgumentException(&quot;PCM target buffer size needs to be equal to maximum buffer size for specified audio format.&quot;, nameof(target));
⋮----
Interop.OpusGetPacketMetrics(opus, this.AudioFormat.SampleRate, out var channels, out _, out _, out var frameSize);
⋮----
decoder.Initialize(outputFormat);
⋮----
var sampleCount = Interop.OpusDecode(decoder.Decoder, opus, frameSize, target, useFec);
⋮----
var sampleSize = outputFormat.SampleCountToSampleSize(sampleCount);
⋮----
///     Processes the packet loss.
⋮----
/// &lt;param name=&quot;frameSize&quot;&gt;The frame size.&lt;/param&gt;
⋮----
public void ProcessPacketLoss(OpusDecoder decoder, int frameSize, ref Span&lt;byte&gt; target)
=&gt; Interop.OpusDecode(decoder.Decoder, frameSize, target);
⋮----
///     Gets the last packet sample count.
⋮----
/// &lt;returns&gt;An int.&lt;/returns&gt;
public int GetLastPacketSampleCount(OpusDecoder decoder)
⋮----
Interop.OpusGetLastPacketDuration(decoder.Decoder, out var sampleCount);
⋮----
///     Creates the decoder.
⋮----
/// &lt;returns&gt;An OpusDecoder.&lt;/returns&gt;
public OpusDecoder CreateDecoder()
⋮----
var managedDecoder = new OpusDecoder(this);
this._managedDecoders.Add(managedDecoder);
⋮----
///     Destroys the decoder.
⋮----
public void DestroyDecoder(OpusDecoder? decoder)
⋮----
if (decoder is null || !this._managedDecoders.Contains(decoder))
⋮----
this._managedDecoders.Remove(decoder);
⋮----
///     Represents an Opus decoder.
⋮----
public sealed class OpusDecoder : IDisposable
⋮----
///     Gets a value indicating whether this &lt;see cref=&quot;OpusDecoder&quot; /&gt; is disposed.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;OpusDecoder&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;managedOpus&quot;&gt;The managed opus.&lt;/param&gt;
⋮----
///     Gets the audio format produced by this decoder.
⋮----
///     Gets the opus.
⋮----
///     Gets the decoder.
⋮----
///     Disposes of this Opus decoder.
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
Interop.OpusDestroyDecoder(this.Decoder);
⋮----
///     Used to lazily initialize the decoder to make sure we&apos;re
///     using the correct output format, this way we don&apos;t end up
///     creating more decoders than we need.
⋮----
/// &lt;param name=&quot;outputFormat&quot;&gt;&lt;/param&gt;
internal void Initialize(AudioFormat outputFormat)
⋮----
this.Decoder = Interop.OpusCreateDecoder(outputFormat);
⋮----
this.Dispose();
⋮----
///     The opus error.
⋮----
///     The opus control.
⋮----
///     The opus signal.</file><file path="DisCatSharp.VoiceNext/Codec/Rtp.cs">/// &lt;summary&gt;
///     The rtp.
/// &lt;/summary&gt;
// ReSharper disable once ClassCanBeSealed.Global - This class can be used by other projects.
internal class Rtp : IDisposable
⋮----
///     The header size.
⋮----
///     The rtp no extension.
⋮----
///     The rtp extension.
⋮----
///     The rtp version.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Rtp&quot; /&gt; class.
⋮----
///     Disposes the Rtp.
⋮----
public void Dispose()
⋮----
///     Encodes the header.
⋮----
/// &lt;param name=&quot;sequence&quot;&gt;The sequence.&lt;/param&gt;
/// &lt;param name=&quot;timestamp&quot;&gt;The timestamp.&lt;/param&gt;
/// &lt;param name=&quot;ssrc&quot;&gt;The ssrc.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target.&lt;/param&gt;
public void EncodeHeader(ushort sequence, uint timestamp, uint ssrc, Span&lt;byte&gt; target)
⋮----
throw new ArgumentException(&quot;Header buffer is too short.&quot;, nameof(target));
⋮----
// Write data big endian
BinaryPrimitives.WriteUInt16BigEndian(target[2..], sequence); // header + magic
BinaryPrimitives.WriteUInt32BigEndian(target[4..], timestamp); // header + magic + sizeof(sequence)
BinaryPrimitives.WriteUInt32BigEndian(target[8..], ssrc); // header + magic + sizeof(sequence) + sizeof(timestamp)
⋮----
///     Are the rtp header.
⋮----
/// &lt;param name=&quot;source&quot;&gt;The source.&lt;/param&gt;
/// &lt;returns&gt;A bool.&lt;/returns&gt;
public bool IsRtpHeader(ReadOnlySpan&lt;byte&gt; source)
⋮----
///     Decodes the header.
⋮----
/// &lt;param name=&quot;hasExtension&quot;&gt;If true, has extension.&lt;/param&gt;
public void DecodeHeader(ReadOnlySpan&lt;byte&gt; source, out ushort sequence, out uint timestamp, out uint ssrc, out bool hasExtension)
⋮----
throw new ArgumentException(&quot;Header buffer is too short.&quot;, nameof(source));
⋮----
throw new ArgumentException(&quot;Invalid RTP header.&quot;, nameof(source));
⋮----
// Read data big endian
sequence = BinaryPrimitives.ReadUInt16BigEndian(source[2..]);
timestamp = BinaryPrimitives.ReadUInt32BigEndian(source[4..]);
ssrc = BinaryPrimitives.ReadUInt32BigEndian(source[8..]);
⋮----
///     Calculates the packet size.
⋮----
/// &lt;param name=&quot;encryptedLength&quot;&gt;The encrypted length.&lt;/param&gt;
/// &lt;param name=&quot;encryptionMode&quot;&gt;The encryption mode.&lt;/param&gt;
/// &lt;returns&gt;An int.&lt;/returns&gt;
public int CalculatePacketSize(int encryptedLength, EncryptionMode encryptionMode) =&gt;
⋮----
_ =&gt; throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode))
⋮----
///     Gets the data from packet.
⋮----
/// &lt;param name=&quot;packet&quot;&gt;The packet.&lt;/param&gt;
/// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
⋮----
public void GetDataFromPacket(ReadOnlySpan&lt;byte&gt; packet, out ReadOnlySpan&lt;byte&gt; data, EncryptionMode encryptionMode)
⋮----
data = packet.Slice(HEADER_SIZE, packet.Length - HEADER_SIZE - Interop.SodiumNonceSize);
⋮----
data = packet.Slice(HEADER_SIZE, packet.Length - HEADER_SIZE - 4);
⋮----
throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode));</file><file path="DisCatSharp.VoiceNext/Codec/Sodium.cs">/// &lt;summary&gt;
///     The sodium.
/// &lt;/summary&gt;
// ReSharper disable once ClassCanBeSealed.Global - This class can be used by other projects.
internal class Sodium : IDisposable
⋮----
///     Gets the buffer.
⋮----
///     Gets the c s p r n g.
⋮----
private readonly RandomNumberGenerator _csprng;
⋮----
///     Gets the key.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Sodium&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
⋮----
throw new ArgumentException($&quot;Invalid Sodium key size. Key needs to have a length of {Interop.SodiumKeySize} bytes.&quot;, nameof(key));
⋮----
this._csprng = RandomNumberGenerator.Create();
⋮----
///     Gets the supported modes.
⋮----
///     Gets the nonce size.
⋮----
///     Disposes the Sodium.
⋮----
public void Dispose()
=&gt; this._csprng.Dispose();
⋮----
///     Generates the nonce.
⋮----
/// &lt;param name=&quot;rtpHeader&quot;&gt;The rtp header.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target.&lt;/param&gt;
public void GenerateNonce(ReadOnlySpan&lt;byte&gt; rtpHeader, Span&lt;byte&gt; target)
⋮----
throw new ArgumentException($&quot;RTP header needs to have a length of exactly {Rtp.HEADER_SIZE} bytes.&quot;, nameof(rtpHeader));
⋮----
throw new ArgumentException($&quot;Invalid nonce buffer size. Target buffer for the nonce needs to have a capacity of {Interop.SodiumNonceSize} bytes.&quot;, nameof(target));
⋮----
// Write the header to the beginning of the span.
rtpHeader.CopyTo(target);
⋮----
// Zero rest of the span.
Helpers.ZeroFill(target[rtpHeader.Length..]);
⋮----
public void GenerateNonce(Span&lt;byte&gt; target)
⋮----
this._csprng.GetBytes(this._buffer);
this._buffer.AsSpan().CopyTo(target);
⋮----
/// &lt;param name=&quot;nonce&quot;&gt;The nonce.&lt;/param&gt;
⋮----
public void GenerateNonce(uint nonce, Span&lt;byte&gt; target)
⋮----
// Write the uint to memory
BinaryPrimitives.WriteUInt32BigEndian(target, nonce);
⋮----
// Zero rest of the buffer.
Helpers.ZeroFill(target[4..]);
⋮----
///     Appends the nonce.
⋮----
/// &lt;param name=&quot;encryptionMode&quot;&gt;The encryption mode.&lt;/param&gt;
public void AppendNonce(ReadOnlySpan&lt;byte&gt; nonce, Span&lt;byte&gt; target, EncryptionMode encryptionMode)
⋮----
nonce.CopyTo(target[^12..]);
⋮----
nonce[..4].CopyTo(target[^4..]);
⋮----
throw new ArgumentException(&quot;Unsupported encryption mode.&quot;, nameof(encryptionMode));
⋮----
///     Gets the nonce.
⋮----
/// &lt;param name=&quot;source&quot;&gt;The source.&lt;/param&gt;
⋮----
public void GetNonce(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, EncryptionMode encryptionMode)
⋮----
source[..12].CopyTo(target);
⋮----
source[^Interop.SodiumNonceSize..].CopyTo(target);
⋮----
source[^4..].CopyTo(target);
⋮----
///     Encrypts the Sodium.
⋮----
public void Encrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; nonce)
⋮----
throw new ArgumentException($&quot;Invalid nonce size. Nonce needs to have a length of {Interop.SodiumNonceSize} bytes.&quot;, nameof(nonce));
⋮----
throw new ArgumentException($&quot;Invalid target buffer size. Target buffer needs to have a length that is a sum of input buffer length and Sodium MAC size ({Interop.SodiumMacSize} bytes).&quot;, nameof(target));
⋮----
if ((result = Interop.Encrypt(source, target, this._key.Span, nonce)) is not 0)
throw new CryptographicException($&quot;Could not encrypt the buffer. Sodium returned code {result}.&quot;);
⋮----
///     Decrypts the Sodium.
⋮----
public void Decrypt(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; target, ReadOnlySpan&lt;byte&gt; nonce)
⋮----
throw new ArgumentException($&quot;Invalid target buffer size. Target buffer needs to have a length that is input buffer decreased by Sodium MAC size ({Interop.SodiumMacSize} bytes).&quot;, nameof(target));
⋮----
if ((result = Interop.Decrypt(source, target, this._key.Span, nonce)) is not 0)
throw new CryptographicException($&quot;Could not decrypt the buffer. Sodium returned code {result}.&quot;);
⋮----
///     Selects the mode.
⋮----
/// &lt;param name=&quot;availableModes&quot;&gt;The available modes.&lt;/param&gt;
/// &lt;returns&gt;A KeyValuePair.&lt;/returns&gt;
⋮----
public static KeyValuePair&lt;string, EncryptionMode&gt; SelectMode(IEnumerable&lt;string&gt; availableModes)
⋮----
if (availableModes.Contains(kvMode.Key))
⋮----
throw new CryptographicException(&quot;Could not negotiate Sodium encryption modes, as none of the modes offered by Discord are supported. This is usually an indicator that something went very wrong.&quot;);
⋮----
///     Calculates the target size.
⋮----
/// &lt;returns&gt;An int.&lt;/returns&gt;
⋮----
public static int CalculateTargetSize(ReadOnlySpan&lt;byte&gt; source)
⋮----
///     Calculates the source size.
⋮----
public static int CalculateSourceSize(ReadOnlySpan&lt;byte&gt; source)
⋮----
///     Specifies an encryption mode to use with Sodium.
⋮----
///     The nonce is an incrementing uint32 value. It is encoded as big endian value at the beginning of the nonce buffer.
///     The 4 bytes are also appended at the end of the packet.
⋮----
///     The nonce consists of random bytes. It is appended at the end of a packet.
⋮----
///     The nonce consists of the RTP header. Nothing is appended to the packet.</file><file path="DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp.VoiceNext/Entities/AudioSender.cs">/// &lt;summary&gt;
///     The audio sender.
/// &lt;/summary&gt;
internal class AudioSender : IDisposable
⋮----
private SequenceWrapState _currentSequenceWrapState = SequenceWrapState.AssumeNextHighSequenceIsOutOfOrder;
⋮----
// starting the counter a full wrap ahead handles an edge case where the VERY first packets
// we see are right around the wraparound line.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;AudioSender&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;ssrc&quot;&gt;The ssrc.&lt;/param&gt;
/// &lt;param name=&quot;decoder&quot;&gt;The decoder.&lt;/param&gt;
⋮----
///     Gets the s s r c.
⋮----
///     Gets the id.
⋮----
///     Gets the decoder.
⋮----
///     Gets or sets the user.
⋮----
///     Gets or sets the last sequence.
⋮----
///     Disposes .
⋮----
public void Dispose()
⋮----
///     Accepts the 16-bit sequence number from the next RTP header in the associated stream and
///     uses heuristics to (attempt to) convert it into a 64-bit counter that takes into account
///     overflow wrapping around to zero.
///     &lt;para /&gt;
///     This method only works properly if it is called for &lt;b&gt;every&lt;/b&gt; sequence number that we
///     see in the stream.
⋮----
/// &lt;param name=&quot;originalSequence&quot;&gt;
///     The 16-bit sequence number from the next RTP header.
/// &lt;/param&gt;
/// &lt;returns&gt;
///     Our best-effort guess of the value that &lt;paramref name=&quot;originalSequence&quot; /&gt; &lt;b&gt;would&lt;/b&gt;
///     have been, if the server had given us a 64-bit integer instead of a 16-bit one.
/// &lt;/returns&gt;
public ulong GetTrueSequenceAfterWrapping(ushort originalSequence)
⋮----
// section off a smallish zone at either end of the 16-bit integer range.  whenever the
// sequence numbers creep into the higher zone, we start keeping an eye out for when
// sequence numbers suddenly start showing up in the lower zone.  we expect this to mean
// that the sequence numbers overflowed and wrapped around.  there&apos;s a bit of a balance
// when determining an appropriate size for the buffer zone: if it&apos;s too small, then a
// brief (but recoverable) network interruption could cause us to miss the lead-up to
// the overflow.  on the other hand, if it&apos;s too large, then such a network interruption
// could cause us to misinterpret a normal sequence for one that&apos;s out-of-order.
//
// at 20 milliseconds per packet, 3,000 packets means that the buffer zone is one minute
// on either side.  in other words, as long as we&apos;re getting packets delivered within a
// minute or so of when they should be, the 64-bit sequence numbers coming out of this
// method will be perfectly consistent with reality.
⋮----
// we were going about our business up to this point.  the sequence numbers have
// gotten a bit high, so let&apos;s start looking out for any sequence numbers that
// are suddenly WAY lower than where they are right now.
⋮----
// we had seen some sequence numbers that got a bit high, and now we see this
// sequence number that&apos;s WAY lower than before.  this is a classic sign that
// the sequence numbers have wrapped around.  in order to present a consistently
// increasing &quot;true&quot; sequence number, add another 65,536 and keep counting.  if
// we see another high sequence number in the near future, assume that it&apos;s a
// packet coming in out of order.
⋮----
// we&apos;re seeing some high sequence numbers EITHER at the beginning of the stream
// OR very close to the time when we saw some very low sequence numbers.  in the
// latter case, it happened because the packets came in out of order, right when
// the sequence numbers wrapped around.  in the former case, we MIGHT be in the
// same kind of situation (we can&apos;t tell yet), so we err on the side of caution
// and burn a full cycle before we start counting so that we can handle both
// cases with the exact same adjustment.
⋮----
// EITHER we&apos;re at the very beginning of the stream OR very close to the time
// when we saw some very low sequence numbers.  either way, we&apos;re out of the
// zones where we should consider very low sequence numbers to come AFTER very
// high ones, so we can go back to normal now.
⋮----
throw new ArgumentOutOfRangeException(null, &quot;CurrentSequenceWrapState was out of range&quot;);</file><file path="DisCatSharp.VoiceNext/Entities/VoiceDispatch.cs">/// &lt;summary&gt;
///     The voice dispatch.
/// &lt;/summary&gt;
internal sealed class VoiceDispatch
⋮----
///     Gets or sets the op code.
⋮----
///     Gets or sets the payload.
⋮----
///     Gets or sets the sequence.
⋮----
///     Gets or sets the event name.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceIdentifyPayload.cs">/// &lt;summary&gt;
///     The voice identify payload.
/// &lt;/summary&gt;
internal sealed class VoiceIdentifyPayload
⋮----
///     Gets or sets the server id.
⋮----
///     Gets or sets the user id.
⋮----
///     Gets or sets the session id.
⋮----
///     Gets or sets the token.</file><file path="DisCatSharp.VoiceNext/Entities/VoicePacket.cs">/// &lt;summary&gt;
///     Gets the bytes.
/// &lt;/summary&gt;
⋮----
///     Gets the millisecond duration.
⋮----
///     Gets or sets a value indicating whether is silence.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoicePacket&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;bytes&quot;&gt;The bytes.&lt;/param&gt;
/// &lt;param name=&quot;msDuration&quot;&gt;The ms duration.&lt;/param&gt;
/// &lt;param name=&quot;isSilence&quot;&gt;If true, is silence.&lt;/param&gt;</file><file path="DisCatSharp.VoiceNext/Entities/VoiceReadyPayload.cs">/// &lt;summary&gt;
///     The voice ready payload.
/// &lt;/summary&gt;
internal sealed class VoiceReadyPayload
⋮----
///     Gets or sets the s s r c.
⋮----
///     Gets or sets the address.
⋮----
///     Gets or sets the port.
⋮----
///     Gets or sets the modes.
⋮----
///     Gets or sets the heartbeat interval.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayload.cs">/// &lt;summary&gt;
///     The voice select protocol payload.
/// &lt;/summary&gt;
internal sealed class VoiceSelectProtocolPayload
⋮----
///     Gets or sets the protocol.
⋮----
///     Gets or sets the data.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSelectProtocolPayloadData.cs">/// &lt;summary&gt;
///     The voice select protocol payload data.
/// &lt;/summary&gt;
internal class VoiceSelectProtocolPayloadData
⋮----
///     Gets or sets the address.
⋮----
///     Gets or sets the port.
⋮----
///     Gets or sets the mode.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceServerUpdatePayload.cs">/// &lt;summary&gt;
///     The voice server update payload.
/// &lt;/summary&gt;
internal sealed class VoiceServerUpdatePayload
⋮----
///     Gets or sets the token.
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the endpoint.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSessionDescriptionPayload.cs">/// &lt;summary&gt;
///     The voice session description payload.
/// &lt;/summary&gt;
internal sealed class VoiceSessionDescriptionPayload
⋮----
///     Gets or sets the secret key.
⋮----
///     Gets or sets the mode.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceSpeakingPayload.cs">/// &lt;summary&gt;
///     The voice speaking payload.
/// &lt;/summary&gt;
internal sealed class VoiceSpeakingPayload
⋮----
///     Gets or sets a value indicating whether speaking.
⋮----
///     Gets or sets the delay.
⋮----
///     Gets or sets the s s r c.
⋮----
///     Gets or sets the user id.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceStateUpdatePayload.cs">/// &lt;summary&gt;
///     The voice state update payload.
/// &lt;/summary&gt;
internal sealed class VoiceStateUpdatePayload
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the user id.
⋮----
///     Gets or sets the session id.
⋮----
///     Gets or sets a value indicating whether deafened.
⋮----
///     Gets or sets a value indicating whether muted.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceUserJoinPayload.cs">/// &lt;summary&gt;
///     The voice user join payload.
/// &lt;/summary&gt;
internal sealed class VoiceUserJoinPayload
⋮----
///     Gets the user id.
⋮----
///     Gets the s s r c.</file><file path="DisCatSharp.VoiceNext/Entities/VoiceUserLeavePayload.cs">/// &lt;summary&gt;
///     The voice user leave payload.
/// &lt;/summary&gt;
internal sealed class VoiceUserLeavePayload
⋮----
///     Gets or sets the user id.</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceReceiveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for VoiceReceived events.
/// &lt;/summary&gt;
public class VoiceReceiveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceReceiveEventArgs&quot; /&gt; class.
⋮----
///     Gets the SSRC of the audio source.
⋮----
///     Gets the user that sent the audio data.
⋮----
///     Gets the received voice data, decoded to PCM format.
⋮----
///     Gets the received voice data, in Opus format. Note that for packets that were lost and/or compensated for, this
///     will be empty.
⋮----
///     Gets the format of the received PCM data.
///     &lt;para&gt;
///         Important: This isn&apos;t always the format set in &lt;see cref=&quot;VoiceNextConfiguration.AudioFormat&quot; /&gt;, and depends
///         on the audio data received.
///     &lt;/para&gt;
⋮----
///     Gets the millisecond duration of the PCM audio sample.</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceUserJoinEventArgs.cs">/// &lt;summary&gt;
///     Arguments for &lt;see cref=&quot;VoiceNextConnection.UserJoined&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class VoiceUserJoinEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceUserJoinEventArgs&quot; /&gt; class.
⋮----
///     Gets the user who left.
⋮----
///     Gets the SSRC of the user who joined.</file><file path="DisCatSharp.VoiceNext/EventArgs/VoiceUserLeaveEventArgs.cs">/// &lt;summary&gt;
///     Arguments for &lt;see cref=&quot;VoiceNextConnection.UserLeft&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class VoiceUserLeaveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceUserLeaveEventArgs&quot; /&gt; class.
⋮----
///     Gets the user who left.
⋮----
///     Gets the SSRC of the user who left.</file><file path="DisCatSharp.VoiceNext/ExtensionMethods.cs">/// &lt;summary&gt;
///     The discord client extensions.
/// &lt;/summary&gt;
public static class ExtensionMethods
⋮----
///     Creates a new VoiceNext client with specified settings.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client to create VoiceNext instance for.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;Configuration for the VoiceNext client.&lt;/param&gt;
/// &lt;returns&gt;VoiceNext client instance.&lt;/returns&gt;
public static VoiceNextExtension UseVoiceNext(this DiscordClient client, VoiceNextConfiguration? config = null)
⋮----
throw new InvalidOperationException(&quot;VoiceNext is already enabled for that client.&quot;);
⋮----
var vnext = new VoiceNextExtension(config ?? new());
client.AddExtension(vnext);
⋮----
///     Creates new VoiceNext clients on all shards in a given sharded client.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord sharded client to create VoiceNext instances for.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;Configuration for the VoiceNext clients.&lt;/param&gt;
/// &lt;returns&gt;A dictionary of created VoiceNext clients.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, VoiceNextExtension&gt;&gt; UseVoiceNextAsync(this DiscordShardedClient client, VoiceNextConfiguration? config = null)
⋮----
await client.InitializeShardsAsync().ConfigureAwait(false);
⋮----
foreach (var shard in client.ShardClients.Select(xkvp =&gt; xkvp.Value))
⋮----
vnext ??= shard.UseVoiceNext(config);
⋮----
///     Gets the active instance of VoiceNext client for the DiscordClient.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client to get VoiceNext instance for.&lt;/param&gt;
⋮----
public static VoiceNextExtension? GetVoiceNext(this DiscordClient client)
⋮----
///     Retrieves a &lt;see cref=&quot;VoiceNextExtension&quot; /&gt; instance for each shard.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The shard client to retrieve &lt;see cref=&quot;VoiceNextExtension&quot; /&gt; instances from.&lt;/param&gt;
/// &lt;returns&gt;A dictionary containing &lt;see cref=&quot;VoiceNextExtension&quot; /&gt; instances for each shard.&lt;/returns&gt;
public static async Task&lt;IReadOnlyDictionary&lt;int, VoiceNextExtension?&gt;&gt; GetVoiceNextAsync(this DiscordShardedClient client)
⋮----
var extensions = client.ShardClients.Values.ToDictionary(shard =&gt; shard.ShardId, shard =&gt; shard.GetExtension&lt;VoiceNextExtension&gt;());
⋮----
return extensions.AsReadOnly();
⋮----
///     Connects to this voice channel using VoiceNext.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to connect to.&lt;/param&gt;
/// &lt;returns&gt;If successful, the VoiceNext connection.&lt;/returns&gt;
public static Task&lt;VoiceNextConnection&gt; ConnectAsync(this DiscordChannel channel)
⋮----
ArgumentNullException.ThrowIfNull(channel);
⋮----
throw new InvalidOperationException(&quot;VoiceNext can only be used with guild channels.&quot;);
⋮----
throw new InvalidOperationException(&quot;You can only connect to voice or stage channels.&quot;);
⋮----
throw new NullReferenceException();
⋮----
var vnext = discord.GetVoiceNext() ?? throw new InvalidOperationException(&quot;VoiceNext is not initialized for this Discord client.&quot;);
var vnc = vnext.GetConnection(channel.Guild);
⋮----
? throw new InvalidOperationException(&quot;VoiceNext is already connected in this guild.&quot;)
: vnext.ConnectAsync(channel);</file><file path="DisCatSharp.VoiceNext/GlobalSuppressions.cs">// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.</file><file path="DisCatSharp.VoiceNext/Interop/Bindings.cs">internal static unsafe class Bindings
⋮----
private static extern IntPtr opus_encoder_create(int samplingRate, int channels, int application, out OpusError error);
⋮----
private static extern void opus_encoder_destroy(IntPtr encoder);
⋮----
private static extern int opus_encode(IntPtr encoder, byte* pcm, int frameSize, byte* data, int maxDataBytes);
⋮----
private static extern OpusError opus_encoder_ctl(IntPtr encoder, OpusControl ctl, int value);
⋮----
private static extern IntPtr opus_decoder_create(int sampleRate, int channels, out OpusError error);
⋮----
private static extern void opus_decoder_destroy(IntPtr decoder);
⋮----
private static extern int opus_decode(IntPtr decoder, byte* opusData, int opusDataLength, byte* data, int frameSize, int decodeFec);
⋮----
private static extern int opus_packet_get_nb_channels(byte* data);
⋮----
private static extern int opus_packet_get_nb_frames(byte* data, int length);
⋮----
private static extern int opus_packet_get_samples_per_frame(byte* data, int samplingRate);
⋮----
private static extern int opus_decoder_ctl(IntPtr decoder, OpusControl ctl, out int value);
⋮----
public static IntPtr CreateEncoder(int sampleRate, int channelCount, int application)
⋮----
public static void SetEncoderOption(IntPtr encoder, OpusControl option, int value)
⋮----
public static void Encode(IntPtr encoder, ReadOnlySpan&lt;byte&gt; pcm, int frameSize, ref Span&lt;byte&gt; data)
⋮----
public static IntPtr CreateDecoder(int sampleRate, int channelCount)
⋮----
public static int Decode(IntPtr decoder, ReadOnlySpan&lt;byte&gt; data, int frameSize, Span&lt;byte&gt; pcm, bool useFec)
⋮----
public static int Decode(IntPtr decoder, int frameSize, Span&lt;byte&gt; pcm)
⋮----
public static OpusPacketMetrics GetPacketMetrics(ReadOnlySpan&lt;byte&gt; data, int samplingRate)
⋮----
public static void GetLastPacketDuration(IntPtr decoder, out int sampleCount)</file><file path="DisCatSharp.VoiceNext/Interop/OpusControl.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusError.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusPacketMetrics.cs"></file><file path="DisCatSharp.VoiceNext/Interop/OpusSignal.cs"></file><file path="DisCatSharp.VoiceNext/IVoiceFilter.cs">/// &lt;summary&gt;
///     Represents a filter for PCM data. PCM data submitted through a &lt;see cref=&quot;VoiceTransmitSink&quot; /&gt; will be sent
///     through all installed instances of &lt;see cref=&quot;IVoiceFilter&quot; /&gt; first.
/// &lt;/summary&gt;
public interface IVoiceFilter
⋮----
///     Transforms the supplied PCM data using this filter.
⋮----
/// &lt;param name=&quot;pcmData&quot;&gt;PCM data to transform. The transformation happens in-place.&lt;/param&gt;
/// &lt;param name=&quot;pcmFormat&quot;&gt;Format of the supplied PCM data.&lt;/param&gt;
/// &lt;param name=&quot;duration&quot;&gt;Millisecond duration of the supplied PCM data.&lt;/param&gt;
void Transform(Span&lt;short&gt; pcmData, AudioFormat pcmFormat, int duration);</file><file path="DisCatSharp.VoiceNext/RawVoicePacket.cs">/// &lt;summary&gt;
///     Initializes a new instance of the &lt;see cref=&quot;RawVoicePacket&quot; /&gt; class.
/// &lt;/summary&gt;
/// &lt;param name=&quot;bytes&quot;&gt;The bytes.&lt;/param&gt;
/// &lt;param name=&quot;duration&quot;&gt;The duration.&lt;/param&gt;
/// &lt;param name=&quot;silence&quot;&gt;If true, silence.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;rentedBuffer&quot;&gt;The rented buffer.&lt;/param&gt;</file><file path="DisCatSharp.VoiceNext/StreamExtensions.cs">/// &lt;summary&gt;
///     The stream extensions.
/// &lt;/summary&gt;
public static class StreamExtensions
⋮----
///     Asynchronously reads the bytes from the current stream and writes them to the specified
///     &lt;see cref=&quot;VoiceTransmitSink&quot; /&gt;.
⋮----
/// &lt;param name=&quot;source&quot;&gt;The source &lt;see cref=&quot;Stream&quot; /&gt;&lt;/param&gt;
/// &lt;param name=&quot;destination&quot;&gt;The target &lt;see cref=&quot;VoiceTransmitSink&quot; /&gt;&lt;/param&gt;
/// &lt;param name=&quot;bufferSize&quot;&gt;
///     The size, in bytes, of the buffer. This value must be greater than zero. If
///     &lt;see langword=&quot;null&quot; /&gt;, defaults to the packet size specified by &lt;paramref name=&quot;destination&quot; /&gt;.
/// &lt;/param&gt;
/// &lt;param name=&quot;cancellationToken&quot;&gt;The token to monitor for cancellation requests.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static async Task CopyToAsync(this Stream source, VoiceTransmitSink destination, int? bufferSize = null, CancellationToken cancellationToken = default)
⋮----
// adapted from CoreFX
// https://source.dot.net/#System.Private.CoreLib/Stream.cs,8048a9680abdd13b
⋮----
ArgumentNullException.ThrowIfNull(source);
ArgumentNullException.ThrowIfNull(destination);
⋮----
throw new ArgumentOutOfRangeException(nameof(bufferSize), bufferSize, &quot;bufferSize cannot be less than or equal to zero&quot;);
⋮----
var buffer = ArrayPool&lt;byte&gt;.Shared.Rent(bufferLength);
⋮----
while ((bytesRead = await source.ReadAsync(buffer.AsMemory(0, bufferLength), cancellationToken).ConfigureAwait(false)) is not 0)
await destination.WriteAsync(new(buffer, 0, bytesRead), cancellationToken).ConfigureAwait(false);
⋮----
ArrayPool&lt;byte&gt;.Shared.Return(buffer);</file><file path="DisCatSharp.VoiceNext/VoiceApplication.cs">/// &lt;summary&gt;
///     Represents encoder settings preset for Opus.
/// &lt;/summary&gt;
⋮----
///     Defines that the encoder must optimize settings for voice data.
⋮----
///     Defines that the encoder must optimize settings for music data.
⋮----
///     Defines that the encoder must optimize settings for low latency applications.</file><file path="DisCatSharp.VoiceNext/VoiceNextConfiguration.cs">/// &lt;summary&gt;
///     VoiceNext client configuration.
/// &lt;/summary&gt;
public sealed class VoiceNextConfiguration
⋮----
///     Creates a new instance of &lt;see cref=&quot;VoiceNextConfiguration&quot; /&gt;.
⋮----
///     Creates a new instance of &lt;see cref=&quot;VoiceNextConfiguration&quot; /&gt;, copying the properties of another configuration.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Configuration the properties of which are to be copied.&lt;/param&gt;
⋮----
///     &lt;para&gt;Sets the audio format for Opus. This will determine the quality of the audio output.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see cref=&quot;AudioFormat.Default&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether incoming voice receiver should be enabled.&lt;/para&gt;
///     &lt;para&gt;Defaults to false.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the size of the packet queue.&lt;/para&gt;
///     &lt;para&gt;Defaults to 25 or ~500ms.&lt;/para&gt;</file><file path="DisCatSharp.VoiceNext/VoiceNextConnection.cs">/// &lt;summary&gt;
///     VoiceNext connection to a voice channel.
/// &lt;/summary&gt;
public sealed class VoiceNextConnection : IDisposable
⋮----
///     Gets the configuration.
⋮----
private readonly VoiceNextConfiguration _configuration;
⋮----
///     Gets the discord.
⋮----
private readonly DiscordClient _discord;
⋮----
///     Gets the guild.
⋮----
private readonly DiscordGuild _guild;
⋮----
///     Gets the keepalive timestamps.
⋮----
///     Gets the pause event.
⋮----
private readonly AsyncManualResetEvent _pauseEvent;
⋮----
///     Gets or sets the ready wait.
⋮----
///     Gets the transmit channel.
⋮----
///     Gets the transmitting s s r cs.
⋮----
///     Gets the udp client.
⋮----
private readonly BaseUdpClient _udpClient;
⋮----
///     Gets or sets the discovered endpoint.
⋮----
private IpEndpoint _discoveredEndpoint;
⋮----
///     Gets or sets the heartbeat interval.
⋮----
///     Gets or sets the heartbeat task.
⋮----
private Task _heartbeatTask;
⋮----
///     Gets or sets a value indicating whether is disposed.
⋮----
///     Gets or sets a value indicating whether is initialized.
⋮----
///     Gets or sets the keepalive task.
⋮----
private Task _keepaliveTask;
⋮----
///     Gets or sets the keepalive token source.
⋮----
private CancellationTokenSource _keepaliveTokenSource;
⋮----
///     Gets or sets the key.
⋮----
///     Gets or sets the last heartbeat.
⋮----
private DateTimeOffset _lastHeartbeat;
⋮----
///     Gets the last keepalive.
⋮----
///     Gets or sets the nonce.
⋮----
///     Gets or sets the opus.
⋮----
private Opus _opus;
⋮----
///     Gets or sets the playing wait.
⋮----
///     Gets the queue count.
⋮----
///     Gets or sets the receiver task.
⋮----
private Task _receiverTask;
⋮----
///     Gets or sets the receiver token source.
⋮----
private CancellationTokenSource _receiverTokenSource;
⋮----
///     Gets or sets the rtp.
⋮----
private Rtp _rtp;
⋮----
///     Gets or sets the selected encryption mode.
⋮----
private EncryptionMode _selectedEncryptionMode;
⋮----
///     Gets or sets the sender task.
⋮----
private Task _senderTask;
⋮----
///     Gets or sets the sender token source.
⋮----
private CancellationTokenSource _senderTokenSource;
⋮----
///     Gets or sets the sequence.
⋮----
///     Gets or sets the sodium.
⋮----
private Sodium _sodium;
⋮----
///     Saves the last speaking flag
⋮----
private SpeakingFlags _speakingFlags;
⋮----
///     Gets or sets the s s r c.
⋮----
///     Gets or sets the timestamp.
⋮----
///     Gets or sets the token source.
⋮----
private CancellationTokenSource _tokenSource;
⋮----
///     Gets or sets the transmit stream.
⋮----
///     Gets the ping.
⋮----
///     Gets or sets the voice ws.
⋮----
private IWebSocketClient _voiceWs;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceNextConnection&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
/// &lt;param name=&quot;server&quot;&gt;The server.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
⋮----
//this.Sodium = new Sodium();
⋮----
var epi = eps.LastIndexOf(&apos;:&apos;);
⋮----
epp = int.Parse(eps[(epi + 1)..]);
⋮----
this._transmitChannel = Channel.CreateBounded&lt;RawVoicePacket&gt;(new BoundedChannelOptions(this._configuration.PacketQueueSize));
⋮----
this._udpClient = this._discord.Configuration.UdpClientFactory();
this._voiceWs = this._discord.Configuration.WebSocketClientFactory(this._discord.Configuration.Proxy, this._discord.ServiceProvider);
⋮----
///     Gets the unix epoch.
⋮----
///     Gets the token.
⋮----
///     Gets or sets the server data.
⋮----
///     Gets or sets the state data.
⋮----
///     Gets or sets a value indicating whether resume.
⋮----
///     Gets or sets the web socket endpoint.
⋮----
///     Gets or sets the udp endpoint.
⋮----
///     Gets the sender token.
⋮----
///     Gets the receiver token.
⋮----
///     Gets the keepalive token.
⋮----
///     Gets the audio format used by the Opus encoder.
⋮----
///     Gets whether this connection is still playing audio.
⋮----
///     Gets the websocket round-trip time in ms.
⋮----
=&gt; Volatile.Read(ref this._wsPing);
⋮----
///     Gets the UDP round-trip time in ms.
⋮----
=&gt; Volatile.Read(ref this._udpPing);
⋮----
///     Gets the channel this voice client is connected to.
⋮----
///     Disconnects and disposes this voice connection.
⋮----
public void Dispose()
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
this._discord.Logger.LogError(ex, &quot;{Message}&quot;, ex.Message);
⋮----
this._voiceWs.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
this._udpClient.Close();
⋮----
GC.SuppressFinalize(this);
⋮----
///     Triggered whenever a user speaks in the connected voice channel.
⋮----
add =&gt; this._userSpeaking.Register(value);
remove =&gt; this._userSpeaking.Unregister(value);
⋮----
///     Triggered whenever a user joins voice in the connected guild.
⋮----
add =&gt; this._userJoined.Register(value);
remove =&gt; this._userJoined.Unregister(value);
⋮----
///     Triggered whenever a user leaves voice in the connected guild.
⋮----
add =&gt; this._userLeft.Register(value);
remove =&gt; this._userLeft.Unregister(value);
⋮----
///     Triggered whenever voice data is received from the connected voice channel.
⋮----
add =&gt; this._voiceReceived.Register(value);
remove =&gt; this._voiceReceived.Unregister(value);
⋮----
///     Triggered whenever voice WebSocket throws an exception.
⋮----
add =&gt; this._voiceSocketError.Register(value);
remove =&gt; this._voiceSocketError.Unregister(value);
⋮----
internal event VoiceDisconnectedEventHandler VoiceDisconnected;
⋮----
this.Dispose();
⋮----
///     Connects to the specified voice channel.
⋮----
/// &lt;returns&gt;A task representing the connection operation.&lt;/returns&gt;
internal Task ConnectAsync()
⋮----
var gwuri = new UriBuilder
⋮----
return this._voiceWs.ConnectAsync(gwuri.Uri);
⋮----
///     Reconnects .
⋮----
/// &lt;returns&gt;A Task.&lt;/returns&gt;
internal Task ReconnectAsync()
=&gt; this._voiceWs.DisconnectAsync();
⋮----
///     Starts .
⋮----
internal async Task StartAsync()
⋮----
// Let&apos;s announce our intentions to the server
var vdp = new VoiceDispatch();
⋮----
vdp.Payload = new VoiceIdentifyPayload
⋮----
var vdj = JsonConvert.SerializeObject(vdp, Formatting.None);
await this.WsSendAsync(vdj).ConfigureAwait(false);
⋮----
///     Waits the for ready async.
⋮----
internal Task WaitForReadyAsync()
⋮----
///     Enqueues the packet async.
⋮----
/// &lt;param name=&quot;packet&quot;&gt;The packet.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The token.&lt;/param&gt;
⋮----
internal async Task EnqueuePacketAsync(RawVoicePacket packet, CancellationToken token = default)
⋮----
await this._transmitChannel.Writer.WriteAsync(packet, token).ConfigureAwait(false);
⋮----
///     Prepares the packet.
⋮----
/// &lt;param name=&quot;pcm&quot;&gt;The pcm.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target.&lt;/param&gt;
/// &lt;param name=&quot;length&quot;&gt;The length.&lt;/param&gt;
/// &lt;returns&gt;A bool.&lt;/returns&gt;
internal bool PreparePacket(ReadOnlySpan&lt;byte&gt; pcm, [NotNullWhen(true)] out byte[]? target, out int length)
⋮----
var packetArray = ArrayPool&lt;byte&gt;.Shared.Rent(this._rtp.CalculatePacketSize(audioFormat.SampleCountToSampleSize(audioFormat.CalculateMaximumFrameSize()), this._selectedEncryptionMode));
var packet = packetArray.AsSpan();
⋮----
this._rtp.EncodeHeader(this._sequence, this._timestamp, this._ssrc, packet);
var opus = packet.Slice(Rtp.HEADER_SIZE, pcm.Length);
this._opus.Encode(pcm, ref opus);
⋮----
this._timestamp += (uint)audioFormat.CalculateFrameSize(audioFormat.CalculateSampleDuration(pcm.Length));
⋮----
this._sodium.GenerateNonce(packet[..Rtp.HEADER_SIZE], nonce);
⋮----
this._sodium.GenerateNonce(nonce);
⋮----
this._sodium.GenerateNonce(this._nonce++, nonce);
⋮----
ArrayPool&lt;byte&gt;.Shared.Return(packetArray);
⋮----
Span&lt;byte&gt; encrypted = stackalloc byte[Sodium.CalculateTargetSize(opus)];
this._sodium.Encrypt(opus, encrypted, nonce);
encrypted.CopyTo(packet[Rtp.HEADER_SIZE..]);
packet = packet[..this._rtp.CalculatePacketSize(encrypted.Length, this._selectedEncryptionMode)];
this._sodium.AppendNonce(nonce, packet, this._selectedEncryptionMode);
⋮----
///     Voices the sender task.
⋮----
private async Task VoiceSenderTask()
⋮----
var synchronizerTicks = (double)Stopwatch.GetTimestamp();
⋮----
this._discord.Logger.LogDebug(VoiceNextEvents.Misc, &quot;Timer accuracy: {Frequency}/{SynchronizerResolution} (high resolution? {IsHighResolution})&quot;, Stopwatch.Frequency, synchronizerResolution, Stopwatch.IsHighResolution);
⋮----
await this._pauseEvent.WaitAsync().ConfigureAwait(false);
⋮----
var hasPacket = reader.TryRead(out var rawPacket);
⋮----
// Provided by Laura#0090 (214796473689178133); this is Python, but adaptable:
//
// delay = max(0, self.delay + ((start_time + self.delay * loops) + - time.time()))
⋮----
// self.delay
//   sample size
// start_time
//   time since streaming started
// loops
//   number of samples sent
// time.time()
//   DateTime.Now
⋮----
hasPacket = this.PreparePacket(rawPacket.Bytes.Span, out data, out length);
⋮----
ArrayPool&lt;byte&gt;.Shared.Return(rawPacket.RentedBuffer);
⋮----
var cts = Math.Max(Stopwatch.GetTimestamp() - synchronizerTicks, 0);
⋮----
await Task.Delay(TimeSpan.FromTicks((long)(((synchronizerResolution * durationModifier) - cts) * tickResolution)), CancellationToken.None).ConfigureAwait(false);
⋮----
await this.SendSpeakingAsync(this._speakingFlags is not SpeakingFlags.NotSpeaking ? this._speakingFlags : SpeakingFlags.Microphone).ConfigureAwait(false);
ArgumentNullException.ThrowIfNull(data);
await this._udpClient.SendAsync(data, length).ConfigureAwait(false);
ArrayPool&lt;byte&gt;.Shared.Return(data);
⋮----
var nullpcm = new byte[this.AudioFormat.CalculateSampleSize(20)];
⋮----
var nullpacketmem = nullpacket.AsMemory();
await this.EnqueuePacketAsync(new(nullpacketmem, 20, true), CancellationToken.None).ConfigureAwait(false);
⋮----
await this.SendSpeakingAsync(this._speakingFlags).ConfigureAwait(false);
⋮----
///     Processes the packet.
⋮----
/// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
/// &lt;param name=&quot;opus&quot;&gt;The opus.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;pcmPackets&quot;&gt;The pcm packets.&lt;/param&gt;
/// &lt;param name=&quot;voiceSender&quot;&gt;The voice sender.&lt;/param&gt;
/// &lt;param name=&quot;outputFormat&quot;&gt;The output format.&lt;/param&gt;
⋮----
private bool ProcessPacket(ReadOnlySpan&lt;byte&gt; data, ref Memory&lt;byte&gt; opus, ref Memory&lt;byte&gt; pcm, List&lt;ReadOnlyMemory&lt;byte&gt;&gt; pcmPackets, [NotNullWhen(true)] out AudioSender? voiceSender, out AudioFormat outputFormat)
⋮----
if (!this._rtp.IsRtpHeader(data))
⋮----
this._rtp.DecodeHeader(data, out var shortSequence, out _, out var ssrc, out var hasExtension);
⋮----
if (!this._transmittingSsrCs.TryGetValue(ssrc, out var vtx))
⋮----
var decoder = this._opus.CreateDecoder();
⋮----
// user isn&apos;t present as we haven&apos;t received a speaking event yet.
⋮----
this._transmittingSsrCs.TryAdd(ssrc, vtx);
⋮----
var sequence = vtx.GetTrueSequenceAfterWrapping(shortSequence);
⋮----
if (sequence &lt;= lastTrueSequence) // out-of-order packet; discard
⋮----
this._discord.Logger.LogWarning(VoiceNextEvents.VoiceReceiveFailure, &quot;5 or more voice packets were dropped when receiving&quot;);
⋮----
this._sodium.GetNonce(data, nonce, this._selectedEncryptionMode);
this._rtp.GetDataFromPacket(data, out var encryptedOpus, this._selectedEncryptionMode);
⋮----
var opusSize = Sodium.CalculateSourceSize(encryptedOpus);
⋮----
this._sodium.Decrypt(encryptedOpus, opusSpan, nonce);
⋮----
// Strip extensions, if any
⋮----
// RFC 5285, 4.2 One-Byte header
// http://www.rfcreader.com/#rfc5285_line186
⋮----
// ID is currently unused since we skip it anyway
//var id = (byte)(@byte &gt;&gt; 4);
⋮----
// Strip extension padding too
⋮----
// TODO: consider implementing RFC 5285, 4.3. Two-Byte Header
⋮----
// I&apos;m not 100% sure what this header is/does, however removing the data causes no
// real issues, and has the added benefit of removing a lot of noise.
⋮----
var lastSampleCount = this._opus.GetLastPacketSampleCount(vtx.Decoder);
var fecpcm = new byte[this.AudioFormat.SampleCountToSampleSize(lastSampleCount)];
var fecpcmMem = fecpcm.AsSpan();
this._opus.Decode(vtx.Decoder, opusSpan, ref fecpcmMem, true, out _);
pcmPackets.Add(fecpcm.AsMemory(0, fecpcmMem.Length));
⋮----
this._opus.ProcessPacketLoss(vtx.Decoder, lastSampleCount, ref fecpcmMem);
⋮----
this._opus.Decode(vtx.Decoder, opusSpan, ref pcmSpan, false, out outputFormat);
⋮----
///     Processes the voice packet.
⋮----
private async Task ProcessVoicePacket(byte[] data)
⋮----
if (data.Length &lt; 13) // minimum packet length
⋮----
var pcm = new byte[this.AudioFormat.CalculateMaximumFrameSize()];
var pcmMem = pcm.AsMemory();
⋮----
var opusMem = opus.AsMemory();
⋮----
if (!this.ProcessPacket(data, ref opusMem, ref pcmMem, pcmFillers, out var vtx, out var audioFormat))
⋮----
await this._voiceReceived.InvokeAsync(this, new(this._discord.ServiceProvider)
⋮----
OpusData = Array.Empty&lt;byte&gt;().AsMemory(),
⋮----
AudioDuration = audioFormat.CalculateSampleDuration(pcmFiller.Length)
}).ConfigureAwait(false);
⋮----
AudioDuration = audioFormat.CalculateSampleDuration(pcmMem.Length)
⋮----
this._discord.Logger.LogError(VoiceNextEvents.VoiceReceiveFailure, ex, &quot;Exception occurred when decoding incoming audio data&quot;);
⋮----
///     Processes the keepalive.
⋮----
private void ProcessKeepalive(byte[] data)
⋮----
var keepalive = BinaryPrimitives.ReadUInt64LittleEndian(data);
⋮----
if (!this._keepaliveTimestamps.TryRemove(keepalive, out var timestamp))
⋮----
var tdelta = (int)((Stopwatch.GetTimestamp() - timestamp) / (double)Stopwatch.Frequency * 1000);
this._discord.Logger.LogDebug(VoiceNextEvents.VoiceKeepalive, &quot;Received UDP keepalive {KeepAlive} (ping {TimeDelta}ms)&quot;, keepalive, tdelta);
Volatile.Write(ref this._udpPing, tdelta);
⋮----
this._discord.Logger.LogError(VoiceNextEvents.VoiceKeepalive, ex, &quot;Exception occurred when handling keepalive&quot;);
⋮----
///     Udps the receiver task.
⋮----
private async Task UdpReceiverTask()
⋮----
var data = await this._udpClient.ReceiveAsync().ConfigureAwait(false);
⋮----
this.ProcessKeepalive(data);
⋮----
await this.ProcessVoicePacket(data).ConfigureAwait(false);
⋮----
///     Sends a speaking status to the connected voice channel.
⋮----
/// &lt;param name=&quot;flags&quot;&gt;Set the speaking flags.&lt;/param&gt;
/// &lt;returns&gt;A task representing the sending operation.&lt;/returns&gt;
public async Task SendSpeakingAsync(SpeakingFlags flags = SpeakingFlags.Microphone)
⋮----
throw new InvalidOperationException(&quot;The connection is not initialized&quot;);
⋮----
var pld = new VoiceDispatch
⋮----
Payload = new VoiceSpeakingPayload
⋮----
var plj = JsonConvert.SerializeObject(pld, Formatting.None);
await this.WsSendAsync(plj).ConfigureAwait(false);
⋮----
///     Gets a transmit stream for this connection, optionally specifying a packet size to use with the stream. If a stream
///     is already configured, it will return the existing one.
⋮----
/// &lt;param name=&quot;sampleDuration&quot;&gt;Duration, in ms, to use for audio packets.&lt;/param&gt;
/// &lt;returns&gt;Transmit stream.&lt;/returns&gt;
public VoiceTransmitSink GetTransmitSink(int sampleDuration = 20)
⋮----
if (!AudioFormat.AllowedSampleDurations.Contains(sampleDuration))
throw new ArgumentOutOfRangeException(nameof(sampleDuration), &quot;Invalid PCM sample duration specified.&quot;);
⋮----
///     Asynchronously waits for playback to be finished. Playback is finished when speaking = false is signaled.
⋮----
/// &lt;returns&gt;A task representing the waiting operation.&lt;/returns&gt;
public async Task WaitForPlaybackFinishAsync()
⋮----
await this._playingWait.Task.ConfigureAwait(false);
⋮----
///     Pauses playback.
⋮----
public void Pause()
=&gt; this._pauseEvent.Reset();
⋮----
///     Asynchronously resumes playback.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public async Task ResumeAsync()
=&gt; await this._pauseEvent.SetAsync().ConfigureAwait(false);
⋮----
public void Disconnect()
=&gt; this.Dispose();
⋮----
///     Heartbeats .
⋮----
private async Task HeartbeatAsync()
⋮----
await Task.Yield();
⋮----
token.ThrowIfCancellationRequested();
⋮----
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHeartbeat, &quot;Sent heartbeat&quot;);
⋮----
var hbd = new VoiceDispatch
⋮----
var hbj = JsonConvert.SerializeObject(hbd);
await this.WsSendAsync(hbj).ConfigureAwait(false);
⋮----
await Task.Delay(this._heartbeatInterval, CancellationToken.None).ConfigureAwait(false);
⋮----
///     Keepalives .
⋮----
private async Task KeepaliveAsync()
⋮----
var timestamp = Stopwatch.GetTimestamp();
var keepalive = Volatile.Read(ref this._lastKeepalive);
Volatile.Write(ref this._lastKeepalive, keepalive + 1);
this._keepaliveTimestamps.TryAdd(keepalive, timestamp);
⋮----
BinaryPrimitives.WriteUInt64LittleEndian(packet, keepalive);
⋮----
await this._udpClient.SendAsync(packet, packet.Length).ConfigureAwait(false);
⋮----
await Task.Delay(5000, token).ConfigureAwait(false);
⋮----
///     Stage1S .
⋮----
/// &lt;param name=&quot;voiceReady&quot;&gt;The voice ready.&lt;/param&gt;
⋮----
private async Task Stage1(VoiceReadyPayload voiceReady)
⋮----
// IP Discovery
this._udpClient.Setup(this.UdpEndpoint);
⋮----
await this._udpClient.SendAsync(pck, pck.Length).ConfigureAwait(false);
⋮----
var ipd = await this._udpClient.ReceiveAsync().ConfigureAwait(false);
⋮----
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Endpoint discovery finished - discovered endpoint is {IP}:{Port}&quot;, ip, port);
⋮----
// Select voice encryption mode
var selectedEncryptionMode = Sodium.SelectMode(voiceReady.Modes);
⋮----
// Ready
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Selected encryption mode is {EncryptionMode}&quot;, selectedEncryptionMode.Key);
var vsp = new VoiceDispatch
⋮----
Payload = new VoiceSelectProtocolPayload
⋮----
Address = this._discoveredEndpoint.Address.ToString(),
⋮----
var vsj = JsonConvert.SerializeObject(vsp, Formatting.None);
await this.WsSendAsync(vsj).ConfigureAwait(false);
⋮----
this._senderTask = Task.Run(this.VoiceSenderTask, this.SENDER_TOKEN);
⋮----
this._receiverTask = Task.Run(this.UdpReceiverTask, this.RECEIVER_TOKEN);
⋮----
var packetSpan = packet.AsSpan();
⋮----
var ipString = Utilities.UTF8.GetString(packet, 8, 64 /* 74 - 10 */).TrimEnd(&apos;\0&apos;);
decodedIp = IPAddress.Parse(ipString);
⋮----
decodedPort = BinaryPrimitives.ReadUInt16BigEndian(packetSpan[72..] /* 74 - 2 */);
⋮----
BinaryPrimitives.WriteUInt16BigEndian(packetSpan[..2], type);
BinaryPrimitives.WriteUInt16BigEndian(packetSpan.Slice(2, 2), length);
BinaryPrimitives.WriteUInt32BigEndian(packetSpan.Slice(4, 4), ssrc);
packetSpan[8..].Clear();
⋮----
///     Stage2S .
⋮----
/// &lt;param name=&quot;voiceSessionDescription&quot;&gt;The voice session description.&lt;/param&gt;
⋮----
private async Task Stage2(VoiceSessionDescriptionPayload voiceSessionDescription)
⋮----
this._selectedEncryptionMode = Sodium.SupportedModes[voiceSessionDescription.Mode.ToLowerInvariant()];
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceHandshake, &quot;Discord updated encryption mode - new mode is {EncryptionMode}&quot;, this._selectedEncryptionMode);
⋮----
// start keepalive
⋮----
this._keepaliveTask = this.KeepaliveAsync();
⋮----
// send 3 packets of silence to get things going
⋮----
var nullpacketmem = nullPcm.AsMemory();
⋮----
this._readyWait.SetResult(true);
⋮----
///     Handles the dispatch.
⋮----
/// &lt;param name=&quot;jo&quot;&gt;The jo.&lt;/param&gt;
⋮----
private async Task HandleDispatch(JObject jo)
⋮----
ArgumentNullException.ThrowIfNull(opc);
⋮----
case 2: // READY
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received READY (OP2)&quot;);
ArgumentNullException.ThrowIfNull(opp);
⋮----
// this is not the valid interval
// oh, discord
//this.HeartbeatInterval = vrp.HeartbeatInterval;
this._heartbeatTask = Task.Run(this.HeartbeatAsync, CancellationToken.None);
await this.Stage1(vrp).ConfigureAwait(false);
⋮----
case 4: // SESSION_DESCRIPTION
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received SESSION_DESCRIPTION (OP4)&quot;);
⋮----
this._sodium = new(this._key.AsMemory());
await this.Stage2(vsd).ConfigureAwait(false);
⋮----
case 5: // SPEAKING
// Don&apos;t spam OP5
// No longer spam, Discord supposedly doesn&apos;t send many of these
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received SPEAKING (OP5)&quot;);
⋮----
ArgumentNullException.ThrowIfNull(spd.Ssrc);
⋮----
var foundUserInCache = spd.UserId.HasValue &amp;&amp; this._discord.TryGetCachedUserInternal(spd.UserId.Value, out resolvedUser);
var spk = new UserSpeakingEventArgs(this._discord.ServiceProvider)
⋮----
if (foundUserInCache &amp;&amp; this._transmittingSsrCs.TryGetValue(spk.Ssrc, out var txssrc5) &amp;&amp; txssrc5.Id is 0)
⋮----
var opus = this._opus.CreateDecoder();
var vtx = new AudioSender(spk.Ssrc, opus)
⋮----
User = spd.UserId.HasValue ? await this._discord.GetUserAsync(spd.UserId.Value, true).ConfigureAwait(false) : null
⋮----
if (!this._transmittingSsrCs.TryAdd(spk.Ssrc, vtx))
this._opus.DestroyDecoder(opus);
⋮----
await this._userSpeaking.InvokeAsync(this, spk).ConfigureAwait(false);
⋮----
case 6: // HEARTBEAT ACK
⋮----
Volatile.Write(ref this._wsPing, ping);
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received HEARTBEAT_ACK (OP6, {Ping}ms)&quot;, ping);
⋮----
case 8: // HELLO
// this sends a heartbeat interval that we need to use for
// ArgumentNullException.ThrowIfNull(opp);
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received HELLO (OP8)&quot;);
⋮----
case 9: // RESUMED
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received RESUMED (OP9)&quot;);
⋮----
case 12: // CLIENT_CONNECTED
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received CLIENT_CONNECTED (OP12)&quot;);
⋮----
var usrj = await this._discord.GetUserAsync(ujpd.UserId, true).ConfigureAwait(false);
⋮----
var vtx = new AudioSender(ujpd.Ssrc, opus)
⋮----
if (!this._transmittingSsrCs.TryAdd(vtx.Ssrc, vtx))
⋮----
await this._userJoined.InvokeAsync(this, new(this._discord.ServiceProvider)
⋮----
case 13: // CLIENT_DISCONNECTED
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received CLIENT_DISCONNECTED (OP13)&quot;);
⋮----
var txssrc = this._transmittingSsrCs.FirstOrDefault(x =&gt; x.Value.Id == ulpd.UserId);
if (this._transmittingSsrCs.ContainsKey(txssrc.Key))
⋮----
this._transmittingSsrCs.TryRemove(txssrc.Key, out var txssrc13);
this._opus.DestroyDecoder(txssrc13?.Decoder);
⋮----
var usrl = await this._discord.GetUserAsync(ulpd.UserId, true).ConfigureAwait(false);
await this._userLeft.InvokeAsync(this, new(this._discord.ServiceProvider)
⋮----
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceDispatch, &quot;Received unknown voice opcode (OP{OpCode})&quot;, opc);
⋮----
///     Voices the w s_ socket closed.
⋮----
/// &lt;param name=&quot;e&quot;&gt;The e.&lt;/param&gt;
⋮----
private async Task VoiceWS_SocketClosed(IWebSocketClient client, SocketCloseEventArgs e)
⋮----
this._discord.Logger.LogDebug(VoiceNextEvents.VoiceConnectionClose, &quot;Voice WebSocket closed ({Code}, &apos;{Message}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
⋮----
// generally this should not be disposed on all disconnects, only on requested ones
// or something
// otherwise problems happen
//this.Dispose();
⋮----
this._tokenSource.Cancel();
⋮----
await this.ConnectAsync().ConfigureAwait(false);
⋮----
///     Voices the w s_ socket message.
⋮----
private Task VoiceWS_SocketMessage(IWebSocketClient client, SocketMessageEventArgs e)
⋮----
this._discord.Logger.LogCritical(VoiceNextEvents.VoiceGatewayError, &quot;Discord Voice Gateway sent binary data - unable to process&quot;);
⋮----
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceWsRx, &quot;{Message}&quot;, et.Message);
return this.HandleDispatch(JObject.Parse(et.Message));
⋮----
///     Voices the w s_ socket opened.
⋮----
private Task VoiceWS_SocketOpened(IWebSocketClient client, SocketEventArgs e)
=&gt; this.StartAsync();
⋮----
///     Voices the ws_ socket exception.
⋮----
private Task VoiceWs_SocketException(IWebSocketClient client, SocketErrorEventArgs e)
=&gt; this._voiceSocketError.InvokeAsync(this, new(this._discord.ServiceProvider)
⋮----
///     Ws the send async.
⋮----
/// &lt;param name=&quot;payload&quot;&gt;The payload.&lt;/param&gt;
⋮----
private async Task WsSendAsync(string payload)
⋮----
this._discord.Logger.LogTrace(VoiceNextEvents.VoiceWsTx, payload);
await this._voiceWs.SendMessageAsync(payload).ConfigureAwait(false);
⋮----
///     Gets the unix timestamp.
⋮----
/// &lt;param name=&quot;dt&quot;&gt;The datetime.&lt;/param&gt;
private static uint UnixTimestamp(DateTime dt)</file><file path="DisCatSharp.VoiceNext/VoiceNextEvents.cs">/// &lt;summary&gt;
///     Contains well-defined event IDs used by the VoiceNext extension.
/// &lt;/summary&gt;
public static class VoiceNextEvents
⋮----
///     Miscellaneous events, that do not fit in any other category.
⋮----
///     Events pertaining to Voice Gateway connection lifespan, specifically, heartbeats.
⋮----
///     Events pertaining to Voice Gateway connection early lifespan, specifically, the establishing thereof as well as
///     negotiating various modes.
⋮----
///     Events emitted when incoming voice data is corrupted, or packets are being dropped.
⋮----
///     Events pertaining to UDP connection lifespan, specifically the keepalive (or heartbeats).
⋮----
///     Events emitted for high-level dispatch receive events.
⋮----
///     Events emitted for Voice Gateway connection closes, clean or otherwise.
⋮----
///     Events emitted when decoding data received via Voice Gateway fails for any reason.
⋮----
///     Events containing raw (but decompressed) payloads, received from Discord Voice Gateway.
⋮----
///     Events containing raw payloads, as they&apos;re being sent to Discord Voice Gateway.</file><file path="DisCatSharp.VoiceNext/VoiceNextExtension.cs">/// &lt;summary&gt;
///     Represents VoiceNext extension, which acts as Discord voice client.
/// &lt;/summary&gt;
public sealed class VoiceNextExtension : BaseExtension
⋮----
///     Gets or sets the active connections.
⋮----
///     Gets or sets the configuration.
⋮----
private readonly VoiceNextConfiguration _configuration;
⋮----
///     Gets or sets the voice server updates.
⋮----
///     Gets or sets the voice state updates.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceNextExtension&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
⋮----
///     Gets whether this connection has incoming voice enabled.
⋮----
///     DO NOT USE THIS MANUALLY.
⋮----
/// &lt;param name=&quot;client&quot;&gt;DO NOT USE THIS MANUALLY.&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot; /&gt;
protected internal override void Setup(DiscordClient client)
⋮----
throw new InvalidOperationException(&quot;What did I tell you?&quot;);
⋮----
///     Create a VoiceNext connection for the specified channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to connect to.&lt;/param&gt;
/// &lt;returns&gt;VoiceNext connection for this channel.&lt;/returns&gt;
public async Task&lt;VoiceNextConnection&gt; ConnectAsync(DiscordChannel channel)
⋮----
throw new ArgumentException(&quot;Invalid channel specified; needs to be voice or stage channel&quot;, nameof(channel));
⋮----
throw new ArgumentException(&quot;Invalid channel specified; needs to be guild channel&quot;, nameof(channel));
⋮----
if (!channel.PermissionsFor(channel.Guild.CurrentMember).HasPermission(Permissions.AccessChannels | Permissions.UseVoice))
throw new InvalidOperationException(&quot;You need AccessChannels and UseVoice permission to connect to this voice channel&quot;);
⋮----
if (this._activeConnections.ContainsKey(gld.Id))
throw new InvalidOperationException(&quot;This guild already has a voice connection&quot;);
⋮----
var vsd = new VoiceDispatch
⋮----
Payload = new VoiceStateUpdatePayload
⋮----
var vsj = JsonConvert.SerializeObject(vsd, Formatting.None);
await (channel.Discord as DiscordClient).WsSendAsync(vsj).ConfigureAwait(false);
⋮----
var vstu = await vstut.Task.ConfigureAwait(false);
var vstup = new VoiceStateUpdatePayload
⋮----
var vsru = await vsrut.Task.ConfigureAwait(false);
var vsrup = new VoiceServerUpdatePayload
⋮----
var vnc = new VoiceNextConnection(this.Client, gld, channel, this._configuration, vsrup, vstup);
⋮----
await vnc.ConnectAsync().ConfigureAwait(false);
await vnc.WaitForReadyAsync().ConfigureAwait(false);
⋮----
///     Gets a VoiceNext connection for specified guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;Guild to get VoiceNext connection for.&lt;/param&gt;
/// &lt;returns&gt;VoiceNext connection for the specified guild.&lt;/returns&gt;
public VoiceNextConnection GetConnection(DiscordGuild guild) =&gt; this._activeConnections.TryGetValue(guild.Id, out var value) ? value : null;
⋮----
///     Vnc_S the voice disconnected.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
private async Task Vnc_VoiceDisconnected(DiscordGuild guild)
⋮----
if (this._activeConnections.ContainsKey(guild.Id))
this._activeConnections.TryRemove(guild.Id, out _);
⋮----
await (guild.Discord as DiscordClient).WsSendAsync(vsj).ConfigureAwait(false);
⋮----
///     Client_S the voice state update.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The e.&lt;/param&gt;
⋮----
private Task Client_VoiceStateUpdate(DiscordClient client, VoiceStateUpdateEventArgs e)
⋮----
if (e.After.Channel is null &amp;&amp; this._activeConnections.TryRemove(gld.Id, out var ac))
ac.Disconnect();
⋮----
if (this._activeConnections.TryGetValue(e.Guild.Id, out var vnc))
⋮----
if (!string.IsNullOrWhiteSpace(e.SessionId) &amp;&amp; e.Channel is not null &amp;&amp; this._voiceStateUpdates.TryRemove(gld.Id, out var xe))
xe.SetResult(e);
⋮----
///     Client_S the voice server update.
⋮----
private async Task Client_VoiceServerUpdate(DiscordClient client, VoiceServerUpdateEventArgs e)
⋮----
var epi = eps.LastIndexOf(&apos;:&apos;);
⋮----
epp = int.Parse(eps[(epi + 1)..]);
⋮----
await vnc.ReconnectAsync().ConfigureAwait(false);
⋮----
if (this._voiceServerUpdates.ContainsKey(gld.Id))
⋮----
this._voiceServerUpdates.TryRemove(gld.Id, out var xe);</file><file path="DisCatSharp.VoiceNext/VoiceTransmitSink.cs">/// &lt;summary&gt;
///     Sink used to transmit audio data via &lt;see cref=&quot;VoiceNextConnection&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class VoiceTransmitSink : IDisposable
⋮----
///     Gets the connection.
⋮----
private readonly VoiceNextConnection _connection;
⋮----
///     Gets the filters.
⋮----
///     Gets the pcm buffer.
⋮----
///     Gets the pcm memory.
⋮----
///     Gets the write semaphore.
⋮----
private readonly SemaphoreSlim _writeSemaphore;
⋮----
///     Gets or sets the pcm buffer length.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceTransmitSink&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;vnc&quot;&gt;The vnc.&lt;/param&gt;
/// &lt;param name=&quot;pcmBufferDuration&quot;&gt;The pcm buffer duration.&lt;/param&gt;
⋮----
this._pcmBuffer = new byte[vnc.AudioFormat.CalculateSampleSize(pcmBufferDuration)];
this._pcmMemory = this._pcmBuffer.AsMemory();
⋮----
///     Gets the PCM sample duration for this sink.
⋮----
///     Gets the length of the PCM buffer for this sink.
///     Written packets should adhere to this size, but the sink will adapt to fit.
⋮----
///     Gets or sets the volume modifier for this sink. Changing this will alter the volume of the output. 1.0 is 100%.
⋮----
throw new ArgumentOutOfRangeException(nameof(value), &quot;Volume needs to be between 0% and 250%.&quot;);
⋮----
///     Disposes .
⋮----
public void Dispose()
⋮----
///     Writes PCM data to the sink. The data is prepared for transmission, and enqueued.
⋮----
/// &lt;param name=&quot;buffer&quot;&gt;PCM data buffer to send.&lt;/param&gt;
/// &lt;param name=&quot;offset&quot;&gt;Start of the data in the buffer.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;Number of bytes from the buffer.&lt;/param&gt;
/// &lt;param name=&quot;cancellationToken&quot;&gt;The token to monitor for cancellation requests.&lt;/param&gt;
public async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default)
=&gt; await this.WriteAsync(new(buffer, offset, count), cancellationToken).ConfigureAwait(false);
⋮----
public async Task WriteAsync(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken = default)
⋮----
await this._writeSemaphore.WaitAsync(cancellationToken).ConfigureAwait(false);
⋮----
var len = Math.Min(pcmSpan.Length - this._pcmBufferLength, remaining);
⋮----
src.CopyTo(tgt);
⋮----
this.ApplyFiltersSync(pcmSpan);
⋮----
var packet = ArrayPool&lt;byte&gt;.Shared.Rent(this._pcmMemory.Length);
var packetMemory = packet.AsMemory()[..this._pcmMemory.Length];
this._pcmMemory.CopyTo(packetMemory);
⋮----
await this._connection.EnqueuePacketAsync(new(packetMemory, this.SampleDuration, false, packet), cancellationToken).ConfigureAwait(false);
⋮----
this._writeSemaphore.Release();
⋮----
///     Flushes the rest of the PCM data in this buffer to VoiceNext packet queue.
⋮----
public async Task FlushAsync(CancellationToken cancellationToken = default)
⋮----
Helpers.ZeroFill(pcm[this._pcmBufferLength..].Span);
⋮----
this.ApplyFiltersSync(pcm);
⋮----
var packet = ArrayPool&lt;byte&gt;.Shared.Rent(pcm.Length);
var packetMemory = packet.AsMemory()[..pcm.Length];
pcm.CopyTo(packetMemory);
⋮----
///     Pauses playback.
⋮----
public void Pause()
=&gt; this._connection.Pause();
⋮----
///     Resumes playback.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public async Task ResumeAsync()
=&gt; await this._connection.ResumeAsync().ConfigureAwait(false);
⋮----
///     Gets the collection of installed PCM filters, in order of their execution.
⋮----
/// &lt;returns&gt;Installed PCM filters, in order of execution.&lt;/returns&gt;
public IEnumerable&lt;IVoiceFilter&gt; GetInstalledFilters()
⋮----
///     Installs a new PCM filter, with specified execution order.
⋮----
/// &lt;param name=&quot;filter&quot;&gt;Filter to install.&lt;/param&gt;
/// &lt;param name=&quot;order&quot;&gt;Order of the new filter. This determines where the filter will be inserted in the filter pipeline.&lt;/param&gt;
public void InstallFilter(IVoiceFilter filter, int order = int.MaxValue)
⋮----
ArgumentNullException.ThrowIfNull(filter);
⋮----
throw new ArgumentOutOfRangeException(nameof(order), &quot;Filter order must be greater than or equal to 0.&quot;);
⋮----
this._filters.Add(filter);
⋮----
this._filters.Insert(order, filter);
⋮----
///     Uninstalls an installed PCM filter.
⋮----
/// &lt;param name=&quot;filter&quot;&gt;Filter to uninstall.&lt;/param&gt;
/// &lt;returns&gt;Whether the filter was uninstalled.&lt;/returns&gt;
public bool UninstallFilter(IVoiceFilter filter)
⋮----
return this._filters.Contains(filter) &amp;&amp; this._filters.Remove(filter);
⋮----
///     Applies the filters sync.
⋮----
/// &lt;param name=&quot;pcmSpan&quot;&gt;The pcm span.&lt;/param&gt;
private void ApplyFiltersSync(Memory&lt;byte&gt; pcmSpan)
⋮----
// pass through any filters, if applicable
⋮----
filter.Transform(pcm16, this._connection.AudioFormat, this.SampleDuration);
⋮----
// alter volume</file><file path="DisCatSharp/BaseExtension.cs">/// &lt;summary&gt;
///     Represents base for all DisCatSharp extensions. To implement your own extension, extend this class, and implement
///     its abstract members.
/// &lt;/summary&gt;
public abstract class BaseExtension
⋮----
///     Gets the instance of &lt;see cref=&quot;DiscordClient&quot; /&gt; this extension is attached to.
⋮----
///     Gets the string representing the version of bot lib extension.
⋮----
///     Gets whether this lib extension supports the built-in version checl.
⋮----
///     Gets the repository owner of this lib extension.
⋮----
///     Gets the repository of this lib extension.
⋮----
///     Gets the package id of this lib extension.
⋮----
///     Initializes this extension for given &lt;see cref=&quot;DiscordClient&quot; /&gt; instance.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client to initialize for.&lt;/param&gt;
protected internal abstract void Setup(DiscordClient client);</file><file path="DisCatSharp/Clients/BaseDiscordClient.cs">/// &lt;summary&gt;
///     Represents a common base for various Discord Client implementations.
/// &lt;/summary&gt;
public abstract class BaseDiscordClient : IDisposable
⋮----
///     Gets the lazy voice regions.
⋮----
///     Initializes this Discord API client.
⋮----
/// &lt;param name=&quot;config&quot;&gt;Configuration for this client.&lt;/param&gt;
⋮----
this.Configuration.LoggerFactory = new DefaultLoggerFactory();
this.Configuration.LoggerFactory.AddProvider(new DefaultLoggerProvider(this));
⋮----
#pragma warning disable CS0618 // Type or member is obsolete
⋮----
#pragma warning restore CS0618 // Type or member is obsolete
⋮----
/*
				var configureFormatterOptions = new ConfigureNamedOptions&lt;ConsoleFormatterOptions&gt;(string.Empty, x =&gt; { x.TimestampFormat = this.Configuration.LogTimestampFormat; });
				var formatterFactory = new OptionsFactory&lt;ConsoleFormatterOptions&gt;(new[] { configureFormatterOptions }, Enumerable.Empty&lt;IPostConfigureOptions&lt;ConsoleFormatterOptions&gt;&gt;());
				var formatterMonitor = new OptionsMonitor&lt;ConsoleFormatterOptions&gt;(formatterFactory, Enumerable.Empty&lt;IOptionsChangeTokenSource&lt;ConsoleFormatterOptions&gt;&gt;(), new OptionsCache&lt;ConsoleFormatterOptions&gt;());
				*/
⋮----
var l = new ConsoleLoggerProvider(optionsMonitor);
this.Configuration.LoggerFactory = new LoggerFactory();
this.Configuration.LoggerFactory.AddProvider(l);
⋮----
var ass = typeof(DiscordClient).GetTypeInfo().Assembly;
⋮----
var v = ass.GetName().Version;
⋮----
this.Configuration.LoggerFactory.AddSentry(o =&gt;
⋮----
o.AddInAppInclude(&quot;DisCatSharp&quot;);
⋮----
o.AddExceptionFilter(new DisCatSharpExceptionFilter(this.Configuration));
⋮----
o.SetBeforeSend((e, _) =&gt;
⋮----
if (!this.Configuration.TrackExceptions.Contains(e.Exception.GetType()))
⋮----
else if (e.Extra.Count == 0 || !e.Extra.ContainsKey(&quot;Found Fields&quot;))
⋮----
if (e.HasUser())
⋮----
Id = this.CurrentUser.Id.ToString(),
⋮----
SentryOptions options = new()
⋮----
options.SetBeforeBreadcrumb(b
=&gt; new(Utilities.StripTokensAndOptIds(b.Message, this.Configuration.EnableDiscordIdScrubber)!,
⋮----
b.Data?.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Utilities.StripTokensAndOptIds(x.Value, this.Configuration.EnableDiscordIdScrubber)!))
.ToDictionary(x =&gt; x.Key, x =&gt; x.Value),
⋮----
options.SetBeforeSendTransaction(tr =&gt;
⋮----
tr.Request.Data = Utilities.StripTokensAndOptIds(str, this.Configuration.EnableDiscordIdScrubber);
⋮----
options.SetBeforeSend((e, _) =&gt;
⋮----
if (!e.HasUser())
⋮----
if (!e.Extra.ContainsKey(&quot;Found Fields&quot;))
e.SetFingerprint(GenerateSentryFingerPrint(e));
⋮----
var httphandler = new HttpClientHandler
⋮----
this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, this.Configuration.Locale);
if (!string.IsNullOrWhiteSpace(this.Configuration.Timezone))
this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, this.Configuration.Timezone);
⋮----
this.RestClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, this.Configuration.Override);
⋮----
var a = typeof(DiscordClient).GetTypeInfo().Assembly;
⋮----
var v = a.GetName().Version;
var vs = v.ToString(3);
⋮----
///     Gets the api client.
⋮----
///     Gets the sentry client.
⋮----
///     Gets the current api channel.
⋮----
///     Gets the current api version.
⋮----
///     Gets the sentry dsn.
⋮----
///     Gets the configuration.
⋮----
///     Gets the instance of the logger for this client.
⋮----
///     Gets the string representing the version of bot lib.
⋮----
///     Gets the bot library name.
⋮----
///     Gets the current user.
⋮----
///     Gets the current application.
⋮----
///     Exposes a &lt;see cref=&quot;HttpClient&quot;&gt;Http Client&lt;/see&gt; for custom operations.
⋮----
///     Gets the cached guilds for this client.
⋮----
///     Gets the statistics for this client.
⋮----
[DisCatSharpStatisticType.Users] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.MemberCount ?? 0)),
[DisCatSharpStatisticType.Channels] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Channels.Count)),
[DisCatSharpStatisticType.Threads] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Threads.Count)),
[DisCatSharpStatisticType.Roles] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Roles.Count)),
[DisCatSharpStatisticType.Emojis] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Emojis.Count)),
[DisCatSharpStatisticType.Stickers] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.Stickers.Count)),
[DisCatSharpStatisticType.SoundboardSounds] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.SoundboardSounds.Count)),
[DisCatSharpStatisticType.StageInstances] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.StageInstances.Count)),
[DisCatSharpStatisticType.ScheduledEvents] = this.Guilds.Values.Sum((Func&lt;DiscordGuild, int&gt;)(guild =&gt; guild.ScheduledEvents.Count))
⋮----
///     Gets the guilds ids for this shard.
⋮----
///     Gets the cached users for this client.
⋮----
///     &lt;para&gt;Gets the service provider.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to null.&lt;/para&gt;
⋮----
///     Gets the list of available voice regions. Note that this property will not contain VIP voice regions.
⋮----
///     Gets the list of available voice regions. This property is meant as a way to modify &lt;see cref=&quot;VoiceRegions&quot; /&gt;.
⋮----
///     Gets the cached application emojis for this client.
⋮----
///     Disposes this client.
⋮----
public abstract void Dispose();
⋮----
///     Gets the current API application.
⋮----
public async Task&lt;DiscordApplication&gt; GetCurrentApplicationAsync()
⋮----
var tapp = await this.ApiClient.GetCurrentApplicationOauth2InfoAsync().ConfigureAwait(false);
⋮----
///     Updates the current API application.
⋮----
/// &lt;param name=&quot;description&quot;&gt;The new description.&lt;/param&gt;
/// &lt;param name=&quot;interactionsEndpointUrl&quot;&gt;The new interactions endpoint url.&lt;/param&gt;
/// &lt;param name=&quot;roleConnectionsVerificationUrl&quot;&gt;The new role connections verification url.&lt;/param&gt;
/// &lt;param name=&quot;customInstallUrl&quot;&gt;The new custom install url.&lt;/param&gt;
/// &lt;param name=&quot;tags&quot;&gt;The new tags.&lt;/param&gt;
/// &lt;param name=&quot;icon&quot;&gt;The new application icon.&lt;/param&gt;
/// &lt;param name=&quot;coverImage&quot;&gt;The new application cover image.&lt;/param&gt;
/// &lt;param name=&quot;flags&quot;&gt;The new application flags. Can be only limited gateway intents.&lt;/param&gt;
/// &lt;param name=&quot;installParams&quot;&gt;The new install params.&lt;/param&gt;
/// &lt;returns&gt;The updated application.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordApplication&gt; UpdateCurrentApplicationInfoAsync(
⋮----
var iconb64 = MediaTool.Base64FromStream(icon);
var coverImageb64 = MediaTool.Base64FromStream(coverImage);
⋮----
if (tags.Value.Any(x =&gt; x.Length &gt; 20))
throw new InvalidOperationException(&quot;Tags can not exceed 20 chars.&quot;);
⋮----
DiscordApplication app = new(await this.ApiClient.ModifyCurrentApplicationInfoAsync(description, interactionsEndpointUrl, roleConnectionsVerificationUrl, customInstallUrl, tags, iconb64, coverImageb64, flags, installParams, Optional.None).ConfigureAwait(false));
⋮----
///     Enables user app functionality.
⋮----
public async Task&lt;DiscordApplication&gt; EnableUserAppsAsync()
⋮----
var currentApplication = await this.GetCurrentApplicationAsync().ConfigureAwait(false);
⋮----
DiscordIntegrationTypesConfig integrationTypesConfig = new()
⋮----
var app = await this.UpdateCurrentApplicationInfoAsync(Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, integrationTypesConfig).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;integrationTypesConfig&quot;&gt;The new integration types configuration.&lt;/param&gt;
⋮----
DiscordApplication app = new(await this.ApiClient.ModifyCurrentApplicationInfoAsync(description, interactionsEndpointUrl, roleConnectionsVerificationUrl, customInstallUrl, tags, iconb64, coverImageb64, flags, Optional.None, integrationTypesConfig).ConfigureAwait(false));
⋮----
///     Gets a list of voice regions.
⋮----
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
=&gt; this.ApiClient.ListVoiceRegionsAsync();
⋮----
///     Initializes this client. This method fetches information about current user, application, and voice regions.
⋮----
public virtual async Task InitializeAsync()
⋮----
this.CurrentUser = await this.ApiClient.GetCurrentUserAsync().ConfigureAwait(false);
this.UserCache.AddOrUpdate(this.CurrentUser.Id, this.CurrentUser, (id, xu) =&gt; this.CurrentUser);
⋮----
this.CurrentApplication = await this.GetCurrentApplicationAsync().ConfigureAwait(false);
⋮----
var vrs = await this.ListVoiceRegionsAsync().ConfigureAwait(false);
⋮----
this.InternalVoiceRegions.TryAdd(xvr.Id, xvr);
⋮----
SentrySdk.ConfigureScope(x =&gt; x.User = new()
⋮----
///     Gets the current gateway info for the provided token.
///     &lt;para&gt;If no value is provided, the configuration value will be used instead.&lt;/para&gt;
⋮----
/// &lt;returns&gt;A gateway info object.&lt;/returns&gt;
public async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync(string? token = null)
⋮----
throw new InvalidOperationException(&quot;Only bot tokens can access this info.&quot;);
⋮----
if (!string.IsNullOrEmpty(this.Configuration.Token))
return await this.ApiClient.GetGatewayInfoAsync().ConfigureAwait(false);
⋮----
if (string.IsNullOrEmpty(token))
throw new InvalidOperationException(&quot;Could not locate a valid token.&quot;);
⋮----
var res = await this.ApiClient.GetGatewayInfoAsync().ConfigureAwait(false);
⋮----
///     Gets a cached user.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user id.&lt;/param&gt;
internal DiscordUser GetCachedOrEmptyUserInternal(ulong userId)
⋮----
if (!this.TryGetCachedUserInternal(userId, out var user))
⋮----
///     Tries the get a cached user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
internal bool TryGetCachedUserInternal(ulong userId, [MaybeNullWhen(false)] out DiscordUser user)
=&gt; this.UserCache.TryGetValue(userId, out user);
⋮----
///     Updates the cached application emojis.
⋮----
/// &lt;param name=&quot;rawEmojis&quot;&gt;The raw emojis.&lt;/param&gt;
internal abstract IReadOnlyDictionary&lt;ulong, DiscordApplicationEmoji&gt; UpdateCachedApplicationEmojis(JArray? rawEmojis);
⋮----
///     Updates a cached application emoji.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
internal abstract DiscordApplicationEmoji UpdateCachedApplicationEmoji(DiscordApplicationEmoji emoji);
⋮----
///     Generates a fingerprint for sentry.
⋮----
/// &lt;param name=&quot;ev&quot;&gt;The sentry event.&lt;/param&gt;
/// &lt;param name=&quot;additional&quot;&gt;The optional additional fingerprint value, if any.&lt;/param&gt;
internal static IEnumerable&lt;string&gt; GenerateSentryFingerPrint(SentryEvent ev, string? additional = null)
⋮----
ev.Level.ToString(),
⋮----
fingerPrint.Add(ev.Message.Message);
⋮----
fingerPrint.Add(additional);
⋮----
fingerPrint.Add(ex.GetType().FullName);
if (!string.IsNullOrEmpty(ex.Message))
fingerPrint.Add(ex.Message);
⋮----
fingerPrint.Add(ex.TargetSite.ToString());
⋮----
fingerPrint.Add(ex.InnerException.GetType().FullName);
if (!string.IsNullOrEmpty(ex.InnerException.Message))
fingerPrint.Add(ex.InnerException.Message);</file><file path="DisCatSharp/Clients/DiscordClient.EventHandlers.cs">/// &lt;summary&gt;
///     A Discord API wrapper.
/// &lt;/summary&gt;
public sealed partial class DiscordClient
⋮----
///     Stores the registered event handlers.
⋮----
///     Maps a tuple of handler, type, and a boolean indicating whether static methods were registered to a list of event
///     info and delegate arrays.
⋮----
///     Maps a type to a list of anonymous handler objects.
⋮----
///     Gets all the registered event handlers.
⋮----
public IReadOnlyDictionary&lt;Type, object&gt; RegisteredEventhandlers =&gt; this._registeredEventhandlers.AsReadOnly();
⋮----
///     Registers all methods annotated with &lt;see cref=&quot;EventAttribute&quot; /&gt; from the given object.
⋮----
/// &lt;param name=&quot;handler&quot;&gt;The event handler object.&lt;/param&gt;
/// &lt;param name=&quot;registerStatic&quot;&gt;Whether to consider static methods.&lt;/param&gt;
public void RegisterEventHandler(object handler, bool registerStatic = false)
=&gt; this.RegisterEventHandlerImpl(handler, handler.GetType(), registerStatic);
⋮----
///     Registers all static methods annotated with &lt;see cref=&quot;EventAttribute&quot; /&gt; from the given type.
⋮----
/// &lt;param name=&quot;t&quot;&gt;The static event handler type.&lt;/param&gt;
public void RegisterStaticEventHandler(Type t)
=&gt; this.RegisterEventHandlerImpl(null, t);
⋮----
///     &lt;see cref=&quot;RegisterStaticEventHandler(Type)&quot; /&gt;.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to register.&lt;/typeparam&gt;
public void RegisterStaticEventHandler&lt;T&gt;()
=&gt; this.RegisterStaticEventHandler(typeof(T));
⋮----
///     &lt;para&gt;If abstract, registers all static methods of the type.&lt;/para&gt;
///     &lt;para&gt;
///         If non-abstract, tries to instantiate it, optionally using the provided
///         &lt;see cref=&quot;DiscordConfiguration.ServiceProvider&quot; /&gt;
///         and registers all instance and static methods.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;type&quot;&gt;Type to register.&lt;/param&gt;
public void RegisterEventHandler(Type type)
⋮----
this.RegisterStaticEventHandler(type);
⋮----
var anon = ActivatorUtilities.CreateInstance(this.Configuration.ServiceProvider, type);
⋮----
this._typeToAnonymousHandlers[type] = this._typeToAnonymousHandlers.TryGetValue(type, out var anonObjs) ? anonObjs : anonObjs = [];
⋮----
anonObjs.Add(anon);
⋮----
this.RegisterEventHandlerImpl(anon, type);
⋮----
///     &lt;see cref=&quot;RegisterEventHandler(Type)&quot; /&gt;.
⋮----
public void RegisterEventHandler&lt;T&gt;()
=&gt; this.RegisterEventHandler(typeof(T));
⋮----
///     Registers all types associated with the provided assembly that have the &lt;see cref=&quot;EventHandler&quot; /&gt; attribute.
⋮----
/// &lt;param name=&quot;assembly&quot;&gt;The assembly from which to get the types.&lt;/param&gt;
public void RegisterEventHandlers(Assembly assembly)
⋮----
this.RegisterEventHandler(t);
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterEventHandler(object, bool)&quot; /&gt;.
⋮----
/// &lt;param name=&quot;wasRegisteredWithStatic&quot;&gt;Whether it considered static methods.&lt;/param&gt;
public void UnregisterEventHandler(object handler, bool wasRegisteredWithStatic = false)
=&gt; this.UnregisterEventHandlerImpl(handler, handler.GetType(), wasRegisteredWithStatic);
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterStaticEventHandler(Type)&quot; /&gt;.
⋮----
/// &lt;param name=&quot;t&quot;&gt;Type to unregister.&lt;/param&gt;
public void UnregisterStaticEventHandler(Type t)
=&gt; this.UnregisterEventHandlerImpl(null, t);
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterStaticEventHandler{T}()&quot; /&gt;.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type to unregister.&lt;/typeparam&gt;
public void UnregisterStaticEventHandler&lt;T&gt;()
=&gt; this.UnregisterEventHandler(typeof(T));
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterEventHandler(Type)&quot; /&gt;.
⋮----
public void UnregisterEventHandler(Type t)
⋮----
this.UnregisterStaticEventHandler(t);
⋮----
if (!this._typeToAnonymousHandlers.TryGetValue(t, out var anonObjs) || anonObjs.Count == 0)
⋮----
anonObjs.RemoveAt(0);
⋮----
this._typeToAnonymousHandlers.Remove(t);
⋮----
this.UnregisterEventHandlerImpl(anon, t);
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterEventHandler{T}()&quot; /&gt;.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The type to unregister&lt;/typeparam&gt;
public void UnregisterEventHandler&lt;T&gt;() =&gt; this.UnregisterEventHandler(typeof(T));
⋮----
///     Perfectly mirrors &lt;see cref=&quot;RegisterEventHandlers(Assembly)&quot; /&gt;.
⋮----
/// &lt;param name=&quot;assembly&quot;&gt;The assembly to unregister.&lt;/param&gt;
public void UnregisterEventHandlers(Assembly assembly)
⋮----
this.UnregisterEventHandler(t);
⋮----
///     Gets the event handlers from the assembly.
⋮----
/// &lt;param name=&quot;assembly&quot;&gt;The assembly to get the event handlers from.&lt;/param&gt;
private static IEnumerable&lt;Type&gt; GetEventHandlersFromAssembly(Assembly assembly)
=&gt; assembly.GetTypes().Where(t =&gt; t.GetCustomAttribute&lt;EventHandlerAttribute&gt;() is not null);
⋮----
///     Unregisters event handler implementations.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;wasRegisteredWithStatic&quot;&gt;Whether it considereded static methods.&lt;/param&gt;
private void UnregisterEventHandlerImpl(object? handler, Type type, bool wasRegisteredWithStatic = true)
⋮----
if (this._registeredEventhandlers.ContainsKey(type))
this._registeredEventhandlers.Remove(type);
⋮----
if (!this._registrationToDelegate.TryGetValue((handler, type, wasRegisteredWithStatic), out var delegateLists) || delegateLists.Count == 0)
⋮----
evnt.RemoveEventHandler(this, dlgt);
⋮----
delegateLists.RemoveAt(0);
⋮----
this._registrationToDelegate.Remove((handler, type, wasRegisteredWithStatic));
⋮----
///     Rregisters event handler implementations.
⋮----
private void RegisterEventHandlerImpl(object? handler, Type type, bool registerStatic = true)
⋮----
from method in type.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
⋮----
let eventInfo = this.GetType().GetEvent(eventName)
?? throw new ArgumentException($&quot;Tried to register handler to non-existent event \&quot;{eventName}\&quot;&quot;)
⋮----
? Delegate.CreateDelegate(eventHandlerType, method, false)
: Delegate.CreateDelegate(eventHandlerType, handler, method, false))
?? throw new ArgumentException($&quot;Method \&quot;{method}\&quot; does not adhere to event specification \&quot;{eventHandlerType}\&quot;&quot;)
⋮----
).ToArray();
⋮----
this._registrationToDelegate[(handler, type, registerStatic)] = this._registrationToDelegate.TryGetValue((handler, type, registerStatic), out var delList) ? delList : delList = [];
⋮----
delList.Add(delegates);
this._registeredEventhandlers.Add(type, handler);
⋮----
evnt.AddEventHandler(this, dlgt);</file><file path="DisCatSharp/Clients/DiscordClient.Events.cs">/// &lt;summary&gt;
///     Represents a discord client.
/// &lt;/summary&gt;
public sealed partial class DiscordClient
⋮----
///     Gets the event execution limit.
⋮----
internal static TimeSpan EventExecutionLimit { get; } = TimeSpan.FromSeconds(1);
⋮----
///     Fired whenever a WebSocket error occurs within the client.
⋮----
add =&gt; this._socketErrored.Register(value);
remove =&gt; this._socketErrored.Unregister(value);
⋮----
///     Fired whenever WebSocket connection is established.
⋮----
add =&gt; this._socketOpened.Register(value);
remove =&gt; this._socketOpened.Unregister(value);
⋮----
///     Fired whenever WebSocket connection is terminated.
⋮----
add =&gt; this._socketClosed.Register(value);
remove =&gt; this._socketClosed.Unregister(value);
⋮----
///     Fired when the client enters ready state.
⋮----
add =&gt; this.ReadyEv.Register(value);
remove =&gt; this.ReadyEv.Unregister(value);
⋮----
///     Fired whenever a session is resumed.
⋮----
add =&gt; this._resumed.Register(value);
remove =&gt; this._resumed.Unregister(value);
⋮----
///     Fired on received heartbeat ACK.
⋮----
add =&gt; this._heartbeated.Register(value);
remove =&gt; this._heartbeated.Unregister(value);
⋮----
///     Fired when a new channel is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.Guilds&quot; /&gt; intent specified in
///     &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;
⋮----
add =&gt; this._channelCreated.Register(value);
remove =&gt; this._channelCreated.Unregister(value);
⋮----
///     Fired when a channel is updated.
⋮----
add =&gt; this._channelUpdated.Register(value);
remove =&gt; this._channelUpdated.Unregister(value);
⋮----
///     Fired when a channel is deleted
⋮----
add =&gt; this._channelDeleted.Register(value);
remove =&gt; this._channelDeleted.Unregister(value);
⋮----
///     Fired when a dm channel is deleted
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.DirectMessages&quot; /&gt; intent specified in
⋮----
add =&gt; this._dmChannelDeleted.Register(value);
remove =&gt; this._dmChannelDeleted.Unregister(value);
⋮----
///     Fired whenever a channel&apos;s pinned message list is updated.
⋮----
add =&gt; this._channelPinsUpdated.Register(value);
remove =&gt; this._channelPinsUpdated.Unregister(value);
⋮----
///     Fired whenever a voice channel&apos;s status is updated.
⋮----
add =&gt; this._voiceChannelStatusUpdated.Register(value);
remove =&gt; this._voiceChannelStatusUpdated.Unregister(value);
⋮----
///     Fired when the user joins a new guild.
⋮----
/// &lt;remarks&gt;[alias=&quot;GuildJoined&quot;][alias=&quot;JoinedGuild&quot;]&lt;/remarks&gt;
⋮----
add =&gt; this._guildCreated.Register(value);
remove =&gt; this._guildCreated.Unregister(value);
⋮----
///     Fired when a guild is becoming available.
⋮----
add =&gt; this._guildAvailable.Register(value);
remove =&gt; this._guildAvailable.Unregister(value);
⋮----
///     Fired when a guild is updated.
⋮----
add =&gt; this._guildUpdated.Register(value);
remove =&gt; this._guildUpdated.Unregister(value);
⋮----
///     Fired when the user leaves or is removed from a guild.
⋮----
add =&gt; this._guildDeleted.Register(value);
remove =&gt; this._guildDeleted.Unregister(value);
⋮----
///     Fired when a guild becomes unavailable.
⋮----
add =&gt; this._guildUnavailable.Register(value);
remove =&gt; this._guildUnavailable.Unregister(value);
⋮----
///     Fired when all guilds finish streaming from Discord.
⋮----
add =&gt; this.GuildDownloadCompletedEv.Register(value);
remove =&gt; this.GuildDownloadCompletedEv.Unregister(value);
⋮----
///     Fired when a guilds emojis get updated
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildEmojisAndStickers&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildEmojisUpdated.Register(value);
remove =&gt; this._guildEmojisUpdated.Unregister(value);
⋮----
///     Fired when a guilds stickers get updated
⋮----
add =&gt; this._guildStickersUpdated.Register(value);
remove =&gt; this._guildStickersUpdated.Unregister(value);
⋮----
///     Fired when a guild integration is updated.
⋮----
add =&gt; this._guildIntegrationsUpdated.Register(value);
remove =&gt; this._guildIntegrationsUpdated.Unregister(value);
⋮----
///     Fired when a guild audit log entry was created.
///     Requires bot to have the &lt;see cref=&quot;Permissions.ViewAuditLog&quot; /&gt; permission.
⋮----
add =&gt; this._guildAuditLogEntryCreated.Register(value);
remove =&gt; this._guildAuditLogEntryCreated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets created.
⋮----
add =&gt; this._automodRuleCreated.Register(value);
remove =&gt; this._automodRuleCreated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets updated.
⋮----
add =&gt; this._automodRuleUpdated.Register(value);
remove =&gt; this._automodRuleUpdated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets deleted.
⋮----
add =&gt; this._automodRuleDeleted.Register(value);
remove =&gt; this._automodRuleDeleted.Unregister(value);
⋮----
///     Fired when a rule is triggered and an action is executed.
⋮----
add =&gt; this._automodActionExecuted.Register(value);
remove =&gt; this._automodActionExecuted.Unregister(value);
⋮----
///     Fired when a guild ban gets added
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildModeration&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildBanAdded.Register(value);
remove =&gt; this._guildBanAdded.Unregister(value);
⋮----
///     Fired when a guild ban gets removed
⋮----
add =&gt; this._guildBanRemoved.Register(value);
remove =&gt; this._guildBanRemoved.Unregister(value);
⋮----
///     Fired when a guild member timeout gets added.
⋮----
add =&gt; this._guildMemberTimeoutAdded.Register(value);
remove =&gt; this._guildMemberTimeoutAdded.Unregister(value);
⋮----
///     Fired when a guild member timeout gets changed.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildMemberTimeoutChanged.Register(value);
remove =&gt; this._guildMemberTimeoutChanged.Unregister(value);
⋮----
///     Fired when a guild member timeout gets removed.
⋮----
add =&gt; this._guildMemberTimeoutRemoved.Register(value);
remove =&gt; this._guildMemberTimeoutRemoved.Unregister(value);
⋮----
///     Fired when a scheduled Event is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildScheduledEvents&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildScheduledEventCreated.Register(value);
remove =&gt; this._guildScheduledEventCreated.Unregister(value);
⋮----
///     Fired when a scheduled Event is updated.
⋮----
add =&gt; this._guildScheduledEventUpdated.Register(value);
remove =&gt; this._guildScheduledEventUpdated.Unregister(value);
⋮----
///     Fired when a scheduled Event is deleted.
⋮----
add =&gt; this._guildScheduledEventDeleted.Register(value);
remove =&gt; this._guildScheduledEventDeleted.Unregister(value);
⋮----
///     Fired when a user subscribes to a scheduled event.
⋮----
add =&gt; this._guildScheduledEventUserAdded.Register(value);
remove =&gt; this._guildScheduledEventUserAdded.Unregister(value);
⋮----
///     Fired when a user unsubscribes from a scheduled event.
⋮----
add =&gt; this._guildScheduledEventUserRemoved.Register(value);
remove =&gt; this._guildScheduledEventUserRemoved.Unregister(value);
⋮----
///     Fired when a guild integration is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildIntegrations&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildIntegrationCreated.Register(value);
remove =&gt; this._guildIntegrationCreated.Unregister(value);
⋮----
add =&gt; this._guildIntegrationUpdated.Register(value);
remove =&gt; this._guildIntegrationUpdated.Unregister(value);
⋮----
///     Fired when a guild integration is deleted.
⋮----
add =&gt; this._guildIntegrationDeleted.Register(value);
remove =&gt; this._guildIntegrationDeleted.Unregister(value);
⋮----
///     Fired when a new user joins a guild.
⋮----
add =&gt; this._guildMemberAdded.Register(value);
remove =&gt; this._guildMemberAdded.Unregister(value);
⋮----
///     Fired when a user is removed from a guild (leave/kick/ban).
⋮----
add =&gt; this._guildMemberRemoved.Register(value);
remove =&gt; this._guildMemberRemoved.Unregister(value);
⋮----
///     Fired when a guild member is updated.
⋮----
add =&gt; this._guildMemberUpdated.Register(value);
remove =&gt; this._guildMemberUpdated.Unregister(value);
⋮----
///     Fired in response to Gateway Request Guild Members.
⋮----
add =&gt; this._guildMembersChunked.Register(value);
remove =&gt; this._guildMembersChunked.Unregister(value);
⋮----
///     Fired when a guild role is created.
⋮----
add =&gt; this._guildRoleCreated.Register(value);
remove =&gt; this._guildRoleCreated.Unregister(value);
⋮----
///     Fired when a guild role is updated.
⋮----
add =&gt; this._guildRoleUpdated.Register(value);
remove =&gt; this._guildRoleUpdated.Unregister(value);
⋮----
add =&gt; this._guildRoleDeleted.Register(value);
remove =&gt; this._guildRoleDeleted.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildExpressions&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildSoundboardSoundCreated.Register(value);
remove =&gt; this._guildSoundboardSoundCreated.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is updated.
⋮----
add =&gt; this._guildSoundboardSoundUpdated.Register(value);
remove =&gt; this._guildSoundboardSoundUpdated.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is deleted.
⋮----
add =&gt; this._guildSoundboardSoundDeleted.Register(value);
remove =&gt; this._guildSoundboardSoundDeleted.Unregister(value);
⋮----
///     Fired when guild soundboard sounds is updated.
⋮----
add =&gt; this._guildSoundboardSoundsUpdated.Register(value);
remove =&gt; this._guildSoundboardSoundsUpdated.Unregister(value);
⋮----
///     Fired in response to &lt;see cref=&quot;DiscordClient.RequestSoundboardSoundsAsync&quot; /&gt;.
⋮----
add =&gt; this._soundboardSounds.Register(value);
remove =&gt; this._soundboardSounds.Unregister(value);
⋮----
///     Fired when a guild join request is created.
⋮----
add =&gt; this._guildJoinRequestCreated.Register(value);
remove =&gt; this._guildJoinRequestCreated.Unregister(value);
⋮----
///     Fired when a guild join request is updated.
⋮----
add =&gt; this._guildJoinRequestUpdated.Register(value);
remove =&gt; this._guildJoinRequestUpdated.Unregister(value);
⋮----
///     Fired when a guild join request is deleted.
⋮----
add =&gt; this._guildJoinRequestDeleted.Register(value);
remove =&gt; this._guildJoinRequestDeleted.Unregister(value);
⋮----
///     Fired when an invite is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildInvites&quot; /&gt; intent specified in
⋮----
add =&gt; this._inviteCreated.Register(value);
remove =&gt; this._inviteCreated.Unregister(value);
⋮----
///     Fired when an invite is deleted.
⋮----
add =&gt; this._inviteDeleted.Register(value);
remove =&gt; this._inviteDeleted.Unregister(value);
⋮----
///     Fired when a message is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessages&quot; /&gt; intent specified in
⋮----
add =&gt; this._messageCreated.Register(value);
remove =&gt; this._messageCreated.Unregister(value);
⋮----
///     Fired when message is acknowledged by the user.
⋮----
add =&gt; this._messageAcknowledged.Register(value);
remove =&gt; this._messageAcknowledged.Unregister(value);
⋮----
///     Fired when a message is updated.
⋮----
add =&gt; this._messageUpdated.Register(value);
remove =&gt; this._messageUpdated.Unregister(value);
⋮----
///     Fired when a message is deleted.
⋮----
add =&gt; this._messageDeleted.Register(value);
remove =&gt; this._messageDeleted.Unregister(value);
⋮----
///     Fired when multiple messages are deleted at once.
⋮----
add =&gt; this._messagesBulkDeleted.Register(value);
remove =&gt; this._messagesBulkDeleted.Unregister(value);
⋮----
///     Fired when a message poll vote is added.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessagePolls&quot; /&gt; and
///     &lt;see cref=&quot;DiscordIntents.DirectMessagePolls&quot; /&gt; intent (depending on where u want to receive events from)
///     specified in &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;.
⋮----
add =&gt; this._messagePollVoteAdded.Register(value);
remove =&gt; this._messagePollVoteAdded.Unregister(value);
⋮----
///     Fired when a message poll vote is removed.
⋮----
add =&gt; this._messagePollVoteRemoved.Register(value);
remove =&gt; this._messagePollVoteRemoved.Unregister(value);
⋮----
///     Fired when a reaction gets added to a message.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessageReactions&quot; /&gt; intent specified in
⋮----
add =&gt; this._messageReactionAdded.Register(value);
remove =&gt; this._messageReactionAdded.Unregister(value);
⋮----
///     Fired when a reaction gets removed from a message.
⋮----
add =&gt; this._messageReactionRemoved.Register(value);
remove =&gt; this._messageReactionRemoved.Unregister(value);
⋮----
///     Fired when all reactions get removed from a message.
⋮----
add =&gt; this._messageReactionsCleared.Register(value);
remove =&gt; this._messageReactionsCleared.Unregister(value);
⋮----
///     Fired when all reactions of a specific reaction are removed from a message.
⋮----
add =&gt; this._messageReactionRemovedEmoji.Register(value);
remove =&gt; this._messageReactionRemovedEmoji.Unregister(value);
⋮----
///     Fired when a embedded activity has been updated.
⋮----
add =&gt; this._embeddedActivityUpdated.Register(value);
remove =&gt; this._embeddedActivityUpdated.Unregister(value);
⋮----
///     Fired when a presence has been updated.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildPresences&quot; /&gt; intent specified in
⋮----
add =&gt; this._presenceUpdated.Register(value);
remove =&gt; this._presenceUpdated.Unregister(value);
⋮----
///     Fired when the current user updates their settings.
⋮----
add =&gt; this._userSettingsUpdated.Register(value);
remove =&gt; this._userSettingsUpdated.Unregister(value);
⋮----
///     Fired when properties about the current user change.
⋮----
/// &lt;remarks&gt;
///     NB: This event only applies for changes to the &lt;b&gt;current user&lt;/b&gt;, the client that is connected to Discord.
⋮----
/// &lt;/remarks&gt;
⋮----
add =&gt; this._userUpdated.Register(value);
remove =&gt; this._userUpdated.Unregister(value);
⋮----
///     Fired when a Stage Instance is created.
⋮----
add =&gt; this._stageInstanceCreated.Register(value);
remove =&gt; this._stageInstanceCreated.Unregister(value);
⋮----
///     Fired when a Stage Instance is updated.
⋮----
add =&gt; this._stageInstanceUpdated.Register(value);
remove =&gt; this._stageInstanceUpdated.Unregister(value);
⋮----
///     Fired when a Stage Instance is deleted.
⋮----
add =&gt; this._stageInstanceDeleted.Register(value);
remove =&gt; this._stageInstanceDeleted.Unregister(value);
⋮----
///     Fired when a thread is created.
⋮----
add =&gt; this._threadCreated.Register(value);
remove =&gt; this._threadCreated.Unregister(value);
⋮----
///     Fired when a thread is updated.
⋮----
add =&gt; this._threadUpdated.Register(value);
remove =&gt; this._threadUpdated.Unregister(value);
⋮----
///     Fired when a thread is deleted.
⋮----
add =&gt; this._threadDeleted.Register(value);
remove =&gt; this._threadDeleted.Unregister(value);
⋮----
///     Fired when a thread member is updated.
⋮----
add =&gt; this._threadListSynced.Register(value);
remove =&gt; this._threadListSynced.Unregister(value);
⋮----
add =&gt; this._threadMemberUpdated.Register(value);
remove =&gt; this._threadMemberUpdated.Unregister(value);
⋮----
///     Fired when the thread members are updated.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; or &lt;see cref=&quot;DiscordIntents.Guilds&quot; /&gt;
///     intent specified in &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;
⋮----
add =&gt; this._threadMembersUpdated.Register(value);
remove =&gt; this._threadMembersUpdated.Unregister(value);
⋮----
///     Fired when someone joins/leaves/moves voice channels.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildVoiceStates&quot; /&gt; intent specified in
⋮----
add =&gt; this._voiceStateUpdated.Register(value);
remove =&gt; this._voiceStateUpdated.Unregister(value);
⋮----
///     Fired when a guild&apos;s voice server is updated.
⋮----
add =&gt; this._voiceServerUpdated.Register(value);
remove =&gt; this._voiceServerUpdated.Unregister(value);
⋮----
///     Fired when a voice channel effect was send.
⋮----
add =&gt; this._voiceChannelEffectSend.Register(value);
remove =&gt; this._voiceChannelEffectSend.Unregister(value);
⋮----
///     Fired when a new application command is registered.
⋮----
add =&gt; this._applicationCommandCreated.Register(value);
remove =&gt; this._applicationCommandCreated.Unregister(value);
⋮----
///     Fired when an application command is updated.
⋮----
add =&gt; this._applicationCommandUpdated.Register(value);
remove =&gt; this._applicationCommandUpdated.Unregister(value);
⋮----
///     Fired when an application command is deleted.
⋮----
add =&gt; this._applicationCommandDeleted.Register(value);
remove =&gt; this._applicationCommandDeleted.Unregister(value);
⋮----
add =&gt; this._guildApplicationCommandCountUpdated.Register(value);
remove =&gt; this._guildApplicationCommandCountUpdated.Unregister(value);
⋮----
///     Fired when a user uses a context menu.
⋮----
add =&gt; this._contextMenuInteractionCreated.Register(value);
remove =&gt; this._contextMenuInteractionCreated.Unregister(value);
⋮----
///     Fired when application command permissions gets updated.
⋮----
add =&gt; this._applicationCommandPermissionsUpdated.Register(value);
remove =&gt; this._applicationCommandPermissionsUpdated.Unregister(value);
⋮----
///     Fired when an interaction is invoked.
⋮----
add =&gt; this._interactionCreated.Register(value);
remove =&gt; this._interactionCreated.Unregister(value);
⋮----
///     Fired when a component is invoked.
⋮----
add =&gt; this._componentInteractionCreated.Register(value);
remove =&gt; this._componentInteractionCreated.Unregister(value);
⋮----
///     Fired when an entitlement was created.
⋮----
add =&gt; this._entitlementCreated.Register(value);
remove =&gt; this._entitlementCreated.Unregister(value);
⋮----
///     Fired when an entitlement was updated.
⋮----
add =&gt; this._entitlementUpdated.Register(value);
remove =&gt; this._entitlementUpdated.Unregister(value);
⋮----
///     Fired when an entitlement was deleted.
⋮----
add =&gt; this._entitlementDeleted.Register(value);
remove =&gt; this._entitlementDeleted.Unregister(value);
⋮----
///     Fired when an subscription was created.
⋮----
add =&gt; this._subscriptionCreated.Register(value);
remove =&gt; this._subscriptionCreated.Unregister(value);
⋮----
///     Fired when an subscription was updated.
⋮----
add =&gt; this._subscriptionUpdated.Register(value);
remove =&gt; this._subscriptionUpdated.Unregister(value);
⋮----
///     Fired when a user starts typing in a channel.
⋮----
add =&gt; this._typingStarted.Register(value);
remove =&gt; this._typingStarted.Unregister(value);
⋮----
///     Fired when an unknown event gets received.
⋮----
add =&gt; this._unknownEvent.Register(value);
remove =&gt; this._unknownEvent.Unregister(value);
⋮----
///     Fired whenever webhooks update.
⋮----
add =&gt; this._webhooksUpdated.Register(value);
remove =&gt; this._webhooksUpdated.Unregister(value);
⋮----
///     Fired whenever an error occurs within an event handler.
⋮----
add =&gt; this._clientErrored.Register(value);
remove =&gt; this._clientErrored.Unregister(value);
⋮----
///     Handles event errors.
⋮----
/// &lt;param name=&quot;asyncEvent&quot;&gt;The event.&lt;/param&gt;
/// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;The event handler.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
internal void EventErrorHandler&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
where TArgs : AsyncEventArgs
⋮----
this.Logger.LogWarning(LoggerEvents.EventHandlerException, &quot;An event handler for {AsyncEventName} took too long to execute. Defined as \&quot;{TrimStart}\&quot; located in \&quot;{MethodDeclaringType}\&quot;&quot;, asyncEvent.Name, handler.Method.ToString()?.Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart(), handler.Method.DeclaringType);
⋮----
this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {Name} thrown from {Method} (defined in {DeclaringType})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
this._clientErrored.InvokeAsync(this, new(this.ServiceProvider)
⋮----
}).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Fired when a ratelimit was hit.
⋮----
add =&gt; this.RateLimitHitInternal.Register(value);
remove =&gt; this.RateLimitHitInternal.Unregister(value);
⋮----
///     Fired on heartbeat attempt cancellation due to too many failed heartbeats.
⋮----
add =&gt; this._zombied.Register(value);
remove =&gt; this._zombied.Unregister(value);
⋮----
///     Fired when a gateway payload is received.
///     Only fired when &lt;see cref=&quot;DiscordConfiguration.EnableLibraryDeveloperMode&quot; /&gt; or
///     &lt;see cref=&quot;DiscordConfiguration.EnablePayloadReceivedEvent&quot; /&gt; is enabled.
⋮----
add =&gt; this._payloadReceived.Register(value);
remove =&gt; this._payloadReceived.Unregister(value);
⋮----
///     Handles event handler exceptions.
⋮----
private void Goof&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {0} (defined in {1}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);</file><file path="DisCatSharp/Clients/DiscordOAuth2Client.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordOAuth2Client : IDisposable
⋮----
///     Gets the file name for the rsa public/private key.
⋮----
///    Gets the discord configuration.
⋮----
///     Gets the api client.
⋮----
internal readonly DiscordApiClient ApiClient;
⋮----
///     Gets the client id.
⋮----
///     Gets the client secret.
⋮----
///     Gets the log timestamp format.
⋮----
///     Gets the minimal log level.
⋮----
internal readonly LogLevel MinimumLogLevel;
⋮----
///     Triggered when an error occurs within an event handler.
⋮----
///     Gets the redirect uri.
⋮----
public readonly Uri RedirectUri;
⋮----
///     Gets the string representing the version header of the bot lib.
⋮----
///     Creates a new OAuth2 client.
⋮----
/// &lt;param name=&quot;clientId&quot;&gt;The client id.&lt;/param&gt;
/// &lt;param name=&quot;clientSecret&quot;&gt;The client secret.&lt;/param&gt;
/// &lt;param name=&quot;redirectUri&quot;&gt;The redirect uri.&lt;/param&gt;
/// &lt;param name=&quot;provider&quot;&gt;The service provider.&lt;/param&gt;
/// &lt;param name=&quot;proxy&quot;&gt;The proxy to use for HTTP connections. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;
///     The optional timeout to use for HTTP requests. Set to
///     &lt;see cref=&quot;System.Threading.Timeout.InfiniteTimeSpan&quot; /&gt; to disable timeouts. Defaults to null.
/// &lt;/param&gt;
/// &lt;param name=&quot;useRelativeRateLimit&quot;&gt;
///     Whether to use the system clock for computing rate limit resets. See
///     &lt;see cref=&quot;DiscordConfiguration.UseRelativeRatelimit&quot; /&gt; for more details. Defaults to true.
⋮----
/// &lt;param name=&quot;loggerFactory&quot;&gt;The optional logging factory to use for this client. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;minimumLogLevel&quot;&gt;The minimum logging level for messages. Defaults to information.&lt;/param&gt;
/// &lt;param name=&quot;logTimestampFormat&quot;&gt;The timestamp format to use for the logger.&lt;/param&gt;
⋮----
loggerFactory = new DefaultLoggerFactory();
loggerFactory.AddProvider(new DefaultLoggerProvider(this));
⋮----
this.ServiceProvider = provider ?? new ServiceCollection().BuildServiceProvider(true);
⋮----
var parsedTimeout = timeout ?? TimeSpan.FromSeconds(10);
⋮----
this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;client_id&quot;, this.ClientId.ToString());
this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(&quot;client_secret&quot;, this.ClientSecret);
⋮----
var a = typeof(DiscordOAuth2Client).GetTypeInfo().Assembly;
⋮----
var v = a.GetName().Version;
⋮----
this.ApiClient.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, this.VersionHeader);
⋮----
if (File.Exists(RSA_KEY_FILE_NAME))
⋮----
var privatePublicKeyPemBytes = File.ReadAllText(RSA_KEY_FILE_NAME);
this.RSA_KEY = new RSACryptoServiceProvider(2048);
this.RSA_KEY.ImportFromPem(privatePublicKeyPemBytes.ToCharArray());
⋮----
this.Logger.LogCritical(ex, &quot;Exception in RSA Import: {msg}&quot;, ex.Message);
⋮----
var privatePublicKeyPem = this.RSA_KEY.ExportRSAPrivateKeyPem();
File.WriteAllText(RSA_KEY_FILE_NAME, privatePublicKeyPem);
⋮----
this.Logger.LogCritical(ex, &quot;Exception in RSA Export: {msg}&quot;, ex.Message);
⋮----
///     Gets the logger for this client.
⋮----
///     Gets the bot library name.
⋮----
///     Gets the service provider this OAuth2 client was configured with.
⋮----
///     Gets the event execution limit.
⋮----
internal static TimeSpan EventExecutionLimit { get; } = TimeSpan.FromMinutes(1);
⋮----
///     Gets the RSA instance.
⋮----
/// &lt;inheritdoc /&gt;
public void Dispose()
⋮----
this.RSA_KEY.Dispose();
GC.SuppressFinalize(this);
⋮----
///     Generates an OAuth2 url.
⋮----
/// &lt;param name=&quot;scopes&quot;&gt;The space seperated scopes to request.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;
///     The state to use for security reasons. Use &lt;see cref=&quot;GenerateState&quot; /&gt; or
///     &lt;see cref=&quot;GenerateSecureState&quot; /&gt;.
⋮----
/// .
/// &lt;param name=&quot;suppressPrompt&quot;&gt;Whether to suppress the prompt. Works only if previously authorized with same scopes.&lt;/param&gt;
/// &lt;returns&gt;The OAuth2 url&lt;/returns&gt;
public Uri GenerateOAuth2Url(string scopes, string state, bool suppressPrompt = false) =&gt;
new(new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
.AddParameter(&quot;client_id&quot;, this.ClientId.ToString(CultureInfo.InvariantCulture))
.AddParameter(&quot;scope&quot;, scopes)
.AddParameter(&quot;state&quot;, state)
.AddParameter(&quot;redirect_uri&quot;, this.RedirectUri.AbsoluteUri)
.AddParameter(&quot;response_type&quot;, &quot;code&quot;)
.AddParameter(&quot;prompt&quot;, suppressPrompt ? &quot;none&quot; : &quot;consent&quot;)
.ToString());
⋮----
///     Generates a state for OAuth2 authorization.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public string GenerateState()
=&gt; $&quot;{DateTimeOffset.UtcNow.UtcTicks}::{this.ClientId.GetHashCode()}::{Guid.NewGuid()}&quot;;
⋮----
///     Generates a secured state bound to the user id.
///     &lt;para&gt;If the bot is completely restarted, such a state can&apos;t be decrypted anymore.&lt;/para&gt;
///     &lt;para&gt;To decrypt this state, use &lt;see cref=&quot;ReadSecureState&quot; /&gt;&lt;/para&gt;
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user id to bind the state on.&lt;/param&gt;
public string GenerateSecureState(ulong userId)
=&gt; Uri.EscapeDataString(Convert.ToBase64String(this.RSA_KEY.Encrypt(Encoding.UTF8.GetBytes($&quot;{DateTimeOffset.UtcNow.UtcTicks}::{userId}::{this.ClientId.GetHashCode()}::{Guid.NewGuid()}&quot;), RSAEncryptionPadding.OaepSHA1)));
⋮----
///     Reads a secured state generated from &lt;see cref=&quot;GenerateSecureState&quot; /&gt;.
⋮----
/// &lt;param name=&quot;state&quot;&gt;The state to read.&lt;/param&gt;
public string ReadSecureState(string state)
=&gt; Encoding.UTF8.GetString(this.RSA_KEY.Decrypt(Convert.FromBase64String(Uri.UnescapeDataString(state)), RSAEncryptionPadding.OaepSHA1));
⋮----
///     Validates the OAuth2 state.
⋮----
/// &lt;param name=&quot;requestUrl&quot;&gt;The request url generated by &lt;see cref=&quot;GenerateOAuth2Url&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;responseUrl&quot;&gt;The response url.&lt;/param&gt;
/// &lt;param name=&quot;secure&quot;&gt;Whether &lt;see cref=&quot;GenerateSecureState&quot; /&gt; and &lt;see cref=&quot;ReadSecureState&quot; /&gt; is used.&lt;/param&gt;
public bool ValidateState(Uri requestUrl, Uri responseUrl, bool secure = false)
⋮----
var requestQueryDictionary = HttpUtility.ParseQueryString(requestUrl.Query, Encoding.UTF8);
var responseQueryDictionary = HttpUtility.ParseQueryString(responseUrl.Query, Encoding.UTF8);
var requestState = requestQueryDictionary.GetValues(&quot;state&quot;)?.First();
var responseState = responseQueryDictionary.GetValues(&quot;state&quot;)?.First();
⋮----
int.Parse(requestState.Split(&quot;::&quot;)[1]) == this.ClientId.GetHashCode() &amp;&amp;
int.Parse(responseState.Split(&quot;::&quot;)[1]) == this.ClientId.GetHashCode() &amp;&amp;
⋮----
throw new NullReferenceException(&quot;State was null&quot;);
⋮----
var decryptedReqState = this.ReadSecureState(requestState);
var decryptedResState = this.ReadSecureState(responseState);
return int.Parse(decryptedReqState.Split(&quot;::&quot;)[2]) == this.ClientId.GetHashCode() &amp;&amp; int.Parse(decryptedResState.Split(&quot;::&quot;)[2]) == this.ClientId.GetHashCode() &amp;&amp; decryptedReqState == decryptedResState
⋮----
: throw new SecurityException(&quot;States invalid&quot;);
⋮----
///     Gets the OAuth2 code to use with &lt;see cref=&quot;ExchangeAccessTokenAsync&quot; /&gt; from the &lt;paramref name=&quot;url&quot; /&gt;.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
public string GetCodeFromUri(Uri url)
⋮----
var responseQueryDictionary = HttpUtility.ParseQueryString(url.Query, Encoding.UTF8);
var code = responseQueryDictionary.GetValues(&quot;code&quot;)?.First();
return code ?? throw new NullReferenceException(&quot;Could not find code in url.&quot;);
⋮----
public string GetStateFromUri(Uri url)
⋮----
var state = responseQueryDictionary.GetValues(&quot;state&quot;)?.First();
return state ?? throw new NullReferenceException(&quot;Could not find code in url.&quot;);
⋮----
///     Exchanges a code for an discord access token.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The exchange code.&lt;/param&gt;
public async Task&lt;DiscordAccessToken&gt; ExchangeAccessTokenAsync(string code)
=&gt; await this.ApiClient.ExchangeOAuth2AccessTokenAsync(code);
⋮----
///     Exchanges a refresh token for a new discord access token.
⋮----
/// &lt;param name=&quot;accessToken&quot;&gt;The current discord access token.&lt;/param&gt;
public async Task&lt;DiscordAccessToken&gt; RefreshAccessTokenAsync(DiscordAccessToken accessToken)
=&gt; await this.ApiClient.RefreshOAuth2AccessTokenAsync(accessToken.RefreshToken);
⋮----
///     Revokes an OAuth2 token via its access token.
⋮----
public async Task RevokeByAccessTokenAsync(DiscordAccessToken accessToken)
=&gt; await this.ApiClient.RevokeOAuth2TokenAsync(accessToken.AccessToken, &quot;access_token&quot;);
⋮----
///     Revokes an OAuth2 token via its refresh token.
⋮----
public async Task RevokeByRefreshTokenAsync(DiscordAccessToken accessToken)
=&gt; await this.ApiClient.RevokeOAuth2TokenAsync(accessToken.RefreshToken, &quot;refresh_token&quot;);
⋮----
///     Gets the current authorization information.
⋮----
/// &lt;param name=&quot;accessToken&quot;&gt;The discord access token.&lt;/param&gt;
public async Task&lt;DiscordAuthorizationInformation&gt; GetCurrentAuthorizationInformationAsync(DiscordAccessToken accessToken)
=&gt; await this.ApiClient.GetCurrentOAuth2AuthorizationInformationAsync(accessToken.AccessToken);
⋮----
///     Gets the current user.
⋮----
public async Task&lt;DiscordUser&gt; GetCurrentUserAsync(DiscordAccessToken accessToken)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;identify&quot;) ? await this.ApiClient.GetCurrentUserAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include identify scope&quot;);
⋮----
///     Gets the current user&apos;s connections.
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetCurrentUserConnectionsAsync(DiscordAccessToken accessToken)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;connections&quot;) ? await this.ApiClient.GetCurrentUserConnectionsAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include connections scope&quot;);
⋮----
///     Gets the current user&apos;s guilds.
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(DiscordAccessToken accessToken)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds&quot;) ? await this.ApiClient.GetCurrentUserGuildsAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include guilds scope&quot;);
⋮----
///     Gets the current user&apos;s guild member for given &lt;paramref name=&quot;guildId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to get the member for.&lt;/param&gt;
public async Task&lt;DiscordMember&gt; GetCurrentUserGuildMemberAsync(DiscordAccessToken accessToken, ulong guildId)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.members.read&quot;) ? await this.ApiClient.GetCurrentUserGuildMemberAsync(accessToken.AccessToken, guildId) : throw new AccessViolationException(&quot;Access token does not include guilds.members.read scope&quot;);
⋮----
///     &lt;para&gt;Adds the current user to the given &lt;paramref name=&quot;guildId&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;
///         Some parameters might need additional permissions for the bot on the target guild. See
///         https://discord.com/developers/docs/resources/guild#add-guild-member for details.
///     &lt;/para&gt;
///     &lt;para&gt;This methods invokes a sub-request to &lt;see cref=&quot;GetCurrentUserAsync&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to add the member to.&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;The new nickname.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;The new roles.&lt;/param&gt;
/// &lt;param name=&quot;muted&quot;&gt;Whether this user has to be muted.&lt;/param&gt;
/// &lt;param name=&quot;deafened&quot;&gt;Whether this user has to be deafened.&lt;/param&gt;
public async Task&lt;DiscordMember&gt; AddCurrentUserToGuildAsync(DiscordAccessToken accessToken, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.join&quot;) ? await this.ApiClient.AddGuildMemberAsync(guildId, (await this.GetCurrentUserAsync(accessToken)).Id, accessToken.AccessToken, nickname, roles, muted, deafened) : throw new AccessViolationException(&quot;Access token does not include guilds.join scope&quot;);
⋮----
///     &lt;para&gt;Adds the given &lt;paramref name=&quot;userId&quot; /&gt; to the given &lt;paramref name=&quot;guildId&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;This methods does not invoke a sub-request to &lt;see cref=&quot;GetCurrentUserAsync&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user id to add.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMember&gt; AddCurrentUserToGuildAsync(DiscordAccessToken accessToken, ulong userId, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;guilds.join&quot;) ? await this.ApiClient.AddGuildMemberAsync(guildId, userId, accessToken.AccessToken, nickname, roles, muted, deafened) : throw new AccessViolationException(&quot;Access token does not include guilds.join scope&quot;);
⋮----
///     Gets the current user&apos;s application role connection.
⋮----
public async Task&lt;DiscordApplicationRoleConnection&gt; GetCurrentUserApplicationRoleConnectionAsync(DiscordAccessToken accessToken)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;role_connections.write&quot;) ? await this.ApiClient.GetCurrentUserApplicationRoleConnectionAsync(accessToken.AccessToken) : throw new AccessViolationException(&quot;Access token does not include role_connections.write scope&quot;);
⋮----
///     Updates the current user&apos;s application role connection.
⋮----
/// &lt;param name=&quot;platformName&quot;&gt;The platform name.&lt;/param&gt;
/// &lt;param name=&quot;platformUsername&quot;&gt;The platform username.&lt;/param&gt;
/// &lt;param name=&quot;metadata&quot;&gt;The metadata.&lt;/param&gt;
public async Task&lt;DiscordApplicationRoleConnection&gt; UpdateCurrentUserApplicationRoleConnectionAsync(DiscordAccessToken accessToken, string platformName, string platformUsername, ApplicationRoleConnectionMetadata metadata)
=&gt; accessToken.Scope.Split(&apos; &apos;).Any(x =&gt; x == &quot;role_connections.write&quot;) ? await this.ApiClient.ModifyCurrentUserApplicationRoleConnectionAsync(accessToken.AccessToken, platformName, platformUsername, metadata) : throw new AccessViolationException(&quot;Access token does not include role_connections.write scope&quot;);
⋮----
///     Fired whenever an error occurs within an event handler.
⋮----
add =&gt; this.OAuth2ClientErroredInternal.Register(value);
remove =&gt; this.OAuth2ClientErroredInternal.Unregister(value);
⋮----
///     Handles event errors.
⋮----
/// &lt;param name=&quot;asyncEvent&quot;&gt;The event.&lt;/param&gt;
/// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;The event handler.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
internal void EventErrorHandler&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
where TArgs : AsyncEventArgs
⋮----
this.Logger.LogWarning(LoggerEvents.EventHandlerException, &quot;An event handler for {AsyncEventName} took too long to execute. Defined as \&quot;{TrimStart}\&quot; located in \&quot;{MethodDeclaringType}\&quot;&quot;, asyncEvent.Name, handler.Method.ToString()?.Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart(), handler.Method.DeclaringType);
⋮----
this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {Name} thrown from {@Method} (defined in {Type})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
this.OAuth2ClientErroredInternal.InvokeAsync(this, new(this.ServiceProvider)
⋮----
}).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Handles event handler exceptions.
⋮----
private void Goof&lt;TSender, TArgs&gt;(AsyncEvent&lt;TSender, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;TSender, TArgs&gt; handler, TSender sender, TArgs eventArgs)
where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {Method} (defined in {DeclaringType}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);
⋮----
///     Disposes the client.
⋮----
this.Dispose();</file><file path="DisCatSharp/Clients/DiscordShardedClient.cs">/// &lt;summary&gt;
///     A Discord client that shards automatically.
/// &lt;/summary&gt;
public sealed partial class DiscordShardedClient
⋮----
///     Initializes a new auto-sharding Discord client.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The configuration to use.&lt;/param&gt;
⋮----
this.InternalSetup();
⋮----
this._configuration.LoggerFactory = new DefaultLoggerFactory();
this._configuration.LoggerFactory.AddProvider(new DefaultLoggerProvider(this._configuration.MinimumLogLevel, this._configuration.LogTimestampFormat));
⋮----
#pragma warning disable CS0618 // Type or member is obsolete
⋮----
#pragma warning restore CS0618 // Type or member is obsolete
⋮----
/*
			var configureFormatterOptions = new ConfigureNamedOptions&lt;ConsoleFormatterOptions&gt;(string.Empty, x =&gt; { x.TimestampFormat = this.Configuration.LogTimestampFormat; });
			var formatterFactory = new OptionsFactory&lt;ConsoleFormatterOptions&gt;(new[] { configureFormatterOptions }, Enumerable.Empty&lt;IPostConfigureOptions&lt;ConsoleFormatterOptions&gt;&gt;());
			var formatterMonitor = new OptionsMonitor&lt;ConsoleFormatterOptions&gt;(formatterFactory, Enumerable.Empty&lt;IOptionsChangeTokenSource&lt;ConsoleFormatterOptions&gt;&gt;(), new OptionsCache&lt;ConsoleFormatterOptions&gt;());
			*/
⋮----
var l = new ConsoleLoggerProvider(optionsMonitor);
this._configuration.LoggerFactory = new LoggerFactory();
this._configuration.LoggerFactory.AddProvider(l);
⋮----
this._configuration.LoggerFactory.AddSentry(o =&gt;
⋮----
var a = typeof(DiscordClient).GetTypeInfo().Assembly;
⋮----
var v = a.GetName().Version;
⋮----
o.AddInAppInclude(&quot;DisCatSharp&quot;);
⋮----
o.AddExceptionFilter(new DisCatSharpExceptionFilter(this._configuration));
⋮----
o.SetBeforeSend((e, _) =&gt;
⋮----
if (!this._configuration.TrackExceptions.Contains(e.Exception.GetType()))
⋮----
else if (e.Extra.Count == 0 || !e.Extra.ContainsKey(&quot;Found Fields&quot;))
⋮----
if (!e.HasUser())
⋮----
Id = this.CurrentUser.Id.ToString(),
⋮----
if (!e.Extra.ContainsKey(&quot;Found Fields&quot;))
e.SetFingerprint(BaseDiscordClient.GenerateSentryFingerPrint(e));
⋮----
///     Initializes the shards.
⋮----
/// &lt;returns&gt;The count of initialized shards.&lt;/returns&gt;
internal async Task&lt;int&gt; InitializeShardsAsync()
⋮----
this.GatewayInfo = await this.GetGatewayInfoAsync().ConfigureAwait(false);
⋮----
var lf = new ShardedLoggerFactory(this.Logger);
⋮----
var cfg = new DiscordConfiguration(this._configuration)
⋮----
var client = new DiscordClient(cfg);
if (!this._shards.TryAdd(i, client))
throw new InvalidOperationException(&quot;Could not initialize shards.&quot;);
⋮----
///     Disposes the client.
⋮----
this.InternalStopAsync(false).GetAwaiter().GetResult();
⋮----
///     Gets the logger for this client.
⋮----
///     Gets all client shards.
⋮----
///     Gets the gateway info for the client&apos;s session.
⋮----
///     Gets the current user.
⋮----
///     Gets the current api channel.
⋮----
///     Gets the current api version.
⋮----
///     Gets the bot library name.
⋮----
///     Gets the current application.
⋮----
///     Gets the list of available voice regions. Note that this property will not contain VIP voice regions.
⋮----
///     Gets combined statistics across all shard clients.
⋮----
var combinedStats = Enum.GetValues(typeof(DisCatSharpStatisticType))
⋮----
.ToDictionary(stat =&gt; stat, _ =&gt; 0);
⋮----
///     Gets the configuration.
⋮----
private readonly DiscordConfiguration _configuration;
⋮----
///     Gets the list of available voice regions. This property is meant as a way to modify &lt;see cref=&quot;VoiceRegions&quot; /&gt;.
⋮----
///     Gets a list of shards.
⋮----
///     Gets a lazy list of voice regions.
⋮----
///     Whether the shard client is started.
⋮----
///     Whether manual sharding is enabled.
⋮----
///     Initializes and connects all shards.
⋮----
/// &lt;exception cref=&quot;AggregateException&quot;&gt;&lt;/exception&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;&lt;/exception&gt;
public async Task StartAsync()
⋮----
throw new InvalidOperationException(&quot;This client has already been started.&quot;);
⋮----
this.Logger.LogWarning(LoggerEvents.Misc, &quot;You are logging in with a token that is not a bot token. This is not officially supported by Discord, and can result in your account being terminated if you aren&apos;t careful&quot;);
this.Logger.LogInformation(LoggerEvents.Startup, &quot;Lib {LibraryName}, version {LibraryVersion}&quot;, this._botLibrary, this._versionString.Value);
⋮----
var shardc = await this.InitializeShardsAsync().ConfigureAwait(false);
⋮----
this.Logger.LogInformation(LoggerEvents.ShardStartup, &quot;Booting {NumShards} shards&quot;, shardc);
⋮----
//This should never happen, but in case it does...
⋮----
await this.ConnectShardAsync(i).ConfigureAwait(false);
⋮----
//Concurrent login.
connectTasks.Add(this.ConnectShardAsync(i));
⋮----
await Task.WhenAll(connectTasks).ConfigureAwait(false);
connectTasks.Clear();
⋮----
await this.InternalStopAsync(false).ConfigureAwait(false);
⋮----
this.Logger.LogCritical(LoggerEvents.ShardClientError, &quot;{Message}\n{Ex}&quot;, message, ex);
throw new AggregateException(message, ex);
⋮----
///     Disconnects and disposes all shards.
⋮----
public Task StopAsync()
=&gt; this.InternalStopAsync();
⋮----
///     Gets a shard from a guild id.
///     &lt;para&gt;
///         If automatically sharding, this will use the &lt;see cref=&quot;Utilities.GetShardId(ulong, int)&quot; /&gt; method.
///         Otherwise if manually sharding, it will instead iterate through each shard&apos;s guild caches.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild ID for the shard.&lt;/param&gt;
/// &lt;returns&gt;The found &lt;see cref=&quot;DiscordClient&quot; /&gt; shard. Otherwise null if the shard was not found for the guild id.&lt;/returns&gt;
public DiscordClient GetShard(ulong guildId)
⋮----
var index = this._manuallySharding ? this.GetShardIdFromGuilds(guildId) : Utilities.GetShardId(guildId, this.ShardClients.Count);
⋮----
///     Gets a shard from a guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild for the shard.&lt;/param&gt;
/// &lt;returns&gt;The found &lt;see cref=&quot;DiscordClient&quot; /&gt; shard. Otherwise null if the shard was not found for the guild.&lt;/returns&gt;
public DiscordClient GetShard(DiscordGuild guild)
=&gt; this.GetShard(guild.Id);
⋮----
///     Updates the status on all shards.
⋮----
/// &lt;param name=&quot;activity&quot;&gt;The activity to set. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;userStatus&quot;&gt;The optional status to set. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;idleSince&quot;&gt;Since when is the client performing the specified activity. Defaults to null.&lt;/param&gt;
/// &lt;returns&gt;Asynchronous operation.&lt;/returns&gt;
public async Task UpdateStatusAsync(DiscordActivity? activity = null, UserStatus? userStatus = null, DateTimeOffset? idleSince = null)
⋮----
var tasks = this._shards.Values.Select(client =&gt; client.UpdateStatusAsync(activity, userStatus, idleSince)).ToList();
⋮----
await Task.WhenAll(tasks).ConfigureAwait(false);
⋮----
///     Gets the gateway info.
⋮----
private async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync()
⋮----
var httphandler = new HttpClientHandler
⋮----
var url = $&quot;{Utilities.GetApiBaseUri(this._configuration)}{Endpoints.GATEWAY}{Endpoints.BOT}&quot;;
var http = new HttpClient(httphandler)
⋮----
BaseAddress = new(Utilities.GetApiBaseUri(this._configuration)),
⋮----
http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, Utilities.GetFormattedToken(this._configuration));
http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, this._configuration.Locale);
if (!string.IsNullOrWhiteSpace(this._configuration.Timezone))
http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, this._configuration.Timezone);
⋮----
http.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, this._configuration.Override);
⋮----
this.Logger.LogDebug(LoggerEvents.ShardRest, $&quot;Obtaining gateway information from GET {Endpoints.GATEWAY}{Endpoints.BOT}...&quot;);
var resp = await http.GetAsync(url).ConfigureAwait(false);
⋮----
http.Dispose();
⋮----
var ratelimited = await HandleHttpError(url, resp).ConfigureAwait(false);
⋮----
return await this.GetGatewayInfoAsync().ConfigureAwait(false);
⋮----
var timer = new Stopwatch();
timer.Start();
⋮----
var jo = JObject.Parse(await resp.Content.ReadAsStringAsync().ConfigureAwait(false));
⋮----
//There is a delay from parsing here.
timer.Stop();
⋮----
info.SessionBucket.ResetAfter = DateTimeOffset.UtcNow + TimeSpan.FromMilliseconds(info.SessionBucket.ResetAfterInternal);
⋮----
this.Logger.LogError(LoggerEvents.ShardClientError, $&quot;Ratelimit hit, requeuing request to {reqUrl}&quot;);
⋮----
var hs = msg.Headers.ToDictionary(xh =&gt; xh.Key, xh =&gt; string.Join(&quot;\n&quot;, xh.Value), StringComparer.OrdinalIgnoreCase);
⋮----
if (hs.TryGetValue(&quot;Retry-After&quot;, out var retryAfterRaw))
waitInterval = int.Parse(retryAfterRaw, CultureInfo.InvariantCulture);
⋮----
await Task.Delay(waitInterval).ConfigureAwait(false);
⋮----
///     Gets the version string.
⋮----
var a = typeof(DiscordShardedClient).GetTypeInfo().Assembly;
⋮----
var vs = v.ToString(3);
⋮----
///     Gets the name of the used bot library.
⋮----
///     Connects a shard.
⋮----
/// &lt;param name=&quot;i&quot;&gt;The shard id.&lt;/param&gt;
private async Task ConnectShardAsync(int i)
⋮----
if (!this._shards.TryGetValue(i, out var client))
⋮----
this.HookEventHandlers(client);
⋮----
await client.ConnectAsync().ConfigureAwait(false);
this.Logger.LogInformation(LoggerEvents.ShardStartup, &quot;Booted shard {0}.&quot;, i);
⋮----
///     Stops all shards.
⋮----
/// &lt;param name=&quot;enableLogger&quot;&gt;Whether to enable the logger.&lt;/param&gt;
private Task InternalStopAsync(bool enableLogger = true)
⋮----
throw new InvalidOperationException(&quot;This client has not been started.&quot;);
⋮----
this.Logger.LogInformation(LoggerEvents.ShardShutdown, &quot;Disposing {0} shards.&quot;, this._shards.Count);
⋮----
if (this._shards.TryGetValue(i, out var client))
⋮----
this.UnhookEventHandlers(client);
⋮----
client.Dispose();
⋮----
this.Logger.LogInformation(LoggerEvents.ShardShutdown, &quot;Disconnected shard {0}.&quot;, i);
⋮----
this._shards.Clear();
⋮----
///     Sets the shard client up internally..
⋮----
private void InternalSetup()
⋮----
///     Hooks the event handlers.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
private void HookEventHandlers(DiscordClient client)
⋮----
///     Unhooks the event handlers.
⋮----
private void UnhookEventHandlers(DiscordClient client)
⋮----
///     Gets the shard id from guilds.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id.&lt;/param&gt;
/// &lt;returns&gt;An int.&lt;/returns&gt;
private int GetShardIdFromGuilds(ulong id)
⋮----
if (s.GuildsInternal.TryGetValue(id, out _))</file><file path="DisCatSharp/Clients/DiscordShardedClient.Events.cs">/// &lt;summary&gt;
///     Represents a discord sharded client.
/// &lt;/summary&gt;
public sealed partial class DiscordShardedClient
⋮----
///     Fired whenever a WebSocket error occurs within the client.
⋮----
add =&gt; this._socketErrored.Register(value);
remove =&gt; this._socketErrored.Unregister(value);
⋮----
///     Fired whenever WebSocket connection is established.
⋮----
add =&gt; this._socketOpened.Register(value);
remove =&gt; this._socketOpened.Unregister(value);
⋮----
///     Fired whenever WebSocket connection is terminated.
⋮----
add =&gt; this._socketClosed.Register(value);
remove =&gt; this._socketClosed.Unregister(value);
⋮----
///     Fired when the client enters ready state.
⋮----
add =&gt; this._ready.Register(value);
remove =&gt; this._ready.Unregister(value);
⋮----
///     Fired whenever a session is resumed.
⋮----
add =&gt; this._resumed.Register(value);
remove =&gt; this._resumed.Unregister(value);
⋮----
///     Fired on received heartbeat ACK.
⋮----
add =&gt; this._heartbeated.Register(value);
remove =&gt; this._heartbeated.Unregister(value);
⋮----
///     Fired when a new channel is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.Guilds&quot; /&gt; intent specified in
///     &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;
⋮----
add =&gt; this._channelCreated.Register(value);
remove =&gt; this._channelCreated.Unregister(value);
⋮----
///     Fired when a channel is updated.
⋮----
add =&gt; this._channelUpdated.Register(value);
remove =&gt; this._channelUpdated.Unregister(value);
⋮----
///     Fired when a channel is deleted
⋮----
add =&gt; this._channelDeleted.Register(value);
remove =&gt; this._channelDeleted.Unregister(value);
⋮----
///     Fired when a dm channel is deleted
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.DirectMessages&quot; /&gt; intent specified in
⋮----
add =&gt; this._dmChannelDeleted.Register(value);
remove =&gt; this._dmChannelDeleted.Unregister(value);
⋮----
///     Fired whenever a channel&apos;s pinned message list is updated.
⋮----
add =&gt; this._channelPinsUpdated.Register(value);
remove =&gt; this._channelPinsUpdated.Unregister(value);
⋮----
///     Fired whenever a voice channel&apos;s status is updated.
⋮----
add =&gt; this._voiceChannelStatusUpdated.Register(value);
remove =&gt; this._voiceChannelStatusUpdated.Unregister(value);
⋮----
///     Fired when the user joins a new guild.
⋮----
/// &lt;remarks&gt;[alias=&quot;GuildJoined&quot;][alias=&quot;JoinedGuild&quot;]&lt;/remarks&gt;
⋮----
add =&gt; this._guildCreated.Register(value);
remove =&gt; this._guildCreated.Unregister(value);
⋮----
///     Fired when a guild is becoming available.
⋮----
add =&gt; this._guildAvailable.Register(value);
remove =&gt; this._guildAvailable.Unregister(value);
⋮----
///     Fired when a guild is updated.
⋮----
add =&gt; this._guildUpdated.Register(value);
remove =&gt; this._guildUpdated.Unregister(value);
⋮----
///     Fired when the user leaves or is removed from a guild.
⋮----
add =&gt; this._guildDeleted.Register(value);
remove =&gt; this._guildDeleted.Unregister(value);
⋮----
///     Fired when a guild becomes unavailable.
⋮----
add =&gt; this._guildUnavailable.Register(value);
remove =&gt; this._guildUnavailable.Unregister(value);
⋮----
///     Fired when all guilds finish streaming from Discord.
⋮----
add =&gt; this._guildDownloadCompleted.Register(value);
remove =&gt; this._guildDownloadCompleted.Unregister(value);
⋮----
///     Fired when a guilds emojis get updated
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildEmojisAndStickers&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildEmojisUpdated.Register(value);
remove =&gt; this._guildEmojisUpdated.Unregister(value);
⋮----
///     Fired when a guilds stickers get updated
⋮----
add =&gt; this._guildStickersUpdated.Register(value);
remove =&gt; this._guildStickersUpdated.Unregister(value);
⋮----
///     Fired when a guild integration is updated.
⋮----
add =&gt; this._guildIntegrationsUpdated.Register(value);
remove =&gt; this._guildIntegrationsUpdated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets created.
⋮----
add =&gt; this._automodRuleCreated.Register(value);
remove =&gt; this._automodRuleCreated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets updated.
⋮----
add =&gt; this._automodRuleUpdated.Register(value);
remove =&gt; this._automodRuleUpdated.Unregister(value);
⋮----
///     Fired when an auto mod rule gets deleted.
⋮----
add =&gt; this._automodRuleDeleted.Register(value);
remove =&gt; this._automodRuleDeleted.Unregister(value);
⋮----
///     Fired when a rule is triggered and an action is executed.
⋮----
add =&gt; this._automodActionExecuted.Register(value);
remove =&gt; this._automodActionExecuted.Unregister(value);
⋮----
///     Fired when a guild audit log entry was created.
⋮----
add =&gt; this._guildAuditLogEntryCreated.Register(value);
remove =&gt; this._guildAuditLogEntryCreated.Unregister(value);
⋮----
///     Fired when a guild ban gets added
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildModeration&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildBanAdded.Register(value);
remove =&gt; this._guildBanAdded.Unregister(value);
⋮----
///     Fired when a guild ban gets removed
⋮----
add =&gt; this._guildBanRemoved.Register(value);
remove =&gt; this._guildBanRemoved.Unregister(value);
⋮----
///     Fired when a guild member timeout gets added.
⋮----
add =&gt; this._guildMemberTimeoutAdded.Register(value);
remove =&gt; this._guildMemberTimeoutAdded.Unregister(value);
⋮----
///     Fired when a guild member timeout gets changed.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildMemberTimeoutChanged.Register(value);
remove =&gt; this._guildMemberTimeoutChanged.Unregister(value);
⋮----
///     Fired when a guild member timeout gets removed.
⋮----
add =&gt; this._guildMemberTimeoutRemoved.Register(value);
remove =&gt; this._guildMemberTimeoutRemoved.Unregister(value);
⋮----
///     Fired when a scheduled event is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildScheduledEvents&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildScheduledEventCreated.Register(value);
remove =&gt; this._guildScheduledEventCreated.Unregister(value);
⋮----
///     Fired when a scheduled event is updated.
⋮----
add =&gt; this._guildScheduledEventUpdated.Register(value);
remove =&gt; this._guildScheduledEventUpdated.Unregister(value);
⋮----
///     Fired when a scheduled event is deleted.
⋮----
add =&gt; this._guildScheduledEventDeleted.Register(value);
remove =&gt; this._guildScheduledEventDeleted.Unregister(value);
⋮----
///     Fired when a user subscribes to a scheduled event.
⋮----
add =&gt; this._guildScheduledEventUserAdded.Register(value);
remove =&gt; this._guildScheduledEventUserAdded.Unregister(value);
⋮----
///     Fired when a user unsubscribes from a scheduled event.
⋮----
add =&gt; this._guildScheduledEventUserRemoved.Register(value);
remove =&gt; this._guildScheduledEventUserRemoved.Unregister(value);
⋮----
///     Fired when a guild integration is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildIntegrations&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildIntegrationCreated.Register(value);
remove =&gt; this._guildIntegrationCreated.Unregister(value);
⋮----
add =&gt; this._guildIntegrationUpdated.Register(value);
remove =&gt; this._guildIntegrationUpdated.Unregister(value);
⋮----
///     Fired when a guild integration is deleted.
⋮----
add =&gt; this._guildIntegrationDeleted.Register(value);
remove =&gt; this._guildIntegrationDeleted.Unregister(value);
⋮----
///     Fired when a new user joins a guild.
⋮----
add =&gt; this._guildMemberAdded.Register(value);
remove =&gt; this._guildMemberAdded.Unregister(value);
⋮----
///     Fired when a user is removed from a guild (leave/kick/ban).
⋮----
add =&gt; this._guildMemberRemoved.Register(value);
remove =&gt; this._guildMemberRemoved.Unregister(value);
⋮----
///     Fired when a guild member is updated.
⋮----
add =&gt; this._guildMemberUpdated.Register(value);
remove =&gt; this._guildMemberUpdated.Unregister(value);
⋮----
///     Fired in response to Gateway Request Guild Members.
⋮----
add =&gt; this._guildMembersChunk.Register(value);
remove =&gt; this._guildMembersChunk.Unregister(value);
⋮----
///     Fired when a guild role is created.
⋮----
add =&gt; this._guildRoleCreated.Register(value);
remove =&gt; this._guildRoleCreated.Unregister(value);
⋮----
///     Fired when a guild role is updated.
⋮----
add =&gt; this._guildRoleUpdated.Register(value);
remove =&gt; this._guildRoleUpdated.Unregister(value);
⋮----
add =&gt; this._guildRoleDeleted.Register(value);
remove =&gt; this._guildRoleDeleted.Unregister(value);
⋮----
///     Fired when an invite is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildInvites&quot; /&gt; intent specified in
⋮----
add =&gt; this._inviteCreated.Register(value);
remove =&gt; this._inviteCreated.Unregister(value);
⋮----
///     Fired when an invite is deleted.
⋮----
add =&gt; this._inviteDeleted.Register(value);
remove =&gt; this._inviteDeleted.Unregister(value);
⋮----
///     Fired when a message is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessages&quot; /&gt; intent specified in
⋮----
add =&gt; this._messageCreated.Register(value);
remove =&gt; this._messageCreated.Unregister(value);
⋮----
///     Fired when a message is updated.
⋮----
add =&gt; this._messageUpdated.Register(value);
remove =&gt; this._messageUpdated.Unregister(value);
⋮----
///     Fired when a message is deleted.
⋮----
add =&gt; this._messageDeleted.Register(value);
remove =&gt; this._messageDeleted.Unregister(value);
⋮----
///     Fired when multiple messages are deleted at once.
⋮----
add =&gt; this._messageBulkDeleted.Register(value);
remove =&gt; this._messageBulkDeleted.Unregister(value);
⋮----
///     Fired when a message poll vote is added.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessagePolls&quot; /&gt; and
///     &lt;see cref=&quot;DiscordIntents.DirectMessagePolls&quot; /&gt; intent (depending on where u want to receive events from)
///     specified in &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;.
⋮----
add =&gt; this._messagePollVoteAdded.Register(value);
remove =&gt; this._messagePollVoteAdded.Unregister(value);
⋮----
///     Fired when a message poll vote is removed.
⋮----
add =&gt; this._messagePollVoteRemoved.Register(value);
remove =&gt; this._messagePollVoteRemoved.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is created.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildExpressions&quot; /&gt; intent specified in
⋮----
add =&gt; this._guildSoundboardSoundCreated.Register(value);
remove =&gt; this._guildSoundboardSoundCreated.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is updated.
⋮----
add =&gt; this._guildSoundboardSoundUpdated.Register(value);
remove =&gt; this._guildSoundboardSoundUpdated.Unregister(value);
⋮----
///     Fired when a guild soundboard sound is deleted.
⋮----
add =&gt; this._guildSoundboardSoundDeleted.Register(value);
remove =&gt; this._guildSoundboardSoundDeleted.Unregister(value);
⋮----
///     Fired when guild soundboard sounds is updated.
⋮----
add =&gt; this._guildSoundboardSoundsUpdated.Register(value);
remove =&gt; this._guildSoundboardSoundsUpdated.Unregister(value);
⋮----
///     Fired in response to &lt;see cref=&quot;DiscordClient.RequestSoundboardSoundsAsync&quot; /&gt;.
⋮----
add =&gt; this._soundboardSounds.Register(value);
remove =&gt; this._soundboardSounds.Unregister(value);
⋮----
///     Fired when a guild join request is created.
⋮----
add =&gt; this._guildJoinRequestCreated.Register(value);
remove =&gt; this._guildJoinRequestCreated.Unregister(value);
⋮----
///     Fired when a guild join request is updated.
⋮----
add =&gt; this._guildJoinRequestUpdated.Register(value);
remove =&gt; this._guildJoinRequestUpdated.Unregister(value);
⋮----
///     Fired when a guild join request is deleted.
⋮----
add =&gt; this._guildJoinRequestDeleted.Register(value);
remove =&gt; this._guildJoinRequestDeleted.Unregister(value);
⋮----
///     Fired when a reaction gets added to a message.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessageReactions&quot; /&gt; intent specified in
⋮----
add =&gt; this._messageReactionAdded.Register(value);
remove =&gt; this._messageReactionAdded.Unregister(value);
⋮----
///     Fired when a reaction gets removed from a message.
⋮----
add =&gt; this._messageReactionRemoved.Register(value);
remove =&gt; this._messageReactionRemoved.Unregister(value);
⋮----
///     Fired when all reactions get removed from a message.
⋮----
add =&gt; this._messageReactionsCleared.Register(value);
remove =&gt; this._messageReactionsCleared.Unregister(value);
⋮----
///     Fired when all reactions of a specific reaction are removed from a message.
⋮----
add =&gt; this._messageReactionRemovedEmoji.Register(value);
remove =&gt; this._messageReactionRemovedEmoji.Unregister(value);
⋮----
///     Fired when a Stage Instance is created.
⋮----
add =&gt; this._stageInstanceCreated.Register(value);
remove =&gt; this._stageInstanceCreated.Unregister(value);
⋮----
///     Fired when a Stage Instance is updated.
⋮----
add =&gt; this._stageInstanceUpdated.Register(value);
remove =&gt; this._stageInstanceUpdated.Unregister(value);
⋮----
///     Fired when a Stage Instance is deleted.
⋮----
add =&gt; this._stageInstanceDeleted.Register(value);
remove =&gt; this._stageInstanceDeleted.Unregister(value);
⋮----
///     Fired when a thread is created.
⋮----
add =&gt; this._threadCreated.Register(value);
remove =&gt; this._threadCreated.Unregister(value);
⋮----
///     Fired when a thread is updated.
⋮----
add =&gt; this._threadUpdated.Register(value);
remove =&gt; this._threadUpdated.Unregister(value);
⋮----
///     Fired when a thread is deleted.
⋮----
add =&gt; this._threadDeleted.Register(value);
remove =&gt; this._threadDeleted.Unregister(value);
⋮----
///     Fired when a thread member is updated.
⋮----
add =&gt; this._threadListSynced.Register(value);
remove =&gt; this._threadListSynced.Unregister(value);
⋮----
add =&gt; this._threadMemberUpdated.Register(value);
remove =&gt; this._threadMemberUpdated.Unregister(value);
⋮----
///     Fired when the thread members are updated.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; or &lt;see cref=&quot;DiscordIntents.Guilds&quot; /&gt;
///     intent specified in &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;
⋮----
add =&gt; this._threadMembersUpdated.Register(value);
remove =&gt; this._threadMembersUpdated.Unregister(value);
⋮----
///     Fired when a embedded activity has been updated.
⋮----
add =&gt; this._embeddedActivityUpdated.Register(value);
remove =&gt; this._embeddedActivityUpdated.Unregister(value);
⋮----
///     Fired when a presence has been updated.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildPresences&quot; /&gt; intent specified in
⋮----
add =&gt; this._presenceUpdated.Register(value);
remove =&gt; this._presenceUpdated.Unregister(value);
⋮----
///     Fired when the current user updates their settings.
⋮----
add =&gt; this._userSettingsUpdated.Register(value);
remove =&gt; this._userSettingsUpdated.Unregister(value);
⋮----
///     Fired when properties about the current user change.
⋮----
/// &lt;remarks&gt;
///     NB: This event only applies for changes to the &lt;b&gt;current user&lt;/b&gt;, the client that is connected to Discord.
/// &lt;/remarks&gt;
⋮----
add =&gt; this._userUpdated.Register(value);
remove =&gt; this._userUpdated.Unregister(value);
⋮----
///     Fired when someone joins/leaves/moves voice channels.
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildVoiceStates&quot; /&gt; intent specified in
⋮----
add =&gt; this._voiceStateUpdated.Register(value);
remove =&gt; this._voiceStateUpdated.Unregister(value);
⋮----
///     Fired when a guild&apos;s voice server is updated.
⋮----
add =&gt; this._voiceServerUpdated.Register(value);
remove =&gt; this._voiceServerUpdated.Unregister(value);
⋮----
///     Fired when a voice channel effect was send.
⋮----
add =&gt; this._voiceChannelEffectSend.Register(value);
remove =&gt; this._voiceChannelEffectSend.Unregister(value);
⋮----
///     Fired when a new application command is registered.
⋮----
add =&gt; this._applicationCommandCreated.Register(value);
remove =&gt; this._applicationCommandCreated.Unregister(value);
⋮----
///     Fired when an application command is updated.
⋮----
add =&gt; this._applicationCommandUpdated.Register(value);
remove =&gt; this._applicationCommandUpdated.Unregister(value);
⋮----
///     Fired when an application command is deleted.
⋮----
add =&gt; this._applicationCommandDeleted.Register(value);
remove =&gt; this._applicationCommandDeleted.Unregister(value);
⋮----
add =&gt; this._guildApplicationCommandCountUpdated.Register(value);
remove =&gt; this._guildApplicationCommandCountUpdated.Unregister(value);
⋮----
///     Fired when a user uses a context menu.
⋮----
add =&gt; this._contextMenuInteractionCreated.Register(value);
remove =&gt; this._contextMenuInteractionCreated.Unregister(value);
⋮----
///     Fired when application command permissions gets updated.
⋮----
add =&gt; this._applicationCommandPermissionsUpdated.Register(value);
remove =&gt; this._applicationCommandPermissionsUpdated.Unregister(value);
⋮----
///     Fired when an interaction is invoked.
⋮----
add =&gt; this._interactionCreated.Register(value);
remove =&gt; this._interactionCreated.Unregister(value);
⋮----
///     Fired when a component is invoked.
⋮----
add =&gt; this._componentInteractionCreated.Register(value);
remove =&gt; this._componentInteractionCreated.Unregister(value);
⋮----
///     Fired when an entitlement was created.
⋮----
add =&gt; this._entitlementCreated.Register(value);
remove =&gt; this._entitlementCreated.Unregister(value);
⋮----
///     Fired when an entitlement was updated.
⋮----
add =&gt; this._entitlementUpdated.Register(value);
remove =&gt; this._entitlementUpdated.Unregister(value);
⋮----
///     Fired when an entitlement was deleted.
⋮----
add =&gt; this._entitlementDeleted.Register(value);
remove =&gt; this._entitlementDeleted.Unregister(value);
⋮----
///     Fired when an subscription was created.
⋮----
add =&gt; this._subscriptionCreated.Register(value);
remove =&gt; this._subscriptionCreated.Unregister(value);
⋮----
///     Fired when an subscription was updated.
⋮----
add =&gt; this._subscriptionUpdated.Register(value);
remove =&gt; this._subscriptionUpdated.Unregister(value);
⋮----
///     Fired when a user starts typing in a channel.
⋮----
add =&gt; this._typingStarted.Register(value);
remove =&gt; this._typingStarted.Unregister(value);
⋮----
///     Fired when an unknown event gets received.
⋮----
add =&gt; this._unknownEvent.Register(value);
remove =&gt; this._unknownEvent.Unregister(value);
⋮----
///     Fired whenever webhooks update.
⋮----
add =&gt; this._webhooksUpdated.Register(value);
remove =&gt; this._webhooksUpdated.Unregister(value);
⋮----
///     Fired whenever an error occurs within an event handler.
⋮----
add =&gt; this._clientErrored.Register(value);
remove =&gt; this._clientErrored.Unregister(value);
⋮----
///     Handles event errors.
⋮----
/// &lt;param name=&quot;asyncEvent&quot;&gt;The event.&lt;/param&gt;
/// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;The event handler.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
internal void EventErrorHandler&lt;TArgs&gt;(AsyncEvent&lt;DiscordClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;DiscordClient, TArgs&gt; handler, DiscordClient sender, TArgs eventArgs)
where TArgs : AsyncEventArgs
⋮----
this.Logger.LogWarning(LoggerEvents.EventHandlerException, $&quot;An event handler for {asyncEvent.Name} took too long to execute. Defined as \&quot;{handler.Method.ToString().Replace(handler.Method.ReturnType.ToString(), &quot;&quot;).TrimStart()}\&quot; located in \&quot;{handler.Method.DeclaringType}\&quot;.&quot;);
⋮----
this.Logger.LogError(LoggerEvents.EventHandlerException, ex, &quot;Event handler exception for event {0} thrown from {1} (defined in {2})&quot;, asyncEvent.Name, handler.Method, handler.Method.DeclaringType);
this._clientErrored.InvokeAsync(sender, new(this.ShardClients[0].ServiceProvider)
⋮----
}).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Fired on heartbeat attempt cancellation due to too many failed heartbeats.
⋮----
add =&gt; this._zombied.Register(value);
remove =&gt; this._zombied.Unregister(value);
⋮----
///     Fired when a gateway payload is received.
⋮----
add =&gt; this._payloadReceived.Register(value);
remove =&gt; this._payloadReceived.Unregister(value);
⋮----
///     Fired when a event handler throws an exception.
⋮----
private void Goof&lt;TArgs&gt;(AsyncEvent&lt;DiscordClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;DiscordClient, TArgs&gt; handler, DiscordClient sender, TArgs eventArgs)
where TArgs : AsyncEventArgs =&gt; this.Logger.LogCritical(LoggerEvents.EventHandlerException, ex, &quot;Exception event handler {0} (defined in {1}) threw an exception&quot;, handler.Method, handler.Method.DeclaringType);
⋮----
///     Handles the client zombied event.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The event args.&lt;/param&gt;
private Task Client_Zombied(DiscordClient client, ZombiedEventArgs e)
=&gt; this._zombied.InvokeAsync(client, e);
⋮----
///     Handles the guild member timeout removed event.
⋮----
private Task Client_GuildMemberTimeoutRemoved(DiscordClient client, GuildMemberTimeoutRemoveEventArgs e)
=&gt; this._guildMemberTimeoutRemoved.InvokeAsync(client, e);
⋮----
///     Handles the guild member timeout changed event.
⋮----
private Task Client_GuildMemberTimeoutChanged(DiscordClient client, GuildMemberTimeoutUpdateEventArgs e)
=&gt; this._guildMemberTimeoutChanged.InvokeAsync(client, e);
⋮----
///     Handles the guild member timeout added event.
⋮----
private Task Client_GuildMemberTimeoutAdded(DiscordClient client, GuildMemberTimeoutAddEventArgs e)
=&gt; this._guildMemberTimeoutAdded.InvokeAsync(client, e);
⋮----
///     Handles the embedded activity updated event.
⋮----
private Task Client_EmbeddedActivityUpdated(DiscordClient client, EmbeddedActivityUpdateEventArgs e)
=&gt; this._embeddedActivityUpdated.InvokeAsync(client, e);
⋮----
///     Handles the payload received event.
⋮----
private Task Client_PayloadReceived(DiscordClient client, PayloadReceivedEventArgs e)
=&gt; this._payloadReceived.InvokeAsync(client, e);
⋮----
///     Handles the client error event.
⋮----
private Task Client_ClientError(DiscordClient client, ClientErrorEventArgs e)
=&gt; this._clientErrored.InvokeAsync(client, e);
⋮----
///     Handles the socket error event.
⋮----
private Task Client_SocketError(DiscordClient client, SocketErrorEventArgs e)
=&gt; this._socketErrored.InvokeAsync(client, e);
⋮----
///     Handles the socket opened event.
⋮----
private Task Client_SocketOpened(DiscordClient client, SocketEventArgs e)
=&gt; this._socketOpened.InvokeAsync(client, e);
⋮----
///     Handles the socket closed event.
⋮----
private Task Client_SocketClosed(DiscordClient client, SocketCloseEventArgs e)
=&gt; this._socketClosed.InvokeAsync(client, e);
⋮----
///     Handles the ready event.
⋮----
private Task Client_Ready(DiscordClient client, ReadyEventArgs e)
=&gt; this._ready.InvokeAsync(client, e);
⋮----
///     Handles the resumed event.
⋮----
private Task Client_Resumed(DiscordClient client, ReadyEventArgs e)
=&gt; this._resumed.InvokeAsync(client, e);
⋮----
///     Handles the channel created event.
⋮----
private Task Client_ChannelCreated(DiscordClient client, ChannelCreateEventArgs e)
=&gt; this._channelCreated.InvokeAsync(client, e);
⋮----
///     Handles the channel updated event.
⋮----
private Task Client_ChannelUpdated(DiscordClient client, ChannelUpdateEventArgs e)
=&gt; this._channelUpdated.InvokeAsync(client, e);
⋮----
///     Handles the channel deleted.
⋮----
private Task Client_ChannelDeleted(DiscordClient client, ChannelDeleteEventArgs e)
=&gt; this._channelDeleted.InvokeAsync(client, e);
⋮----
///     Handles the dm channel deleted event.
⋮----
private Task Client_DMChannelDeleted(DiscordClient client, DmChannelDeleteEventArgs e)
=&gt; this._dmChannelDeleted.InvokeAsync(client, e);
⋮----
///     Handles the channel pins updated event.
⋮----
private Task Client_ChannelPinsUpdated(DiscordClient client, ChannelPinsUpdateEventArgs e)
=&gt; this._channelPinsUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild created event.
⋮----
private Task Client_GuildCreated(DiscordClient client, GuildCreateEventArgs e)
=&gt; this._guildCreated.InvokeAsync(client, e);
⋮----
///     Handles the guild available event.
⋮----
private Task Client_GuildAvailable(DiscordClient client, GuildCreateEventArgs e)
=&gt; this._guildAvailable.InvokeAsync(client, e);
⋮----
///     Handles the guild updated event.
⋮----
private Task Client_GuildUpdated(DiscordClient client, GuildUpdateEventArgs e)
=&gt; this._guildUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild deleted event.
⋮----
private Task Client_GuildDeleted(DiscordClient client, GuildDeleteEventArgs e)
=&gt; this._guildDeleted.InvokeAsync(client, e);
⋮----
///     Handles the guild unavailable event.
⋮----
private Task Client_GuildUnavailable(DiscordClient client, GuildDeleteEventArgs e)
=&gt; this._guildUnavailable.InvokeAsync(client, e);
⋮----
///     Handles the guild download completed event.
⋮----
private Task Client_GuildDownloadCompleted(DiscordClient client, GuildDownloadCompletedEventArgs e)
=&gt; this._guildDownloadCompleted.InvokeAsync(client, e);
⋮----
///     Handles the message created event.
⋮----
private Task Client_MessageCreated(DiscordClient client, MessageCreateEventArgs e)
=&gt; this._messageCreated.InvokeAsync(client, e);
⋮----
///     Handles the invite created event.
⋮----
private Task Client_InviteCreated(DiscordClient client, InviteCreateEventArgs e)
=&gt; this._inviteCreated.InvokeAsync(client, e);
⋮----
///     Handles the invite deleted event.
⋮----
private Task Client_InviteDeleted(DiscordClient client, InviteDeleteEventArgs e)
=&gt; this._inviteDeleted.InvokeAsync(client, e);
⋮----
///     Handles the presence update event.
⋮----
private Task Client_PresenceUpdate(DiscordClient client, PresenceUpdateEventArgs e)
=&gt; this._presenceUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild ban add event.
⋮----
private Task Client_GuildBanAdd(DiscordClient client, GuildBanAddEventArgs e)
=&gt; this._guildBanAdded.InvokeAsync(client, e);
⋮----
///     Handles the guild ban remove event.
⋮----
private Task Client_GuildBanRemove(DiscordClient client, GuildBanRemoveEventArgs e)
=&gt; this._guildBanRemoved.InvokeAsync(client, e);
⋮----
///     Handles the guild emojis update event.
⋮----
private Task Client_GuildEmojisUpdate(DiscordClient client, GuildEmojisUpdateEventArgs e)
=&gt; this._guildEmojisUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild stickers update event.
⋮----
private Task Client_GuildStickersUpdate(DiscordClient client, GuildStickersUpdateEventArgs e)
=&gt; this._guildStickersUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild integrations update event.
⋮----
private Task Client_GuildIntegrationsUpdate(DiscordClient client, GuildIntegrationsUpdateEventArgs e)
=&gt; this._guildIntegrationsUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild member add event.
⋮----
private Task Client_GuildMemberAdd(DiscordClient client, GuildMemberAddEventArgs e)
=&gt; this._guildMemberAdded.InvokeAsync(client, e);
⋮----
///     Handles the guild member remove event.
⋮----
private Task Client_GuildMemberRemove(DiscordClient client, GuildMemberRemoveEventArgs e)
=&gt; this._guildMemberRemoved.InvokeAsync(client, e);
⋮----
///     Handles the guild member update event.
⋮----
private Task Client_GuildMemberUpdate(DiscordClient client, GuildMemberUpdateEventArgs e)
=&gt; this._guildMemberUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild role create event.
⋮----
private Task Client_GuildRoleCreate(DiscordClient client, GuildRoleCreateEventArgs e)
=&gt; this._guildRoleCreated.InvokeAsync(client, e);
⋮----
///     Handles the guild role update event.
⋮----
private Task Client_GuildRoleUpdate(DiscordClient client, GuildRoleUpdateEventArgs e)
=&gt; this._guildRoleUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild role delete event.
⋮----
private Task Client_GuildRoleDelete(DiscordClient client, GuildRoleDeleteEventArgs e)
=&gt; this._guildRoleDeleted.InvokeAsync(client, e);
⋮----
///     Handles the message update event.
⋮----
private Task Client_MessageUpdate(DiscordClient client, MessageUpdateEventArgs e)
=&gt; this._messageUpdated.InvokeAsync(client, e);
⋮----
///     Handles the message delete event.
⋮----
private Task Client_MessageDelete(DiscordClient client, MessageDeleteEventArgs e)
=&gt; this._messageDeleted.InvokeAsync(client, e);
⋮----
///     Handles the message bulk delete event.
⋮----
private Task Client_MessageBulkDelete(DiscordClient client, MessageBulkDeleteEventArgs e)
=&gt; this._messageBulkDeleted.InvokeAsync(client, e);
⋮----
///     Handles the typing start event.
⋮----
private Task Client_TypingStart(DiscordClient client, TypingStartEventArgs e)
=&gt; this._typingStarted.InvokeAsync(client, e);
⋮----
///     Handles the user settings update event.
⋮----
private Task Client_UserSettingsUpdate(DiscordClient client, UserSettingsUpdateEventArgs e)
=&gt; this._userSettingsUpdated.InvokeAsync(client, e);
⋮----
///     Handles the user update event.
⋮----
private Task Client_UserUpdate(DiscordClient client, UserUpdateEventArgs e)
=&gt; this._userUpdated.InvokeAsync(client, e);
⋮----
///     Handles the voice state update event.
⋮----
private Task Client_VoiceStateUpdate(DiscordClient client, VoiceStateUpdateEventArgs e)
=&gt; this._voiceStateUpdated.InvokeAsync(client, e);
⋮----
///     Handles the voice server update event.
⋮----
private Task Client_VoiceServerUpdate(DiscordClient client, VoiceServerUpdateEventArgs e)
=&gt; this._voiceServerUpdated.InvokeAsync(client, e);
⋮----
///     Handles the voice channel effect send event.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
private Task Client_VoiceChannelEffectSend(DiscordClient client, VoiceChannelEffectSendEventArgs e)
=&gt; this._voiceChannelEffectSend.InvokeAsync(client, e);
⋮----
///     Handles the guild members chunk event.
⋮----
private Task Client_GuildMembersChunk(DiscordClient client, GuildMembersChunkEventArgs e)
=&gt; this._guildMembersChunk.InvokeAsync(client, e);
⋮----
///     Handles the unknown events.
⋮----
private Task Client_UnknownEvent(DiscordClient client, UnknownEventArgs e)
=&gt; this._unknownEvent.InvokeAsync(client, e);
⋮----
///     Handles the message reaction add event.
⋮----
private Task Client_MessageReactionAdd(DiscordClient client, MessageReactionAddEventArgs e)
=&gt; this._messageReactionAdded.InvokeAsync(client, e);
⋮----
///     Handles the message reaction remove event.
⋮----
private Task Client_MessageReactionRemove(DiscordClient client, MessageReactionRemoveEventArgs e)
=&gt; this._messageReactionRemoved.InvokeAsync(client, e);
⋮----
///     Handles the message reaction remove all event.
⋮----
private Task Client_MessageReactionRemoveAll(DiscordClient client, MessageReactionsClearEventArgs e)
=&gt; this._messageReactionsCleared.InvokeAsync(client, e);
⋮----
///     Handles the message reaction removed emoji event.
⋮----
private Task Client_MessageReactionRemovedEmoji(DiscordClient client, MessageReactionRemoveEmojiEventArgs e)
=&gt; this._messageReactionRemovedEmoji.InvokeAsync(client, e);
⋮----
///     Handles the interaction create event.
⋮----
private Task Client_InteractionCreated(DiscordClient client, InteractionCreateEventArgs e)
=&gt; this._interactionCreated.InvokeAsync(client, e);
⋮----
///     Handles the entitlement create event.
⋮----
private Task Client_EntitlementCreated(DiscordClient client, EntitlementCreateEventArgs e)
=&gt; this._entitlementCreated.InvokeAsync(client, e);
⋮----
///     Handles the entitlement update event.
⋮----
private Task Client_EntitlementUpdated(DiscordClient client, EntitlementUpdateEventArgs e)
=&gt; this._entitlementUpdated.InvokeAsync(client, e);
⋮----
///     Handles the entitlement delete event.
⋮----
private Task Client_EntitlementDeleted(DiscordClient client, EntitlementDeleteEventArgs e)
=&gt; this._entitlementDeleted.InvokeAsync(client, e);
⋮----
///     Handles the subscription create event.
⋮----
private Task Client_SubscriptionCreated(DiscordClient client, SubscriptionCreateEventArgs e)
=&gt; this._subscriptionCreated.InvokeAsync(client, e);
⋮----
///     Handles the subscription update event.
⋮----
private Task Client_SubscriptionUpdated(DiscordClient client, SubscriptionUpdateEventArgs e)
=&gt; this._subscriptionUpdated.InvokeAsync(client, e);
⋮----
///     Handles the component interaction create event.
⋮----
private Task Client_ComponentInteractionCreate(DiscordClient client, ComponentInteractionCreateEventArgs e)
=&gt; this._componentInteractionCreated.InvokeAsync(client, e);
⋮----
///     Handles the context menu interaction create event.
⋮----
private Task Client_ContextMenuInteractionCreate(DiscordClient client, ContextMenuInteractionCreateEventArgs e)
=&gt; this._contextMenuInteractionCreated.InvokeAsync(client, e);
⋮----
///     Handles the webhooks update event.
⋮----
private Task Client_WebhooksUpdate(DiscordClient client, WebhooksUpdateEventArgs e)
=&gt; this._webhooksUpdated.InvokeAsync(client, e);
⋮----
///     Handles the heartbeated event.
⋮----
private Task Client_HeartBeated(DiscordClient client, HeartbeatEventArgs e)
=&gt; this._heartbeated.InvokeAsync(client, e);
⋮----
///     Handles the application command created event.
⋮----
private Task Client_ApplicationCommandCreated(DiscordClient client, ApplicationCommandEventArgs e)
=&gt; this._applicationCommandCreated.InvokeAsync(client, e);
⋮----
///     Handles the application command updated event.
⋮----
private Task Client_ApplicationCommandUpdated(DiscordClient client, ApplicationCommandEventArgs e)
=&gt; this._applicationCommandUpdated.InvokeAsync(client, e);
⋮----
///     Handles the application command deleted event.
⋮----
private Task Client_ApplicationCommandDeleted(DiscordClient client, ApplicationCommandEventArgs e)
=&gt; this._applicationCommandDeleted.InvokeAsync(client, e);
⋮----
///     Handles the guild application command count updated event.
⋮----
private Task Client_GuildApplicationCommandCountUpdated(DiscordClient client, GuildApplicationCommandCountEventArgs e)
=&gt; this._guildApplicationCommandCountUpdated.InvokeAsync(client, e);
⋮----
///     Handles the application command permissions updated event.
⋮----
private Task Client_ApplicationCommandPermissionsUpdated(DiscordClient client, ApplicationCommandPermissionsUpdateEventArgs e)
=&gt; this._applicationCommandPermissionsUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild integration created event.
⋮----
private Task Client_GuildIntegrationCreated(DiscordClient client, GuildIntegrationCreateEventArgs e)
=&gt; this._guildIntegrationCreated.InvokeAsync(client, e);
⋮----
///     Handles the guild integration updated event.
⋮----
private Task Client_GuildIntegrationUpdated(DiscordClient client, GuildIntegrationUpdateEventArgs e)
=&gt; this._guildIntegrationUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild integration deleted event.
⋮----
private Task Client_GuildIntegrationDeleted(DiscordClient client, GuildIntegrationDeleteEventArgs e)
=&gt; this._guildIntegrationDeleted.InvokeAsync(client, e);
⋮----
///     Handles the stage instance created event.
⋮----
private Task Client_StageInstanceCreated(DiscordClient client, StageInstanceCreateEventArgs e)
=&gt; this._stageInstanceCreated.InvokeAsync(client, e);
⋮----
///     Handles the stage instance updated event.
⋮----
private Task Client_StageInstanceUpdated(DiscordClient client, StageInstanceUpdateEventArgs e)
=&gt; this._stageInstanceUpdated.InvokeAsync(client, e);
⋮----
///     Handles the stage instance deleted event.
⋮----
private Task Client_StageInstanceDeleted(DiscordClient client, StageInstanceDeleteEventArgs e)
=&gt; this._stageInstanceDeleted.InvokeAsync(client, e);
⋮----
///     Handles the thread created event.
⋮----
private Task Client_ThreadCreated(DiscordClient client, ThreadCreateEventArgs e)
=&gt; this._threadCreated.InvokeAsync(client, e);
⋮----
///     Handles the thread updated event.
⋮----
private Task Client_ThreadUpdated(DiscordClient client, ThreadUpdateEventArgs e)
=&gt; this._threadUpdated.InvokeAsync(client, e);
⋮----
///     Handles the thread deleted event.
⋮----
private Task Client_ThreadDeleted(DiscordClient client, ThreadDeleteEventArgs e)
=&gt; this._threadDeleted.InvokeAsync(client, e);
⋮----
///     Handles the thread list synced event.
⋮----
private Task Client_ThreadListSynced(DiscordClient client, ThreadListSyncEventArgs e)
=&gt; this._threadListSynced.InvokeAsync(client, e);
⋮----
///     Handles the thread member updated event.
⋮----
private Task Client_ThreadMemberUpdated(DiscordClient client, ThreadMemberUpdateEventArgs e)
=&gt; this._threadMemberUpdated.InvokeAsync(client, e);
⋮----
///     Handles the thread members updated event.
⋮----
private Task Client_ThreadMembersUpdated(DiscordClient client, ThreadMembersUpdateEventArgs e)
=&gt; this._threadMembersUpdated.InvokeAsync(client, e);
⋮----
///     Handles the scheduled event created event.
⋮----
private Task Client_GuildScheduledEventCreated(DiscordClient client, GuildScheduledEventCreateEventArgs e)
=&gt; this._guildScheduledEventCreated.InvokeAsync(client, e);
⋮----
///     Handles the scheduled event updated event.
⋮----
private Task Client_GuildScheduledEventUpdated(DiscordClient client, GuildScheduledEventUpdateEventArgs e)
=&gt; this._guildScheduledEventUpdated.InvokeAsync(client, e);
⋮----
///     Handles the scheduled event deleted event.
⋮----
private Task Client_GuildScheduledEventDeleted(DiscordClient client, GuildScheduledEventDeleteEventArgs e)
=&gt; this._guildScheduledEventDeleted.InvokeAsync(client, e);
⋮----
///     Handles the scheduled event user added event.
⋮----
private Task Client_GuildScheduledEventUserAdded(DiscordClient client, GuildScheduledEventUserAddEventArgs e)
=&gt; this._guildScheduledEventUserAdded.InvokeAsync(client, e);
⋮----
///     Handles the scheduled event user removed event.
⋮----
private Task Client_GuildScheduledEventUserRemoved(DiscordClient client, GuildScheduledEventUserRemoveEventArgs e)
=&gt; this._guildScheduledEventUserRemoved.InvokeAsync(client, e);
⋮----
///     Handles the automod rule created event.
⋮----
private Task Client_AutomodRuleCreated(DiscordClient client, AutomodRuleCreateEventArgs e)
=&gt; this._automodRuleCreated.InvokeAsync(client, e);
⋮----
///     Handles the automod rule updated event.
⋮----
private Task Client_AutomodRuleUpdated(DiscordClient client, AutomodRuleUpdateEventArgs e)
=&gt; this._automodRuleUpdated.InvokeAsync(client, e);
⋮----
///     Handles the automod rule deleted event.
⋮----
private Task Client_AutomodRuleDeleted(DiscordClient client, AutomodRuleDeleteEventArgs e)
=&gt; this._automodRuleDeleted.InvokeAsync(client, e);
⋮----
///     Handles the automod action executed event.
⋮----
private Task Client_AutomodActionExecuted(DiscordClient client, AutomodActionExecutedEventArgs e)
=&gt; this._automodActionExecuted.InvokeAsync(client, e);
⋮----
///     Handles the guild audit log created event.
⋮----
private Task Client_GuildAuditLogEntryCreated(DiscordClient client, GuildAuditLogEntryCreateEventArgs e)
=&gt; this._guildAuditLogEntryCreated.InvokeAsync(client, e);
⋮----
///     Handles the voice channel status updated event.
⋮----
private Task Client_VoiceChannelStatusUpdated(DiscordClient client, VoiceChannelStatusUpdateEventArgs e)
=&gt; this._voiceChannelStatusUpdated.InvokeAsync(client, e);
⋮----
///     Handles the message poll vote add event.
⋮----
private Task Client_MessagePollVoteAdded(DiscordClient client, MessagePollVoteAddEventArgs e)
=&gt; this._messagePollVoteAdded.InvokeAsync(client, e);
⋮----
///     Handles the message poll vote remove event.
⋮----
private Task Client_MessagePollVoteRemoved(DiscordClient client, MessagePollVoteRemoveEventArgs e)
=&gt; this._messagePollVoteRemoved.InvokeAsync(client, e);
⋮----
///     Handles the guild soundboard sound created event.
⋮----
private Task Client_SoundboardSoundCreated(DiscordClient client, GuildSoundboardSoundCreateEventArgs e)
=&gt; this._guildSoundboardSoundCreated.InvokeAsync(client, e);
⋮----
///     Handles the guild soundboard sound updated event.
⋮----
private Task Client_SoundboardSoundUpdated(DiscordClient client, GuildSoundboardSoundUpdateEventArgs e)
=&gt; this._guildSoundboardSoundUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild soundboard sound deleted event.
⋮----
private Task Client_SoundboardSoundDeleted(DiscordClient client, GuildSoundboardSoundDeleteEventArgs e)
=&gt; this._guildSoundboardSoundDeleted.InvokeAsync(client, e);
⋮----
///     Handles the guild soundboard sounds updated event.
⋮----
private Task Client_SoundboardSoundsUpdated(DiscordClient client, GuildSoundboardSoundsUpdateEventArgs e)
=&gt; this._guildSoundboardSoundsUpdated.InvokeAsync(client, e);
⋮----
///     Handles the soundboard sounds event.
⋮----
private Task Client_SoundboardSounds(DiscordClient client, SoundboardSoundsEventArgs e)
=&gt; this._soundboardSounds.InvokeAsync(client, e);
⋮----
///     Handles the guild join request created event.
⋮----
private Task Client_GuildJoinRequestCreated(DiscordClient client, GuildJoinRequestCreateEventArgs e)
=&gt; this._guildJoinRequestCreated.InvokeAsync(client, e);
⋮----
///     Handles the guild join request updated event.
⋮----
private Task Client_GuildJoinRequestUpdated(DiscordClient client, GuildJoinRequestUpdateEventArgs e)
=&gt; this._guildJoinRequestUpdated.InvokeAsync(client, e);
⋮----
///     Handles the guild join request deleted event.
⋮----
private Task Client_GuildJoinRequestDeleted(DiscordClient client, GuildJoinRequestDeleteEventArgs e)
=&gt; this._guildJoinRequestDeleted.InvokeAsync(client, e);</file><file path="DisCatSharp/Clients/DiscordWebhookClient.cs">/// &lt;summary&gt;
///     Represents a webhook-only client. This client can be used to execute Discord Webhooks.
/// &lt;/summary&gt;
public class DiscordWebhookClient
⋮----
///     Gets the API client for this webhook client.
⋮----
internal readonly DiscordApiClient ApiClient;
⋮----
///     Gets the log timestamp format for this webhook client.
⋮----
///     Gets the minimum log level for this webhook client.
⋮----
internal readonly LogLevel MinimumLogLevel;
⋮----
///     Creates a new webhook client.
⋮----
///     Creates a new webhook client, with specified HTTP proxy, timeout, and logging settings.
⋮----
/// &lt;param name=&quot;proxy&quot;&gt;The proxy to use for HTTP connections. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;
///     The optional timeout to use for HTTP requests. Set to
///     &lt;see cref=&quot;System.Threading.Timeout.InfiniteTimeSpan&quot; /&gt; to disable timeouts. Defaults to null.
/// &lt;/param&gt;
/// &lt;param name=&quot;useRelativeRateLimit&quot;&gt;
///     Whether to use the system clock for computing rate limit resets. See
///     &lt;see cref=&quot;DiscordConfiguration.UseRelativeRatelimit&quot; /&gt; for more details. Defaults to true.
⋮----
/// &lt;param name=&quot;loggerFactory&quot;&gt;The optional logging factory to use for this client. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;minimumLogLevel&quot;&gt;The minimum logging level for messages. Defaults to information.&lt;/param&gt;
/// &lt;param name=&quot;logTimestampFormat&quot;&gt;The timestamp format to use for the logger.&lt;/param&gt;
⋮----
loggerFactory = new DefaultLoggerFactory();
loggerFactory.AddProvider(new DefaultLoggerProvider(this));
⋮----
var parsedTimeout = timeout ?? TimeSpan.FromSeconds(10);
⋮----
///     Gets the list of registered webhooks.
⋮----
///     Gets the logger for this client.
⋮----
///     Gets the collection of registered webhooks.
⋮----
///     Gets or sets the username for registered webhooks. Note that this only takes effect when broadcasting.
⋮----
///     Gets or set the avatar for registered webhooks. Note that this only takes effect when broadcasting.
⋮----
///     Registers a webhook with this client. This retrieves a webhook based on the ID and token supplied.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The ID of the webhook to add.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The token of the webhook to add.&lt;/param&gt;
/// &lt;returns&gt;The registered webhook.&lt;/returns&gt;
public async Task&lt;DiscordWebhook&gt; AddWebhookAsync(ulong id, string token)
⋮----
if (string.IsNullOrWhiteSpace(token))
throw new ArgumentNullException(nameof(token));
⋮----
token = token.Trim();
⋮----
if (this.Hooks.Any(x =&gt; x.Id == id))
throw new InvalidOperationException(&quot;This webhook is registered with this client.&quot;);
⋮----
var wh = await this.ApiClient.GetWebhookWithTokenAsync(id, token).ConfigureAwait(false);
this.Hooks.Add(wh);
⋮----
///     Registers a webhook with this client. This retrieves a webhook from webhook URL.
⋮----
/// &lt;param name=&quot;url&quot;&gt;URL of the webhook to retrieve. This URL must contain both ID and token.&lt;/param&gt;
⋮----
public Task&lt;DiscordWebhook&gt; AddWebhookAsync(Uri url)
⋮----
ArgumentNullException.ThrowIfNull(url);
⋮----
var m = DiscordRegEx.WebhookRegex().Match(url.ToString());
⋮----
throw new ArgumentException(&quot;Invalid webhook URL supplied.&quot;, nameof(url));
⋮----
if (!ulong.TryParse(idRaw.Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var id))
⋮----
return this.AddWebhookAsync(id, token);
⋮----
///     Registers a webhook with this client. This retrieves a webhook using the supplied full discord client.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the webhook to register.&lt;/param&gt;
/// &lt;param name=&quot;client&quot;&gt;Discord client to which the webhook will belong.&lt;/param&gt;
⋮----
public async Task&lt;DiscordWebhook&gt; AddWebhookAsync(ulong id, BaseDiscordClient client)
⋮----
ArgumentNullException.ThrowIfNull(client);
⋮----
throw new ArgumentException(&quot;This webhook is already registered with this client.&quot;);
⋮----
var wh = await client.ApiClient.GetWebhookAsync(id).ConfigureAwait(false);
⋮----
///     Registers a webhook with this client. This reuses the supplied webhook object.
⋮----
/// &lt;param name=&quot;webhook&quot;&gt;Webhook to register.&lt;/param&gt;
⋮----
public DiscordWebhook AddWebhook(DiscordWebhook webhook)
⋮----
ArgumentNullException.ThrowIfNull(webhook);
⋮----
if (this.Hooks.Any(x =&gt; x.Id == webhook.Id))
⋮----
this.Hooks.Add(webhook);
⋮----
///     Unregisters a webhook with this client.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the webhook to unregister.&lt;/param&gt;
/// &lt;returns&gt;The unregistered webhook.&lt;/returns&gt;
public DiscordWebhook RemoveWebhook(ulong id)
⋮----
if (this.Hooks.All(x =&gt; x.Id != id))
throw new ArgumentException(&quot;This webhook is not registered with this client.&quot;);
⋮----
var wh = this.GetRegisteredWebhook(id);
this.Hooks.Remove(wh!);
⋮----
///     Gets a registered webhook with specified ID.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the registered webhook to retrieve.&lt;/param&gt;
/// &lt;returns&gt;The requested webhook.&lt;/returns&gt;
public DiscordWebhook? GetRegisteredWebhook(ulong id)
=&gt; this.Hooks.FirstOrDefault(xw =&gt; xw.Id == id);
⋮----
///     Broadcasts a message to all registered webhooks.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;Webhook builder filled with data to send.&lt;/param&gt;
/// &lt;returns&gt;
///     A dictionary of &lt;see cref=&quot;DisCatSharp.Entities.DiscordWebhook&quot; /&gt;s and
///     &lt;see cref=&quot;DisCatSharp.Entities.DiscordMessage&quot; /&gt;s.
/// &lt;/returns&gt;
public async Task&lt;Dictionary&lt;DiscordWebhook, DiscordMessage&gt;&gt; BroadcastMessageAsync(DiscordWebhookBuilder builder)
⋮----
builder = builder.WithUsername(this.Username);
⋮----
builder = builder.WithAvatarUrl(this.AvatarUrl);
messages.Add(hook, await hook.ExecuteAsync(builder).ConfigureAwait(false));
⋮----
deadHooks.Add(hook);
⋮----
// Removing dead webhooks from collection
⋮----
this.Hooks.Remove(xwh);
⋮----
///     Disposes the client.
⋮----
this.Hooks.Clear();
⋮----
this.ApiClient.Rest.Dispose();</file><file path="DisCatSharp/DisCatSharp.csproj.DotSettings">&lt;wpf:ResourceDictionary xml:space=&quot;preserve&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot; xmlns:ss=&quot;urn:shemas-jetbrains-com:settings-storage-xaml&quot; xmlns:wpf=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
	&lt;s:String x:Key=&quot;/Default/CodeInspection/Daemon/ConfigureAwaitAnalysisMode/@EntryValue&quot;&gt;Library&lt;/s:String&gt;&lt;/wpf:ResourceDictionary&gt;</file><file path="DisCatSharp/DiscordConfiguration.cs">/// &lt;summary&gt;
///     Represents configuration for &lt;see cref=&quot;DiscordClient&quot; /&gt; and &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordConfiguration
⋮----
///     The exception we track with sentry.
⋮----
///     Sets the token used to identify the client (protected).
⋮----
///     Sets the factory method and creates a new instances of the &lt;see cref=&quot;DcsUdpClient&quot; /&gt;.
⋮----
private UdpClientFactoryDelegate _udpClientFactory = DcsUdpClient.CreateNew;
⋮----
///     Sets the factory method and creates a new instances of the &lt;see cref=&quot;WebSocketClient&quot; /&gt;.
⋮----
private WebSocketClientFactoryDelegate _webSocketClientFactory = WebSocketClient.CreateNew;
⋮----
///     Creates a new configuration with default values.
⋮----
///     Utilized via dependency injection pipeline.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The service provider.&lt;/param&gt;
⋮----
///     Creates a clone of another discord configuration.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Client configuration to clone.&lt;/param&gt;
⋮----
///     Sets the token used to identify the client.
⋮----
if (string.IsNullOrWhiteSpace(value))
throw new ArgumentNullException(nameof(value), &quot;Token cannot be null, empty, or all whitespace.&quot;);
⋮----
this._token = value.Trim();
⋮----
///     &lt;para&gt;Sets the type of the token used to identify the client.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see cref=&quot;Enums.TokenType.Bot&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the minimum logging level for messages.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see cref=&quot;LogLevel.Information&quot; /&gt;.&lt;/para&gt;
⋮----
///     Overwrites the api version.
///     Defaults to 10.
⋮----
///     &lt;para&gt;
///         Sets whether to rely on Discord for NTP (Network Time Protocol) synchronization with the
///         &quot;X-Ratelimit-Reset-After&quot; header.
///     &lt;/para&gt;
⋮----
///         If the system clock is unsynced, setting this to true will ensure ratelimits are synced with Discord and
///         reduce the risk of hitting one.
⋮----
///     &lt;para&gt;This should only be set to false if the system clock is synced with NTP.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Allows you to overwrite the time format used by the internal debug logger.&lt;/para&gt;
⋮----
///         Only applicable when &lt;see cref=&quot;LoggerFactory&quot; /&gt; is set left at default value. Defaults to ISO 8601-like
///         format.
⋮----
///     &lt;para&gt;Sets the member count threshold at which guilds are considered large.&lt;/para&gt;
///     &lt;para&gt;Defaults to 250.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets whether to automatically reconnect in case a connection is lost.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the ID of the shard to connect to.&lt;/para&gt;
///     &lt;para&gt;If not sharding, or sharding automatically, this value should be left with the default value of 0.&lt;/para&gt;
⋮----
///         Sets the total number of shards the bot is on. If not sharding, this value should be left with a default
///         value of 1.
⋮----
///         If sharding automatically, this value will indicate how many shards to boot. If left default for automatic
///         sharding, the client will determine the shard count automatically.
⋮----
///     &lt;para&gt;Sets the level of compression for WebSocket traffic.&lt;/para&gt;
⋮----
///         Disabling this option will increase the amount of traffic sent via WebSocket. Setting
///         &lt;see cref=&quot;GatewayCompressionLevel.Payload&quot; /&gt; will enable compression for READY and GUILD_CREATE payloads.
///         Setting &lt;see cref=&quot;GatewayCompressionLevel.Stream&quot; /&gt; will enable compression for the entire WebSocket stream,
///         drastically reducing amount of traffic.
⋮----
///     &lt;para&gt;Defaults to &lt;see cref=&quot;GatewayCompressionLevel.Stream&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the size of the global message cache.&lt;/para&gt;
///     &lt;para&gt;Setting this to 0 will disable message caching entirely.&lt;/para&gt;
///     &lt;para&gt;Defaults to 1024.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the proxy to use for HTTP and WebSocket connections to Discord.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the timeout for HTTP requests.&lt;/para&gt;
///     &lt;para&gt;Set to &lt;see cref=&quot;System.Threading.Timeout.InfiniteTimeSpan&quot; /&gt; to disable timeouts.&lt;/para&gt;
///     &lt;para&gt;Defaults to 20 seconds.&lt;/para&gt;
⋮----
public TimeSpan HttpTimeout { internal get; set; } = TimeSpan.FromSeconds(20);
⋮----
///     &lt;para&gt;Defines that the client should attempt to reconnect indefinitely.&lt;/para&gt;
///     &lt;para&gt;This is typically a very bad idea to set to &lt;c&gt;true&lt;/c&gt;, as it will swallow all connection errors.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Defines that the client should attempt to fetch application emojis on startup.&lt;/para&gt;
⋮----
///     Sets whether the client should attempt to cache members if exclusively using unprivileged intents.
⋮----
///         This will only take effect if there are no &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; or
///         &lt;see cref=&quot;DiscordIntents.GuildPresences&quot; /&gt;
///         intents specified. Otherwise, this will always be overwritten to true.
⋮----
///     Sets whether a shard logger is attached.
⋮----
///     &lt;para&gt;Sets the gateway intents for this client.&lt;/para&gt;
///     &lt;para&gt;If set, the client will only receive events that they specify with intents.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see cref=&quot;DiscordIntents.AllUnprivileged&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the factory method used to create instances of WebSocket clients.&lt;/para&gt;
⋮----
///         Use &lt;see cref=&quot;WebSocketClient.CreateNew&quot; /&gt; and equivalents on other implementations to switch out client
///         implementations.
⋮----
///     &lt;para&gt;Defaults to &lt;see cref=&quot;WebSocketClient.CreateNew&quot; /&gt;.&lt;/para&gt;
⋮----
set =&gt; this._webSocketClientFactory = value ?? throw new InvalidOperationException(&quot;You need to supply a valid WebSocket client factory method.&quot;);
⋮----
///     &lt;para&gt;Sets the factory method used to create instances of UDP clients.&lt;/para&gt;
⋮----
///         Use &lt;see cref=&quot;DcsUdpClient.CreateNew&quot; /&gt; and equivalents on other implementations to switch out client
⋮----
///     &lt;para&gt;Defaults to &lt;see cref=&quot;DcsUdpClient.CreateNew&quot; /&gt;.&lt;/para&gt;
⋮----
set =&gt; this._udpClientFactory = value ?? throw new InvalidOperationException(&quot;You need to supply a valid UDP client factory method.&quot;);
⋮----
///     &lt;para&gt;Sets the logger implementation to use.&lt;/para&gt;
///     &lt;para&gt;To create your own logger, implement the &lt;see cref=&quot;Microsoft.Extensions.Logging.ILoggerFactory&quot; /&gt; instance.&lt;/para&gt;
///     &lt;para&gt;Defaults to built-in implementation.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets if the bot&apos;s status should show the mobile icon.&lt;/para&gt;
⋮----
///     &lt;para&gt;Which api channel to use.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see cref=&quot;ApiChannel.Stable&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Refresh full guild channel cache.&lt;/para&gt;
⋮----
///     &lt;para&gt;Do not use, this is meant for DisCatSharp Devs.&lt;/para&gt;
⋮----
///     Sets your preferred API language. See &lt;see cref=&quot;DiscordLocales&quot; /&gt; for valid locales.
⋮----
///     Sets your timezone.
⋮----
///     &lt;para&gt;Whether to report missing fields for discord object.&lt;/para&gt;
///     &lt;para&gt;Useful for library development.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the service provider.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to an empty service provider.&lt;/para&gt;
⋮----
public IServiceProvider ServiceProvider { internal get; init; } = new ServiceCollection().BuildServiceProvider(true);
⋮----
///     &lt;para&gt;Whether to enable sentry.&lt;/para&gt;
///     &lt;para&gt;This helps us to track missing data and library bugs better.&lt;/para&gt;
⋮----
///         &lt;note type=&quot;note&quot;&gt;
///             Please refer to the &lt;a href=&quot;https://docs.dcs.aitsys.dev/articles/misc/sentry&quot;&gt;docs&lt;/a&gt; for
///             more information.
///         &lt;/note&gt;
⋮----
///     &lt;para&gt;Whether to attach recent log entris.&lt;/para&gt;
⋮----
///     &lt;para&gt;Whether to attach the bots username and id to sentry reports.&lt;/para&gt;
///     &lt;para&gt;This helps us to pinpoint problems.&lt;/para&gt;
⋮----
///     &lt;para&gt;Your email address we can reach out when your bot encounters library bugs.&lt;/para&gt;
///     &lt;para&gt;Will only be transmitted if &lt;see cref=&quot;AttachUserInfo&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Your discord user id we can reach out when your bot encounters library bugs.&lt;/para&gt;
⋮----
///     &lt;para&gt;Causes the &lt;see cref=&quot;DiscordClient.PayloadReceived&quot; /&gt; event to be fired.&lt;/para&gt;
///     &lt;para&gt;Useful if you want to work with raw events.&lt;/para&gt;
⋮----
///     &lt;para&gt;Whether to replace every discord-based id with &lt;c&gt;{DISCORD_ID}&lt;/c&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets which exceptions to track with sentry.&lt;/para&gt;
///     &lt;para&gt;Do not touch this unless you&apos;re developing the library.&lt;/para&gt;
⋮----
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
///     Thrown when the base type of all exceptions is not
///     &lt;see cref=&quot;DisCatSharpException&quot; /&gt;.
/// &lt;/exception&gt;
⋮----
throw new AccessViolationException(&quot;Cannot set this as non-library-dev&quot;);
⋮----
this._exceptions.Clear();
⋮----
this._exceptions = value.All(val =&gt; val.BaseType == typeof(DisCatSharpException))
⋮----
: throw new InvalidOperationException(&quot;Can only track exceptions who inherit from &quot; + nameof(DisCatSharpException) + &quot; and must be constructed with typeof(Type)&quot;);
⋮----
///     &lt;para&gt;Whether to enable the library developer mode.&lt;/para&gt;
///     &lt;para&gt;Defaults &lt;see langword=&quot;false&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Whether to disable all safety scrubbers.&lt;/para&gt;
///     &lt;para&gt;Can only be enabled by whitelisted developers.&lt;/para&gt;
⋮----
///     Whether to turn sentry&apos;s debug mode on.
⋮----
///     Whether to disable the exception filter.
⋮----
///     Custom Sentry Dsn.
⋮----
///     Whether to autofetch the sku ids.
///     &lt;para&gt;Mutually exclusive to &lt;see cref=&quot;SkuId&quot; /&gt;.&lt;/para&gt;
⋮----
///     The applications sku id for premium apps.
///     &lt;para&gt;Mutually exclusive to &lt;see cref=&quot;AutoFetchSkuIds&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to disable the update check.
⋮----
///     Against which channel to check for updates.
///     &lt;para&gt;Defaults to &lt;see cref=&quot;VersionCheckMode.NuGet&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include prerelease versions in the update check.
⋮----
///     Sets the GitHub token to use for the update check.
⋮----
///         Only useful if extensions are private and &lt;see cref=&quot;UpdateCheckMode&quot; /&gt; is
///         &lt;see cref=&quot;VersionCheckMode.GitHub&quot; /&gt;.
⋮----
///     Whether to show release notes in the update check.
⋮----
///     Whether this app uses activities.
⋮----
///     If &lt;see cref=&quot;HasActivitiesEnabled&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;, determines which handler type we use..
///     &lt;para&gt;Defaults to &lt;see cref=&quot;ApplicationCommandHandlerType.DiscordLaunchActivity&quot; /&gt;.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Application/DiscordApplication.cs">/// &lt;summary&gt;
///     Represents an OAuth2 application.
/// &lt;/summary&gt;
public sealed class DiscordApplication : DiscordMessageApplication, IEquatable&lt;DiscordApplication&gt;
⋮----
///     Gets or sets a list of &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt;.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplication&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;tapp&quot;&gt;The transport application to populate the data from.&lt;/param&gt;
⋮----
this.RoleConnectionsVerificationUrl = tapp.RoleConnectionsVerificationUrl.ValueOrDefault();
⋮----
new DiscordUser(tapp.Owner)
⋮----
.Select(x =&gt; new DiscordTeamMember(x)
⋮----
.ToArray();
⋮----
.Where(x =&gt; x.MembershipStatus == DiscordTeamMembershipStatus.Accepted)
.Select(x =&gt; x.User)
⋮----
this.Team.Owner = members.First(x =&gt; x.Role == &quot;owner&quot;).User;
⋮----
this.GuildId = tapp.GuildId.ValueOrDefault();
this.Slug = tapp.Slug.ValueOrDefault();
this.PrimarySkuId = tapp.PrimarySkuId.ValueOrDefault();
this.VerifyKey = tapp.VerifyKey.ValueOrDefault();
this.CoverImageHash = tapp.CoverImageHash.ValueOrDefault();
this.Guild = tapp.Guild.ValueOrDefault();
this.ApproximateGuildCount = tapp.ApproximateGuildCount.ValueOrDefault();
this.ApproximateUserInstallCount = tapp.ApproximateUserInstallCount.ValueOrDefault();
this.RequiresCodeGrant = tapp.BotRequiresCodeGrant.ValueOrDefault();
this.IsPublic = tapp.IsPublicBot.ValueOrDefault();
⋮----
this.InteractionsEndpointUrl = tapp.InteractionsEndpointUrl.ValueOrDefault();
⋮----
this.RpcOrigins = tapp.RpcOrigins.AsReadOnly();
⋮----
this.InteractionsEventTypes = tapp.InteractionsEventTypes.AsReadOnly();
⋮----
///     Gets the application&apos;s summary.
⋮----
///     Gets the application&apos;s icon.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash)
? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=1024&quot;
⋮----
///     Gets the application&apos;s icon hash.
⋮----
///     Gets the application&apos;s allowed RPC origins.
⋮----
///     Gets the application&apos;s flags.
⋮----
///     Gets the application&apos;s team members.
⋮----
///     Gets the application&apos;s owner.
⋮----
///     Gets whether this application&apos;s bot user requires code grant.
⋮----
///     Gets whether this bot application is public.
⋮----
///     Gets the terms of service url of the application.
⋮----
///     Gets the privacy policy url of the application.
⋮----
///     Gets the team name of the application.
⋮----
///     Gets the hash of the application&apos;s cover image.
⋮----
///     Gets this application&apos;s cover image URL.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CoverImageHash)
? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.CoverImageHash}.png?size=1024&quot;
⋮----
///     Gets the team which owns this application.
⋮----
///     Gets the hex encoded key for verification in interactions and the GameSDK&apos;s GetTicket
⋮----
///     If this application is a game sold on Discord, this field will be the guild to which it has been linked
⋮----
///     Gets the partial guild if set as support server.
⋮----
///     If this application is a game sold on Discord, this field will be the id of the &quot;Game SKU&quot; that is created, if
///     exists
⋮----
///     If this application is a game sold on Discord, this field will be the URL slug that links to the store page
⋮----
///     A custom url for the Add To Server button.
⋮----
///     Install parameters for adding the application to a guild.
⋮----
///     The application&apos;s role connection verification entry point,
///     which when configured will render the app as a verification method in the guild role verification configuration.
⋮----
///     The application tags.
///     Not used atm.
⋮----
///     Whether the application is hooked.
⋮----
///     Gets the application type.
///     Mostly null.
⋮----
///     Gets the approximate guild count
⋮----
///     Gets the approximate user install count
⋮----
///     Gets the interactions endpoint url.
⋮----
///     Gets the redirect uris.
⋮----
///     Gets the integration types config.
⋮----
///     Gets whether the application is monetized.
⋮----
///     Gets whether the application is verified.
⋮----
///     Gets whether the storefront is available.
⋮----
///     Gets the interaction event types.
⋮----
///     Gets the interactions version.
⋮----
///     Gets the explicit content filter level.
⋮----
///     Gets the RPC application state.
⋮----
///     Gets the store application state.
⋮----
///     Gets the verification state.
⋮----
///     Gets whether the integration is public.
⋮----
///     Gets whether the integration requires code grant.
⋮----
///     Gets the discoverability state.
⋮----
///     Gets the discovery eligibility flags.
⋮----
///     Gets the monetization state.
⋮----
///     Gets the verification eligibility flags.
⋮----
///     Gets the monetization eligibility flags.
⋮----
///     Gets the internal guild restriction level.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplication&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordApplication&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordApplication&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordApplication&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordApplication&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordApplication e)
⋮----
///     Gets the application&apos;s cover image URL, in requested format and size.
⋮----
/// &lt;param name=&quot;fmt&quot;&gt;Format of the image to get.&lt;/param&gt;
/// &lt;param name=&quot;size&quot;&gt;Maximum size of the cover image. Must be a power of two, minimum 16, maximum 2048.&lt;/param&gt;
/// &lt;returns&gt;URL of the application&apos;s cover image.&lt;/returns&gt;
public string? GetAvatarUrl(MediaFormat fmt, ushort size = 1024)
⋮----
throw new ArgumentException(&quot;You must specify valid image format.&quot;, nameof(fmt));
⋮----
throw new ArgumentOutOfRangeException(nameof(size));
⋮----
var log = Math.Log(size, 2);
⋮----
_ =&gt; throw new ArgumentOutOfRangeException(nameof(fmt))
⋮----
var ssize = size.ToString(CultureInfo.InvariantCulture);
return !string.IsNullOrWhiteSpace(this.CoverImageHash)
? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{sfmt}?size={ssize}&quot;
⋮----
///     Retrieves this application&apos;s assets.
⋮----
/// &lt;returns&gt;This application&apos;s assets.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;DiscordApplicationAsset&gt;&gt; GetAssetsAsync()
⋮----
this._assets ??= await this.Discord.ApiClient.GetApplicationAssetsAsync(this).ConfigureAwait(false);
⋮----
///     Generates an oauth url for the application.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;The permissions.&lt;/param&gt;
/// &lt;returns&gt;OAuth Url&lt;/returns&gt;
public string GenerateBotOAuth(Permissions permissions = Permissions.None)
⋮----
// hey look, it&apos;s not all annoying and blue :P
return new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
.AddParameter(&quot;client_id&quot;, this.Id.ToString(CultureInfo.InvariantCulture))
.AddParameter(&quot;scope&quot;, &quot;bot&quot;)
.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
.ToString();
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplication&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordApplication&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordApplication);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordApplication&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordApplication&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordApplication&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First application to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second application to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two applications are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordApplication&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two applications are not equal.&lt;/returns&gt;
⋮----
///     Represents an discord asset.
⋮----
public abstract class DiscordAsset
⋮----
///     Gets the ID of this asset.
⋮----
///     Gets the URL of this asset.
⋮----
///     Represents an asset for an OAuth2 application.
⋮----
public sealed class DiscordApplicationAsset : DiscordAsset, IEquatable&lt;DiscordApplicationAsset&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;app&quot;&gt;The app.&lt;/param&gt;
⋮----
///     Gets the Discord client instance for this asset.
⋮----
///     Gets the asset&apos;s name.
⋮----
///     Gets the asset&apos;s type.
⋮----
///     Gets the application this asset belongs to.
⋮----
///     Gets the Url of this asset.
⋮----
=&gt; new($&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ASSETS}/{this.Application.Id.ToString(CultureInfo.InvariantCulture)}/{this.Id}.png&quot;);
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; is equal to another
///     &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordApplicationAsset e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; is equal to another object.
⋮----
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt;.&lt;/returns&gt;
⋮----
=&gt; this.Equals(obj as DiscordApplicationAsset);
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First application asset to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second application asset to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two application assets not equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordApplicationAsset&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two application assets are not equal.&lt;/returns&gt;
⋮----
///     Represents an spotify asset.
⋮----
public sealed class DiscordSpotifyAsset : DiscordAsset
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordSpotifyAsset&quot; /&gt; class.
⋮----
var ids = this.Id.Split(&apos;:&apos;);
⋮----
///     Determines the type of the asset attached to the application.
⋮----
///     Unknown type. This indicates something went terribly wrong.
⋮----
///     This asset can be used as small image for rich presences.
⋮----
///     This asset can be used as large image for rich presences.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommand.cs">/// &lt;summary&gt;
///     Represents a command that is registered to an application.
/// &lt;/summary&gt;
public class DiscordApplicationCommand : SnowflakeObject, IEquatable&lt;DiscordApplicationCommand&gt;
⋮----
///     Creates a new instance of a &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the command.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the command.&lt;/param&gt;
/// &lt;param name=&quot;options&quot;&gt;Optional parameters for this command.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The type of the command. Defaults to ChatInput.&lt;/param&gt;
/// &lt;param name=&quot;nameLocalizations&quot;&gt;The localizations of the command name.&lt;/param&gt;
/// &lt;param name=&quot;descriptionLocalizations&quot;&gt;The localizations of the command description.&lt;/param&gt;
/// &lt;param name=&quot;defaultMemberPermissions&quot;&gt;The default member permissions.&lt;/param&gt;
/// &lt;param name=&quot;isNsfw&quot;&gt;Whether this command is NSFW.&lt;/param&gt;
/// &lt;param name=&quot;allowedContexts&quot;&gt;Where the command can be used.&lt;/param&gt;
/// &lt;param name=&quot;integrationTypes&quot;&gt;The allowed integration types.&lt;/param&gt;
/// &lt;param name=&quot;handlerType&quot;&gt;The handler type.&lt;/param&gt;
⋮----
if (!Utilities.IsValidSlashCommandName(name))
throw new ArgumentException($&quot;Invalid slash command name specified. It must be below 32 characters and not contain any whitespace. Error for command {name}.&quot;, nameof(name));
if (name.Any(char.IsUpper))
throw new ArgumentException($&quot;Slash command name cannot have any upper case characters. Error for command {name}.&quot;, nameof(name));
⋮----
throw new ArgumentException($&quot;Slash command description cannot exceed 100 characters. Error for command {name}.&quot;, nameof(description));
if (string.IsNullOrWhiteSpace(description))
throw new ArgumentException($&quot;Slash commands need a description. Error for command {name}.&quot;, nameof(description));
⋮----
this.Options = options != null &amp;&amp; options.Any() ? options.ToList() : null;
⋮----
throw new ArgumentException($&quot;Primary entrypoints do not support options. Error for command {name}.&quot;);
⋮----
if (!string.IsNullOrWhiteSpace(description))
throw new ArgumentException($&quot;Context menus do not support descriptions. Error for command {name}.&quot;);
⋮----
throw new ArgumentException($&quot;Context menus do not support options. Error for command {name}.&quot;);
⋮----
///     Creates a new empty Discord Application Command.
⋮----
: base([&quot;name_localizations&quot;, &quot;description_localizations&quot;, &quot;guild_id&quot;]) // Why tf is that so inconsistent?!
⋮----
///     Gets the type of this application command.
⋮----
///     Gets the unique ID of this command&apos;s application.
⋮----
///     Gets the name of this command.
⋮----
///     Sets the name localizations.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the description of this command.
⋮----
///     Sets the description localizations.
⋮----
///     Gets the description localizations.
⋮----
///     Gets the potential parameters for this command.
⋮----
///     Gets the commands needed permissions.
⋮----
///     Gets whether the command can be used in direct messages.
⋮----
///     Gets where the application command can be used.
⋮----
///     Gets the application command allowed integration types.
⋮----
///     Gets whether the command is marked as NSFW.
⋮----
///     Gets the version number for this command.
⋮----
///     Gets the mention for this command.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt; object is equal to another object.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The command to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the command is equal to this &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordApplicationCommand other)
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;The first command object.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;The second command object.&lt;/param&gt;
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt; objects are equal.&lt;/returns&gt;
⋮----
=&gt; e1.Equals(e2);
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt; objects are not equal.&lt;/returns&gt;
⋮----
///     Determines if a &lt;see cref=&quot;object&quot; /&gt; is equal to the current &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The object to compare to.&lt;/param&gt;
⋮----
public override bool Equals(object other)
=&gt; other is DiscordApplicationCommand dac &amp;&amp; this.Equals(dac);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandAutocompleteChoice.cs">/// &lt;summary&gt;
///     Represents an option for a user to select for auto-completion.
/// &lt;/summary&gt;
public sealed class DiscordApplicationCommandAutocompleteChoice
⋮----
///     Creates a new instance of &lt;see cref=&quot;DiscordApplicationCommandAutocompleteChoice&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of this option, which will be presented to the user.&lt;/param&gt;
/// &lt;param name=&quot;nameLocalizations&quot;&gt;The localizations of the option name.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value of this option.&lt;/param&gt;
⋮----
throw new ArgumentException(&quot;Application command choice name cannot exceed 100 characters.&quot;, nameof(name));
⋮----
throw new ArgumentException(&quot;Application command choice value cannot exceed 100 characters.&quot;, nameof(value));
⋮----
throw new InvalidOperationException($&quot;Only {typeof(string)}, {typeof(long)}, {typeof(double)} or {typeof(int)} types may be passed to a autocomplete choice.&quot;);
⋮----
///     Gets the name of this option which will be presented to the user.
⋮----
///     Sets the name localizations.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the value of this option.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandLocalization.cs">/// &lt;summary&gt;
///     Represents a application command localization.
/// &lt;/summary&gt;
public sealed class DiscordApplicationCommandLocalization
⋮----
///     Gets valid [locales](xref:modules_application_commands_translations_reference#valid-locales) for Discord.
⋮----
///     Initializes a new instance of &lt;see cref=&quot;DiscordApplicationCommandLocalization&quot; /&gt;.
⋮----
/// &lt;param name=&quot;localizations&quot;&gt;Localizations.&lt;/param&gt;
⋮----
foreach (var locale in localizations.Keys.Where(locale =&gt; !this.Validate(locale)))
throw new NotSupportedException($&quot;The provided locale \&quot;{locale}\&quot; is not valid for Discord.\n&quot; +
$&quot;Valid locales: {string.Join(&quot;, &quot;, this.ValidLocales)}&quot;);
⋮----
///     Gets the localization dict.
⋮----
///     Adds a localization.
⋮----
/// &lt;param name=&quot;locale&quot;&gt;The [locale](xref:modules_application_commands_translations_reference#valid-locales) to add.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The translation to add.&lt;/param&gt;
public void AddLocalization(string locale, string value)
⋮----
if (this.Validate(locale))
this.Localizations.Add(locale, value);
⋮----
///     Removes a localization.
⋮----
/// &lt;param name=&quot;locale&quot;&gt;The [locale](xref:modules_application_commands_translations_reference#valid-locales) to remove.&lt;/param&gt;
public void RemoveLocalization(string locale)
=&gt; this.Localizations.Remove(locale);
⋮----
///     Gets the KVPs.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public Dictionary&lt;string, string&gt; GetKeyValuePairs()
⋮----
///     Whether the [locale](xref:modules_application_commands_translations_reference#valid-locales) to be added is valid
///     for Discord.
⋮----
/// &lt;param name=&quot;lang&quot;&gt;[Locale](xref:modules_application_commands_translations_reference#valid-locales) string.&lt;/param&gt;
public bool Validate(string lang)
=&gt; this.ValidLocales.Contains(lang);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandOption.cs">/// &lt;summary&gt;
///     Represents a parameter for a &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
/// &lt;/summary&gt;
public class DiscordApplicationCommandOption
⋮----
///     Creates a new instance of a &lt;see cref=&quot;DiscordApplicationCommandOption&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of this parameter.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the parameter.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The type of this parameter.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether the parameter is required.&lt;/param&gt;
/// &lt;param name=&quot;choices&quot;&gt;The optional choice selection for this parameter.&lt;/param&gt;
/// &lt;param name=&quot;options&quot;&gt;The optional subcommands for this parameter.&lt;/param&gt;
/// &lt;param name=&quot;channelTypes&quot;&gt;If the option is a channel type, the channels shown will be restricted to these types.&lt;/param&gt;
/// &lt;param name=&quot;autocomplete&quot;&gt;Whether this option provides autocompletion.&lt;/param&gt;
/// &lt;param name=&quot;minimumValue&quot;&gt;
///     The minimum value for this parameter. Only valid for types
///     &lt;see cref=&quot;ApplicationCommandOptionType.Integer&quot; /&gt; or &lt;see cref=&quot;ApplicationCommandOptionType.Number&quot; /&gt;.
/// &lt;/param&gt;
/// &lt;param name=&quot;maximumValue&quot;&gt;
///     The maximum value for this parameter. Only valid for types
⋮----
/// &lt;param name=&quot;nameLocalizations&quot;&gt;The localizations of the parameter name.&lt;/param&gt;
/// &lt;param name=&quot;descriptionLocalizations&quot;&gt;The localizations of the parameter description.&lt;/param&gt;
/// &lt;param name=&quot;minimumLength&quot;&gt;The minimum allowed length of the string. (Min 0)&lt;/param&gt;
/// &lt;param name=&quot;maximumLength&quot;&gt;The maximum allowed length of the string. (Min 1)&lt;/param&gt;
⋮----
if (!Utilities.IsValidSlashCommandName(name))
throw new ArgumentException(&quot;Invalid application command option name specified. It must be below 32 characters and not contain any whitespace.&quot;, nameof(name));
if (name.Any(char.IsUpper))
throw new ArgumentException(&quot;Application command option name cannot have any upper case characters.&quot;, nameof(name));
⋮----
throw new ArgumentException(&quot;Application command option description cannot exceed 100 characters.&quot;, nameof(description));
⋮----
throw new InvalidOperationException(&quot;Auto-complete slash command options cannot provide choices.&quot;);
⋮----
if (string.IsNullOrWhiteSpace(description))
throw new ArgumentException(&quot;Slash commands need a description.&quot;, nameof(description));
⋮----
this.Choices = choices is not null &amp;&amp; choices.Any() ? choices.ToList() : null;
this.Options = options is not null &amp;&amp; options.Any() ? options.ToList() : null;
this.ChannelTypes = channelTypes is not null &amp;&amp; channelTypes.Any() ? channelTypes.ToList() : null;
⋮----
///     Creates a new empty DiscordApplicationCommandOption.
⋮----
///     Gets the type of this command parameter.
⋮----
///     Gets the name of this command parameter.
⋮----
///     Sets the name localizations.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the description of this command parameter.
⋮----
///     Sets the description localizations.
⋮----
///     Gets the description localizations.
⋮----
///     Gets whether this command parameter is required.
⋮----
///     Gets the optional choices for this command parameter.
///     Not applicable for auto-complete options.
⋮----
///     Gets the optional subcommand parameters for this parameter.
⋮----
///     Gets the optional allowed channel types.
⋮----
///     Gets whether this option provides autocompletion.
⋮----
///     Gets the minimum value for this slash command parameter.
⋮----
///     Gets the maximum value for this slash command parameter.
⋮----
///     Gets the maximum length for this slash command parameter.
⋮----
///     Gets the minimum length for this slash command parameter.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandOptionChoice.cs">/// &lt;summary&gt;
///     Represents a command parameter choice for a &lt;see cref=&quot;DiscordApplicationCommandOption&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordApplicationCommandOptionChoice
⋮----
///     Creates a new instance of a &lt;see cref=&quot;DiscordApplicationCommandOptionChoice&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the parameter choice.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value of the parameter choice.&lt;/param&gt;
/// &lt;param name=&quot;nameLocalizations&quot;&gt;The localizations of the parameter choice name.&lt;/param&gt;
⋮----
throw new InvalidOperationException($&quot;Only {typeof(string)}, {typeof(long)}, {typeof(double)} or {typeof(int)} types may be passed to a command option choice.&quot;);
⋮----
throw new ArgumentException(&quot;Application command choice name cannot exceed 100 characters.&quot;, nameof(name));
⋮----
throw new ArgumentException(&quot;Application command choice value cannot exceed 100 characters.&quot;, nameof(value));
⋮----
///     Gets the name of this choice parameter.
⋮----
///     Sets the name localizations.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the value of this choice parameter. This will either be a type of &lt;see cref=&quot;int&quot; /&gt;, &lt;see cref=&quot;long&quot; /&gt;,
///     &lt;see cref=&quot;double&quot; /&gt; or &lt;see cref=&quot;string&quot; /&gt;.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationCommandPermission.cs">/// &lt;summary&gt;
///     Represents a application command permission.
/// &lt;/summary&gt;
public sealed class DiscordApplicationCommandPermission : SnowflakeObject, IEquatable&lt;DiscordApplicationCommandPermission&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the role or user for this permission.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;Defines whether the permission effects a user or role.&lt;/param&gt;
/// &lt;param name=&quot;permission&quot;&gt;
///     The permission for this command. True allows the subject to use the command, false does not
///     allow the subject to use the command.
/// &lt;/param&gt;
⋮----
///     Gets the id of the role or user.
⋮----
///     Gets the application command permission type.
⋮----
///     Gets the permission .
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; object is equal to another object.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The command to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the command is equal to this &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordApplicationCommandPermission other)
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;The first command object.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;The second command object.&lt;/param&gt;
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; objects are equal.&lt;/returns&gt;
⋮----
=&gt; e1.Equals(e2);
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt; objects are not equal.&lt;/returns&gt;
⋮----
///     Determines if a &lt;see cref=&quot;object&quot; /&gt; is equal to the current &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The object to compare to.&lt;/param&gt;
⋮----
public override bool Equals(object other) =&gt; other is DiscordApplicationCommandPermission dacp &amp;&amp; this.Equals(dacp);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordApplicationCommandPermission&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordApplicationEmoji.cs">/// &lt;summary&gt;
///     Represents a application emoji.
/// &lt;/summary&gt;
public sealed class DiscordApplicationEmoji : DiscordEmoji
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplicationEmoji&quot; /&gt; class.
⋮----
///     Gets the user that created the emoji (Either a team member or the bot through api).
⋮----
///     Modifies this emoji.
⋮----
/// &lt;param name=&quot;name&quot;&gt;New name for this emoji.&lt;/param&gt;
/// &lt;returns&gt;The modified emoji.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the emoji does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;DiscordApplicationEmoji&gt; ModifyAsync(string name)
=&gt; this.Discord.ApiClient.ModifyApplicationEmojiAsync(this.Discord.CurrentApplication.Id, this.Id, name);
⋮----
///     Deletes this emoji.
⋮----
public Task DeleteAsync()
=&gt; this.Discord.ApiClient.DeleteApplicationEmojiAsync(this.Discord.CurrentApplication.Id, this.Id);</file><file path="DisCatSharp/Entities/Application/DiscordApplicationInstallParams.cs">/// &lt;summary&gt;
///     The application install params.
/// &lt;/summary&gt;
public sealed class DiscordApplicationInstallParams : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplicationInstallParams&quot; /&gt; class.
⋮----
///     Gets the scopes.
⋮----
///     Gets or sets the permissions.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationIntegrationTypeConfiguration.cs">/// &lt;summary&gt;
///     Represets the application integration type configuration.
/// &lt;/summary&gt;
public sealed class DiscordApplicationIntegrationTypeConfiguration : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApplicationIntegrationTypeConfiguration&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;oAuth2InstallParams&quot;&gt;The oauth2 install params.&lt;/param&gt;
⋮----
///     Gets or sets the oauth2 install params.</file><file path="DisCatSharp/Entities/Application/DiscordApplicationRoleConnectionMetadata.cs">/// &lt;summary&gt;
///     Represents a role connection metadata object that is registered to an application.
/// &lt;/summary&gt;
public sealed class DiscordApplicationRoleConnectionMetadata : ObservableApiObject, IEquatable&lt;DiscordApplicationRoleConnectionMetadata&gt;
⋮----
///     Creates a new instance of a &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt;.
⋮----
///     Gets the type of this role connection metadata object.
⋮----
///     The dictionary key for the metadata field.
///     Must be `a-z`, `0-9`, or `_` characters.
⋮----
///     Gets the name of the metadata field.
⋮----
///     Sets the name localizations.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the description of the metadata field.
⋮----
///     Sets the description localizations.
⋮----
///     Gets the description localizations.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt; object is equal to another object.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The command to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the command is equal to this &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordApplicationRoleConnectionMetadata other)
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;The first command object.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;The second command object.&lt;/param&gt;
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt; objects are equal.&lt;/returns&gt;
⋮----
=&gt; e1.Equals(e2);
⋮----
///     Determines if two &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt; objects are not equal.&lt;/returns&gt;
⋮----
///     Determines if a &lt;see cref=&quot;object&quot; /&gt; is equal to the current
///     &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The object to compare to.&lt;/param&gt;
⋮----
public override bool Equals(object other)
=&gt; other is DiscordApplicationRoleConnectionMetadata dac &amp;&amp; this.Equals(dac);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordApplicationRoleConnectionMetadata&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Key.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordGuildApplicationCommandPermission.cs">/// &lt;summary&gt;
///     Represents a guild application command permission.
/// &lt;/summary&gt;
public sealed class DiscordGuildApplicationCommandPermission : SnowflakeObject, IEquatable&lt;DiscordGuildApplicationCommandPermission&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; class.
⋮----
///     Gets the id of the command.
⋮----
///     Gets the unique ID of this command&apos;s application.
⋮----
///     Gets the guild id this permission applies to.
⋮----
///     Gets the guild this permission applies to.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
⋮----
///     Gets the permission array.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; object is equal to another object.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The command to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the command is equal to this &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordGuildApplicationCommandPermission other)
⋮----
///     Determines if two &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;The first command object.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;The second command object.&lt;/param&gt;
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; objects are equal.&lt;/returns&gt;
⋮----
=&gt; e1.Equals(e2);
⋮----
///     Determines if two &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt; objects are not equal.&lt;/returns&gt;
⋮----
///     Determines if a &lt;see cref=&quot;object&quot; /&gt; is equal to the current &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The object to compare to.&lt;/param&gt;
⋮----
public override bool Equals(object other) =&gt; other is DiscordGuildApplicationCommandPermission dgacp &amp;&amp; this.Equals(dgacp);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordGuildApplicationCommandPermission&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();</file><file path="DisCatSharp/Entities/Application/DiscordIntegrationTypesConfig.cs">/// &lt;summary&gt;
///     Represents the application integration type configuration.
/// &lt;/summary&gt;
public sealed class DiscordIntegrationTypesConfig
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordIntegrationTypesConfig&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;guildInstall&quot;&gt;The guild install configuration. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;userInstall&quot;&gt;The user install configuration. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
⋮----
///     &lt;para&gt;Gets or sets the guild install configuration.&lt;/para&gt;
///     &lt;para&gt;Disabled when &lt;see langword=&quot;null&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/para&gt;
⋮----
///     &lt;para&gt;Gets or sets the user install configuration.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Application/DiscordOAuth2InstallParams.cs">/// &lt;summary&gt;
///     Represents Discord OAuth2 install parameters. Is the same model as &lt;see cref=&quot;DiscordApplicationInstallParams&quot; /&gt;,
///     which is obsolete in future.
/// &lt;/summary&gt;
public sealed class DiscordOAuth2InstallParams
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordOAuth2InstallParams&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;scopes&quot;&gt;The scopes.&lt;/param&gt;
/// &lt;param name=&quot;permissions&quot;&gt;The permissions.&lt;/param&gt;
⋮----
///     Gets the scopes.
⋮----
///     Gets or sets the permissions.</file><file path="DisCatSharp/Entities/Application/DiscordRpcApplication.cs">/// &lt;summary&gt;
///     Represents an OAuth2 application.
/// &lt;/summary&gt;
public sealed class DiscordRpcApplication : SnowflakeObject, IEquatable&lt;DiscordRpcApplication&gt;
⋮----
public ApplicationFlags Flags;
⋮----
public DiscordApplicationInstallParams InstallParams;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; class.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordRpcApplication e)
⋮----
///     Generates an oauth url for the application.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;The permissions.&lt;/param&gt;
/// &lt;returns&gt;OAuth Url&lt;/returns&gt;
public string GenerateBotOAuth(Permissions permissions = Permissions.None)
⋮----
// hey look, it&apos;s not all annoying and blue :P
return new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
.AddParameter(&quot;client_id&quot;, this.Id.ToString(CultureInfo.InvariantCulture))
.AddParameter(&quot;scope&quot;, &quot;bot&quot;)
.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
.ToString();
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordRpcApplication);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First application to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second application to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two applications are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordRpcApplication&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two applications are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Channel/ChannelTypeExtensions.cs">/// &lt;summary&gt;
///     Extension methods for &lt;see cref=&quot;ChannelType&quot; /&gt;.
/// &lt;/summary&gt;
public static class ChannelTypeExtensions
⋮----
///     Contains sets used by Discord to determine features of a channel.
⋮----
///     Determines if the channel type is callable.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The channel type.&lt;/param&gt;
/// &lt;returns&gt;True if the channel type is callable, otherwise false.&lt;/returns&gt;
public static bool IsCallable(this ChannelType type)
=&gt; s_callable.Contains((int)type);
⋮----
///     Determines if the channel type is textual.
⋮----
/// &lt;returns&gt;True if the channel type is textual, otherwise false.&lt;/returns&gt;
public static bool IsTextual(this ChannelType type)
=&gt; s_textual.Contains((int)type);
⋮----
///     Determines if the channel type is guild threads only.
⋮----
/// &lt;returns&gt;True if the channel type is guild threads only, otherwise false.&lt;/returns&gt;
public static bool IsGuildThreadsOnly(this ChannelType type)
=&gt; s_guildThreadsOnly.Contains((int)type);
⋮----
///     Determines if the channel type supports stickers.
⋮----
/// &lt;returns&gt;True if the channel type supports stickers, otherwise false.&lt;/returns&gt;
public static bool IsStickers(this ChannelType type)
=&gt; s_stickers.Contains((int)type);
⋮----
///     Determines if the channel type is readable.
⋮----
/// &lt;returns&gt;True if the channel type is readable, otherwise false.&lt;/returns&gt;
public static bool IsReadable(this ChannelType type)
=&gt; s_readable.Contains((int)type);
⋮----
///     Determines if the channel type is a guild channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild channel, otherwise false.&lt;/returns&gt;
public static bool IsGuild(this ChannelType type)
=&gt; s_guild.Contains((int)type);
⋮----
///     Determines if the channel type is a thread.
⋮----
/// &lt;returns&gt;True if the channel type is a thread, otherwise false.&lt;/returns&gt;
public static bool IsThreads(this ChannelType type)
=&gt; s_threads.Contains((int)type);
⋮----
///     Determines if the channel type is a public thread.
⋮----
/// &lt;returns&gt;True if the channel type is a public thread, otherwise false.&lt;/returns&gt;
public static bool IsPublicThreads(this ChannelType type)
=&gt; s_publicThreads.Contains((int)type);
⋮----
///     Determines if the channel type is a guild threaded channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild threaded channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildThreaded(this ChannelType type)
=&gt; s_guildThreaded.Contains((int)type);
⋮----
///     Determines if the channel type is a guild stored channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild stored channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildStored(this ChannelType type)
=&gt; s_guildStored.Contains((int)type);
⋮----
///     Determines if the channel type is a guild textual channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild textual channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildTextual(this ChannelType type)
=&gt; s_guildTextual.Contains((int)type);
⋮----
///     Determines if the channel type is a guild vocal channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild vocal channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildVocal(this ChannelType type)
=&gt; s_guildVocal.Contains((int)type);
⋮----
///     Determines if the channel type is a vocal thread.
⋮----
/// &lt;returns&gt;True if the channel type is a vocal thread, otherwise false.&lt;/returns&gt;
public static bool IsVocalThread(this ChannelType type)
=&gt; s_vocalThread.Contains((int)type);
⋮----
///     Determines if the channel type is vocal.
⋮----
/// &lt;returns&gt;True if the channel type is vocal, otherwise false.&lt;/returns&gt;
public static bool IsVocal(this ChannelType type)
=&gt; s_vocal.Contains((int)type);
⋮----
///     Determines if the channel type supports voice effects.
⋮----
/// &lt;returns&gt;True if the channel type supports voice effects, otherwise false.&lt;/returns&gt;
public static bool IsVoiceEffects(this ChannelType type)
=&gt; s_voiceEffects.Contains((int)type);
⋮----
///     Determines if the channel type is a guild text only channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild text only channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildTextOnly(this ChannelType type)
=&gt; s_guildTextOnly.Contains((int)type);
⋮----
///     Determines if the channel type has a limited channel name.
⋮----
/// &lt;returns&gt;True if the channel type has a limited channel name, otherwise false.&lt;/returns&gt;
public static bool IsLimitedChannelName(this ChannelType type)
=&gt; s_limitedChannelName.Contains((int)type);
⋮----
///     Determines if the channel type is searchable.
⋮----
/// &lt;returns&gt;True if the channel type is searchable, otherwise false.&lt;/returns&gt;
public static bool IsSearchable(this ChannelType type)
=&gt; s_searchable.Contains((int)type);
⋮----
///     Determines if the channel type supports guild user content.
⋮----
/// &lt;returns&gt;True if the channel type supports guild user content, otherwise false.&lt;/returns&gt;
public static bool IsGuildUserContent(this ChannelType type)
=&gt; s_guildUserContent.Contains((int)type);
⋮----
///     Determines if the channel type is a guild topical channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild topical channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildTopical(this ChannelType type)
=&gt; s_guildTopical.Contains((int)type);
⋮----
///     Determines if the channel type supports guild webhooks.
⋮----
/// &lt;returns&gt;True if the channel type supports guild webhooks, otherwise false.&lt;/returns&gt;
public static bool IsGuildWebhooks(this ChannelType type)
=&gt; s_guildWebhooks.Contains((int)type);
⋮----
///     Determines if the channel type is a guild system channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild system channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildSystemChannel(this ChannelType type)
=&gt; s_guildSystemChannel.Contains((int)type);
⋮----
///     Determines if the channel type is a guild parentable channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild parentable channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildParentable(this ChannelType type)
=&gt; s_guildParentable.Contains((int)type);
⋮----
///     Determines if the channel type is guild auto moderated.
⋮----
/// &lt;returns&gt;True if the channel type is guild auto moderated, otherwise false.&lt;/returns&gt;
public static bool IsGuildAutoModerated(this ChannelType type)
=&gt; s_guildAutoModerated.Contains((int)type);
⋮----
///     Determines if the channel type is a guild basic channel.
⋮----
/// &lt;returns&gt;True if the channel type is a guild basic channel, otherwise false.&lt;/returns&gt;
public static bool IsGuildBasic(this ChannelType type)
=&gt; s_guildBasic.Contains((int)type);
⋮----
///     Determines if the channel type is a createable guild channel.
⋮----
/// &lt;returns&gt;True if the channel type is a createable guild channel, otherwise false.&lt;/returns&gt;
public static bool IsCreateableGuildChannels(this ChannelType type)
=&gt; s_createableGuildChannels.Contains((int)type);
⋮----
///     Determines if the channel type is a multi-user DM.
⋮----
/// &lt;returns&gt;True if the channel type is a multi-user DM, otherwise false.&lt;/returns&gt;
public static bool IsMultiUserDms(this ChannelType type)
=&gt; s_multiUserDms.Contains((int)type);
⋮----
///     Determines if the channel type is a DM.
⋮----
/// &lt;returns&gt;True if the channel type is a DM, otherwise false.&lt;/returns&gt;
public static bool IsAllDms(this ChannelType type)
=&gt; s_allDms.Contains((int)type);
⋮----
///     Determines if the channel type is invitable.
⋮----
/// &lt;returns&gt;True if the channel type is invitable, otherwise false.&lt;/returns&gt;
public static bool IsInvitable(this ChannelType type)
=&gt; s_invitable.Contains((int)type);
⋮----
///     Determines if the channel type supports guild feed featurable messages.
⋮----
/// &lt;returns&gt;True if the channel type supports guild feed featurable messages, otherwise false.&lt;/returns&gt;
public static bool IsGuildFeedFeaturableMessages(this ChannelType type)
=&gt; s_guildFeedFeaturableMessages.Contains((int)type);
⋮----
///     Determines if the channel type supports role subscriptions.
⋮----
/// &lt;returns&gt;True if the channel type supports role subscriptions, otherwise false.&lt;/returns&gt;
public static bool IsRoleSubscriptions(this ChannelType type)
=&gt; s_roleSubscriptions.Contains((int)type);
⋮----
///     Determines if the channel type supports icon emojis.
⋮----
/// &lt;returns&gt;True if the channel type supports icon emojis, otherwise false.&lt;/returns&gt;
public static bool IsIconEmojis(this ChannelType type)
=&gt; s_iconEmojis.Contains((int)type);
⋮----
///     Determines if the channel type is summarizeable.
⋮----
/// &lt;returns&gt;True if the channel type is summarizeable, otherwise false.&lt;/returns&gt;
public static bool IsSummarizeable(this ChannelType type)
=&gt; s_summarizeable.Contains((int)type);
⋮----
///     Determines if the channel type supports content entry embeds.
⋮----
/// &lt;returns&gt;True if the channel type supports content entry embeds, otherwise false.&lt;/returns&gt;
public static bool IsContentEntryEmbeds(this ChannelType type) =&gt; s_contentEntryEmbeds.Contains((int)type);
⋮----
///     Determines if the channel type supports polls.
⋮----
/// &lt;returns&gt;True if the channel type supports polls, otherwise false.&lt;/returns&gt;
public static bool IsPolls(this ChannelType type)
=&gt; s_polls.Contains((int)type);
⋮----
///     Determines if the channel type supports activity launch.
⋮----
/// &lt;returns&gt;True if the channel type supports activity launch, otherwise false.&lt;/returns&gt;
public static bool IsActivityLaunchable(this ChannelType type)
=&gt; s_activityLaunchable.Contains((int)type);
⋮----
///     Determines if the channel type is any type. Not really useful, but here for completeness.
⋮----
/// &lt;returns&gt;True if the channel type is any type, otherwise false.&lt;/returns&gt;
public static bool IsAll(this ChannelType type)
=&gt; s_all.Contains((int)type);</file><file path="DisCatSharp/Entities/Channel/DiscordDmChannel.cs">/// &lt;summary&gt;
///     Represents a direct message channel.
/// &lt;/summary&gt;
public class DiscordDmChannel : DiscordChannel
⋮----
///     Gets the recipients of this direct message.
⋮----
///     Gets the hash of this channel&apos;s icon.
⋮----
///     Gets the id of this direct message&apos;s creator.
⋮----
///     Gets the application id of the direct message&apos;s creator if it a bot.
⋮----
///     Gets whether the channel is managed by an application via the `gdm.join` OAuth2 scope.
⋮----
///     Gets the URL of this channel&apos;s icon.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CHANNEL_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png&quot; : null;
⋮----
///     Only use for Group DMs! Whitelisted bots only. Requires user&apos;s oauth2 access token.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The id of the user to add.&lt;/param&gt;
/// &lt;param name=&quot;accessToken&quot;&gt;The OAuth2 access token.&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;The nickname to give to the user.&lt;/param&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the channel does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task AddDmRecipientAsync(ulong userId, string accessToken, string nickname)
=&gt; this.Discord.ApiClient.AddGroupDmRecipientAsync(this.Id, userId, accessToken, nickname);
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The id of the User to remove.&lt;/param&gt;
⋮----
public Task RemoveDmRecipientAsync(ulong userId, string accessToken)
=&gt; this.Discord.ApiClient.RemoveGroupDmRecipientAsync(this.Id, userId);</file><file path="DisCatSharp/Entities/Channel/DiscordFollowedChannel.cs">/// &lt;summary&gt;
///     Represents a followed channel.
/// &lt;/summary&gt;
public class DiscordFollowedChannel : ObservableApiObject
⋮----
///     Gets the id of the channel following the announcement channel.
⋮----
///     Gets the id of the webhook that posts crossposted messages to the channel.</file><file path="DisCatSharp/Entities/Channel/DiscordGuildDirectoryChannel.cs">/// &lt;summary&gt;
///     Represents a discord guild directory channel.
/// &lt;/summary&gt;
public class DiscordGuildDirectoryChannel : DiscordChannel, IEquatable&lt;DiscordGuildDirectoryChannel&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; class.
⋮----
this.Guild.ChannelsInternal.Values.Where(e =&gt; e.ParentId == this.Id).Select(x =&gt; x as DiscordGuildDirectoryEntry).ToList();
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; is equal to another
///     &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;
///     Whether the &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; is equal to this
⋮----
/// &lt;/returns&gt;
public bool Equals(DiscordGuildDirectoryChannel e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordGuildDirectoryChannel);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First channel to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second channel to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two channels are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuildDirectoryChannel&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two channels are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Channel/DiscordGuildDirectoryEntry.cs">/// &lt;summary&gt;
///     Represents a discord guild directory channel.
/// &lt;/summary&gt;
public class DiscordGuildDirectoryEntry : DiscordChannel, IEquatable&lt;DiscordGuildDirectoryEntry&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; class.
⋮----
///     Gets the description of the directory entry.
⋮----
///     Gets the primary category of the directory entry.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; is equal to another
///     &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;
///     Whether the &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; is equal to this
⋮----
/// &lt;/returns&gt;
public bool Equals(DiscordGuildDirectoryEntry e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordGuildDirectoryEntry);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First channel to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second channel to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two channels are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuildDirectoryEntry&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two channels are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Channel/Overwrite/DiscordOverwrite.cs">/// &lt;summary&gt;
///     Represents a permission overwrite for a channel.
/// &lt;/summary&gt;
public class DiscordOverwrite : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordOverwrite&quot; /&gt; class.
⋮----
///     Gets the type of the overwrite. Either &quot;role&quot; or &quot;member&quot;.
⋮----
///     Gets the allowed permission set.
⋮----
///     Gets the denied permission set.
⋮----
///     Checks whether given permissions are allowed, denied, or not set.
⋮----
/// &lt;param name=&quot;permission&quot;&gt;Permissions to check.&lt;/param&gt;
/// &lt;returns&gt;Whether given permissions are allowed, denied, or not set.&lt;/returns&gt;
public PermissionLevel CheckPermission(Permissions permission) =&gt;
⋮----
///     Automatically converts this &lt;see cref=&quot;DiscordOverwrite&quot; /&gt; to a &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt;.
⋮----
///     Deletes this channel overwrite.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason as to why this overwrite gets deleted.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the overwrite does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task DeleteAsync(string reason = null) =&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.ChannelId, this.Id, reason);
⋮----
///     Updates this channel overwrite.
⋮----
/// &lt;param name=&quot;allow&quot;&gt;Permissions that are allowed.&lt;/param&gt;
/// &lt;param name=&quot;deny&quot;&gt;Permissions that are denied.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason as to why you made this change.&lt;/param&gt;
⋮----
public Task UpdateAsync(Permissions? allow = null, Permissions? deny = null, string reason = null)
=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.ChannelId, this.Id, allow ?? this.Allowed, deny ?? this.Denied, this.Type.ToString().ToLowerInvariant(), reason);
⋮----
///     Gets the DiscordMember that is affected by this overwrite.
⋮----
/// &lt;returns&gt;The DiscordMember that is affected by this overwrite&lt;/returns&gt;
⋮----
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.AccessChannels&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordMember&gt; GetMemberAsync() =&gt;
⋮----
? throw new ArgumentException(nameof(this.Type), &quot;This overwrite is for a role, not a member.&quot;)
: await (await this.Discord.ApiClient.GetChannelAsync(this.ChannelId).ConfigureAwait(false)).Guild.GetMemberAsync(this.Id).ConfigureAwait(false);
⋮----
///     Gets the DiscordRole that is affected by this overwrite.
⋮----
/// &lt;returns&gt;The DiscordRole that is affected by this overwrite&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the role does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordRole&gt; GetRoleAsync() =&gt;
⋮----
? throw new ArgumentException(nameof(this.Type), &quot;This overwrite is for a member, not a role.&quot;)
: (await this.Discord.ApiClient.GetChannelAsync(this.ChannelId).ConfigureAwait(false)).Guild.GetRole(this.Id);
⋮----
///     Converts this &lt;see cref=&quot;DiscordOverwrite&quot; /&gt; into a &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt;.
⋮----
/// &lt;returns&gt;The created &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt;.&lt;/returns&gt;
public DiscordOverwriteBuilder ConvertToBuilder()</file><file path="DisCatSharp/Entities/Channel/Overwrite/DiscordOverwriteBuilder.cs">/// &lt;summary&gt;
///     Represents a Discord permission overwrite builder.
/// &lt;/summary&gt;
public sealed class DiscordOverwriteBuilder
⋮----
///     Creates a new &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt; for a &lt;see cref=&quot;SnowflakeObject&quot; /&gt;.
⋮----
///     Creates a new &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt; for a &lt;see cref=&quot;DiscordMember&quot; /&gt;.
⋮----
///     Creates a new &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt; for a &lt;see cref=&quot;DiscordRole&quot; /&gt;.
⋮----
///     Creates a new &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt; from &lt;see cref=&quot;DiscordOverwrite&quot; /&gt;.
⋮----
///     Creates a new and empty &lt;see cref=&quot;DiscordOverwriteBuilder&quot; /&gt;.
⋮----
///     Gets or sets the allowed permissions for this overwrite.
⋮----
///     Gets or sets the denied permissions for this overwrite.
⋮----
///     Sets all unset permissions for this overwrite.
⋮----
set =&gt; this.Remove(value);
⋮----
///     Gets or sets the type of this overwrite&apos;s target.
⋮----
///     Gets or sets the target for this overwrite.
⋮----
///     Allows a permission for this overwrite.
⋮----
/// &lt;param name=&quot;permission&quot;&gt;Permission or permission set to allow for this overwrite.&lt;/param&gt;
/// &lt;returns&gt;This builder.&lt;/returns&gt;
public DiscordOverwriteBuilder Allow(Permissions permission)
⋮----
this.Remove(permission);
⋮----
///     Denies a permission for this overwrite.
⋮----
/// &lt;param name=&quot;permission&quot;&gt;Permission or permission set to deny for this overwrite.&lt;/param&gt;
⋮----
public DiscordOverwriteBuilder Deny(Permissions permission)
⋮----
///     Unsets a permission for this overwrite.
⋮----
/// &lt;param name=&quot;permission&quot;&gt;Permission or permission set to unset for this overwrite.&lt;/param&gt;
⋮----
public DiscordOverwriteBuilder Remove(Permissions permission)
⋮----
this.Allowed = this.Allowed.Revoke(permission);
this.Denied = this.Denied.Revoke(permission);
⋮----
///     Sets the member to which this overwrite applies.
⋮----
/// &lt;param name=&quot;member&quot;&gt;Member to which apply this overwrite&apos;s permissions.&lt;/param&gt;
⋮----
public DiscordOverwriteBuilder SetTarget(DiscordMember member)
⋮----
/// &lt;inheritdoc cref=&quot;SetTarget(DiscordMember)&quot; /&gt;
public DiscordOverwriteBuilder For(DiscordMember member)
=&gt; this.SetTarget(member);
⋮----
///     Sets the role to which this overwrite applies.
⋮----
/// &lt;param name=&quot;role&quot;&gt;Role to which apply this overwrite&apos;s permissions.&lt;/param&gt;
⋮----
public DiscordOverwriteBuilder SetTarget(DiscordRole role)
⋮----
/// &lt;inheritdoc cref=&quot;SetTarget(DiscordRole)&quot; /&gt;
public DiscordOverwriteBuilder For(DiscordRole role)
=&gt; this.SetTarget(role);
⋮----
///     Builds this DiscordOverwrite.
⋮----
/// &lt;returns&gt;Use this object for creation of new overwrites.&lt;/returns&gt;
internal DiscordRestOverwrite Build()
⋮----
public static class DiscordOverwriteBuilderExtensions
⋮----
///     Merges new permissions for a target with target&apos;s existing permissions.
⋮----
/// &lt;param name=&quot;builderList&quot;&gt;The PermissionOverwrites to apply this to.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;What type of overwrite you want to target.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The target&apos;s id.&lt;/param&gt;
/// &lt;param name=&quot;allowed&quot;&gt;The permissions to allow.&lt;/param&gt;
/// &lt;param name=&quot;denied&quot;&gt;The permissions deny.&lt;/param&gt;
/// &lt;param name=&quot;unset&quot;&gt;The permissions to unset.&lt;/param&gt;
/// &lt;returns&gt;A new &lt;see cref=&quot;List{DiscordOverwriteBuilder}&quot; /&gt; containing the merged role.&lt;/returns&gt;
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, OverwriteType type, ulong target, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
⋮----
var newList = builderList.ToList();
⋮----
if (!newList.Any(x =&gt; x.Target == target &amp;&amp; x.Type == type))
newList.Add(new()
⋮----
var discordOverwriteBuilder = newList.First(x =&gt; x.Target == target &amp;&amp; x.Type == type);
discordOverwriteBuilder.Allow(allowed);
discordOverwriteBuilder.Deny(denied);
discordOverwriteBuilder.Remove(unset);
⋮----
///     Merges new permissions for member with member&apos;s existing permissions.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member of which to modify their permissions.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;denied&quot;&gt;The permissions to deny.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A new &lt;see cref=&quot;List{DiscordOverwriteBuilder}&quot; /&gt; containing the merged member.&lt;/returns&gt;
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, DiscordMember member, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
=&gt; builderList.Merge(OverwriteType.Member, member.Id, allowed, denied, unset);
⋮----
///     Merges new permissions for role with role&apos;s existing permissions.
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role of which to modify their permissions.&lt;/param&gt;
⋮----
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwriteBuilder&gt; builderList, DiscordRole role, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
=&gt; builderList.Merge(OverwriteType.Role, role.Id, allowed, denied, unset);
⋮----
/// &lt;inheritdoc cref=&quot;Merge(IEnumerable{DiscordOverwriteBuilder}, DiscordMember, Permissions, Permissions, Permissions)&quot; /&gt;
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, DiscordMember member, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(OverwriteType.Member, member.Id, allowed, denied, unset);
⋮----
/// &lt;inheritdoc cref=&quot;Merge(IEnumerable{DiscordOverwriteBuilder}, DiscordRole, Permissions, Permissions, Permissions)&quot; /&gt;
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, DiscordRole role, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(OverwriteType.Role, role.Id, allowed, denied, unset);
⋮----
/// &lt;inheritdoc
///     cref=&quot;Merge(IEnumerable{DiscordOverwriteBuilder}, OverwriteType, ulong, Permissions, Permissions, Permissions)&quot; /&gt;
public static List&lt;DiscordOverwriteBuilder&gt; Merge(this IEnumerable&lt;DiscordOverwrite&gt; builderList, OverwriteType type, ulong target, Permissions allowed, Permissions denied, Permissions unset = Permissions.None)
=&gt; builderList.Select(x =&gt; new DiscordOverwriteBuilder(x)).Merge(type, target, allowed, denied, unset);
⋮----
///     Determines what is allowed.
⋮----
///     Determines what is denied.
⋮----
///     Gets or sets the id.
⋮----
///     Gets or sets the overwrite type.</file><file path="DisCatSharp/Entities/Color/DiscordColor.Colors.cs">/// &lt;summary&gt;
///     Represents no color, or integer 0;
/// &lt;/summary&gt;
⋮----
///     A near-black color. Due to API limitations, the color is #010101, rather than #000000, as the latter is treated as
///     no color.
⋮----
///     White, or #FFFFFF.
⋮----
///     Gray, or #808080.
⋮----
///     Dark gray, or #A9A9A9.
⋮----
///     Light gray, or #808080.
⋮----
///     Very dark gray, or #666666.
⋮----
// See https://discord.com/branding.
⋮----
///     Discord Blurple, or #5865F2.
⋮----
///     Discord Fuchsia, or #EB459E.
⋮----
///     Discord Green, or #57F287.
⋮----
///     Discord Yellow, or #FEE75C.
⋮----
///     Discord Red, or #ED4245.
⋮----
///     Dark red, or #7F0000.
⋮----
///     Dark green, or #007F00.
⋮----
///     Blue, or #0000FF.
⋮----
///     Dark blue, or #00007F.
⋮----
///     Cyan, or #00FFFF.
⋮----
///     Magenta, or #FF00FF.
⋮----
///     Teal, or #008080.
⋮----
// meme
⋮----
///     Aquamarine, or #00FFBF.
⋮----
///     Gold, or #FFD700.
⋮----
///     Goldenrod, or #DAA520.
⋮----
///     Azure, or #007FFF.
⋮----
///     Rose, or #FF007F.
⋮----
///     Spring green, or #00FF7F.
⋮----
///     Chartreuse, or #7FFF00.
⋮----
///     Orange, or #FFA500.
⋮----
///     Purple, or #800080.
⋮----
///     Violet, or #EE82EE.
⋮----
///     Brown, or #A52A2A.
⋮----
///     Hot pink, or #FF69B4
⋮----
///     Lilac, or #C8A2C8.
⋮----
///     Cornflower blue, or #6495ED.
⋮----
///     Midnight blue, or #191970.
⋮----
///     Wheat, or #F5DEB3.
⋮----
///     Indian red, or #CD5C5C.
⋮----
///     Turquoise, or #30D5C8.
⋮----
///     Sap green, or #507D2A.
⋮----
// meme, specifically bob ross
⋮----
///     Phthalo blue, or #000F89.
⋮----
///     Phthalo green, or #123524.
⋮----
///     Sienna, or #882D17.</file><file path="DisCatSharp/Entities/Color/DiscordColor.cs">/// &lt;summary&gt;
///     Represents a color used in Discord API.
/// &lt;/summary&gt;
⋮----
///     Gets the integer representation of this color.
⋮----
///     Gets the red component of this color as an 8-bit integer.
⋮----
///     Gets the green component of this color as an 8-bit integer.
⋮----
///     Gets the blue component of this color as an 8-bit integer.
⋮----
///     Creates a new color with specified value.
⋮----
/// &lt;param name=&quot;color&quot;&gt;Value of the color.&lt;/param&gt;
⋮----
///     Creates a new color with specified values for red, green, and blue components.
⋮----
/// &lt;param name=&quot;r&quot;&gt;Value of the red component.&lt;/param&gt;
/// &lt;param name=&quot;g&quot;&gt;Value of the green component.&lt;/param&gt;
/// &lt;param name=&quot;b&quot;&gt;Value of the blue component.&lt;/param&gt;
⋮----
throw new ArgumentOutOfRangeException(null, &quot;Each component must be between 0.0 and 1.0 inclusive.&quot;);
⋮----
///     Creates a new color from specified string representation.
⋮----
/// &lt;param name=&quot;color&quot;&gt;String representation of the color. Must be 6 hexadecimal characters, optionally with # prefix.&lt;/param&gt;
⋮----
if (string.IsNullOrWhiteSpace(color))
throw new ArgumentNullException(nameof(color), &quot;Null or empty values are not allowed!&quot;);
⋮----
throw new ArgumentException(&quot;Color must be 6 or 7 characters in length.&quot;, nameof(color));
⋮----
color = color.ToUpper();
⋮----
throw new ArgumentException(&quot;7-character colors must begin with #.&quot;, nameof(color));
⋮----
if (color.Any(xc =&gt; !s_hexAlphabet.Contains(xc)))
throw new ArgumentException(&quot;Colors must consist of hexadecimal characters only.&quot;, nameof(color));
⋮----
this.Value = int.Parse(color, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
⋮----
///     Gets a string representation of this color.
⋮----
/// &lt;returns&gt;String representation of this color.&lt;/returns&gt;
public override string ToString() =&gt; $&quot;#{this.Value:X6}&quot;;</file><file path="DisCatSharp/Entities/Core/CooldownBucket.cs">/// &lt;summary&gt;
///     Represents a cooldown bucket.
/// &lt;/summary&gt;
// ReSharper disable once ClassCanBeSealed.Global &quot;This class can be inherited from by developers.&quot;
public class CooldownBucket : IBucket, IEquatable&lt;CooldownBucket&gt;
⋮----
///     Gets the semaphore used to lock the use value.
⋮----
internal readonly SemaphoreSlim UsageSemaphore;
⋮----
///     Gets the remaining uses for this bucket.
⋮----
///     Creates a new command cooldown bucket.
⋮----
/// &lt;param name=&quot;maxUses&quot;&gt;Maximum number of uses for this bucket.&lt;/param&gt;
/// &lt;param name=&quot;resetAfter&quot;&gt;Time after which this bucket resets.&lt;/param&gt;
/// &lt;param name=&quot;commandId&quot;&gt;ID of the command&lt;/param&gt;
/// &lt;param name=&quot;commandName&quot;&gt;Name of the command.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;ID of the user with which this cooldown is associated.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;ID of the channel with which this cooldown is associated.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;ID of the guild with which this cooldown is associated.&lt;/param&gt;
/// &lt;param name=&quot;memberId&quot;&gt;ID of the member with which this cooldown is associated.&lt;/param&gt;
⋮----
///     The member id for this bucket.
⋮----
///     The user id for this bucket.
⋮----
///     The channel id for this bucket.
⋮----
///     The guild id for this bucket.
⋮----
///     The id for this bucket.
⋮----
///     The remaining uses for this bucket.
⋮----
=&gt; Volatile.Read(ref this.RemainingUsesInternal);
⋮----
///     The max uses for this bucket.
⋮----
///     The datetime offset when this bucket resets.
⋮----
///     The timespan when this bucket resets.
⋮----
///     Checks whether this &lt;see cref=&quot;CooldownBucket&quot; /&gt; is equal to another &lt;see cref=&quot;CooldownBucket&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;&lt;see cref=&quot;CooldownBucket&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;CooldownBucket&quot; /&gt; is equal to this &lt;see cref=&quot;CooldownBucket&quot; /&gt;.&lt;/returns&gt;
public bool Equals(CooldownBucket? other)
⋮----
///     Decrements the remaining use counter.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The context.&lt;/param&gt;
/// &lt;returns&gt;Whether decrement succeeded or not.&lt;/returns&gt;
internal async Task&lt;bool&gt; DecrementUseAsync(DisCatSharpCommandContext ctx)
⋮----
await this.UsageSemaphore.WaitAsync().ConfigureAwait(false);
ctx.Client.Logger.LogDebug($&quot;[Cooldown::prev_check({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
⋮----
Interlocked.Exchange(ref this.RemainingUsesInternal, this.MaxUses);
⋮----
ctx.Client.Logger.LogDebug($&quot;[Cooldown::check({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
⋮----
Interlocked.Decrement(ref this.RemainingUsesInternal);
⋮----
this.UsageSemaphore.Release();
⋮----
ctx.Client.Logger.LogWarning($&quot;[Cooldown::hit({ctx.FullCommandName})]:\n\tRemaining: {this.RemainingUses}/{this.MaxUses}\n\tResets: {this.ResetsAt}\n\tNow: {DateTimeOffset.UtcNow}\n\tVars[u,c,g,m]: {this.UserId} {this.ChannelId} {this.GuildId} {this.MemberId}\n\tId: {this.BucketId}&quot;);
⋮----
///     Checks whether this &lt;see cref=&quot;CooldownBucket&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;CooldownBucket&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object? obj)
=&gt; this.Equals(obj as CooldownBucket);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;CooldownBucket&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;CooldownBucket&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; HashCode.Combine(this.UserId, this.ChannelId, this.GuildId, this.MemberId);
⋮----
///     Gets whether the two &lt;see cref=&quot;CooldownBucket&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;bucket1&quot;&gt;First bucket to compare.&lt;/param&gt;
/// &lt;param name=&quot;bucket2&quot;&gt;Second bucket to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two buckets are equal.&lt;/returns&gt;
⋮----
return (null1 &amp;&amp; null2) || (null1 == null2 &amp;&amp; null1.Equals(null2));
⋮----
///     Gets whether the two &lt;see cref=&quot;CooldownBucket&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two buckets are not equal.&lt;/returns&gt;
⋮----
///     Creates a bucket ID from given bucket parameters.
⋮----
/// &lt;returns&gt;Generated bucket ID.&lt;/returns&gt;
public static string MakeId(string commandId, string commandName, ulong userId = 0, ulong channelId = 0, ulong guildId = 0, ulong memberId = 0)
=&gt; $&quot;{commandId}:{commandName}::{userId.ToString(CultureInfo.InvariantCulture)}:{channelId.ToString(CultureInfo.InvariantCulture)}:{guildId.ToString(CultureInfo.InvariantCulture)}:{memberId.ToString(CultureInfo.InvariantCulture)}&quot;;</file><file path="DisCatSharp/Entities/Core/DisCatSharpCommandContext.cs">/// &lt;summary&gt;
///     Interface for various command types like slash commands, user commands, message commands, text commands, etc.
/// &lt;/summary&gt;
public class DisCatSharpCommandContext
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DisCatSharpCommandContext&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The command type.&lt;/param&gt;
⋮----
///     Gets the client.
⋮----
///     Gets the id of the user who executes this command.
⋮----
///     Gets the id of the channel this command gets executed in.
⋮----
///     Gets the id of the guild this command gets executed in.
⋮----
///     Gets the id of the member who executes this command.
⋮----
///     Gets the id of the command.
⋮----
///     Gets the name of the command.
⋮----
///     Gets the name of the sub command.
⋮----
///     Gets the name of the sub command within a sub group.
⋮----
///     Gets the fully qualified name of the command.
⋮----
///     Gets the type of the command.</file><file path="DisCatSharp/Entities/Core/IBucket.cs">/// &lt;summary&gt;
///     Defines the standard contract for bucket feature
/// &lt;/summary&gt;
public interface IBucket
⋮----
///     Gets the ID of the user whom this cooldown is associated
⋮----
///     Gets the ID of the channel with which this cooldown is associated
⋮----
///     Gets the ID of the guild with which this cooldown is associated
⋮----
///     Gets the ID of the bucket. This is used to distinguish between cooldown buckets
⋮----
///     Gets the remaining number of uses before the cooldown is triggered
⋮----
///     Gets the maximum number of times this command can be used in a given timespan
⋮----
///     Gets the date and time at which the cooldown resets
⋮----
///     Get the time after which this cooldown resets</file><file path="DisCatSharp/Entities/Core/ICooldown.cs">/// &lt;summary&gt;
///     Cooldown feature contract
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TContextType&quot;&gt;Type of &lt;see cref=&quot;DisCatSharpCommandContext&quot; /&gt; in which this cooldown handles&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TBucketType&quot;&gt;Type of Cooldown bucket&lt;/typeparam&gt;
public interface ICooldown&lt;in TContextType, out TBucketType&gt;
where TContextType : DisCatSharpCommandContext
where TBucketType : CooldownBucket
⋮----
///     Gets the maximum number of uses before this command triggers a cooldown for its bucket.
⋮----
///     Gets the time after which the cooldown is reset.
⋮----
///     Gets the type of the cooldown bucket. This determines how a cooldown is applied.
⋮----
///     Calculates the cooldown remaining for given context.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Context for which to calculate the cooldown.&lt;/param&gt;
/// &lt;returns&gt;Remaining cooldown, or zero if no cooldown is active&lt;/returns&gt;
TimeSpan GetRemainingCooldown(TContextType ctx);
⋮----
///     Gets a cooldown bucket for given context
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;Command context to get cooldown bucket for.&lt;/param&gt;
/// &lt;returns&gt;Requested cooldown bucket, or null if one wasn&apos;t present&lt;/returns&gt;
TBucketType GetBucket(TContextType ctx);
⋮----
///     Responds to a ratelimit hit.
⋮----
/// &lt;param name=&quot;ctx&quot;&gt;The command context.&lt;/param&gt;
/// &lt;param name=&quot;noHit&quot;&gt;Whether the ratelimit wasn&apos;t hit.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;The cooldown bucket.&lt;/param&gt;
Task&lt;bool&gt; RespondRatelimitHitAsync(TContextType ctx, bool noHit, CooldownBucket bucket);</file><file path="DisCatSharp/Entities/DiscordLocales.cs">public static class DiscordLocales</file><file path="DisCatSharp/Entities/DiscordProtocol.cs">/// &lt;summary&gt;
///     Represents the discord protocol.
/// &lt;/summary&gt;
public sealed class DiscordProtocol
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordProtocol&quot; /&gt; class.</file><file path="DisCatSharp/Entities/DiscordSignedLink.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordSignedLink&quot; /&gt; used for attachments and other things to improve security
///     and prevent bad actors from abusing Discord&apos;s CDN.
/// &lt;/summary&gt;
⋮----
public sealed class DiscordSignedLink : DiscordUri
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordSignedLink&quot; /&gt; class with the specified URI for signed discord
///     links.
⋮----
/// &lt;param name=&quot;uri&quot;&gt;An &lt;see cref=&quot;Uri&quot; /&gt;.&lt;/param&gt;
⋮----
ArgumentNullException.ThrowIfNull(uri);
⋮----
if (string.IsNullOrWhiteSpace(uri.Query))
⋮----
var queries = HttpUtility.ParseQueryString(uri.Query);
⋮----
if (!queries.HasKeys())
⋮----
if (queries.Get(&quot;ex&quot;) is { } expiresString &amp;&amp; long.TryParse(expiresString, NumberStyles.HexNumber,
⋮----
this.ExpiresAt = DateTimeOffset.FromUnixTimeSeconds(expiresTimeStamp);
⋮----
if (queries.Get(&quot;is&quot;) is { } issuedString &amp;&amp;
long.TryParse(issuedString, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var issuedTimeStamp))
this.IssuedAt = DateTimeOffset.FromUnixTimeSeconds(issuedTimeStamp);
⋮----
this.Signature = queries.Get(&quot;hm&quot;);
⋮----
/// &lt;param name=&quot;uriString&quot;&gt;
///     A string that identifies the resource to be represented by the &lt;see cref=&quot;DiscordSignedLink&quot; /&gt;
///     instance.
/// &lt;/param&gt;
⋮----
ArgumentNullException.ThrowIfNull(uriString);
⋮----
var uri = this.ToUri() ?? throw new UriFormatException(&quot;Invalid URI format.&quot;);
⋮----
///     Gets whether the url is signed.
⋮----
=&gt; this.ExpiresAt.HasValue &amp;&amp; this.IssuedAt.HasValue &amp;&amp; !string.IsNullOrWhiteSpace(this.Signature);
⋮----
///     Gets when the signed link expires.
⋮----
///     Gets when the signed link was generated.
⋮----
///     Gets the signature of the signed link.
⋮----
///     Returns a string representation of this &lt;see cref=&quot;DiscordSignedLink&quot;/&gt;.
⋮----
/// &lt;returns&gt;This &lt;see cref=&quot;DiscordSignedLink&quot;/&gt;, as a string.&lt;/returns&gt;
public override string? ToString()
⋮----
///    Converts a &lt;see cref=&quot;DiscordSignedLink&quot; /&gt; to a &lt;see cref=&quot;Uri&quot; /&gt; implicitly, if possible.
⋮----
/// &lt;param name=&quot;duri&quot;&gt;The &lt;see cref=&quot;DiscordSignedLink&quot; /&gt; to convert.&lt;/param&gt;
⋮----
=&gt; duri.ToUri();
⋮----
///     Represents a &lt;see cref=&quot;DiscordSignedLinkJsonConverter&quot; /&gt;.
⋮----
internal sealed class DiscordSignedLinkJsonConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
=&gt; writer.WriteValue((value as DiscordSignedLink)?._value);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object? ReadJson(
⋮----
? throw new JsonReaderException(&quot;DiscordSignedLink value invalid format! This is a bug in DisCatSharp. &quot; +
⋮----
: new DiscordSignedLink(s);
⋮----
///     Whether it can be converted.
⋮----
/// &lt;returns&gt;A bool.&lt;/returns&gt;
public override bool CanConvert(Type objectType)</file><file path="DisCatSharp/Entities/DiscordUri.cs">/// &lt;summary&gt;
///     An URI in a Discord embed doesn&apos;t necessarily conform to the RFC 3986. If it uses the &lt;c&gt;attachment://&lt;/c&gt;
///     protocol, it mustn&apos;t contain a trailing slash to be interpreted correctly as an embed attachment reference by
///     Discord.
/// &lt;/summary&gt;
⋮----
public class DiscordUri
⋮----
///     Gets the raw value.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordUri&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
⋮----
this._value = value ?? throw new ArgumentNullException(nameof(value));
⋮----
ArgumentNullException.ThrowIfNull(value);
⋮----
this._value = new Uri(value);
⋮----
///     The type of this URI.
⋮----
///     Whether the uri is a standard uri
⋮----
/// &lt;param name=&quot;value&quot;&gt;Uri string&lt;/param&gt;
⋮----
private static bool IsStandard(string value)
=&gt; !value.StartsWith(&quot;attachment://&quot;, StringComparison.Ordinal);
⋮----
///     Returns a string representation of this &lt;see cref=&quot;DiscordUri&quot;/&gt;.
⋮----
/// &lt;returns&gt;This &lt;see cref=&quot;DiscordUri&quot;/&gt;, as a string.&lt;/returns&gt;
public override string? ToString()
⋮----
///    Converts a &lt;see cref=&quot;DiscordUri&quot; /&gt; to a &lt;see cref=&quot;Uri&quot; /&gt; implicitly, if possible.
⋮----
/// &lt;param name=&quot;duri&quot;&gt;The &lt;see cref=&quot;DiscordUri&quot; /&gt; to convert.&lt;/param&gt;
⋮----
=&gt; duri.ToUri();
⋮----
///     Converts this &lt;see cref=&quot;DiscordUri&quot;/&gt; into a canonical representation of a &lt;see cref=&quot;Uri&quot; /&gt; if it can be represented as
///     such, throwing an exception otherwise.
⋮----
/// &lt;returns&gt;A canonical representation of this DiscordUri.&lt;/returns&gt;
/// &lt;exception cref=&quot;UriFormatException&quot;&gt;
///     If &lt;see cref=&quot;System.Type&quot; /&gt; is not &lt;see cref=&quot;DiscordUriType.Standard&quot; /&gt;, as
///     that would mean creating an invalid Uri, which would result in loss of data.
/// &lt;/exception&gt;
public Uri? ToUri()
⋮----
: throw new UriFormatException(
⋮----
///     Represents a uri json converter.
⋮----
internal sealed class DiscordUriJsonConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
=&gt; writer.WriteValue((value as DiscordUri)?._value);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object? ReadJson(
⋮----
? throw new JsonReaderException(&quot;DiscordUri value invalid format! This is a bug in DisCatSharp. &quot; +
⋮----
? new(new Uri(s))
: new DiscordUri(s);
⋮----
///     Whether it can be converted.
⋮----
/// &lt;returns&gt;A bool.&lt;/returns&gt;
public override bool CanConvert(Type objectType)
⋮----
///     Represents a uri type.
⋮----
///     Represents a URI that conforms to RFC 3986, meaning it&apos;s stored internally as a &lt;see cref=&quot;Uri&quot; /&gt; and will
///     contain a trailing slash after the domain name.
⋮----
///     Represents a URI that does not conform to RFC 3986, meaning it&apos;s stored internally as a plain string and
///     should be treated as one.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedAuthor.cs">/// &lt;summary&gt;
///     Gets the author of a discord embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedAuthor : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedAuthor&quot; /&gt; class.
⋮----
///     Gets the name of the author.
⋮----
///     Gets the url of the author.
⋮----
///     Gets the url of the author&apos;s icon.
⋮----
///     Gets the proxied url of the author&apos;s icon.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedBuilder.cs">/// &lt;summary&gt;
///     Constructs embeds.
/// &lt;/summary&gt;
public sealed class DiscordEmbedBuilder
⋮----
///
⋮----
///     Constructs a new empty embed builder.
⋮----
///     Constructs a new embed builder using another embed as prototype.
⋮----
/// &lt;param name=&quot;original&quot;&gt;Embed to use as prototype.&lt;/param&gt;
⋮----
if (original.Fields.Any())
this._fields.AddRange(original.Fields);
⋮----
this._fields.RemoveAt(this._fields.Count - 1);
⋮----
///     Gets or sets the embed&apos;s title.
⋮----
throw new ArgumentException(&quot;Title length cannot exceed 256 characters.&quot;, nameof(value));
⋮----
///     Gets or sets the embed&apos;s description.
⋮----
throw new ArgumentException(&quot;Description length cannot exceed 4096 characters.&quot;, nameof(value));
⋮----
///     Gets or sets the url for the embed&apos;s title.
⋮----
set =&gt; this._url = string.IsNullOrEmpty(value) ? null : new Uri(value);
⋮----
///     Gets or sets the embed&apos;s color.
⋮----
///     Gets or sets the embed&apos;s timestamp.
⋮----
///     Gets or sets the embed&apos;s image url.
⋮----
set =&gt; this._imageUri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);
⋮----
///     Gets or sets the embed&apos;s author.
⋮----
///     Gets or sets the embed&apos;s footer.
⋮----
///     Gets or sets the embed&apos;s thumbnail.
⋮----
///     Gets the embed&apos;s fields.
⋮----
///     Sets the embed&apos;s title.
⋮----
/// &lt;param name=&quot;title&quot;&gt;Title to set.&lt;/param&gt;
/// &lt;returns&gt;This embed builder.&lt;/returns&gt;
public DiscordEmbedBuilder WithTitle(string title)
⋮----
///     Sets the embed&apos;s description.
⋮----
/// &lt;param name=&quot;description&quot;&gt;Description to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithDescription(string description)
⋮----
///     Sets the embed&apos;s title url.
⋮----
/// &lt;param name=&quot;url&quot;&gt;Title url to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithUrl(string url)
⋮----
public DiscordEmbedBuilder WithUrl(Uri url)
⋮----
///     Sets the embed&apos;s color.
⋮----
/// &lt;param name=&quot;color&quot;&gt;Embed color to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithColor(DiscordColor color)
⋮----
///     Sets the embed&apos;s timestamp.
⋮----
/// &lt;param name=&quot;timestamp&quot;&gt;Timestamp to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithTimestamp(DateTimeOffset? timestamp)
⋮----
public DiscordEmbedBuilder WithTimestamp(DateTime? timestamp)
⋮----
this.Timestamp = timestamp == null ? null : new DateTimeOffset(timestamp.Value);
⋮----
///     Sets the embed&apos;s timestamp based on a snowflake.
⋮----
/// &lt;param name=&quot;snowflake&quot;&gt;Snowflake to calculate timestamp from.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithTimestamp(ulong snowflake)
⋮----
this.Timestamp = new DateTimeOffset(2015, 1, 1, 0, 0, 0, TimeSpan.Zero).AddMilliseconds(snowflake &gt;&gt; 22);
⋮----
///     Sets the embed&apos;s image url.
⋮----
/// &lt;param name=&quot;url&quot;&gt;Image url to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithImageUrl(string url)
⋮----
public DiscordEmbedBuilder WithImageUrl(Uri url)
⋮----
///     Sets the embed&apos;s thumbnail.
⋮----
/// &lt;param name=&quot;url&quot;&gt;Thumbnail url to set.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height of the thumbnail to set.&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;The width of the thumbnail to set.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithThumbnail(string url, int height = 0, int width = 0)
⋮----
public DiscordEmbedBuilder WithThumbnail(Uri url, int height = 0, int width = 0)
⋮----
///     Sets the embed&apos;s author.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Author&apos;s name.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;Author&apos;s url.&lt;/param&gt;
/// &lt;param name=&quot;iconUrl&quot;&gt;Author icon&apos;s url.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithAuthor(string? name = null, string? url = null, string? iconUrl = null)
⋮----
if (!string.IsNullOrEmpty(name) &amp;&amp; name.Length &gt; 256)
throw new NotSupportedException(&quot;Embed author name can not exceed 256 chars. See https://discord.com/developers/docs/resources/channel#embed-limits.&quot;);
⋮----
this.Author = string.IsNullOrEmpty(name) &amp;&amp; string.IsNullOrEmpty(url) &amp;&amp; string.IsNullOrEmpty(iconUrl)
⋮----
: new EmbedAuthor
⋮----
///     Sets the embed&apos;s footer.
⋮----
/// &lt;param name=&quot;text&quot;&gt;Footer&apos;s text.&lt;/param&gt;
/// &lt;param name=&quot;iconUrl&quot;&gt;Footer icon&apos;s url.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder WithFooter(string? text = null, string? iconUrl = null)
⋮----
throw new ArgumentException(&quot;Footer text length cannot exceed 2048 characters.&quot;, nameof(text));
⋮----
this.Footer = string.IsNullOrEmpty(text) &amp;&amp; string.IsNullOrEmpty(iconUrl)
⋮----
: new EmbedFooter
⋮----
///     Adds a field to this embed.
⋮----
/// &lt;param name=&quot;field&quot;&gt;The field to add.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder AddField(DiscordEmbedField field)
⋮----
throw new InvalidOperationException(&quot;Cannot add more than 25 fields.&quot;);
⋮----
if (string.IsNullOrWhiteSpace(field.Name))
⋮----
ArgumentNullException.ThrowIfNull(field.Name);
⋮----
throw new ArgumentException(&quot;Name cannot be empty or whitespace.&quot;, nameof(field));
⋮----
throw new ArgumentException(&quot;Embed field name length cannot exceed 256 characters.&quot;, nameof(field));
⋮----
if (string.IsNullOrWhiteSpace(field.Value))
⋮----
ArgumentNullException.ThrowIfNull(field.Value);
⋮----
throw new ArgumentException(&quot;Value cannot be empty or whitespace.&quot;, nameof(field));
⋮----
throw new ArgumentException(&quot;Embed field value length cannot exceed 1024 characters.&quot;, nameof(field));
⋮----
this._fields.Add(field);
⋮----
///     Adds multiple fields to this embed.
⋮----
/// &lt;param name=&quot;fields&quot;&gt;The fields to add.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder AddFields(params DiscordEmbedField[] fields)
=&gt; this.AddFields((IEnumerable&lt;DiscordEmbedField&gt;)fields);
⋮----
public DiscordEmbedBuilder AddFields(IEnumerable&lt;DiscordEmbedField&gt; fields)
=&gt; fields.Aggregate(this, (x, y) =&gt; x.AddField(y));
⋮----
///     Removes a field from this embed, if it is part of it.
⋮----
/// &lt;param name=&quot;field&quot;&gt;The field to remove.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder RemoveField(DiscordEmbedField field)
⋮----
this._fields.Remove(field);
⋮----
///     Removes multiple fields from this embed, if they are part of it.
⋮----
/// &lt;param name=&quot;fields&quot;&gt;The fields to remove.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder RemoveFields(params DiscordEmbedField[] fields)
⋮----
this.RemoveFields((IEnumerable&lt;DiscordEmbedField&gt;)fields);
⋮----
public DiscordEmbedBuilder RemoveFields(IEnumerable&lt;DiscordEmbedField&gt; fields)
⋮----
this._fields.RemoveAll(fields.Contains);
⋮----
///     Removes a field of the specified index from this embed.
⋮----
/// &lt;param name=&quot;index&quot;&gt;Index of the field to remove.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder RemoveFieldAt(int index)
⋮----
this._fields.RemoveAt(index);
⋮----
///     Removes fields of the specified range from this embed.
⋮----
/// &lt;param name=&quot;index&quot;&gt;Index of the first field to remove.&lt;/param&gt;
/// &lt;param name=&quot;count&quot;&gt;Number of fields to remove.&lt;/param&gt;
⋮----
public DiscordEmbedBuilder RemoveFieldRange(int index, int count)
⋮----
this._fields.RemoveRange(index, count);
⋮----
///     Removes all fields from this embed.
⋮----
public DiscordEmbedBuilder ClearFields()
⋮----
this._fields.Clear();
⋮----
///     Constructs a new embed from data supplied to this builder.
⋮----
/// &lt;returns&gt;New discord embed.&lt;/returns&gt;
public DiscordEmbed Build()
⋮----
var embed = new DiscordEmbed
⋮----
ColorInternal = this.Color.Map(e =&gt; e.Value),
⋮----
if (embed.Fields.Any())
⋮----
if (embed.Author is not null &amp;&amp; !string.IsNullOrEmpty(embed.Author.Name))
⋮----
if (embed.Footer is not null &amp;&amp; !string.IsNullOrEmpty(embed.Footer.Text))
⋮----
if (!string.IsNullOrEmpty(embed.Title))
⋮----
if (!string.IsNullOrEmpty(embed.Description))
⋮----
? throw new NotSupportedException(&quot;Total char count can not exceed 6000 chars. See https://discord.com/developers/docs/resources/channel#embed-limits.&quot;)
⋮----
///     Implicitly converts this builder to an embed.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;Builder to convert.&lt;/param&gt;
⋮----
=&gt; builder is not null ? builder.Build() : throw new NullReferenceException(&quot;Argument builder was null&quot;);
⋮----
///     Represents an embed author.
⋮----
public sealed class EmbedAuthor
⋮----
///     Gets or sets the name of the author.
⋮----
throw new ArgumentException(&quot;Author name length cannot exceed 256 characters.&quot;, nameof(value));
⋮----
///     Gets or sets the Url to which the author&apos;s link leads.
⋮----
set =&gt; this.Uri = string.IsNullOrEmpty(value) ? null : new Uri(value);
⋮----
///     Gets or sets the Author&apos;s icon url.
⋮----
set =&gt; this.IconUri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);
⋮----
///     Represents an embed footer.
⋮----
public sealed class EmbedFooter
⋮----
///     Gets or sets the text of the footer.
⋮----
throw new ArgumentException(&quot;Footer text length cannot exceed 2048 characters.&quot;, nameof(value));
⋮----
///     Gets or sets the Url
⋮----
///     Represents an embed thumbnail.
⋮----
public sealed class EmbedThumbnail
⋮----
///     Gets or sets the thumbnail&apos;s image url.
⋮----
set =&gt; this.Uri = string.IsNullOrEmpty(value) ? null : new DiscordUri(value);
⋮----
///     Gets or sets the thumbnail&apos;s height.
⋮----
///     Gets or sets the thumbnail&apos;s width.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedField.cs">/// &lt;summary&gt;
///     Represents a field inside a discord embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedField : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedField&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;name&quot;&gt;
///     &lt;see cref=&quot;Name&quot; /&gt;
/// &lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;
///     &lt;see cref=&quot;Value&quot; /&gt;
⋮----
/// &lt;param name=&quot;inline&quot;&gt;
///     &lt;see cref=&quot;Inline&quot; /&gt;
⋮----
///     The name of the field.
///     Must be non-null, non-empty and &amp;lt;= 256 characters.
⋮----
/// ///
⋮----
///     The value of the field.
///     Must be non-null, non-empty and &amp;lt;= 1024 characters.
⋮----
///     Whether or not this field should display inline.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedFooter.cs">/// &lt;summary&gt;
///     Represents a footer in an embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedFooter : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedFooter&quot; /&gt; class.
⋮----
///     Gets the footer&apos;s text.
⋮----
///     Gets the url of the footer&apos;s icon.
⋮----
///     Gets the proxied url of the footer&apos;s icon.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedImage.cs">/// &lt;summary&gt;
///     Represents an image in an embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedImage : DiscordUnfurledMedia
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedImage&quot; /&gt; class.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedProvider.cs">/// &lt;summary&gt;
///     Represents an embed provider.
/// &lt;/summary&gt;
public sealed class DiscordEmbedProvider : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedProvider&quot; /&gt; class.
⋮----
///     Gets the name of the provider.
⋮----
///     Gets the url of the provider.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedThumbnail.cs">/// &lt;summary&gt;
///     Represents a thumbnail in an embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedThumbnail : DiscordUnfurledMedia
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedThumbnail&quot; /&gt; class.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbedVideo.cs">/// &lt;summary&gt;
///     Represents a video inside an embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbedVideo : DiscordUnfurledMedia
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbedVideo&quot; /&gt; class.</file><file path="DisCatSharp/Entities/Emoji/PartialEmoji.cs">/// &lt;summary&gt;
///     Represents a partial emoji to be send to discord.
/// &lt;/summary&gt;
public sealed class PartialEmoji
⋮----
///     Constructs a new &lt;see cref=&quot;PartialEmoji&quot; /&gt; from a guild emoji id.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The emojis id.&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;PartialEmoji&quot; /&gt; from an unicode emoji.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The unicode. I.e. 😀&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;PartialEmoji&quot; /&gt; from a &lt;see cref=&quot;DiscordEmoji&quot; /&gt;
⋮----
/// &lt;param name=&quot;discordEmoji&quot;&gt;&lt;/param&gt;
⋮----
///     Creates a new empty &lt;see cref=&quot;PartialEmoji&quot; /&gt;
⋮----
///     Sets whether this emoji is animated.
⋮----
///     Sets the guild emoji.
⋮----
///     Sets the unicode emoji.
⋮----
///     Implicitly converts &lt;see cref=&quot;DiscordEmoji&quot; /&gt; to &lt;see cref=&quot;PartialEmoji&quot; /&gt;.</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodAction.cs">/// &lt;summary&gt;
///     Represents an action which will execute when a rule is triggered.
/// &lt;/summary&gt;
public class AutomodAction : ObservableApiObject
⋮----
///     Creates a new empty automod action.
⋮----
///     Creates a new automod action.
⋮----
/// &lt;param name=&quot;actionType&quot;&gt;The type of action.&lt;/param&gt;
/// &lt;param name=&quot;metadata&quot;&gt;The additional metadata for this action.&lt;/param&gt;
⋮----
///     The type of action.
⋮----
///     The additional meta data needed during execution for this specific action type.</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodActionMetadata.cs">/// &lt;summary&gt;
///     Additional data used when an action is executed.
///     Different fields are relevant based on the action type.
/// &lt;/summary&gt;
public class AutomodActionMetadata : ObservableApiObject
⋮----
///     The channel to which user content should be logged.
///     Only works with SendAlertMessage.
⋮----
///     The timeout duration in seconds.
///     Maximum of 2419200 seconds (4 weeks).</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodRule.cs">/// &lt;summary&gt;
///     Represents an auto mod rule.
/// &lt;/summary&gt;
public class AutomodRule : SnowflakeObject
⋮----
///     Gets the id of the guild this rule belongs to.
⋮----
///     Gets the name of this rule.
⋮----
///     The id of the user who first created this rule.
⋮----
///     Gets the type of this rule.
⋮----
///     Gets the trigger type of this rule.
⋮----
///     Gets the rule trigger meta data.
⋮----
///     The actions which will execute when the rule is triggered.
⋮----
///     Whether the rule is enabled.
⋮----
///     The role ids that should not be affected by the rule.
///     Maximum of 20.
⋮----
///     The channel ids that should not be affected by the rule.
///     Maximum of 50.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
⋮----
///     Modifies this auto mod rule.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this rule.&lt;/param&gt;
/// &lt;returns&gt;The modified rule object.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the rule does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task&lt;AutomodRule&gt; ModifyAsync(Action&lt;AutomodRuleEditModel&gt; action)
⋮----
var mdl = new AutomodRuleEditModel();
⋮----
throw new ArgumentException($&quot;Cannot use KeywordFilter and RegexPattern for a {this.TriggerType} rule. Only {AutomodTriggerType.Keyword} is valid in this context.&quot;);
⋮----
throw new ArgumentException($&quot;Cannot use AllowList for a {this.TriggerType} rule. Only {AutomodTriggerType.KeywordPreset} is valid in this context.&quot;);
⋮----
throw new ArgumentException($&quot;Cannot use MentionTotalLimit for a {this.TriggerType} rule. Only {AutomodTriggerType.MentionSpam} is valid in this context.&quot;);
⋮----
throw new ArgumentException($&quot;Cannot use MentionRaidProtectionEnabled for a {this.TriggerType} rule. Only {AutomodTriggerType.MentionSpam} is valid in this context.&quot;);
⋮----
return await this.Discord.ApiClient.ModifyAutomodRuleAsync(this.GuildId, this.Id, mdl.Name, mdl.EventType, mdl.TriggerMetadata, mdl.Actions, mdl.Enabled, mdl.ExemptRoles, mdl.ExemptChannels, mdl.AuditLogReason).ConfigureAwait(false);
⋮----
///     Deletes this auto mod rule.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The reason for this deletion.&lt;/param&gt;
⋮----
public async Task DeleteAsync(string reason = null)
=&gt; await this.Discord.ApiClient.DeleteAutomodRuleAsync(this.GuildId, this.Id, reason).ConfigureAwait(false);</file><file path="DisCatSharp/Entities/Guild/Automod/AutomodTriggerMetadata.cs">/// &lt;summary&gt;
///     Represents the rule&apos;s meta data.
/// &lt;/summary&gt;
public class AutomodTriggerMetadata : ObservableApiObject
⋮----
///     &lt;para&gt;The substrings which will be searched for in content. Maximum of 1000.&lt;/para&gt;
///     &lt;para&gt;
///         A keyword can be a phrase which contains multiple words. Wildcard symbols (not available to allow lists) can
///         be used to customize how each keyword will be matched.
///     &lt;/para&gt;
⋮----
///         See
///         &lt;see
///             href=&quot;https://discord.com/developers/docs/resources/auto-moderation#auto-moderation-rule-object-keyword-matching-strategies&quot;&gt;
///             keyword
///             matching strategies
///         &lt;/see&gt;
///         . Each keyword must be 30 characters or less.
⋮----
///     The internally predefined word-sets which will be searched for in content.
⋮----
///     &lt;para&gt;The regex patterns the content will be checked against. Maximum of 10.&lt;/para&gt;
⋮----
///         Only Rust flavored regex is currently supported, which can be tested in online editors such as
///         &lt;see href=&quot;https://rustexp.lpil.uk/&quot;&gt;Rustexp&lt;/see&gt;.
⋮----
///     &lt;para&gt; Each regex pattern must be 75 characters or less.&lt;/para&gt;
⋮----
///     The substrings which will be exempt from triggering the preset type. Maximum of 1000.
⋮----
///     The total number of unique role and user mentions allowed per message. Maximum of 50.
⋮----
///     Whether to automatically detect mention raids.</file><file path="DisCatSharp/Entities/Guild/DiscordAuditLogObjects.cs">/// &lt;summary&gt;
///     Represents an audit log entry.
/// &lt;/summary&gt;
public abstract class DiscordAuditLogEntry : SnowflakeObject
⋮----
///     Gets the entry&apos;s action type.
⋮----
///     Gets the user responsible for the action.
⋮----
///     Gets the reason defined in the action.
⋮----
///     Gets the category under which the action falls.
⋮----
///     Represents a description of how a property changed.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the changed property.&lt;/typeparam&gt;
public sealed class PropertyChange&lt;T&gt;
⋮----
///     The property&apos;s value before it was changed.
⋮----
///     The property&apos;s value after it was changed.
⋮----
///     Represents a audit log guild entry.
⋮----
public sealed class DiscordAuditLogGuildEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogGuildEntry&quot; /&gt; class.
⋮----
///     Gets the affected guild.
⋮----
///     Gets the name change.
⋮----
///     Gets the owner change.
⋮----
///     Gets the icon change.
⋮----
///     Gets the verification level change.
⋮----
///     Gets the afk channel change.
⋮----
///     Gets the system channel flags change.
⋮----
///     &lt;see cref=&quot;DiscordGuild.WidgetChannel&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.RulesChannel&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.PublicUpdatesChannel&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.DefaultMessageNotifications&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.SystemChannel&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.ExplicitContentFilter&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.MfaLevel&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.SplashUrl&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.VoiceRegion&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.VanityUrlCode&quot; /&gt;
⋮----
///     &lt;see cref=&quot;DiscordGuild.PremiumProgressBarEnabled&quot; /&gt;
⋮----
///     Represents a audit log channel entry.
⋮----
public sealed class DiscordAuditLogChannelEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogChannelEntry&quot; /&gt; class.
⋮----
///     Gets the affected channel.
⋮----
///     Gets the description of channel&apos;s name change.
⋮----
///     Gets the description of channel&apos;s type change.
⋮----
///     Gets the description of channel&apos;s nsfw flag change.
⋮----
///     Gets the rtc region id change.
⋮----
///     Gets the description of channel&apos;s bitrate change.
⋮----
///     Gets the description of channel permission overwrites&apos; change.
⋮----
///     Gets the description of channel&apos;s topic change.
⋮----
///     Gets the user limit change.
⋮----
///     Gets the description of channel&apos;s slow mode timeout change.
⋮----
///     Gets the channel flags change.
⋮----
///     Gets the default auto archive duration change.
⋮----
///     Gets the default available tags change.
⋮----
///     Represents a audit log overwrite entry.
⋮----
public sealed class DiscordAuditLogOverwriteEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogOverwriteEntry&quot; /&gt; class.
⋮----
///     Gets the affected overwrite.
⋮----
///     Gets the channel for which the overwrite was changed.
⋮----
///     Gets the description of overwrite&apos;s allow value change.
⋮----
///     Gets the description of overwrite&apos;s deny value change.
⋮----
///     Gets the description of overwrite&apos;s type change.
⋮----
///     Gets the description of overwrite&apos;s target id change.
⋮----
///     Represents a audit log kick entry.
⋮----
public sealed class DiscordAuditLogKickEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogKickEntry&quot; /&gt; class.
⋮----
///     Gets the kicked member.
⋮----
///     Represents a audit log prune entry.
⋮----
public sealed class DiscordAuditLogPruneEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogPruneEntry&quot; /&gt; class.
⋮----
///     Gets the number inactivity days after which members were pruned.
⋮----
///     Gets the number of members pruned.
⋮----
///     Represents a audit log ban entry.
⋮----
public sealed class DiscordAuditLogBanEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogBanEntry&quot; /&gt; class.
⋮----
///     Gets the banned member.
⋮----
///     Represents a audit log member update entry.
⋮----
public sealed class DiscordAuditLogMemberUpdateEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogMemberUpdateEntry&quot; /&gt; class.
⋮----
///     Gets the affected member.
⋮----
///     Gets the description of member&apos;s nickname change.
⋮----
///     Gets the roles that were removed from the member.
⋮----
///     Gets the roles that were added to the member.
⋮----
///     Gets the description of member&apos;s mute status change.
⋮----
///     Gets the description of member&apos;s deaf status change.
⋮----
///     Get&apos;s the timeout change.
⋮----
///     Represents a audit log role update entry.
⋮----
public sealed class DiscordAuditLogRoleUpdateEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogRoleUpdateEntry&quot; /&gt; class.
⋮----
///     Gets the affected role.
⋮----
///     Gets the description of role&apos;s name change.
⋮----
///     Gets the description of role&apos;s color change.
⋮----
///     Gets the description of role&apos;s permission set change.
⋮----
///     Gets the description of the role&apos;s position change.
⋮----
///     Gets the description of the role&apos;s mentionability change.
⋮----
///     Gets the description of the role&apos;s hoist status change.
⋮----
///     Gets the role icon hash change.
⋮----
///     Represents a audit log invite entry.
⋮----
public sealed class DiscordAuditLogInviteEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogInviteEntry&quot; /&gt; class.
⋮----
///     Gets the affected invite.
⋮----
///     Gets the description of invite&apos;s max age change.
⋮----
///     Gets the description of invite&apos;s code change.
⋮----
///     Gets the description of invite&apos;s temporariness change.
⋮----
///     Gets the description of invite&apos;s inviting member change.
⋮----
///     Gets the description of invite&apos;s target channel change.
⋮----
///     Gets the description of invite&apos;s use count change.
⋮----
///     Gets the description of invite&apos;s max use count change.
⋮----
///     Represents a audit log webhook entry.
⋮----
public sealed class DiscordAuditLogWebhookEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogWebhookEntry&quot; /&gt; class.
⋮----
///     Gets the affected webhook.
⋮----
///     Undocumented.
⋮----
///     Gets the description of webhook&apos;s name change.
⋮----
///     Gets the description of webhook&apos;s target channel change.
⋮----
///     Gets the description of webhook&apos;s type change.
⋮----
///     Gets the description of webhook&apos;s avatar change.
⋮----
///     Represents a audit log emoji entry.
⋮----
public sealed class DiscordAuditLogEmojiEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogEmojiEntry&quot; /&gt; class.
⋮----
///     Gets the affected emoji.
⋮----
///     Gets the description of emoji&apos;s name change.
⋮----
///     Represents a audit log sticker entry.
⋮----
public sealed class DiscordAuditLogStickerEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogStickerEntry&quot; /&gt; class.
⋮----
///     Gets the affected sticker.
⋮----
///     Gets the description of sticker&apos;s name change.
⋮----
///     Gets the description of sticker&apos;s description change.
⋮----
///     Gets the description of sticker&apos;s tags change.
⋮----
///     Gets the description of sticker&apos;s guild id change.
⋮----
///     Gets the description of sticker&apos;s availability change.
⋮----
///     Gets the description of sticker&apos;s id change.
⋮----
///     Gets the description of sticker&apos;s type change.
⋮----
///     Gets the description of sticker&apos;s format change.
⋮----
///     Represents a audit log message entry.
⋮----
public sealed class DiscordAuditLogMessageEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogMessageEntry&quot; /&gt; class.
⋮----
///     Gets the affected message. Note that more often than not, this will only have ID specified.
⋮----
///     Gets the channel in which the action occurred.
⋮----
///     Gets the number of messages that were affected.
⋮----
///     Represents a audit log message pin entry.
⋮----
public sealed class DiscordAuditLogMessagePinEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogMessagePinEntry&quot; /&gt; class.
⋮----
///     Gets the affected message&apos;s user.
⋮----
///     Gets the channel the message is in.
⋮----
///     Gets the message the pin action was for.
⋮----
///     Represents a audit log bot add entry.
⋮----
public sealed class DiscordAuditLogBotAddEntry : DiscordAuditLogEntry
⋮----
///     Gets the bot that has been added to the guild.
⋮----
///     Represents a audit log member move entry.
⋮----
public sealed class DiscordAuditLogMemberMoveEntry : DiscordAuditLogEntry
⋮----
///     Gets the channel the members were moved in.
⋮----
///     Gets the amount of users that were moved out from the voice channel.
⋮----
///     Represents a audit log member disconnect entry.
⋮----
public sealed class DiscordAuditLogMemberDisconnectEntry : DiscordAuditLogEntry
⋮----
///     Gets the amount of users that were disconnected from the voice channel.
⋮----
///     Represents a audit log integration entry.
⋮----
public sealed class DiscordAuditLogIntegrationEntry : DiscordAuditLogEntry
⋮----
///     The type of integration.
⋮----
///     Gets the description of emoticons&apos; change.
⋮----
///     Gets the description of expire grace period&apos;s change.
⋮----
///     Gets the description of expire behavior change.
⋮----
///     Represents a audit log stage entry.
⋮----
public sealed class DiscordAuditLogStageEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogStageEntry&quot; /&gt; class.
⋮----
///     Gets the affected stage instance
⋮----
///     Gets the description of stage instance&apos;s topic change.
⋮----
///     Represents a audit log event entry.
⋮----
public sealed class DiscordAuditLogGuildScheduledEventEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogGuildScheduledEventEntry&quot; /&gt; class.
⋮----
///     Gets the affected event
⋮----
///     Gets the channel change.
⋮----
///     Gets the description change.
⋮----
/* Will be added https://github.com/discord/discord-api-docs/pull/3586#issuecomment-969137241
        public PropertyChange&lt;&gt; ScheduledStartTimeChange { get; internal set; }

        public PropertyChange&lt;&gt; ScheduledEndTimeChange { get; internal set; }
        */
⋮----
///     Gets the location change.
⋮----
///     Gets the status change.
⋮----
///     Gets the entity type change.
⋮----
///     Represents a audit log thread entry.
⋮----
public sealed class DiscordAuditLogThreadEntry : DiscordAuditLogEntry
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAuditLogThreadEntry&quot; /&gt; class.
⋮----
///     Gets the affected thread
⋮----
///     Gets the name of the thread.
⋮----
///     Gets the type of the thread.
⋮----
///     Gets the archived state of the thread.
⋮----
///     Gets the locked state of the thread.
⋮----
///     Gets the invitable state of the thread.
⋮----
///     Gets the new auto archive duration of the thread.
⋮----
///     Gets the new ratelimit of the thread.</file><file path="DisCatSharp/Entities/Guild/DiscordBan.cs">/// &lt;summary&gt;
///     Represents a Discord ban
/// &lt;/summary&gt;
public class DiscordBan : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordBan&quot; /&gt; class.
⋮----
///     Gets the reason for the ban
⋮----
///     Gets the banned user
⋮----
///     Gets the raw user.</file><file path="DisCatSharp/Entities/Guild/DiscordBulkBanResponse.cs">/// &lt;summary&gt;
///     Represents a bulk ban response
/// &lt;/summary&gt;
public sealed class DiscordBulkBanResponse : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordBulkBanResponse&quot; /&gt; class.
⋮----
///     Gets the list of user ids, that were successfully banned.
⋮----
///     &lt;para&gt;Gets the list of user ids, that were not banned.&lt;/para&gt;
///     &lt;para&gt;These users were either already banned or could not be banned due to various reasons.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Guild/DiscordGameActivity.cs">/// &lt;summary&gt;
///    Represents a Discord game activity.
/// &lt;/summary&gt;
public sealed class DiscordGameActivity
⋮----
///    Gets the activity level.
⋮----
///    Gets the activity score.</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.AuditLog.cs">public partial class DiscordGuild
⋮----
// TODO: Rework audit logs!
⋮----
/// &lt;summary&gt;
///     Gets audit log entries for this guild.
/// &lt;/summary&gt;
/// &lt;param name=&quot;limit&quot;&gt;Maximum number of entries to fetch.&lt;/param&gt;
/// &lt;param name=&quot;byMember&quot;&gt;Filter by member responsible.&lt;/param&gt;
/// &lt;param name=&quot;actionType&quot;&gt;Filter by action type.&lt;/param&gt;
/// &lt;returns&gt;A collection of requested audit log entries.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ViewAuditLog&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task&lt;IReadOnlyList&lt;DiscordAuditLogEntry&gt;&gt; GetAuditLogsAsync(int? limit = null, DiscordMember byMember = null, AuditLogActionType? actionType = null)
⋮----
rmn = Math.Min(100, rmn);
⋮----
var alr = await this.Discord.ApiClient.GetAuditLogsAsync(this.Id, rmn, null, last == 0 ? null : last, byMember?.Id, (int?)actionType).ConfigureAwait(false);
⋮----
alrs.Add(alr);
⋮----
var auditLogResult = await this.ProcessAuditLog(alrs).ConfigureAwait(false);
⋮----
///     Proceesses audit log objects.
⋮----
/// &lt;param name=&quot;auditLogApiResult&quot;&gt;A list of raw audit log objects.&lt;/param&gt;
/// &lt;returns&gt;The processed audit log list as readonly.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordAuditLogEntry&gt;&gt; ProcessAuditLog(List&lt;AuditLog&gt; auditLogApiResult)
⋮----
if (auditLogApiResult.Any(ar =&gt; ar.Users != null &amp;&amp; ar.Users.Any()))
amr = auditLogApiResult.SelectMany(xa =&gt; xa.Users)
.GroupBy(xu =&gt; xu.Id)
.Select(xgu =&gt; xgu.First()).ToList();
⋮----
if (this.Discord.UserCache.ContainsKey(xau.Id))
⋮----
var xtu = new TransportUser
⋮----
var xu = new DiscordUser(xtu)
⋮----
xu = this.Discord.UserCache.AddOrUpdate(xu.Id, xu, (id, old) =&gt;
⋮----
if (auditLogApiResult.Any(ar =&gt; ar.ScheduledEvents != null &amp;&amp; ar.ScheduledEvents.Any()))
atgse = auditLogApiResult.SelectMany(xa =&gt; xa.ScheduledEvents)
.GroupBy(xse =&gt; xse.Id)
.Select(xgse =&gt; xgse.First()).ToList();
⋮----
if (auditLogApiResult.Any(ar =&gt; ar.Threads != null &amp;&amp; ar.Threads.Any()))
ath = auditLogApiResult.SelectMany(xa =&gt; xa.Threads)
.GroupBy(xt =&gt; xt.Id)
.Select(xgt =&gt; xgt.First()).ToList();
⋮----
if (auditLogApiResult.Any(ar =&gt; ar.Integrations != null &amp;&amp; ar.Integrations.Any()))
aig = auditLogApiResult.SelectMany(xa =&gt; xa.Integrations)
.GroupBy(xi =&gt; xi.Id)
.Select(xgi =&gt; xgi.First()).ToList();
⋮----
if (auditLogApiResult.Any(ar =&gt; ar.Webhooks != null &amp;&amp; ar.Webhooks.Any()))
ahr = auditLogApiResult.SelectMany(xa =&gt; xa.Webhooks)
.GroupBy(xh =&gt; xh.Id)
.Select(xgh =&gt; xgh.First()).ToList();
⋮----
ams = amr.Select(xau =&gt; this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xau.Id, out var member)
⋮----
}).ToList();
⋮----
amd = ams.ToDictionary(xm =&gt; xm.Id, xm =&gt; xm);
⋮----
var whr = await this.GetWebhooksAsync().ConfigureAwait(false);
var whs = whr.ToDictionary(xh =&gt; xh.Id, xh =&gt; xh);
⋮----
var amh = ahr.Select(xah =&gt; whs.TryGetValue(xah.Id, out var webhook)
⋮----
ahd = amh.ToDictionary(xh =&gt; xh.Id, xh =&gt; xh);
⋮----
var acs = auditLogApiResult.SelectMany(xa =&gt; xa.Entries).OrderByDescending(xa =&gt; xa.Id);
⋮----
DiscordAuditLogEntry entry = null;
⋮----
entry = new DiscordAuditLogGuildEntry
⋮----
ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
⋮----
Before = this.GetChannel(t1) ?? new DiscordChannel
⋮----
After = this.GetChannel(t2) ?? new DiscordChannel
⋮----
switch (xc.Key.ToLowerInvariant())
⋮----
Before = this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xc.OldValueUlong, out var oldMember) ? oldMember : await this.GetMemberAsync(xc.OldValueUlong).ConfigureAwait(false),
After = this.MembersInternal != null &amp;&amp; this.MembersInternal.TryGetValue(xc.NewValueUlong, out var newMember) ? newMember : await this.GetMemberAsync(xc.NewValueUlong).ConfigureAwait(false)
⋮----
Before = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id}/{xc.OldValueString}.webp&quot; : null,
After = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id}/{xc.NewValueString}.webp&quot; : null
⋮----
Before = xc.OldValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id}/{xc.OldValueString}.webp?size=2048&quot; : null,
After = xc.NewValueString != null ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id}/{xc.NewValueString}.webp?size=2048&quot; : null
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in guild update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogChannelEntry
⋮----
Target = this.GetChannel(xac.TargetId.Value) ?? new DiscordChannel
⋮----
p1 = ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
p2 = ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in channel update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogOverwriteEntry
⋮----
Target = this.GetChannel(xac.TargetId.Value)?.PermissionOverwrites.FirstOrDefault(xo =&gt; xo.Id == xac.Options.Id),
Channel = this.GetChannel(xac.TargetId.Value)
⋮----
p1 = ulong.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t1);
⋮----
p2 = ulong.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t2);
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in overwrite update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogKickEntry
⋮----
Target = amd.TryGetValue(xac.TargetId.Value, out var kickMember)
⋮----
entry = new DiscordAuditLogPruneEntry
⋮----
entry = new DiscordAuditLogBanEntry
⋮----
Target = amd.TryGetValue(xac.TargetId.Value, out var unbanMember)
⋮----
entry = new DiscordAuditLogMemberUpdateEntry
⋮----
Target = amd.TryGetValue(xac.TargetId.Value, out var roleUpdMember)
⋮----
entrymbu.AddedRoles = new ReadOnlyCollection&lt;DiscordRole&gt;(xc.NewValues.Select(xo =&gt; (ulong)xo[&quot;id&quot;]).Select(this.GetRole).ToList());
⋮----
entrymbu.RemovedRoles = new ReadOnlyCollection&lt;DiscordRole&gt;(xc.NewValues.Select(xo =&gt; (ulong)xo[&quot;id&quot;]).Select(this.GetRole).ToList());
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in member update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogRoleUpdateEntry
⋮----
Target = this.GetRole(xac.TargetId.Value) ?? new DiscordRole
⋮----
p1 = int.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t3);
p2 = int.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t4);
⋮----
Before = xc.OldValue != null ? (Permissions?)long.Parse((string)xc.OldValue) : null,
After = xc.NewValue != null ? (Permissions?)long.Parse((string)xc.NewValue) : null
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in role update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogInviteEntry();
⋮----
var inv = new DiscordInvite
⋮----
p2 = int.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t4);
⋮----
Before = amd.TryGetValue(t1, out var propBeforeMember)
⋮----
After = amd.TryGetValue(t2, out var propAfterMember)
⋮----
? this.GetChannel(t1) ?? new DiscordChannel
⋮----
? this.GetChannel(t2) ?? new DiscordChannel
⋮----
// TODO: Add changes for target application
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in invite update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogWebhookEntry
⋮----
case &quot;application_id&quot;: // ???
⋮----
case &quot;type&quot;: // ???
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in webhook update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogEmojiEntry
⋮----
Target = this.EmojisInternal.TryGetValue(xac.TargetId.Value, out var target)
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in emote update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogStageEntry
⋮----
Target = this.StageInstancesInternal.TryGetValue(xac.TargetId.Value, out var stage)
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in stage instance update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogStickerEntry
⋮----
Target = this.StickersInternal.TryGetValue(xac.TargetId.Value, out var sticker)
⋮----
Before = ulong.TryParse(xc.OldValueString, out var ogid) ? ogid : null,
After = ulong.TryParse(xc.NewValueString, out var ngid) ? ngid : null
⋮----
Before = ulong.TryParse(xc.OldValueString, out var oid) ? oid : null,
After = ulong.TryParse(xc.NewValueString, out var nid) ? nid : null
⋮----
p1 = long.TryParse(xc.OldValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t5);
p2 = long.TryParse(xc.NewValue as string, NumberStyles.Integer, CultureInfo.InvariantCulture, out t6);
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in sticker update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogMessageEntry();
⋮----
entrymsg.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
⋮----
&amp;&amp; dc.MessageCache.TryGet(xm =&gt; xm.Id == xac.TargetId.Value &amp;&amp; xm.ChannelId == entrymsg.Channel.Id, out var msg)
⋮----
entry = new DiscordAuditLogMessagePinEntry();
⋮----
DiscordMessage message = default;
⋮----
entrypin.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
⋮----
entrypin.Message = message ?? new DiscordMessage
⋮----
dc.UserCache.TryGetValue(xac.TargetId.Value, out var user);
entrypin.Target = user ?? new DiscordUser
⋮----
entry = new DiscordAuditLogBotAddEntry();
⋮----
dc.UserCache.TryGetValue(xac.TargetId.Value, out var bot);
(entry as DiscordAuditLogBotAddEntry).TargetBot = bot ?? new DiscordUser
⋮----
entry = new DiscordAuditLogMemberMoveEntry();
⋮----
moveentry.Channel = this.GetChannel(xac.Options.ChannelId) ?? new DiscordChannel
⋮----
entry = new DiscordAuditLogMemberDisconnectEntry
⋮----
entry = new DiscordAuditLogIntegrationEntry();
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in integration update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogThreadEntry
⋮----
Target = this.ThreadsInternal.TryGetValue(xac.TargetId.Value, out var thread)
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in thread update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
entry = new DiscordAuditLogGuildScheduledEventEntry
⋮----
Target = this.ScheduledEventsInternal.TryGetValue(xac.TargetId.Value, out var scheduledEvent)
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown key in scheduled event update: {Key} - this should be reported to library developers&quot;, xc.Key);
⋮----
// TODO: Handle ApplicationCommandPermissionUpdate
⋮----
// TODO: Implement auto mod audit log
⋮----
this.Discord.Logger.LogWarning(LoggerEvents.AuditLog, &quot;Unknown audit log action type: {Key} - this should be reported to library developers&quot;, (int)xac.ActionType);
⋮----
entry.UserResponsible = amd.Count != 0 &amp;&amp; amd.TryGetValue(xac.UserId, out var resp)
⋮----
: this.MembersInternal.TryGetValue(xac.UserId, out var mem)
⋮----
entries.Add(entry);</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.Features.cs">/// &lt;summary&gt;
///     Represents the guild features.
/// &lt;/summary&gt;
public class GuildFeatures
⋮----
///     Checks the guild features and constructs a new &lt;see cref=&quot;GuildFeatures&quot; /&gt; object.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;Guild to check&lt;/param&gt;
⋮----
if (guild.RawFeatures.Contains(&quot;APPLICATION_COMMAND_PERMISSIONS_V2&quot;)) this.Features.Add(GuildFeaturesEnum.UsesApplicationCommandsPermissionsV2);
if (guild.RawFeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.RaidAlertsEnabled);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_RESTRICTED&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableRestricted);
if (guild.RawFeatures.Contains(&quot;VOICE_IN_THREADS&quot;)) this.Features.Add(GuildFeaturesEnum.VoiceInThreadsEnabled);
if (guild.RawFeatures.Contains(&quot;CHANNEL_HIGHLIGHTS_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.ChannelHighlightsDisabled);
if (guild.RawFeatures.Contains(&quot;CHANNEL_HIGHLIGHTS&quot;)) this.Features.Add(GuildFeaturesEnum.ChannelHighlights);
if (guild.RawFeatures.Contains(&quot;GUILD_ONBOARDING_EVER_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HadGuildOnBoardingEverEnabled);
if (guild.RawFeatures.Contains(&quot;BURST_REACTIONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanUseBurstReactions);
if (guild.RawFeatures.Contains(&quot;CREATOR_STORE_PAGE&quot;)) this.Features.Add(GuildFeaturesEnum.CanUseCreatorStorePage);
⋮----
if (guild.RawFeatures.Contains(&quot;ANIMATED_ICON&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetAnimatedIcon);
if (guild.RawFeatures.Contains(&quot;ANIMATED_BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetAnimatedBanner);
if (guild.RawFeatures.Contains(&quot;BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetBanner);
if (guild.RawFeatures.Contains(&quot;COMMUNITY&quot;)) this.Features.Add(GuildFeaturesEnum.HasCommunityEnabled);
if (!guild.RawFeatures.Contains(&quot;DISCOVERABLE_DISABLED&quot;) &amp;&amp; guild.RawFeatures.Contains(&quot;DISCOVERABLE&quot;)) this.Features.Add(GuildFeaturesEnum.IsDiscoverable);
if (guild.RawFeatures.Contains(&quot;FEATUREABLE&quot;)) this.Features.Add(GuildFeaturesEnum.IsFeatureable);
if (guild.RawFeatures.Contains(&quot;INVITE_SPLASH&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetInviteSplash);
if (guild.RawFeatures.Contains(&quot;MEMBER_VERIFICATION_GATE_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasMembershipScreeningEnabled);
if (guild.RawFeatures.Contains(&quot;NEWS&quot;)) this.Features.Add(GuildFeaturesEnum.CanCreateNewsChannels);
if (guild.RawFeatures.Contains(&quot;PARTNERED&quot;)) this.Features.Add(GuildFeaturesEnum.IsPartnered);
if (guild.RawFeatures.Contains(&quot;MORE_EMOJI&quot;)) this.Features.Add(GuildFeaturesEnum.CanUploadMoreEmojis);
if (guild.RawFeatures.Contains(&quot;PREVIEW_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasPreviewEnabled);
if (guild.RawFeatures.Contains(&quot;VANITY_URL&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetVanityUrl);
if (guild.RawFeatures.Contains(&quot;VERIFIED&quot;)) this.Features.Add(GuildFeaturesEnum.IsVerified);
if (guild.RawFeatures.Contains(&quot;VIP_REGIONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanAccessVipRegions);
if (guild.RawFeatures.Contains(&quot;WELCOME_SCREEN_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasWelcomeScreenEnabled);
if (guild.RawFeatures.Contains(&quot;TICKETED_EVENTS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasTicketedEventsEnabled);
if (guild.RawFeatures.Contains(&quot;MONETIZATION_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasMonetizationEnabled);
if (guild.RawFeatures.Contains(&quot;MORE_STICKERS&quot;)) this.Features.Add(GuildFeaturesEnum.CanUploadMoreStickers);
if (guild.RawFeatures.Contains(&quot;HUB&quot;)) this.Features.Add(GuildFeaturesEnum.IsHub);
if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED_TESTING&quot;)) this.Features.Add(GuildFeaturesEnum.HasThreadTestingEnabled);
if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasThreadsEnabled);
if (guild.RawFeatures.Contains(&quot;ROLE_ICONS&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetRoleIcons);
if (guild.RawFeatures.Contains(&quot;NEW_THREAD_PERMISSIONS&quot;)) this.Features.Add(GuildFeaturesEnum.HasNewThreadPermissions);
if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.HasRoleSubscriptionsEnabled);
if (guild.RawFeatures.Contains(&quot;PREMIUM_TIER_3_OVERRIDE&quot;)) this.Features.Add(GuildFeaturesEnum.PremiumTierThreeOverride);
if (guild.RawFeatures.Contains(&quot;THREAD_DEFAULT_AUTO_ARCHIVE_DURATION&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetThreadDefaultAutoArchiveDuration);
if (guild.RawFeatures.Contains(&quot;TEXT_IN_VOICE_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.TextInVoiceEnabled);
if (guild.RawFeatures.Contains(&quot;HAS_DIRECTORY_ENTRY&quot;)) this.Features.Add(GuildFeaturesEnum.HasDirectoryEntry);
if (guild.RawFeatures.Contains(&quot;LINKED_TO_HUB&quot;)) this.Features.Add(GuildFeaturesEnum.IsLinkedToHub);
if (guild.RawFeatures.Contains(&quot;MEMBER_PROFILES&quot;)) this.Features.Add(GuildFeaturesEnum.HasMemberProfiles);
if (guild.RawFeatures.Contains(&quot;INTERNAL_EMPLOYEE_ONLY&quot;)) this.Features.Add(GuildFeaturesEnum.IsStaffOnly);
if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE&quot;)) this.Features.Add(GuildFeaturesEnum.RoleSubscriptionsIsAvailableForPurchase);
if (guild.RawFeatures.Contains(&quot;AUTO_MODERATION&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetupAutoModeration);
if (guild.RawFeatures.Contains(&quot;GUILD_HOME_TEST&quot;)) this.Features.Add(GuildFeaturesEnum.GuildHomeTest);
if (guild.RawFeatures.Contains(&quot;INVITES_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.InvitesDisabled);
if (guild.RawFeatures.Contains(&quot;ACTIVITIES_ALPHA&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesAlpha);
if (guild.RawFeatures.Contains(&quot;ACTIVITIES_EMPLOYEE&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesEmployee);
if (guild.RawFeatures.Contains(&quot;ACTIVITIES_INTERNAL_DEV&quot;)) this.Features.Add(GuildFeaturesEnum.ActivitiesInternalDev);
if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_KEYWORD_FILTER&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerKeywordFilter);
if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_ML_SPAM_FILTER&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerMlSpamFilter);
if (guild.RawFeatures.Contains(&quot;AUTOMOD_TRIGGER_SPAM_LINK_FILTERGuild&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodTriggerSpamLinkFilterGuild);
if (guild.RawFeatures.Contains(&quot;AUTOMOD_DEFAULT_LIST&quot;)) this.Features.Add(GuildFeaturesEnum.AutomodDefaultList);
if (guild.RawFeatures.Contains(&quot;BFG&quot;)) this.Features.Add(GuildFeaturesEnum.Bfg);
if (guild.RawFeatures.Contains(&quot;BOOSTING_TIERS_EXPERIMENT_MEDIUM_GUILD&quot;)) this.Features.Add(GuildFeaturesEnum.BoostingTiersExperimentMediumGuild);
if (guild.RawFeatures.Contains(&quot;BOOSTING_TIERS_EXPERIMENT_SMALL_GUILD&quot;)) this.Features.Add(GuildFeaturesEnum.BoostingTiersExperimentSmallGuild);
if (guild.RawFeatures.Contains(&quot;BOT_DEVELOPER_EARLY_ACCESS&quot;)) this.Features.Add(GuildFeaturesEnum.BotDeveloperEarlyAccess);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizable);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableDisabled);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_PROVISIONAL&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableProvisional);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZABLE_WHITEGLOVE&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizableWhiteGlove);
if (guild.RawFeatures.Contains(&quot;CREATOR_MONETIZATION_APPLICATION_ALLOWLIST&quot;)) this.Features.Add(GuildFeaturesEnum.CreatorMonetizationApplicationAllowlist);
if (guild.RawFeatures.Contains(&quot;DEVELOPER_SUPPORT_SERVER&quot;)) this.Features.Add(GuildFeaturesEnum.DeveloperSupportServer);
if (guild.RawFeatures.Contains(&quot;EXPOSED_TO_ACTIVITIES_WTP_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.ExposedToActivitiesWtpExperiment);
if (guild.RawFeatures.Contains(&quot;GUILD_COMMUNICATION_DISABLED_GUILDS&quot;)) this.Features.Add(GuildFeaturesEnum.GuildCommunicationDisabledGuilds);
if (guild.RawFeatures.Contains(&quot;DISABLE_GUILD_COMMUNICATION&quot;)) this.Features.Add(GuildFeaturesEnum.DisableGuildCommunication);
if (guild.RawFeatures.Contains(&quot;GUILD_HOME_OVERRIDE&quot;)) this.Features.Add(GuildFeaturesEnum.GuildHomeOverride);
if (guild.RawFeatures.Contains(&quot;GUILD_AUTOMOD_DEFAULT_LIST&quot;)) this.Features.Add(GuildFeaturesEnum.GuildAutomodDefaultList);
if (guild.RawFeatures.Contains(&quot;GUILD_MEMBER_VERIFICATION_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.GuildMemberVerificationExperiment);
if (guild.RawFeatures.Contains(&quot;GUILD_ROLE_SUBSCRIPTION_PURCHASE_FEEDBACK_LOOP&quot;)) this.Features.Add(GuildFeaturesEnum.GuildRoleSubscriptionPurchaseFeedbackLoop);
if (guild.RawFeatures.Contains(&quot;GUILD_ROLE_SUBSCRIPTION_TRIALS&quot;)) this.Features.Add(GuildFeaturesEnum.GuildRoleSubscriptionTrials);
if (guild.RawFeatures.Contains(&quot;HAD_EARLY_ACTIVITIES_ACCESS&quot;)) this.Features.Add(GuildFeaturesEnum.HadEarlyActivitiesAccess);
if (guild.RawFeatures.Contains(&quot;INCREASED_THREAD_LIMIT&quot;)) this.Features.Add(GuildFeaturesEnum.IncreasedThreadLimit);
if (guild.RawFeatures.Contains(&quot;MOBILE_WEB_ROLE_SUBSCRIPTION_PURCHASE_PAGE&quot;)) this.Features.Add(GuildFeaturesEnum.MobileWebRoleSubscriptionPurchasePage);
if (guild.RawFeatures.Contains(&quot;RELAY_ENABLED&quot;)) this.Features.Add(GuildFeaturesEnum.RelayEnabled);
if (guild.RawFeatures.Contains(&quot;RESTRICT_SPAM_RISK_GUILDS&quot;)) this.Features.Add(GuildFeaturesEnum.RestrictSpamRiskGuilds);
if (guild.RawFeatures.Contains(&quot;ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE&quot;)) this.Features.Add(GuildFeaturesEnum.RoleSubscriptionsAvailableForPurchase);
if (guild.RawFeatures.Contains(&quot;THREADS_ENABLED_TESTING&quot;)) this.Features.Add(GuildFeaturesEnum.ThreadsEnabledTesting);
if (guild.RawFeatures.Contains(&quot;VOICE_CHANNEL_EFFECTS&quot;)) this.Features.Add(GuildFeaturesEnum.VoiceChannelEffects);
if (guild.RawFeatures.Contains(&quot;SOUNDBOARD&quot;)) this.Features.Add(GuildFeaturesEnum.Soundboard);
⋮----
if (guild.RawFeatures.Contains(&quot;COMMERCE&quot;)) this.Features.Add(GuildFeaturesEnum.Commerce);
if (guild.RawFeatures.Contains(&quot;EXPOSED_TO_BOOSTING_TIERS_EXPERIMENT&quot;)) this.Features.Add(GuildFeaturesEnum.ExposedToBoostingTiersExperiment);
if (guild.RawFeatures.Contains(&quot;PUBLIC_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.PublicDisabled);
if (guild.RawFeatures.Contains(&quot;PUBLIC&quot;)) this.Features.Add(GuildFeaturesEnum.Public);
if (guild.RawFeatures.Contains(&quot;SEVEN_DAY_THREAD_ARCHIVE&quot;)) this.Features.Add(GuildFeaturesEnum.SevenDayThreadArchive);
if (guild.RawFeatures.Contains(&quot;THREE_DAY_THREAD_ARCHIVE&quot;)) this.Features.Add(GuildFeaturesEnum.ThreeDayThreadArchive);
if (guild.RawFeatures.Contains(&quot;FEATURABLE&quot;)) this.Features.Add(GuildFeaturesEnum.Featurable);
if (guild.RawFeatures.Contains(&quot;FORCE_RELAY&quot;)) this.Features.Add(GuildFeaturesEnum.ForceRelay);
if (guild.RawFeatures.Contains(&quot;LURKABLE&quot;)) this.Features.Add(GuildFeaturesEnum.Lurkable);
if (guild.RawFeatures.Contains(&quot;MEMBER_LIST_DISABLED&quot;)) this.Features.Add(GuildFeaturesEnum.MemberListDisabled);
if (guild.RawFeatures.Contains(&quot;CHANNEL_BANNER&quot;)) this.Features.Add(GuildFeaturesEnum.CanSetChannelBanner);
if (guild.RawFeatures.Contains(&quot;PRIVATE_THREADS&quot;)) this.Features.Add(GuildFeaturesEnum.CanCreatePrivateThreads);
⋮----
///     List of all guild features.
⋮----
///     Checks whether the guild has a feature enabled.
⋮----
/// &lt;param name=&quot;flag&quot;&gt;The feature you&apos;d like to check for.&lt;/param&gt;
/// &lt;returns&gt;Whether the guild has the requested feature.&lt;/returns&gt;
public bool HasFeature(GuildFeaturesEnum flag)
=&gt; this.Features.Contains(flag);
⋮----
public string ToString(string separator, bool humanReadable)
⋮----
if (!humanReadable) return string.Join(separator, this.Features);
⋮----
var humanReadableFeatures = this.Features.Select(x =&gt; AddSpacesToWord(x.ToString()));
⋮----
return string.Join(separator, humanReadableFeatures);
⋮----
///     Converts a string of characters (here: enum) into a string of characters separated by spaces after a capital
///     letter.
⋮----
/// &lt;param name=&quot;text&quot;&gt;String of text to convert&lt;/param&gt;
/// &lt;returns&gt;String separated by a space after every capital letter.&lt;/returns&gt;
private static string AddSpacesToWord(string text)
⋮----
if (string.IsNullOrWhiteSpace(text))
⋮----
var newText = new StringBuilder(text.Length * 2);
newText.Append(text[0]);
⋮----
if (char.IsUpper(text[i]) &amp;&amp; text[i - 1] != &apos; &apos;)
newText.Append(&apos; &apos;);
newText.Append(text[i]);
⋮----
return newText.ToString();
⋮----
///     Guild has access to set an animated guild icon.
⋮----
///     Guild has access to set a guild banner image.
⋮----
///     Guild has access to use commerce features (i.e. create store channels)
⋮----
///     Guild can enable Welcome Screen, Membership Screening, Stage Channels, News Channels and receives community
///     updates.
///     Furthermore the guild can apply as a partner and for the discovery (if the prerequisites are given).
///     &lt;see cref=&quot;ChannelType.Stage&quot; /&gt; and &lt;see cref=&quot;ChannelType.News&quot; /&gt; is usable.
⋮----
///     Guild is able to be discovered in the discovery.
⋮----
///     Guild is able to be featured in the discovery.
⋮----
///     Guild has access to set an invite splash background.
⋮----
///     Guild has enabled Membership Screening.
⋮----
///     Guild has access to create news channels.
///     &lt;see cref=&quot;ChannelType.News&quot; /&gt; is usable.
⋮----
///     Guild is partnered.
⋮----
///     Guild has increased custom emoji slots.
⋮----
///     Guild can be previewed before joining via Membership Screening or the discovery.
⋮----
///     Guild has access to set a vanity URL.
⋮----
///     Guild is verified.
⋮----
///     Guild has access to set 384kbps bitrate in voice (previously VIP voice servers).
⋮----
///     Guild has enabled the welcome screen.
⋮----
///     Guild has enabled ticketed events.
⋮----
///     Guild has enabled monetization.
⋮----
///     Guild has increased custom sticker slots.
⋮----
///     Guild has access to the three day archive time for threads.
///     Needs Premium Tier 1 (&lt;see cref=&quot;PremiumTier.TierOne&quot; /&gt;).
⋮----
///     Guild has access to the seven day archive time for threads.
///     Needs Premium Tier 2 (&lt;see cref=&quot;PremiumTier.TierTwo&quot; /&gt;).
⋮----
///     Guild has access to create private threads.
⋮----
///     Guild is a hub.
///     &lt;see cref=&quot;ChannelType.GuildDirectory&quot; /&gt; is usable.
⋮----
///     Guild is in a hub.
///     https://github.com/discord/discord-api-docs/pull/3757/commits/4932d92c9d0c783861bc715bf7ebbabb15114e34
⋮----
///     Guild is linked to a hub.
⋮----
///     Guild has full access to threads.
///     Old Feature.
⋮----
///     Guild has access to threads.
⋮----
///     Guild can set role icons.
⋮----
///     Guild has the new thread permissions.
⋮----
///     Guild can set thread default auto archive duration.
⋮----
///     Guild has enabled role subscriptions.
⋮----
///     Guild role subscriptions as purchaseable.
⋮----
///     Guild has premium tier 3 override.
⋮----
///     Guild has access to text in voice.
///     Restricted to &lt;see cref=&quot;IsStaffOnly&quot; /&gt;.
⋮----
///     Guild can set an animated banner.
///     Needs Premium Tier 3 (&lt;see cref=&quot;PremiumTier.TierThree&quot; /&gt;).
⋮----
///     Allows members to customize their avatar, banner and bio for that server.
⋮----
///     Guild is restricted to users with the &lt;see cref=&quot;UserFlags.Staff&quot; /&gt; badge.
⋮----
///     Guild can use and setup the experimental auto moderation feature.
⋮----
///     Guild has access to home.
⋮----
///     Guild has disabled invites.
⋮----
///     Currently unknown.
⋮----
///     Guild has early access features for bot and library developers.
⋮----
///     Guild is set as a support server for an app in App Directory.
⋮----
///     Guild was previously in the 2021-11_activities_baseline_engagement_bundle experiment.
⋮----
///     Guild had early access to the user timeouts.
⋮----
///     Guild has access to the Home feature.
⋮----
///     Guild had early access to the Automod Default List.
⋮----
///     Guild had early access to approving membership manually.
⋮----
///     Guilds was previously in the 2022-05_mobile_web_role_subscription_purchase_page experiment.
⋮----
///     Guild was previously in the 2022-01_guild_role_subscription_trials experiment.
⋮----
///     Guild previously had access to voice channel activities and can bypass the boost level requirement.
⋮----
///     Allows the guild to have 1,000+ active threads.
⋮----
///     Guild was previously in the 2022-05_mobile_web_role_subscription_purchase_page experiment.
⋮----
///     Shards connections to the guild to different nodes that relay information between each other.
⋮----
///     Allows guild&apos;s members to purchase role subscriptions.
⋮----
///     Used by bot developers to test their bots with threads in guilds with 5 or less members and a bot.
⋮----
///     Guild had early access to the voice channel effects.
⋮----
///     Guild had early access to the soundboard feature.
⋮----
///     Ability to create and use store channels.
⋮----
///     Deprecated in favor of Community.
⋮----
///     The guild can use the seven-day archive time for threads.
⋮----
///     The guild can use the three-day archive time for threads.
⋮----
///     Previously used to control which servers were displayed under the &quot;Featured&quot; category in Discovery.
⋮----
///     Created for the Fortnite server blackout event on Oct 13, 2019, when viewing the member list it would show &quot;There&apos;s
///     nothing to see here.&quot;.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildEmoji.cs">/// &lt;summary&gt;
///     Represents a guild emoji.
/// &lt;/summary&gt;
public sealed class DiscordGuildEmoji : DiscordEmoji
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildEmoji&quot; /&gt; class.
⋮----
///     Gets the user that created this emoji.
⋮----
///     Gets the guild to which this emoji belongs.
⋮----
///     Modifies this emoji.
⋮----
/// &lt;param name=&quot;name&quot;&gt;New name for this emoji.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;
///     Roles for which this emoji will be available. This works only if your application is whitelisted as
///     integration.
/// &lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit log.&lt;/param&gt;
/// &lt;returns&gt;The modified emoji.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageGuildExpressions&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the emoji does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;DiscordGuildEmoji&gt; ModifyAsync(string name, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
=&gt; this.Guild.ModifyEmojiAsync(this, name, roles, reason);
⋮----
///     Deletes this emoji.
⋮----
public Task DeleteAsync(string reason = null)
=&gt; this.Guild.DeleteEmojiAsync(this, reason);</file><file path="DisCatSharp/Entities/Guild/DiscordGuildInventorySettings.cs">/// &lt;summary&gt;
///     Represents guild inventory settings.
/// &lt;/summary&gt;
public sealed class DiscordGuildInventorySettings
⋮----
///     Whether anyone is allowed to use and collect this guild&apos;s emojis.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildJoinRequest.cs">/// &lt;summary&gt;
///     Represents a guild join request.
/// &lt;/summary&gt;
public sealed class DiscordGuildJoinRequest : SnowflakeObject
⋮----
///     Gets the id of the join request.
⋮----
///     &lt;para&gt;Gets the id of the interview channel.&lt;/para&gt;
///     &lt;para&gt;This will be a group dm channel.&lt;/para&gt;
///     &lt;para&gt;Bots cannot access this, so it&apos;s pretty much useless.&lt;/para&gt;
⋮----
///     Gets the id of the user that created the join request.
⋮----
///     Gets the user that created the join request.
⋮----
///     Gets the id of the guild that the join request is for.
⋮----
///     Gets the guild that the join request is for.
⋮----
///     Gets the form responses of the join request.
⋮----
///     Gets the application status of the join request.
⋮----
///     Gets the user that actioned the join request.
⋮----
///     Gets the datetime of when the join request was actioned.
⋮----
///     Gets the datetime of when the join request was created.
⋮----
///     &lt;para&gt;Gets the datetime of when the user was last seen.&lt;/para&gt;
///     &lt;para&gt;Seems to always be see &lt;see langword=&quot;null&quot; /&gt; tho.&lt;/para&gt;
⋮----
///     Gets the rejection reason of the join request.
⋮----
///     Modifies this join request.
⋮----
/// &lt;param name=&quot;approve&quot;&gt;Whether to approve or deny this request.&lt;/param&gt;
/// &lt;param name=&quot;rejectionReason&quot;&gt;The optional rejection reason.&lt;/param&gt;
⋮----
public async Task&lt;DiscordGuildJoinRequest&gt; ModifyAsync(bool approve, string? rejectionReason)
=&gt; await this.Discord.ApiClient.ModifyGuildJoinRequestsAsync(this.GuildId, this.RequestId, approve ? JoinRequestStatusType.Approved : JoinRequestStatusType.Rejected, rejectionReason);</file><file path="DisCatSharp/Entities/Guild/DiscordGuildJoinRequestSearchResult.cs">/// &lt;summary&gt;
///     Represents a guild join request search result.
/// &lt;/summary&gt;
public sealed class DiscordGuildJoinRequestSearchResult : ObservableApiObject
⋮----
///     Gets the limit for results.
⋮----
///     Gets the total count of results.
⋮----
///     Gets the join requests.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreening.cs">/// &lt;summary&gt;
///     Represents a guild&apos;s membership screening form.
/// &lt;/summary&gt;
public class DiscordGuildMembershipScreening : ObservableApiObject
⋮----
///     Gets when the fields were last updated.
⋮----
///     Gets the steps in the screening form.
⋮----
///     Gets the server description shown in the screening form.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningField.cs">/// &lt;summary&gt;
///     Represents a field in a guild&apos;s membership screening form
/// &lt;/summary&gt;
public class DiscordGuildMembershipScreeningField : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildMembershipScreeningField&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;label&quot;&gt;The label.&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;The values.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;If true, required.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;placeholder&quot;&gt;The placeholder.&lt;/param&gt;
⋮----
///     Gets the type of the field.
⋮----
///     Gets the title of the field.
⋮----
///     Gets the list of rules
⋮----
///     .
///     Gets whether the user has to fill out this field
⋮----
///     Gets the placeholder.
⋮----
///     Gets the description.
⋮----
///     Unknown.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildMembershipScreeningFieldResponse.cs">/// &lt;summary&gt;
///     Represents a response to a field in a guild&apos;s membership screening form.
/// &lt;/summary&gt;
public sealed class DiscordGuildMembershipScreeningFieldResponse : DiscordGuildMembershipScreeningField
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildMembershipScreeningFieldResponse&quot; /&gt; class.
⋮----
///     Gets the response. Might also be a boolean.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildPreview.cs">/// &lt;summary&gt;
///     Represents the guild preview.
/// &lt;/summary&gt;
public class DiscordGuildPreview : SnowflakeObject
⋮----
///     Gets the emojis.
⋮----
///     Gets the stickers.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildPreview&quot; /&gt; class.
⋮----
///     Gets the guild name.
⋮----
///     Gets the guild icon&apos;s hash.
⋮----
///     Gets the guild icon&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{(this.IconHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot; : null;
⋮----
///     Gets the guild splash&apos;s hash.
⋮----
///     Gets the guild splash&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.png?size=1024&quot; : null;
⋮----
///     Gets the guild discovery splash&apos;s hash.
⋮----
///     Gets the guild discovery splash&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.DiscoverySplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_DISCOVERY_SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.DiscoverySplashHash}.png?size=1024&quot; : null;
⋮----
///     Gets the guild home header&apos;s hash.
⋮----
///     Gets the guild home header&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.HomeHeaderHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_HOME_HEADERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.HomeHeaderHash}.jpg?size=1280&quot; : null;
⋮----
///     Gets a collection of this guild&apos;s emojis.
⋮----
///     Gets a collection of this guild&apos;s stickers.
⋮----
///     Gets a collection of this guild&apos;s features.
⋮----
///     Gets the approximate member count.
⋮----
///     Gets the approximate presence count.
⋮----
///     Gets the description for the guild, if the guild is discoverable.
⋮----
///     Gets the system channel flags for the guild.
⋮----
///     Gets this hub type for the guild, if the guild is a hub.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildProfile.cs">/// &lt;summary&gt;
///     Represents a Discord guild profile.
/// &lt;/summary&gt;
public sealed class DiscordGuildProfile : SnowflakeObject
⋮----
///     Gets the guild name.
⋮----
///     Gets the guild icon&apos;s hash.
⋮----
///     Gets the guild icon&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{(this.IconHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot; : null;
⋮----
///     Gets the guild banner&apos;s hash.
⋮----
///     Gets the guild banner&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BannerHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}&quot; : null;
⋮----
///     Gets the guild custom banner&apos;s hash.
⋮----
///     Gets the guild custom banner&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CustomBannerHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.CUSTOM_BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.CustomBannerHash}.{(this.CustomBannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}&quot; : null;
⋮----
///     Gets the member count.
⋮----
///     Gets the online count.
⋮----
///     Gets the guild description.
⋮----
///     Gets the primary brand color.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BrandColorPrimaryRaw) ? new DiscordColor(this.BrandColorPrimaryRaw) : null;
⋮----
///     Gets the primary badge color.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BadgeColorPrimaryRaw) ? new DiscordColor(this.BadgeColorPrimaryRaw) : null;
⋮----
///     Gets the secondary badge color.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BadgeColorSecondaryRaw) ? new DiscordColor(this.BadgeColorSecondaryRaw) : null;
⋮----
///     Gets the badge hash.
⋮----
///     Gets the badge url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BadgeHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.BADGES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BadgeHash}.png&quot; : null;
⋮----
///     Gets the badge.
⋮----
///     Gets the guild tag.
⋮----
///     Gets the game application IDs.
⋮----
///     Gets the game activities.
⋮----
///     Gets the traits.
⋮----
///     Gets the features.
⋮----
///     &lt;para&gt;Gets the visibility.&lt;/para&gt;
///     &lt;para&gt;&lt;c&gt;1&lt;/c&gt; seems to be the default, for discovery, apply to join and invite only.&lt;/para&gt;
///     &lt;para&gt;&lt;c&gt;3&lt;/c&gt; seems to be for when you enabled &lt;c&gt;Apply From Profile&lt;/c&gt; when having apply to join enabled.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Guild/DiscordGuildTemplate.cs">/// &lt;summary&gt;
///     Represents a guild template.
/// &lt;/summary&gt;
public class DiscordGuildTemplate : ObservableApiObject
⋮----
///     Gets the template code.
⋮----
///     Gets the name of the template.
⋮----
///     Gets the description of the template.
⋮----
///     Gets the number of times the template has been used.
⋮----
///     Gets the ID of the creator of the template.
⋮----
///     Gets the creator of the template.
⋮----
///     Date the template was created.
⋮----
///     Date the template was updated.
⋮----
///     Gets the ID of the source guild.
⋮----
///     Gets the source guild.
⋮----
///     Gets whether the template has unsynced changes.
⋮----
/// &lt;remarks&gt;
///     &lt;see cref=&quot;IsDirty&quot; /&gt;
/// &lt;/remarks&gt;</file><file path="DisCatSharp/Entities/Guild/DiscordGuildTrait.cs">/// &lt;summary&gt;
///    Represents a Discord guild trait.
/// &lt;/summary&gt;
public sealed class DiscordGuildTrait
⋮----
///    Gets whether the emoji is animated.
⋮----
///    Gets the emoji ID.
⋮----
///    Gets the emoji name.
⋮----
///    Gets the label.
⋮----
///    Gets the position.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreen.cs">/// &lt;summary&gt;
///     Represents a discord welcome screen object.
/// &lt;/summary&gt;
public class DiscordGuildWelcomeScreen : ObservableApiObject
⋮----
///     Gets the server description shown in the welcome screen.
⋮----
///     Gets the channels shown in the welcome screen.</file><file path="DisCatSharp/Entities/Guild/DiscordGuildWelcomeScreenChannel.cs">/// &lt;summary&gt;
///     Represents a channel in a welcome screen
/// &lt;/summary&gt;
public class DiscordGuildWelcomeScreenChannel : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuildWelcomeScreenChannel&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel id.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
⋮----
///     Gets the id of the channel.
⋮----
///     Gets the description shown for the channel.
⋮----
///     Gets the emoji id if the emoji is custom, when applicable.
⋮----
///     Gets the name of the emoji if custom or the unicode character if standard, when applicable.</file><file path="DisCatSharp/Entities/Guild/DiscordRoleTags.cs">/// &lt;summary&gt;
///     Represents a Discord role tags object with detailed classification logic.
/// &lt;/summary&gt;
public sealed class DiscordRoleTags : ObservableApiObject
⋮----
///     Whether this role is a guild&apos;s linked role.
⋮----
///     Whether this is the guild&apos;s booster role.
⋮----
///     Gets the ID of the bot this role belongs to.
⋮----
///     Gets the ID of the integration this role belongs to.
⋮----
///     Gets the ID of this role&apos;s subscription SKU and listing.
⋮----
///     Whether this role is available for purchase.
⋮----
///     Whether this role is a guild product role.
⋮----
///     Determines the type of role based on its tags.
⋮----
public RoleType DetermineRoleType()
⋮----
return RoleType.ExternalPlatformOrPremiumSubscriber; // We need to wait for discord to fix this bullshit, to return RoleType.ExternalPlatform or RoleType.PremiumSubscriber.</file><file path="DisCatSharp/Entities/Guild/IncidentsData.cs">/// &lt;summary&gt;
///     Represents an incidents data object
/// &lt;/summary&gt;
public class IncidentsData : ObservableApiObject
⋮----
///     Constructs a new &lt;see cref=&quot;IncidentsData&quot; /&gt; object.
⋮----
///     Gets until when direct messages are disabled.
⋮----
///     Gets until when invites are disabled.
⋮----
///     Gets when the dm spam was detected at.
⋮----
///     Gets when the raid was detected at.</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboarding.cs">/// &lt;summary&gt;
///     Represents a guild&apos;s onboarding configuration.
/// &lt;/summary&gt;
public sealed class DiscordOnboarding : ObservableApiObject
⋮----
///     Constructs a new onboarding configuration.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
⋮----
///     Gets the onboarding prompts
⋮----
///     Gets the default channel ids.
⋮----
///     Gets whether onboarding is enabled.
⋮----
///     Gets the onboarding mode.
⋮----
///     Gets whether the current configuration is below discords requirements.</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordServerGuide.cs">/// &lt;summary&gt;
///     Represents a guild&apos;s server guide.
/// &lt;/summary&gt;
public sealed class DiscordServerGuide : ObservableApiObject
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
⋮----
///     Gets whether the server guide is enabled.
⋮----
///     Gets the welcome message.
⋮----
///     Gets the new member actions.
⋮----
///     Gets the resource channels.</file><file path="DisCatSharp/Entities/Guild/Onboarding/NewMemberAction.cs">/// &lt;summary&gt;
///     Represents a new-member action.
/// &lt;/summary&gt;
public sealed class NewMemberAction : ObservableApiObject
⋮----
///     Constructs a new new-member action.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The action&apos;s target channel id.&lt;/param&gt;
/// &lt;param name=&quot;actionType&quot;&gt;The action&apos;s type.&lt;/param&gt;
/// &lt;param name=&quot;title&quot;&gt;Te action&apos;s title.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The action&apos;s description.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The action&apos;s emoji.&lt;/param&gt;
⋮----
///     Gets the new-member action channel id.
⋮----
///     Gets the new-member action type.
⋮----
///     Gets the new-member action title.
⋮----
///     Gets the new-member action description.
⋮----
///     Gets the new-member action emoji.</file><file path="DisCatSharp/Entities/Guild/Onboarding/ResourceChannel.cs">public sealed class ResourceChannel : ObservableApiObject</file><file path="DisCatSharp/Entities/Guild/Onboarding/WelcomeMessage.cs">/// &lt;summary&gt;
///     Represents a welcome message for the server guide.
/// &lt;/summary&gt;
public sealed class WelcomeMessage : ObservableApiObject
⋮----
///     Constructs a new welcome message for the server guide.
⋮----
/// &lt;param name=&quot;authorId&quot;&gt;The author id.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message. Use &lt;c&gt;[@username]&lt;/c&gt; to mention the new member. Required.&lt;/param&gt;
⋮----
///     Constructs a welcome message for the server guide.
⋮----
///     Gets the welcome message author ids.
///     Can only be &lt;c&gt;1&lt;/c&gt; and target must have write permission.
⋮----
///     Gets the author id.
⋮----
=&gt; this.AuthorIds.First();
⋮----
///     Gets the welcome message.
///     &lt;para&gt; &lt;c&gt;[@username]&lt;/c&gt; is used to mention the new member.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordRecurrenceRuleNWeekday.cs">/// &lt;summary&gt;
///     Represents a specific day within a specific week to recur on.
/// &lt;/summary&gt;
public sealed class DiscordRecurrenceRuleNWeekday
⋮----
///     Gets or sets the week number (1-5) for recurrence.
⋮----
///     Gets or sets the day of the week for recurrence.</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEvent.cs">/// &lt;summary&gt;
///     Represents an scheduled event.
/// &lt;/summary&gt;
public class DiscordScheduledEvent : SnowflakeObject, IEquatable&lt;DiscordScheduledEvent&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; class.
⋮----
///     Gets the guild id of the associated scheduled event.
⋮----
///     Gets the guild to which this scheduled event belongs.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
⋮----
///     Gets the associated channel.
⋮----
=&gt; this.ChannelId.HasValue ? this.Discord.ApiClient.GetChannelAsync(this.ChannelId.Value).Result : null;
⋮----
///     Gets id of the associated channel id.
⋮----
///     Gets the ID of the user that created the scheduled event.
⋮----
[JsonProperty(&quot;creator_id&quot;, NullValueHandling = NullValueHandling.Ignore)] // TODO: Check if this is a bug or not
⋮----
///     Gets the user that created the scheduled event.
⋮----
///     Gets the member that created the scheduled event.
⋮----
=&gt; this.Guild.MembersInternal.TryGetValue(this.CreatorId, out var owner)
⋮----
: this.Discord.ApiClient.GetGuildMemberAsync(this.GuildId, this.CreatorId).Result;
⋮----
///     Gets the name of the scheduled event.
⋮----
///     Gets the description of the scheduled event.
⋮----
///     Gets this event&apos;s cover hash, when applicable.
⋮----
///     Gets this event&apos;s cover in url form.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CoverImageHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.GUILD_EVENTS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.CoverImageHash}.png&quot; : null;
⋮----
///     Gets the scheduled start time of the scheduled event.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.ScheduledStartTimeRaw) &amp;&amp; DateTimeOffset.TryParse(this.ScheduledStartTimeRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the scheduled start time of the scheduled event as raw string.
⋮----
///     Gets the scheduled end time of the scheduled event.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.ScheduledEndTimeRaw) &amp;&amp; DateTimeOffset.TryParse(this.ScheduledEndTimeRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the scheduled end time of the scheduled event as raw string.
⋮----
///     Gets the status of the scheduled event.
⋮----
///     Gets the entity type.
⋮----
///     Gets id of the entity.
⋮----
///     Gets metadata of the entity.
⋮----
/*
	 This isn&apos;t used.
         * See https://github.com/discord/discord-api-docs/pull/3586#issuecomment-969066061.
         * Was originally for paid stages.
        /// &lt;summary&gt;
        /// Gets the sku ids of the scheduled event.
        /// &lt;/summary&gt;
        [JsonProperty(&quot;sku_ids&quot;, NullValueHandling = NullValueHandling.Ignore)]
        public IReadOnlyList&lt;ulong&gt; SkuIds { get; internal set; }
	*/
⋮----
///     Gets the recurrence rule for this scheduled event, if any.
⋮----
///     Gets the total number of users subscribed to the scheduled event.
⋮----
///     Gets whether the scheduled event auto starts.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordScheduledEvent e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordScheduledEvent);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First event to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second event to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two events are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordScheduledEvent&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two events are not equal.&lt;/returns&gt;
⋮----
///     Modifies the current scheduled event.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this thread&lt;/param&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageEvents&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the event does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task ModifyAsync(Action&lt;ScheduledEventEditModel&gt; action)
⋮----
var mdl = new ScheduledEventEditModel();
⋮----
? throw new ArgumentException(&quot;Channel needs to be a voice or stage channel.&quot;)
⋮----
var coverb64 = MediaTool.Base64FromStream(mdl.CoverImage);
⋮----
await this.Discord.ApiClient.ModifyGuildScheduledEventAsync(this.GuildId, this.Id, channelId, this.EntityType == ScheduledEventEntityType.External ? new DiscordScheduledEventEntityMetadata(mdl.Location.Value) : null, mdl.Name, mdl.ScheduledStartTime, scheduledEndTime, mdl.Description, mdl.EntityType, mdl.Status, coverb64, mdl.RecurrenceRule, mdl.AuditLogReason).ConfigureAwait(false);
⋮----
///     Starts the current scheduled event.
⋮----
public async Task&lt;DiscordScheduledEvent&gt; StartAsync(string reason = null)
=&gt; this.Status == ScheduledEventStatus.Scheduled ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Active, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only start scheduled events&quot;);
⋮----
///     Cancels the current scheduled event.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The audit log reason.&lt;/param&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; CancelAsync(string reason = null)
=&gt; this.Status == ScheduledEventStatus.Scheduled ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Canceled, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only cancel scheduled events&quot;);
⋮----
///     Ends the current scheduled event.
⋮----
public async Task&lt;DiscordScheduledEvent&gt; EndAsync(string reason = null)
=&gt; this.Status == ScheduledEventStatus.Active ? await this.Discord.ApiClient.ModifyGuildScheduledEventStatusAsync(this.GuildId, this.Id, ScheduledEventStatus.Completed, reason).ConfigureAwait(false) : throw new InvalidOperationException(&quot;You can only stop active events&quot;);
⋮----
///     Gets a list of users RSVP&apos;d to the scheduled event.
⋮----
/// &lt;param name=&quot;limit&quot;&gt;The limit how many users to receive from the event. Defaults to 100. Max 100.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Get results of &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; before the given snowflake.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get results of &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; after the given snowflake.&lt;/param&gt;
/// &lt;param name=&quot;withMember&quot;&gt;Whether to include guild member data.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the client does not have the correct permissions.&lt;/exception&gt;
⋮----
public async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEventUser&gt;&gt; GetUsersAsync(int? limit = null, ulong? before = null, ulong? after = null, bool? withMember = null)
=&gt; await this.Discord.ApiClient.GetGuildScheduledEventRspvUsersAsync(this.GuildId, this.Id, limit, before, after, withMember).ConfigureAwait(false);
⋮----
///     Deletes a scheduled event.
⋮----
public async Task DeleteAsync(string reason = null)
=&gt; await this.Discord.ApiClient.DeleteGuildScheduledEventAsync(this.GuildId, this.Id, reason).ConfigureAwait(false);</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventEntityMetadata.cs">/// &lt;summary&gt;
///     Represents an scheduled event.
/// &lt;/summary&gt;
public class DiscordScheduledEventEntityMetadata : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordScheduledEventEntityMetadata&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;location&quot;&gt;The location.&lt;/param&gt;
⋮----
///     External location if event type is &lt;see cref=&quot;ScheduledEventEntityType.External&quot; /&gt;.</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRule.cs">/// &lt;summary&gt;
///     Represents the recurrence rule for a scheduled event.
/// &lt;/summary&gt;
public sealed class DiscordScheduledEventRecurrenceRule
⋮----
///     Gets or sets the start time of the recurrence interval.
⋮----
///     Gets the end time of the recurrence interval.
⋮----
///     Gets or sets the frequency of the recurrence.
⋮----
///     Gets or sets the interval between events.
⋮----
///     Gets or sets specific days within a week for the event to recur on.
⋮----
///     Gets or sets specific days within a specific week (1-5) to recur on.
⋮----
///     Gets or sets specific months to recur on.
⋮----
///     Gets or sets specific dates within a month to recur on.
⋮----
///     Gets specific dates within a year to recur on.
⋮----
///     Gets the total amount of times that the event is allowed to recur before stopping.</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventRecurrenceRuleValidator.cs">/// &lt;summary&gt;
///     Validator for &lt;see cref=&quot;DiscordScheduledEventRecurrenceRule&quot; /&gt; instances.
/// &lt;/summary&gt;
public static class DiscordScheduledEventRecurrenceRuleValidator
⋮----
///     A collection of valid weekday sets for events with a daily recurrence frequency.
⋮----
///     Creates a set of weekdays for easier readability.
⋮----
/// &lt;param name=&quot;weekdays&quot;&gt;The weekdays to include in the set.&lt;/param&gt;
/// &lt;returns&gt;A list of &lt;see cref=&quot;RecurrenceRuleWeekday&quot; /&gt; objects.&lt;/returns&gt;
private static List&lt;RecurrenceRuleWeekday&gt; CreateWeekdaySet(params RecurrenceRuleWeekday[] weekdays)
⋮----
///     Validates the recurrence rule.
⋮----
/// &lt;param name=&quot;rule&quot;&gt;The recurrence rule to validate.&lt;/param&gt;
/// &lt;returns&gt;A tuple containing a boolean indicating validity and an optional error message.&lt;/returns&gt;
public static (bool IsValid, string? ErrorMessage) Validate(this DiscordScheduledEventRecurrenceRule rule)
⋮----
RecurrenceRuleFrequency.Daily =&gt; rule.ValidateDailyFrequency(),
RecurrenceRuleFrequency.Weekly =&gt; rule.ValidateWeeklyFrequency(),
RecurrenceRuleFrequency.Monthly =&gt; rule.ValidateMonthlyFrequency(),
RecurrenceRuleFrequency.Yearly =&gt; rule.ValidateYearlyFrequency(),
⋮----
///     Validates recurrence rules with a daily frequency.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateDailyFrequency(this DiscordScheduledEventRecurrenceRule rule)
=&gt; rule.ByWeekday is not null &amp;&amp; !rule.ByWeekday.IsValidDailyWeekdaySet()
⋮----
///     Validates recurrence rules with a weekly frequency.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateWeeklyFrequency(this DiscordScheduledEventRecurrenceRule rule)
⋮----
///     Validates recurrence rules with a monthly frequency.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateMonthlyFrequency(this DiscordScheduledEventRecurrenceRule rule)
⋮----
///     Validates recurrence rules with a yearly frequency.
⋮----
private static (bool IsValid, string? ErrorMessage) ValidateYearlyFrequency(this DiscordScheduledEventRecurrenceRule rule)
⋮----
///     Validates if the weekday set is valid for a daily frequency.
⋮----
/// &lt;param name=&quot;byWeekday&quot;&gt;The weekday set to validate.&lt;/param&gt;
/// &lt;returns&gt;&lt;see langword=&quot;true&quot; /&gt; if the set is valid; otherwise, &lt;see langword=&quot;false&quot; /&gt;.&lt;/returns&gt;
private static bool IsValidDailyWeekdaySet(this IReadOnlyCollection&lt;RecurrenceRuleWeekday&gt; byWeekday)
=&gt; s_validDailyWeekdaySets.Any(set =&gt; set.SequenceEqual(byWeekday));</file><file path="DisCatSharp/Entities/Guild/ScheduledEvent/DiscordScheduledEventUser.cs">/// &lt;summary&gt;
///     The discord scheduled event user.
/// &lt;/summary&gt;
public class DiscordScheduledEventUser : ObservableApiObject, IEquatable&lt;DiscordScheduledEventUser&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; class.
⋮----
///     Gets the client instance this object is tied to.
⋮----
///     Gets the user.
⋮----
///     Gets the member.
///     Only applicable when requested with `with_member`.
⋮----
///     Gets the scheduled event.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) &amp;&amp; guild.ScheduledEvents.TryGetValue(this.EventId, out var scheduledEvent) ? scheduledEvent : null;
⋮----
///     Gets or sets the event id.
⋮----
///     Gets or sets the guild id.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; is equal to another
///     &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;
///     Whether the &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt;
///     .
/// &lt;/returns&gt;
public bool Equals(DiscordScheduledEventUser e)
=&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || HashCode.Combine(this.User.Id, this.EventId) == HashCode.Combine(e.User.Id, e.EventId));
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordScheduledEventUser);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; HashCode.Combine(this.User.Id, this.EventId);
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First event to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second event to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two events are equal.&lt;/returns&gt;
⋮----
return (o1 != null || o2 == null) &amp;&amp; (o1 == null || o2 != null) &amp;&amp; ((o1 == null &amp;&amp; o2 == null) || HashCode.Combine(e1.User.Id, e1.EventId) == HashCode.Combine(e2.User.Id, e2.EventId));
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordScheduledEventUser&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two events are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Guild/Stage/DiscordStageInstance.cs">/// &lt;summary&gt;
///     Represents a Stage instance.
/// &lt;/summary&gt;
public class DiscordStageInstance : SnowflakeObject, IEquatable&lt;DiscordStageInstance&gt;
⋮----
///     Initializes a new instance of &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.
⋮----
///     Gets the scheduled event id of the associated stage channel.
⋮----
///     Gets the scheduled event of the associated stage channel.
⋮----
? this.Guild.ScheduledEvents.GetValueOrDefault(this.ScheduledEventId.Value)
⋮----
///     Gets the invite code of the associated stage channel.
⋮----
///     Gets the guild id of the associated Stage channel.
⋮----
///     Gets the guild to which this channel belongs.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null!;
⋮----
///     Gets id of the associated Stage channel.
⋮----
///     Gets the topic of the Stage instance.
⋮----
///     Gets whether or not stage discovery is disabled.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordStageInstance&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordStageInstance&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordStageInstance e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordStageInstance);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordStageInstance&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode() =&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordStageInstance&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First channel to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second channel to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two channels are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordStageInstance&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two channels are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannel.cs">/// &lt;summary&gt;
///     Represents a discord thread channel.
/// &lt;/summary&gt;
public class DiscordThreadChannel : DiscordChannel
⋮----
///     List of applied tag ids.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordThreadChannel&quot; /&gt; class.
⋮----
///     Gets ID of the owner that started this thread.
⋮----
///     Gets whether this thread is newly created.
///     &lt;para&gt;Why? We don&apos;t know.&lt;/para&gt;
⋮----
///     Gets an approximate count of messages in a thread, stops counting at 50.
⋮----
///     Gets an approximate count of users in a thread, stops counting at 50.
⋮----
///     Represents the current member for this thread. This will have a value if the user has joined the thread.
⋮----
///     Gets the threads metadata.
⋮----
///     Gets the thread members object.
⋮----
///     Gets the list of applied tags.
///     Only applicable for forum channel posts.
⋮----
=&gt; this.AppliedTagIds?.Select(id =&gt; this.Parent.GetForumPostTag(id)).Where(x =&gt; x != null).ToList();
⋮----
///     Modifies the current thread.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this thread&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageThreads&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the thread does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotSupportedException&quot;&gt;
///     Thrown when the &lt;see cref=&quot;ThreadAutoArchiveDuration&quot; /&gt; cannot be modified.
///     This happens, when the guild hasn&apos;t reached a certain boost &lt;see cref=&quot;PremiumTier&quot; /&gt;.
⋮----
public Task ModifyAsync(Action&lt;ThreadEditModel&gt; action)
⋮----
var mdl = new ThreadEditModel();
⋮----
return this.Parent.Type == ChannelType.Forum &amp;&amp; mdl.AppliedTags.HasValue &amp;&amp; mdl.AppliedTags.Value.Count() &gt; 5
? throw new NotSupportedException(&quot;Cannot have more than 5 applied tags.&quot;)
: this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, mdl.Name, mdl.Locked, mdl.Archived, mdl.PerUserRateLimit, mdl.AutoArchiveDuration, mdl.Invitable, mdl.AppliedTags, mdl.Pinned, mdl.AuditLogReason);
⋮----
///     Add a tag to the current thread.
⋮----
/// &lt;param name=&quot;tag&quot;&gt;The tag to add.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for the audit logs.&lt;/param&gt;
⋮----
public Task AddTagAsync(ForumPostTag tag, string reason = null)
⋮----
: this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, null, null, null, null, new List&lt;ForumPostTag&gt;(this.AppliedTags)
⋮----
///     Remove a tag from the current thread.
⋮----
/// &lt;param name=&quot;tag&quot;&gt;The tag to remove.&lt;/param&gt;
⋮----
public async Task RemoveTagAsync(ForumPostTag tag, string reason = null)
=&gt; await this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, null, null, null, null, new List&lt;ForumPostTag&gt;(this.AppliedTags).Where(x =&gt; x != tag).ToList(), null, reason).ConfigureAwait(false);
⋮----
///     Archives a thread.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
⋮----
public Task ArchiveAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, true, null, null, null, null, null, reason);
⋮----
///     Unarchives a thread.
⋮----
public Task UnarchiveAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, null, false, null, null, null, null, null, reason);
⋮----
///     Locks a thread.
⋮----
public Task LockAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, true, null, null, null, null, null, null, reason);
⋮----
///     Unlocks a thread.
⋮----
public Task UnlockAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyThreadAsync(this.Id, this.Parent.Type, null, false, true, null, null, null, null, null, reason);
⋮----
///     Gets the members of a thread. Needs the &lt;see cref=&quot;DiscordIntents.GuildMembers&quot; /&gt; intent.
⋮----
/// &lt;param name=&quot;withMember&quot;&gt;Whether to request the member object. (If set to true, will paginate the result)&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Request all members after the specified. (Currently only utilized if withMember is set to true)&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The amount of members to fetch. (Currently only utilized if withMember is set to true)&lt;/param&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt; GetMembersAsync(bool withMember = false, ulong? after = null, int? limit = null)
=&gt; await this.Discord.ApiClient.GetThreadMembersAsync(this.Id).ConfigureAwait(false);
⋮----
///     Adds a member to this thread.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;The member id to be added.&lt;/param&gt;
⋮----
public Task AddMemberAsync(ulong memberId)
=&gt; this.Discord.ApiClient.AddThreadMemberAsync(this.Id, memberId);
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to be added.&lt;/param&gt;
⋮----
public Task AddMemberAsync(DiscordMember member)
=&gt; this.AddMemberAsync(member.Id);
⋮----
///     Gets a member in this thread.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;The id of the member to get.&lt;/param&gt;
/// &lt;param name=&quot;withMember&quot;&gt;Whether to request the member object.&lt;/param&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the member is not part of the thread.&lt;/exception&gt;
⋮----
public Task&lt;DiscordThreadChannelMember&gt; GetMemberAsync(ulong memberId, bool withMember = false)
=&gt; this.Discord.ApiClient.GetThreadMemberAsync(this.Id, memberId, withMember);
⋮----
///     Tries to get a member in this thread.
⋮----
public async Task&lt;DiscordThreadChannelMember?&gt; TryGetMemberAsync(ulong memberId, bool withMember = false)
⋮----
return await this.GetMemberAsync(memberId, withMember).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to get.&lt;/param&gt;
⋮----
public Task&lt;DiscordThreadChannelMember&gt; GetMemberAsync(DiscordMember member, bool withMember = false)
=&gt; this.Discord.ApiClient.GetThreadMemberAsync(this.Id, member.Id, withMember);
⋮----
public async Task&lt;DiscordThreadChannelMember?&gt; TryGetMemberAsync(DiscordMember member, bool withMember = false)
⋮----
return await this.GetMemberAsync(member, withMember).ConfigureAwait(false);
⋮----
///     Removes a member from this thread.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;The member id to be removed.&lt;/param&gt;
⋮----
public Task RemoveMemberAsync(ulong memberId)
=&gt; this.Discord.ApiClient.RemoveThreadMemberAsync(this.Id, memberId);
⋮----
///     Removes a member from this thread. Only applicable to private threads.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to be removed.&lt;/param&gt;
⋮----
public Task RemoveMemberAsync(DiscordMember member)
=&gt; this.RemoveMemberAsync(member.Id);
⋮----
///     Adds a role to this thread. Only applicable to private threads.
⋮----
/// &lt;param name=&quot;roleId&quot;&gt;The role id to be added.&lt;/param&gt;
⋮----
public async Task AddRoleAsync(ulong roleId)
⋮----
var role = this.Guild.GetRole(roleId);
var members = await this.Guild.GetAllMembersAsync().ConfigureAwait(false);
var roleMembers = members.Where(m =&gt; m.Roles.Contains(role));
⋮----
await this.Discord.ApiClient.AddThreadMemberAsync(this.Id, member.Id).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role to be added.&lt;/param&gt;
⋮----
public Task AddRoleAsync(DiscordRole role)
=&gt; this.AddRoleAsync(role.Id);
⋮----
///     Removes a role from this thread. Only applicable to private threads.
⋮----
/// &lt;param name=&quot;roleId&quot;&gt;The role id to be removed.&lt;/param&gt;
⋮----
public async Task RemoveRoleAsync(ulong roleId)
⋮----
await this.Discord.ApiClient.RemoveThreadMemberAsync(this.Id, member.Id).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role to be removed.&lt;/param&gt;
⋮----
public Task RemoveRoleAsync(DiscordRole role)
=&gt; this.RemoveRoleAsync(role.Id);
⋮----
///     Joins a thread.
⋮----
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the client has no access to this thread.&lt;/exception&gt;
⋮----
public Task JoinAsync()
=&gt; this.Discord.ApiClient.JoinThreadAsync(this.Id);
⋮----
///     Leaves a thread.
⋮----
public Task LeaveAsync()
=&gt; this.Discord.ApiClient.LeaveThreadAsync(this.Id);
⋮----
///     Returns a string representation of this thread.
⋮----
/// &lt;returns&gt;String representation of this thread.&lt;/returns&gt;
public override string ToString()</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMember.cs">/// &lt;summary&gt;
///     Represents a discord thread member object.
/// &lt;/summary&gt;
public class DiscordThreadChannelMember : SnowflakeObject, IEquatable&lt;DiscordThreadChannelMember&gt;
⋮----
[JsonIgnore] // guild_id exists
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt; class.
⋮----
///     Gets the id of the user.
⋮----
///     Gets the member object of the user.
⋮----
///     Gets the presence of the user.
⋮----
///     Gets the timestamp when the user joined the thread.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.JoinTimeStampRaw) &amp;&amp; DateTimeOffset.TryParse(this.JoinTimeStampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the timestamp when the user joined the thread as raw string.
⋮----
///     Gets the thread member flags.
⋮----
///     Gets the category that contains this channel. For threads, gets the channel this thread was created in.
⋮----
=&gt; this.Guild != null &amp;&amp; this.Guild.ThreadsInternal.TryGetValue(this.Id, out var thread) ? thread : null;
⋮----
///     Gets the guild to which this channel belongs.
⋮----
=&gt; this.Discord.Guilds.TryGetValue(this.GuildId, out var guild) ? guild : null;
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordThreadChannel&quot; /&gt; is equal to another
///     &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordThreadChannel&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordThreadChannel&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordThreadChannelMember e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordThreadChannelMember);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; HashCode.Combine(this.Id.GetHashCode(), this.UserId.GetHashCode());
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordThreadChannel&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First channel to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second channel to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two channels are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordThreadChannelMember&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two channels are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadChannelMetadata.cs">/// &lt;summary&gt;
///     Represents a discord thread metadata object.
/// &lt;/summary&gt;
public class DiscordThreadChannelMetadata : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordThreadChannelMetadata&quot; /&gt; class.
⋮----
///     Gets whether the thread is archived or not.
⋮----
///     Gets ID of the archiver.
⋮----
///     Gets the time when it will be archived, while there is no action inside the thread (In minutes).
⋮----
///     Gets the timestamp when it was archived.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.ArchiveTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.ArchiveTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the timestamp when it was archived as raw string.
⋮----
///     Gets whether the thread is locked.
⋮----
///     Gets whether non-moderators can add other non-moderators to a thread; only available on private threads.
⋮----
///     Gets the timestamp when the thread was created.
///     Only populated for threads created after 2022-01-09.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CreateTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.CreateTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the timestamp when the thread was created as raw string.</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/DiscordThreadResult.cs">/// &lt;summary&gt;
///     Represents a discord thread result.
/// &lt;/summary&gt;
public class DiscordThreadResult : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordThreadResult&quot; /&gt; class.
⋮----
///     Gets the returned threads.
⋮----
: this.Threads.Select(t =&gt; new
⋮----
}).ToDictionary(t =&gt; t.Id, t =&gt; t.t);
⋮----
///     Gets the active members.
⋮----
///     Whether there are more results.</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/ForumReactionEmoji.cs">public class ForumReactionEmoji : ObservableApiObject
⋮----
/// &lt;summary&gt;
///     Creates a new forum reaction emoji.
///     Use either &lt;paramref name=&quot;emojiId&quot; /&gt; or &lt;paramref name=&quot;unicodeEmojiString&quot; /&gt;. Not both.
/// &lt;/summary&gt;
/// &lt;param name=&quot;emojiId&quot;&gt;The emoji id. Has to be from the same server.&lt;/param&gt;
/// &lt;param name=&quot;unicodeEmojiString&quot;&gt;The unicode emoji.&lt;/param&gt;
⋮----
///     Gets the emoji id of the forum post tag.
⋮----
///     Gets the unicode emoji of the forum post tag.
⋮----
///     Gets the emoji.
⋮----
public DiscordEmoji GetEmoji(DiscordClient client)
=&gt; this.EmojiName != null ? DiscordEmoji.FromName(client, $&quot;:{this.EmojiName}:&quot;, false) : DiscordEmoji.FromGuildEmote(client, this.EmojiId.Value);</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidget.cs">/// &lt;summary&gt;
///     Represents a Discord guild&apos;s widget.
/// &lt;/summary&gt;
public class DiscordWidget : SnowflakeObject
⋮----
///     Gets the guild.
⋮----
///     Gets the guild&apos;s name.
⋮----
///     Gets the guild&apos;s invite URL.
⋮----
///     Gets the number of online members.
⋮----
///     Gets a list of online members.
⋮----
///     Gets a list of widget channels.</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidgetMember.cs">/// &lt;summary&gt;
///     Represents a member within a Discord guild&apos;s widget.
/// &lt;/summary&gt;
public class DiscordWidgetMember : ObservableApiObject
⋮----
///     Gets the member&apos;s identifier within the widget.
⋮----
///     Gets the member&apos;s username.
⋮----
///     Gets the member&apos;s discriminator.
⋮----
///     Gets the member&apos;s avatar.
⋮----
///     Gets the member&apos;s online status.
⋮----
///     Gets the member&apos;s avatar url.</file><file path="DisCatSharp/Entities/Guild/Widget/DiscordWidgetSettings.cs">/// &lt;summary&gt;
///     Represents a Discord guild&apos;s widget settings.
/// &lt;/summary&gt;
public class DiscordWidgetSettings : ObservableApiObject
⋮----
///     Gets the guild.
⋮----
///     Gets the guild&apos;s widget channel id.
⋮----
///     Gets the guild&apos;s widget channel.
⋮----
///     Whether if the guild&apos;s widget is enabled.</file><file path="DisCatSharp/Entities/Integration/DiscordIntegration.cs">/// &lt;summary&gt;
///     Represents a Discord integration. These appear on the profile as linked 3rd party accounts.
/// &lt;/summary&gt;
public class DiscordIntegration : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordIntegration&quot; /&gt; class.
⋮----
///     Gets the integration name.
⋮----
///     Gets the integration type.
⋮----
///     Gets whether this integration is enabled.
⋮----
///     Gets whether this integration is syncing.
⋮----
///     Gets ID of the role this integration uses for subscribers.
⋮----
///     Gets ID of the guild this integration is attached to.
⋮----
///     Gets the expiration behaviour.
⋮----
///     Gets the grace period before expiring subscribers.
⋮----
///     Gets the user that owns this integration.
⋮----
///     Gets the 3rd party service account for this integration.
⋮----
///     Gets the date and time this integration was last synced.
⋮----
///     Gets the subscriber count.
⋮----
///     Whether the integration is revoked.
⋮----
///     Gets the application this integration is bound to.
⋮----
///     Gets the integration&apos;s scopes.
⋮----
///     Gets whether emoticons are enabled.</file><file path="DisCatSharp/Entities/Integration/DiscordIntegrationAccount.cs">/// &lt;summary&gt;
///     Represents a Discord integration account.
/// &lt;/summary&gt;
public class DiscordIntegrationAccount : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordIntegrationAccount&quot; /&gt; class.
⋮----
///     Gets the ID of the account.
⋮----
///     Gets the name of the account.</file><file path="DisCatSharp/Entities/Interaction/AuthorizingIntegrationOwners.cs">/// &lt;summary&gt;
///     Represents the authorizing integration owners.
/// &lt;/summary&gt;
public sealed class AuthorizingIntegrationOwners
⋮----
///     Constructs a new &lt;see cref=&quot;AuthorizingIntegrationOwners&quot; /&gt; object.
⋮----
///     If an interaction was created for an app that was installed to a user, a &lt;c&gt;USER_INSTALL&lt;/c&gt; key will be present
///     and its value will be the user’s ID.
⋮----
///     If an interaction was created for an app that was installed to a guild, a &lt;c&gt;GUILD_INSTALL&lt;/c&gt; key will be present.
///     &lt;para&gt;If the interaction was sent from a guild context, the value is the guild’s ID.&lt;/para&gt;
///     &lt;para&gt;If the interaction was sent from a bot DM context, the value is &lt;c&gt;0&lt;/c&gt;.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordLinkButtonComponent.cs">/// &lt;summary&gt;
///     Represents a link button. Clicking a link button does not send an interaction.
/// &lt;/summary&gt;
public class DiscordLinkButtonComponent : DiscordBaseButtonComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordLinkButtonComponent&quot; /&gt;. This type of button does not send back and interaction
///     when pressed.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The url to set the button to.&lt;/param&gt;
/// &lt;param name=&quot;label&quot;&gt;The text to display on the button. Can be left blank if &lt;paramref name=&quot;emoji&quot; /&gt; is set.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;Whether or not this button can be pressed.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to set with this button. This is required if &lt;paramref name=&quot;label&quot; /&gt; is null or empty.&lt;/param&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordLinkButtonComponent&quot; /&gt; class.
⋮----
///     The url to open when pressing this button.
⋮----
///     The text to add to this button. If this is not specified, &lt;see cref=&quot;Emoji&quot; /&gt; must be.
⋮----
///     Whether this button can be pressed.
⋮----
///     The emoji to add to the button. Can be used in conjunction with a label, or as standalone. Must be added if label
///     is not specified.
⋮----
///     Gets the style.
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordLinkButtonComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordLinkButtonComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordLinkButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordPremiumButtonComponent.cs">/// &lt;summary&gt;
///     Represents a premium button. Clicking a premium button does not send an interaction.
///     &lt;para&gt;Requires your app to have monitization enabled.&lt;/para&gt;
/// &lt;/summary&gt;
public class DiscordPremiumButtonComponent : DiscordBaseButtonComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordPremiumButtonComponent&quot; /&gt;. This type of button does not send back and
///     interaction when pressed.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to set the button to.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;Whether or not this button can be pressed.&lt;/param&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPremiumButtonComponent&quot; /&gt; class.
⋮----
///     The premium sku to open when pressing this button.
⋮----
///     Whether this button can be pressed.
⋮----
///     Gets the style.
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordPremiumButtonComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordPremiumButtonComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordPremiumButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordComponent.cs">/// &lt;summary&gt;
///     A component to attach to a message.
/// &lt;/summary&gt;
⋮----
public class DiscordComponent : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordComponent&quot; /&gt; class.
⋮----
///     The type of component this represents.
⋮----
///     The custom Id of this component, if applicable. Not applicable on ActionRow(s) and link buttons.
⋮----
///     Gets the Id of the compenent. Auto populated by discord if not provided.</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordComponentEmoji.cs">/// &lt;summary&gt;
///     Represents an emoji to add to a component.
/// &lt;/summary&gt;
public sealed class DiscordComponentEmoji : ObservableApiObject
⋮----
///     Constructs a new component emoji to add to a &lt;see cref=&quot;DiscordComponent&quot; /&gt;.
⋮----
///     Constructs a new component emoji from an emoji Id.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the emoji to use. Any valid emoji Id can be passed.&lt;/param&gt;
⋮----
///     Constructs a new component emoji from unicode.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The unicode emoji to set.&lt;/param&gt;
⋮----
if (!DiscordEmoji.IsValidUnicode(name))
throw new ArgumentException(&quot;Only unicode emojis can be passed.&quot;);
⋮----
///     Constructs a new component emoji from an existing &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to use.&lt;/param&gt;
⋮----
///     The Id of the emoji to use.
⋮----
///     The name of the emoji to use. Ignored if &lt;see cref=&quot;Id&quot; /&gt; is set.</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordSelectDefaultValue.cs">/// &lt;summary&gt;
///     A select default value for use with &lt;see cref=&quot;ComponentType.UserSelect&quot; /&gt;,
///     &lt;see cref=&quot;ComponentType.RoleSelect&quot; /&gt;, &lt;see cref=&quot;ComponentType.ChannelSelect&quot; /&gt; or
///     &lt;see cref=&quot;ComponentType.MentionableSelect&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordSelectDefaultValue
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSelectDefaultValue&quot; /&gt; for an &lt;paramref name=&quot;id&quot; /&gt; with corrosponding
///     &lt;paramref name=&quot;type&quot; /&gt;.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to set.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The type of the &lt;paramref name=&quot;id&quot; /&gt;. Can be &lt;c&gt;user&lt;/c&gt;, &lt;c&gt;role&lt;/c&gt; or &lt;c&gt;channel&lt;/c&gt;&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSelectDefaultValue&quot; /&gt; for a role.
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role to set.&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSelectDefaultValue&quot; /&gt; for a user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to set.&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSelectDefaultValue&quot; /&gt; for a channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to set.&lt;/param&gt;
⋮----
///     The id of a user, role, or channel.
⋮----
///     The type of value that &lt;see cref=&quot;Id&quot; /&gt; represents.</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponentOption.cs">/// &lt;summary&gt;
///     Represents options for &lt;see cref=&quot;DiscordBaseSelectComponent&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordStringSelectComponentOption : ObservableApiObject
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordStringSelectComponentOption&quot; /&gt;.
⋮----
/// &lt;param name=&quot;label&quot;&gt;The label of this option.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value of this option.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the option.&lt;/param&gt;
/// &lt;param name=&quot;isDefault&quot;&gt;Whether this option is default. If true, this option will be pre-selected.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to set with this option.&lt;/param&gt;
⋮----
throw new NotSupportedException(&quot;Select label can&apos;t be longer then 100 chars.&quot;);
⋮----
throw new NotSupportedException(&quot;Select value can&apos;t be longer then 100 chars.&quot;);
⋮----
throw new NotSupportedException(&quot;Select description can&apos;t be longer then 100 chars.&quot;);
⋮----
///     The label to add. This is required.
⋮----
///     The value of this option. Akin to the Custom Id of components.
⋮----
///     Whether this option is default. If true, this option will be pre-selected. Defaults to false.
⋮----
public bool Default { get; internal set; } // false //
⋮----
///     The description of this option. This is optional.
⋮----
///     The emoji of this option. This is optional.</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordBaseButtonComponent.cs">/// &lt;summary&gt;
///     Represents a button component.
/// &lt;/summary&gt;</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordContainerComponent.cs">/// &lt;summary&gt;
///     Represents a container component.
/// &lt;/summary&gt;
public sealed class DiscordContainerComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordContainerComponent&quot; /&gt;.
⋮----
///     Constructs a new container component based on another container component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The container component to copy.&lt;/param&gt;
⋮----
///     Constructs a new container component field with the specified options.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The container components. Max of &lt;c&gt;10&lt;/c&gt;.&lt;/param&gt;
/// &lt;param name=&quot;spoiler&quot;&gt;Whether the container should be marked as spoiler.&lt;/param&gt;
/// &lt;param name=&quot;accentColor&quot;&gt;The accent color for the container.&lt;/param&gt;
⋮----
var comps = components.ToList();
⋮----
throw new ArgumentException(&quot;You can only have up to 10 components in a container.&quot;);
⋮----
if (comps.Any(c =&gt; !allowedTypes.Contains(c.Type)))
throw new ArgumentException(&quot;All components must be of type ActionRow, TextDisplay, Section, MediaGallery, Separator, or File.&quot;);
⋮----
///     The components for the container.
⋮----
///     The accent color for the container.
⋮----
///     Gets the accent color int for the container.
⋮----
///     Gets whether this container should be marked as spoiler.
⋮----
///     Adds multiple components to the container.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to add.&lt;/param&gt;
/// &lt;returns&gt;The updated container component.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Thrown if the number of components exceeds 10 or if any of the components are not
///     of the allowed types.
/// &lt;/exception&gt;
public DiscordContainerComponent AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
⋮----
///     Adds a component to the container.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The component to add.&lt;/param&gt;
⋮----
public DiscordContainerComponent AddComponent(DiscordComponent component)
⋮----
if (!allowedTypes.Contains(component.Type))
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordContainerComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryComponent.cs">/// &lt;summary&gt;
///     Represents a media gallery component.
/// &lt;/summary&gt;
public sealed class DiscordMediaGalleryComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordMediaGalleryComponent&quot; /&gt;.
⋮----
///     Constructs a new media gallery component based on another media gallery component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The media gallery component to copy.&lt;/param&gt;
⋮----
///     Constructs a new media gallery component field with the specified options.
⋮----
/// &lt;param name=&quot;items&quot;&gt;The media gallery items.&lt;/param&gt;
⋮----
var it = items.ToList();
⋮----
throw new ArgumentException(&quot;You can only have up to 10 items in a media gallery.&quot;);
⋮----
///     The content for the media gallery.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordMediaGalleryComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordMediaGalleryItem.cs">/// &lt;summary&gt;
///     Represents a media gallery item.
/// &lt;/summary&gt;
public sealed class DiscordMediaGalleryItem
⋮----
///     Constructs a new empty &lt;see cref=&quot;DiscordMediaGalleryItem&quot; /&gt;.
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordMediaGalleryItem&quot; /&gt;.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;spoiler&quot;&gt;Whether this item should be marked as spoiler.&lt;/param&gt;
⋮----
///     Gets the media item.
⋮----
///     Gets the description.
⋮----
///     Gets whether this gallery item should be marked as spoiler.</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionAccessory.cs">/// &lt;summary&gt;
///     Represents a (potential) section accessory component.
/// &lt;/summary&gt;</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSectionComponent.cs">/// &lt;summary&gt;
///     Represents a section component.
/// &lt;/summary&gt;
public sealed class DiscordSectionComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSectionComponent&quot; /&gt;.
⋮----
///     Constructs a new section component based on another section component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The section component to copy.&lt;/param&gt;
⋮----
///     Constructs a new section component field with the specified options.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The section components. Max of &lt;c&gt;3&lt;/c&gt;.&lt;/param&gt;
⋮----
var comps = components.ToList();
⋮----
throw new ArgumentException(&quot;You can only have up to 3 components in a section.&quot;);
⋮----
///     The components for the section.
⋮----
///     The accessory for the section.
///     Can be &lt;see cref=&quot;DiscordThumbnailComponent&quot; /&gt; or &lt;see cref=&quot;DiscordButtonComponent&quot;/&gt; at the moment.
⋮----
///     Adds a thumbnail component to the section as accessory.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The thumbnail url.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the thumbnail.&lt;/param&gt;
/// &lt;param name=&quot;spoiler&quot;&gt;Whether this thumbnail should be marked as spoiler.&lt;/param&gt;
/// &lt;returns&gt;The current &lt;see cref=&quot;DiscordSectionComponent&quot; /&gt;.&lt;/returns&gt;
public DiscordSectionComponent WithThumbnailComponent(string url, string? description = null, bool? spoiler = null)
⋮----
this.Accessory = new DiscordThumbnailComponent(url, description, spoiler);
⋮----
///     Adds a button component to the section as accessory.
⋮----
/// &lt;param name=&quot;button&quot;&gt;The button to add.&lt;/param&gt;
⋮----
public DiscordSectionComponent WithButtonComponent(DiscordBaseButtonComponent button)
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordSectionComponent WithId(int id)
⋮----
///     Adds a text display components to the section.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The component to add.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown if the number of components exceeds 3.&lt;/exception&gt;
public DiscordSectionComponent AddTextDisplayComponent(DiscordTextDisplayComponent component)
⋮----
this.Components.Add(component);
⋮----
///     Adds multiple text display components to the section.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to add.&lt;/param&gt;
⋮----
public DiscordSectionComponent AddTextDisplayComponents(IEnumerable&lt;DiscordTextDisplayComponent&gt; components)
⋮----
this.Components.AddRange(components);</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordSeparatorComponent.cs">/// &lt;summary&gt;
///     Represents a separator component.
/// &lt;/summary&gt;
public sealed class DiscordSeparatorComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordSeparatorComponent&quot; /&gt;.
⋮----
///     Constructs a new separator component based on another separator component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The button to copy.&lt;/param&gt;
⋮----
///     Constructs a new separator component field with the specified options.
⋮----
/// &lt;param name=&quot;divider&quot;&gt;Whether this is a divider.&lt;/param&gt;
/// &lt;param name=&quot;spacing&quot;&gt;The spacing size.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Is thrown when no label is set.&lt;/exception&gt;
⋮----
///     The spacing size.
⋮----
///     Whether this is a divider.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordSeparatorComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordTextDisplayComponent.cs">/// &lt;summary&gt;
///     Represents a text display component.
/// &lt;/summary&gt;
public sealed class DiscordTextDisplayComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordTextDisplayComponent&quot; /&gt;.
⋮----
///     Constructs a new text display component based on another text display component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The text display component to copy.&lt;/param&gt;
⋮----
///     Constructs a new text display component field with the specified options.
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content for the text display.&lt;/param&gt;
⋮----
///     The content for the text display.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordTextDisplayComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordThumbnailComponent.cs">/// &lt;summary&gt;
///     Represents a thumbnail component.
/// &lt;/summary&gt;
public sealed class DiscordThumbnailComponent : DiscordSectionAccessory
⋮----
///     Constructs a new empty &lt;see cref=&quot;DiscordThumbnailComponent&quot; /&gt;.
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordThumbnailComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The thumbnail url.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the thumbnail.&lt;/param&gt;
/// &lt;param name=&quot;spoiler&quot;&gt;Whether this thumbnail should be marked as spoiler.&lt;/param&gt;
⋮----
///     Gets the media item.
⋮----
///     Gets the description.
⋮----
///     Gets whether this gallery item should be marked as spoiler.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordThumbnailComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordUnfurledMediaItem.cs">/// &lt;summary&gt;
///     Represents a unfurled media item.
/// &lt;/summary&gt;
public sealed class DiscordUnfurledMediaItem : DiscordUnfurledMedia
⋮----
///     Constructs a new empty &lt;see cref=&quot;DiscordUnfurledMediaItem&quot; /&gt;.
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordUnfurledMediaItem&quot; /&gt;.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The unfurled media item url.&lt;/param&gt;</file><file path="DisCatSharp/Entities/Interaction/DiscordActivityInstance.cs">/// &lt;summary&gt;
///     Represents the activity instance.
/// &lt;/summary&gt;
public sealed class DiscordActivityInstance : ObservableApiObject
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordActivityInstance&quot; /&gt; object.
⋮----
///     The instance ID of the Activity if one was launched or joined.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionApplicationCommandCallbackData.cs">/// &lt;summary&gt;
///     Represents an interactions application command callback data.
/// &lt;/summary&gt;
internal sealed class DiscordInteractionApplicationCommandCallbackData : ObservableApiObject
⋮----
///     Whether this message is text to speech.
⋮----
///     Gets the content.
⋮----
///     Gets the embeds.
⋮----
///     Gets the mentions.
⋮----
///     Gets the flags.
⋮----
///     Gets the components.
⋮----
///     Gets the autocomplete choices.
⋮----
///     Gets the attachments.
⋮----
///     Gets or sets the poll request.
⋮----
///     Represents an interactions application command callback data for modals.
⋮----
internal sealed class DiscordInteractionApplicationCommandModalCallbackData : ObservableApiObject
⋮----
///     Gets the custom id.
⋮----
///     Represents an interactions application command callback data for iFrames.
⋮----
internal sealed class DiscordInteractionApplicationCommandIframeCallbackData : ObservableApiObject
⋮----
///     Gets the iFrame modal size.
⋮----
///     Gets the iFrame path.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionCallback.cs">/// &lt;summary&gt;
///     Represents a partial interaction in interaction responses
/// &lt;/summary&gt;
public sealed class DiscordInteractionCallback : SnowflakeObject
⋮----
///     Gets the interaction type.
⋮----
///     Gets the instance ID of the Activity if one was launched or joined.
⋮----
///     Gets the message id of the created response, if any.
⋮----
///     Gets whether the response message is a loading message (deferred response).
⋮----
///     Gets whether the response message is ephemeral.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionCallbackResponse.cs">/// &lt;summary&gt;
///     Represents a interaction response.
/// &lt;/summary&gt;
public sealed class DiscordInteractionCallbackResponse : ObservableApiObject
⋮----
///     Gets the created interaction.
⋮----
///     Gets the interaction resource.
⋮----
///     Gets the created message from the &lt;see cref=&quot;Resource&quot; /&gt;.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionDataOption.cs">/// &lt;summary&gt;
///     Represents parameters for interaction commands.
/// &lt;/summary&gt;
public sealed class DiscordInteractionDataOption : ObservableApiObject
⋮----
///     Gets the name of this interaction parameter.
⋮----
///     Gets the type of this interaction parameter.
⋮----
///     Whether this option is currently focused by the user.
///     Only applicable for autocomplete option choices.
⋮----
///     Gets the value of this interaction parameter.
⋮----
///     &lt;para&gt;
///         This can be cast to a &lt;see langword=&quot;long&quot; /&gt;, &lt;see langword=&quot;bool&quot;&gt;&lt;/see&gt;, &lt;see langword=&quot;string&quot;&gt;&lt;/see&gt;,
///         &lt;see langword=&quot;double&quot;&gt;&lt;/see&gt; or &lt;see langword=&quot;ulong&quot; /&gt; depending on the &lt;see cref=&quot;System.Type&quot; /&gt;
///     &lt;/para&gt;
⋮----
string.IsNullOrEmpty(this.RawValue)
⋮----
: this.Type == ApplicationCommandOptionType.Integer &amp;&amp; int.TryParse(this.RawValue, out var raw)
⋮----
? long.Parse(this.RawValue)
⋮----
ApplicationCommandOptionType.Boolean =&gt; bool.Parse(this.RawValue),
⋮----
ApplicationCommandOptionType.Channel =&gt; ulong.Parse(this.RawValue),
ApplicationCommandOptionType.User =&gt; ulong.Parse(this.RawValue),
ApplicationCommandOptionType.Role =&gt; ulong.Parse(this.RawValue),
ApplicationCommandOptionType.Mentionable =&gt; ulong.Parse(this.RawValue),
ApplicationCommandOptionType.Number =&gt; double.Parse(this.RawValue),
ApplicationCommandOptionType.Attachment =&gt; ulong.Parse(this.RawValue),
⋮----
///     Gets the additional parameters if this parameter is a subcommand.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionMetadata.cs">/// &lt;summary&gt;
///     Represents the interaction metadata.
/// &lt;/summary&gt;
public sealed class DiscordInteractionMetadata : SnowflakeObject
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordInteractionMetadata&quot; /&gt; object.
⋮----
///     Type of the interaction.
⋮----
///     The transport user who triggered the interaction.
⋮----
///     Ther user who triggered the interaction.
⋮----
///     This is the same field on interaction.
⋮----
///     &lt;para&gt;On followup messages only, this will be the ID of the original response message.&lt;/para&gt;
///     &lt;para&gt;On original response messages this will not be present.&lt;/para&gt;
⋮----
///     &lt;para&gt;The name of the application command.&lt;/para&gt;
///     &lt;note type=&quot;note&quot;&gt;
///         &lt;para&gt;For messages created from application command interactions.&lt;/para&gt;
///         &lt;para&gt;Check &lt;see cref=&quot;Type&quot; /&gt; to determine if this field is represented.&lt;/para&gt;
///     &lt;/note&gt;
⋮----
///     &lt;para&gt;The ID of the message that was interacted with to trigger the interaction.&lt;/para&gt;
⋮----
///         &lt;para&gt;For messages created from message component interactions.&lt;/para&gt;
⋮----
///     &lt;para&gt;The interaction metadata of the interaction that responded with the modal.&lt;/para&gt;
⋮----
///         &lt;para&gt;For messages created from a modal submit interaction.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResolvedCollection.cs">/// &lt;summary&gt;
///     Represents a collection of Discord snowflake objects resolved from interaction arguments.
/// &lt;/summary&gt;
public sealed class DiscordInteractionResolvedCollection : ObservableApiObject
⋮----
///     Gets the resolved user objects, if any.
⋮----
///     Gets the resolved member objects, if any.
⋮----
///     Gets the resolved channel objects, if any.
⋮----
///     Gets the resolved role objects, if any.
⋮----
///     Gets the resolved message objects, if any.
///     &lt;para&gt;Not applicable for messages with resolved data for auto-populated select menus.&lt;/para&gt;
⋮----
///     Gets the resolved attachments objects, if any.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResource.cs">/// &lt;summary&gt;
///     Represents a interaction resource.
/// &lt;/summary&gt;
public sealed class DiscordInteractionResource : ObservableApiObject
⋮----
///     Gets the resource type.
⋮----
///     Message created by the interaction..
///     &lt;para&gt;
///         Only present if &lt;see cref=&quot;Type&quot; /&gt; is either &lt;see cref=&quot;InteractionResponseType.ChannelMessageWithSource&quot; /&gt;
///         or &lt;see cref=&quot;InteractionResponseType.UpdateMessage&quot; /&gt;.
///     &lt;/para&gt;
⋮----
///     Represents the Activity launched by this interaction.
///     &lt;para&gt;Only present if &lt;see cref=&quot;Type&quot; /&gt; is either &lt;see cref=&quot;InteractionResponseType.LaunchActivity&quot; /&gt;.&lt;/para&gt;</file><file path="DisCatSharp/Entities/Invite/DiscordInvite.cs">/// &lt;summary&gt;
///     Represents a Discord invite.
/// &lt;/summary&gt;
public class DiscordInvite : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordInvite&quot; /&gt; class.
⋮----
///     Gets the invite&apos;s code.
⋮----
///     Gets the invite&apos;s url.
⋮----
public string Url =&gt; DiscordDomain.GetDomain(CoreDomain.DiscordShortlink).Url + &quot;/&quot; + this.Code;
⋮----
///     Gets the invite&apos;s url as Uri.
⋮----
///     Gets the guild this invite is for.
⋮----
///     Gets the channel this invite is for.
⋮----
///     Gets the target type for the voice channel this invite is for.
⋮----
///     Gets the type of this invite.
⋮----
///     Gets the user that is currently livestreaming.
⋮----
///     Gets the embedded partial application to open for this voice channel.
⋮----
///     Gets the approximate guild online member count for the invite.
⋮----
///     Gets the approximate guild total member count for the invite.
⋮----
///     Gets the user who created the invite.
⋮----
///     Gets the number of times this invite has been used.
⋮----
///     Gets the max number of times this invite can be used.
⋮----
///     Gets duration in seconds after which the invite expires.
⋮----
///     Gets whether this invite only grants temporary membership.
⋮----
///     Gets the date and time this invite was created.
⋮----
///     Gets the date and time when this invite expires.
⋮----
///     Gets the date and time when this invite got expired.
⋮----
///     Gets whether this invite is revoked.
⋮----
///     Gets the guild scheduled event data for the invite.
⋮----
///     Gets the invites flags.
⋮----
///    Gets whether the useer can change their nickname on the guild.
⋮----
///    Gets the guild profile, if applicable.
⋮----
///     Deletes the invite.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt; permission or the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the emoji does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;DiscordInvite&gt; DeleteAsync(string reason = null)
=&gt; this.Discord.ApiClient.DeleteInviteAsync(this.Code, reason);
⋮----
///     Converts this invite into a link.
⋮----
/// &lt;returns&gt;A discord.gg invite link.&lt;/returns&gt;
public override string ToString()
=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordShortlink).Url}/{this.Code}&quot;;</file><file path="DisCatSharp/Entities/Invite/DiscordInviteChannel.cs">/// &lt;summary&gt;
///     Represents the channel to which an invite is linked.
/// &lt;/summary&gt;
public class DiscordInviteChannel : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordInviteChannel&quot; /&gt; class.
⋮----
///     Gets the name of the channel.
⋮----
///     Gets the type of the channel.</file><file path="DisCatSharp/Entities/Invite/DiscordInviteGuild.cs">/// &lt;summary&gt;
///     Represents a guild to which the user is invited.
/// &lt;/summary&gt;
public class DiscordInviteGuild : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordInviteGuild&quot; /&gt; class.
⋮----
///     Gets the name of the guild.
⋮----
///     Gets the guild icon&apos;s hash.
⋮----
///     Gets the guild icon&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.jpg&quot; : null;
⋮----
///     Gets the hash of guild&apos;s invite splash.
⋮----
///     Gets the URL of guild&apos;s invite splash.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.jpg&quot; : null;
⋮----
///     Gets the guild&apos;s banner hash, when applicable.
⋮----
///     Gets the guild&apos;s banner in url form.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.Banner) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.BANNERS}/{this.Id}/{this.Banner}&quot; : null;
⋮----
///     Gets the guild description, when applicable.
⋮----
///     Gets a collection of this guild&apos;s features.
⋮----
///     Gets the guild&apos;s verification level.
⋮----
///     Gets vanity URL code for this guild, when applicable.
⋮----
///     Gets the guild&apos;s welcome screen, when applicable.
⋮----
///     Gets the guild nsfw status.
⋮----
///     Gets the guild nsfw level.</file><file path="DisCatSharp/Entities/Message/DiscordForwardedMessage.cs">/// &lt;summary&gt;
///     Represents a forwarded &lt;see cref=&quot;DiscordMessage&quot; /&gt; which contains only a subset of fields.
/// &lt;/summary&gt;
⋮----
public sealed class DiscordForwardedMessage : ObservableApiObject
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordAttachment&quot; /&gt;s.
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordComponent&quot; /&gt;s.
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordEmbed&quot; /&gt;s.
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordChannel&quot; /&gt; mentions.
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordRole&quot; /&gt; mentions.
⋮----
///     Holds the list of &lt;see cref=&quot;DiscordSticker&quot; /&gt;s.
⋮----
///     Gets the &lt;see cref=&quot;DiscordAttachment&quot; /&gt;s.
⋮----
///     Gets the attached &lt;see cref=&quot;DiscordComponent&quot; /&gt;s.
⋮----
///     Gets the attached &lt;see cref=&quot;DiscordEmbed&quot; /&gt;s.
⋮----
///     Constructs the list of &lt;see cref=&quot;DiscordChannel&quot; /&gt; mentions.
⋮----
///     Gets role ids mentioned by this forwarded message.
///     If the bot is in the forwarded guild and has the guild on it&apos;s shard, you can use &lt;see cref=&quot;MentionedRoles&quot; /&gt; to
///     get the &lt;see cref=&quot;DiscordRole&quot; /&gt;&apos;s directly.
⋮----
///     Constructs the list of &lt;see cref=&quot;DiscordRole&quot; /&gt; mentions.
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordForwardedMessage&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;Optional guild id.&lt;/param&gt;
⋮----
///     Gets components for this forwarded message.
⋮----
///     Gets stickers for this forwarded message.
⋮----
///     Gets the guild id.
⋮----
///     Gets the type of the forwarded message.
⋮----
///     Gets the forwarded message&apos;s content.
⋮----
///     Gets embeds attached to this forwarded message.
⋮----
///     Gets the attached &lt;see cref=&quot;DiscordAttachment&quot; /&gt;s.
⋮----
///     Gets the forwarded message&apos;s creation timestamp.
⋮----
=&gt; DateTimeOffset.TryParse(this.TimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : throw new ArithmeticException(&quot;Could not convert timestamp to DateTimeOffset&quot;);
⋮----
///     Gets the forwarded message&apos;s creation timestamp as raw string.
⋮----
///     Gets the forwarded message&apos;s edit timestamp. Will be null if the forwarded message was not edited.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.EditedTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the forwarded message&apos;s edit timestamp as raw string. Will be null if the forwarded message was not edited.
⋮----
///     Gets whether this forwarded message was edited.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw);
⋮----
///     Gets the bitwise flags for this forwarded message.
⋮----
///     Gets whether the forwarded message mentions everyone.
⋮----
///     Gets users or members mentioned by this forwarded message.
⋮----
///     Gets the mentioned &lt;see cref=&quot;DiscordUser&quot; /&gt;s.
⋮----
///     Gets roles mentioned by this forwarded message.
⋮----
///     Gets channels mentioned by this forwarded message.
⋮----
///     Gets the mentions of this forwarded message.
⋮----
/// &lt;returns&gt;An array of IMentions.&lt;/returns&gt;
private List&lt;IMention&gt; GetMentions()
⋮----
mentions.AddRange(this.MentionedUsersInternal.Select(m =&gt; (IMention)new UserMention(m)));
⋮----
mentions.AddRange(this.MentionedRoleIds.Select(r =&gt; (IMention)new RoleMention(r)));
⋮----
///     Populates the mentions of this forwarded message.
⋮----
internal void PopulateMentions()
⋮----
var guild = this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var gld) ? gld : null;
⋮----
var mentionedUsers = new HashSet&lt;DiscordUser&gt;(new DiscordUserComparer());
⋮----
this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
⋮----
mentionedUsers.Add(guild.MembersInternal.TryGetValue(usr.Id, out var member) ? member : usr);
⋮----
if (!string.IsNullOrWhiteSpace(this.Content))
⋮----
this.MentionedRolesInternal = this.MentionedRolesInternal.Union(this.MentionedRoleIds.Select(xid =&gt; guild.GetRole(xid))).ToList();
⋮----
this.MentionedChannelsInternal = this.MentionedChannelsInternal.Union(Utilities.GetChannelMentions(this.Content).Select(xid =&gt; guild.GetChannel(xid))).ToList();</file><file path="DisCatSharp/Entities/Message/DiscordMentions.cs">/// &lt;summary&gt;
///     Handles mentionables.
/// &lt;/summary&gt;
internal class DiscordMentions : ObservableApiObject
⋮----
///     Parse users.
⋮----
///     Parse roles.
⋮----
///     Parse everyone.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMentions&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;mentions&quot;&gt;The mentions.&lt;/param&gt;
/// &lt;param name=&quot;mention&quot;&gt;If true, mention.&lt;/param&gt;
/// &lt;param name=&quot;repliedUser&quot;&gt;If true, replied user.&lt;/param&gt;
⋮----
if (!mentions.Any())
⋮----
throw new NotSupportedException(&quot;Type not supported in mentions.&quot;);
⋮----
users.Add(u.Id.Value);
⋮----
parse.Add(PARSE_USERS);
⋮----
roles.Add(r.Id.Value);
⋮----
parse.Add(PARSE_ROLES);
⋮----
parse.Add(PARSE_EVERYONE);
⋮----
if (!parse.Contains(PARSE_USERS) &amp;&amp; users.Count &gt; 0)
this.Users = users.ToArray();
⋮----
if (!parse.Contains(PARSE_ROLES) &amp;&amp; roles.Count &gt; 0)
this.Roles = roles.ToArray();
⋮----
this.Parse = parse.ToArray();
⋮----
///     Collection roles to serialize
⋮----
///     Collection of users to serialize
⋮----
///     The values to be parsed
⋮----
///     For replies, whether to mention the author of the message being replied to.</file><file path="DisCatSharp/Entities/Message/DiscordMessageActivity.cs">/// &lt;summary&gt;
///     Represents a Rich Presence activity.
/// &lt;/summary&gt;
public class DiscordMessageActivity : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMessageActivity&quot; /&gt; class.
⋮----
///     Gets the activity type.
⋮----
///     Gets the party id of the activity.</file><file path="DisCatSharp/Entities/Message/DiscordMessageApplication.cs">/// &lt;summary&gt;
///     Represents a Rich Presence application.
/// &lt;/summary&gt;
public class DiscordMessageApplication : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMessageApplication&quot; /&gt; class.
⋮----
///     Gets the ID of this application&apos;s cover image.
⋮----
///     Gets the application&apos;s description.
⋮----
///     Gets the ID of the application&apos;s icon.
⋮----
///     Gets the application&apos;s name.</file><file path="DisCatSharp/Entities/Message/DiscordMessageFile.cs">/// &lt;summary&gt;
///     Represents the File that should be sent to Discord from the
///     &lt;see cref=&quot;DisCatSharp.Entities.DiscordMessageBuilder&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordMessageFile
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMessageFile&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;The file name.&lt;/param&gt;
/// &lt;param name=&quot;stream&quot;&gt;The stream.&lt;/param&gt;
/// &lt;param name=&quot;resetPositionTo&quot;&gt;The reset position to.&lt;/param&gt;
/// &lt;param name=&quot;fileType&quot;&gt;The file type.&lt;/param&gt;
/// &lt;param name=&quot;contentType&quot;&gt;The content type.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
⋮----
///     Gets the name of the File.
⋮----
///     Gets the description of the File.
⋮----
///     Gets the stream of the File.
⋮----
///     Gets or sets the file type.
⋮----
///     Gets or sets the content type.
⋮----
///     Gets the position the File should be reset to.</file><file path="DisCatSharp/Entities/Message/DiscordMessageInteraction.cs">/// &lt;summary&gt;
///     Represents the message interaction data sent when a message is an interaction response.
/// &lt;/summary&gt;
public class DiscordMessageInteraction : SnowflakeObject
⋮----
///     Gets the type of the interaction.
⋮----
///     Gets the name of the &lt;see cref=&quot;DiscordApplicationCommand&quot; /&gt;.
⋮----
///     Gets the user who invoked the interaction.</file><file path="DisCatSharp/Entities/Message/DiscordMessageReference.cs">/// &lt;summary&gt;
///     Represents data from the original message.
/// &lt;/summary&gt;
public class DiscordMessageReference
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMessageReference&quot; /&gt; class.
⋮----
///     Gets the type of the reference.
⋮----
///     Gets the original message.
⋮----
///     Gets the channel of the original message.
⋮----
///     Gets the guild of the original message.
⋮----
///     Gets the guild id.
⋮----
///     Gets a readable message reference string.
⋮----
public override string ToString()
⋮----
///     Represents raw data from the original message.
⋮----
///     Gets the message id.
⋮----
///     Gets the channel id.
⋮----
///     Whether it should fail if it does not exists.</file><file path="DisCatSharp/Entities/Message/DiscordMessageSnapshots.cs">/// &lt;summary&gt;
///     Represents a message snapshot.
/// &lt;/summary&gt;
⋮----
public class DiscordMessageSnapshot : ObservableApiObject
⋮----
///     Gets the forwarded message.</file><file path="DisCatSharp/Entities/Message/DiscordReaction.cs">/// &lt;summary&gt;
///     Represents a reaction to a message.
/// &lt;/summary&gt;
public class DiscordReaction : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordReaction&quot; /&gt; class.
⋮----
///     Gets the total number of users who reacted with this emoji.
⋮----
///     Gets the total number of users who burst reacted with this emoji.
⋮----
///     Gets whether the current user burst reacted with this emoji.
⋮----
///     Gets the ids of users who burst reacted with this emoji.
⋮----
///     Gets the burst colors.
⋮----
///     Gets whether the current user reacted with this emoji.
⋮----
///     Gets the emoji used to react to this message.</file><file path="DisCatSharp/Entities/Message/Mentions.cs">/// &lt;summary&gt;
///     Interface for mentionables
/// &lt;/summary&gt;
public interface IMention
⋮----
///     Allows a reply to ping the user being replied to.
⋮----
//This is pointless because new RepliedUserMention() will work, but it is here for consistency with the other mentionables.
⋮----
///     Mention the user being replied to. Alias to &lt;seealso cref=&quot;RepliedUserMention&quot; /&gt; constructor.
⋮----
public static readonly RepliedUserMention All = new();
⋮----
///     Allows @everyone and @here pings to mention in the message.
⋮----
//This is pointless because new EveryoneMention() will work, but it is here for consistency with the other mentionables.
⋮----
///     Allow the mentioning of @everyone and @here. Alias to &lt;see cref=&quot;EveryoneMention&quot; /&gt; constructor.
⋮----
public static readonly EveryoneMention All = new();
⋮----
///     Allows @user pings to mention in the message.
⋮----
///     Allow mentioning of all users. Alias to &lt;see cref=&quot;UserMention&quot; /&gt; constructor.
⋮----
public static readonly UserMention All = new();
⋮----
///     Optional Id of the user that is allowed to be mentioned. If null, then all user mentions will be allowed.
⋮----
///     Allows the specific user to be mentioned
⋮----
/// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
⋮----
/// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt;
⋮----
///     Allows @role pings to mention in the message.
⋮----
///     Allow the mentioning of all roles.  Alias to &lt;see cref=&quot;RoleMention&quot; /&gt; constructor.
⋮----
public static readonly RoleMention All = new();
⋮----
///     Optional Id of the role that is allowed to be mentioned. If null, then all role mentions will be allowed.
⋮----
///     Allows the specific id to be mentioned
⋮----
///     Allows the specific role to be mentioned
⋮----
/// &lt;param name=&quot;role&quot;&gt;&lt;/param&gt;
⋮----
///     Contains static instances of common mention patterns.
⋮----
public static class Mentions
⋮----
///     All possible mentions - @everyone + @here, users, and roles.
⋮----
///     No mentions allowed.</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPoll.cs">/// &lt;summary&gt;
///     Represents a poll for a message.
/// &lt;/summary&gt;
public sealed class DiscordPoll : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPoll&quot; /&gt; class.
⋮----
///     Gets the poll question.
⋮----
///     Gets the poll answers to choose from.
⋮----
///     Gets the poll&apos;s end time as raw string.
⋮----
///     Gets the poll&apos;s end time.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.ExpiryRaw) &amp;&amp; DateTimeOffset.TryParse(this.ExpiryRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the poll layout type.
⋮----
///     Gets whether the poll allows multiselect.
⋮----
///     Gets the id of the channel this poll was send in.
⋮----
///     Gets the id of the message this poll belongs to.
⋮----
///     Gets the id of the author this poll belongs to.
⋮----
///     Gets the answer voters for an answer.
⋮----
/// &lt;param name=&quot;answerId&quot;&gt;The id of the answer to get voters for.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The max number of users to return (&lt;c&gt;1&lt;/c&gt;-&lt;c&gt;100&lt;/c&gt;). Defaults to &lt;c&gt;25&lt;/c&gt;.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get users after this user ID.&lt;/param&gt;
/// &lt;returns&gt;A read-only collection of users who voted for given answer.&lt;/returns&gt;
public async Task&lt;ReadOnlyCollection&lt;DiscordUser&gt;&gt; GetAnswerVotersAsync(int answerId, int? limit = null, ulong? after = null)
=&gt; await this.Discord.ApiClient.GetAnswerVotersAsync(this.ChannelId, this.MessageId, answerId, limit, after);
⋮----
///     &lt;para&gt;Ends the poll.&lt;/para&gt;
///     &lt;para&gt;Works only for own polls and if they are not expired yet. &lt;/para&gt;
⋮----
/// &lt;returns&gt;The fresh discord message.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when the author is not us, or the poll has been already ended.&lt;/exception&gt;
public async Task&lt;DiscordMessage&gt; EndAsync()
⋮----
? throw new InvalidOperationException(&quot;Can only end own polls.&quot;)
⋮----
? throw new InvalidOperationException(&quot;The poll was already ended.&quot;)
: await this.Discord.ApiClient.EndPollAsync(this.ChannelId, this.MessageId);</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollAnswer.cs">/// &lt;summary&gt;
///     Represents an poll answer for a &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordPollAnswer
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPollAnswer&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;text&quot;&gt;The text to set.&lt;/param&gt;
/// &lt;param name=&quot;partialEmoji&quot;&gt;The emoji to set.&lt;/param&gt;
⋮----
///     Gets the id of the answer.
///     &lt;para&gt;Only sent as part of responses from Discord&apos;s API/Gateway.&lt;/para&gt;
⋮----
///     Gets the poll media.</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollAnswerCount.cs">/// &lt;summary&gt;
///     Represents an poll answer count object for a &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordPollAnswerCount
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPollAnswerCount&quot; /&gt; class.
⋮----
///     Gets the answer id.
⋮----
///     Gets the number of votes for this answer.
⋮----
///     Gets whether the current user voted for this answer.</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollBuilder.cs">/// &lt;summary&gt;
///     Constructs a poll to be send.
/// &lt;/summary&gt;
public sealed class DiscordPollBuilder
⋮----
private DiscordPollMedia _question;
⋮----
///     Gets or sets the question.
⋮----
throw new ArgumentException(&quot;Question cannot exceed 300 characters.&quot;, nameof(value));
⋮----
///     Gets the answers.
⋮----
///     Gets or sets the layout type. Defaults to &lt;see cref=&quot;PollLayoutType.Default&quot; /&gt;.
⋮----
///     Gets or sets the number of hours the poll should be open for, up to 32 days.
///     Defaults to &lt;c&gt;24&lt;/c&gt; hours.
⋮----
///     Gets or sets whether a user can select multiple answers.
///     Defaults to &lt;see langword=&quot;false&quot; /&gt;.
⋮----
///     Sets the duration for the poll.
⋮----
/// &lt;param name=&quot;hours&quot;&gt;How long the poll should be open for. Max 7 days.&lt;/param&gt;
/// &lt;returns&gt;The current builder to be chained.&lt;/returns&gt;
public DiscordPollBuilder SetDuration(int hours)
⋮----
///     ALlows users to select multiple answers or not.
⋮----
/// &lt;param name=&quot;allow&quot;&gt;Whether a user can select multiple answers.&lt;/param&gt;
⋮----
public DiscordPollBuilder WithAllowMultiselect(bool allow = true)
⋮----
///     Sets the question of a poll.
⋮----
/// &lt;param name=&quot;question&quot;&gt;The question to be set.&lt;/param&gt;
⋮----
public DiscordPollBuilder WithQuestion(string question)
⋮----
///     Adds answers to a poll, up to 10 answers.
⋮----
/// &lt;param name=&quot;answers&quot;&gt;The answers to add to the poll.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;No answers were passed.&lt;/exception&gt;
public DiscordPollBuilder AddAnswers(params DiscordPollAnswer[] answers)
=&gt; this.AddAnswers((IEnumerable&lt;DiscordPollAnswer&gt;)answers);
⋮----
///     Adds answers without emoji to a poll, up to 10 answers.
⋮----
public DiscordPollBuilder AddAnswers(params string[] answers)
=&gt; this.AddAnswers(answers.Select(x =&gt; new DiscordPollAnswer(x)));
⋮----
/// &lt;param name=&quot;answers&quot;&gt;The answers to add to the message.&lt;/param&gt;
⋮----
public DiscordPollBuilder AddAnswers(IEnumerable&lt;DiscordPollAnswer&gt; answers)
⋮----
var cmpArr = answers.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(answers), &quot;You must provide at least one answer&quot;);
⋮----
throw new ArgumentException(&quot;Cannot add more than 10 answers to a poll!&quot;);
⋮----
throw new ArgumentException($&quot;Answers text cannot exceed 55 characters. Thrown in answer {answerId}&quot;);
⋮----
this._answers.AddRange(cmpArr);
⋮----
///     Sends the poll to a specific channel
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel the poll should be sent to.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendAsync(DiscordChannel channel)
=&gt; channel.SendMessageAsync(new DiscordMessageBuilder().WithPoll(this));
⋮----
///     Clears all answers on this builder.
⋮----
public void ClearAnswers()
=&gt; this._answers.Clear();
⋮----
///     Allows for clearing the poll builder so that it can be used again to build a new poll.
⋮----
public void Clear()
⋮----
this._answers.Clear();
⋮----
///     Does the validation before we send a the create request.
⋮----
internal void Validate()
⋮----
throw new ArgumentException(&quot;A poll can only have up to 10 answers.&quot;);
⋮----
throw new ArgumentException(&quot;You must specify a question.&quot;);
⋮----
throw new ArgumentException(&quot;Polls can only be open for up to 32 days or 768 hours.&quot;);
⋮----
///     Builds the poll request.
⋮----
/// &lt;returns&gt;The constructed poll request.&lt;/returns&gt;
internal DiscordPollRequest Build()</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollMedia.cs">/// &lt;summary&gt;
///     Represents an poll media object for a &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordPollMedia
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPollMedia&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;text&quot;&gt;The text of the field.&lt;/param&gt;
/// &lt;param name=&quot;partialEmoji&quot;&gt;The emoji of the field.&lt;/param&gt;
⋮----
///     Gets the text.
⋮----
///     Gets the partial emoji. If you need the full emoji, get it from &lt;see cref=&quot;DiscordEmoji.FromName&quot; /&gt; or
///     &lt;see cref=&quot;DiscordEmoji.FromGuildEmote&quot; /&gt;.</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollRequest.cs">/// &lt;summary&gt;
///     Represents a poll request for a message.
/// &lt;/summary&gt;
internal sealed class DiscordPollRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPollRequest&quot; /&gt; class.
⋮----
///     Sets the poll question.
⋮----
///     Sets the poll answers to choose from.
⋮----
///     Sets the poll duration in hours.
⋮----
///     Sets the poll layout type.
⋮----
///     Sets whether the poll allows multiselect.</file><file path="DisCatSharp/Entities/Message/Polls/DiscordPollResult.cs">/// &lt;summary&gt;
///     Represents an poll result object for a &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordPollResult : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPollResult&quot; /&gt; class.
⋮----
///     Gets the answer counts.
⋮----
///     Gets whether this poll is finalized (closed).</file><file path="DisCatSharp/Entities/NullableSnowflakeObject.cs">/// &lt;summary&gt;
///     Represents an object in Discord API.
/// &lt;/summary&gt;
public abstract class NullableSnowflakeObject : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;NullableSnowflakeObject&quot; /&gt; class.
⋮----
///     Gets the ID of this object.
⋮----
///     Gets the date and time this object was created.
⋮----
=&gt; this.Id.GetSnowflakeTime();</file><file path="DisCatSharp/Entities/OAuth2/DiscordAccessToken.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordAccessToken&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordAccessToken : ObservableApiObject
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordAccessToken&quot; /&gt; for usage with &lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt;.
⋮----
/// &lt;param name=&quot;accessToken&quot;&gt;The access token.&lt;/param&gt;
/// &lt;param name=&quot;tokenType&quot;&gt;The token type.&lt;/param&gt;
/// &lt;param name=&quot;expiresIn&quot;&gt;When the token expires.&lt;/param&gt;
/// &lt;param name=&quot;refreshToken&quot;&gt;The refresh token.&lt;/param&gt;
/// &lt;param name=&quot;scope&quot;&gt;The scope(s).&lt;/param&gt;
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordAccessToken&quot; /&gt;.
⋮----
///     Gets the access token.
⋮----
///     Gets the token type.
⋮----
///     Gets when the token expires.
⋮----
///     Gets the refresh token.
⋮----
///     Gets the scope.
⋮----
///     Generates a new &lt;see cref=&quot;DiscordAccessToken&quot; /&gt; from json.
⋮----
/// &lt;param name=&quot;json&quot;&gt;The json.&lt;/param&gt;
public static DiscordAccessToken FromJson(string json)</file><file path="DisCatSharp/Entities/OAuth2/DiscordApplicationRoleConnection.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordApplicationRoleConnection&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordApplicationRoleConnection : ObservableApiObject
⋮----
///     Gets the platform name.
⋮----
///     Gets the platform username.
⋮----
///     Gets the raw role connection metadata.
⋮----
///     Gets the role connection metadata.
⋮----
///     Represents a &lt;see cref=&quot;ApplicationRoleConnectionMetadata&quot; /&gt;.
⋮----
public sealed class ApplicationRoleConnectionMetadata
⋮----
///     Initializes a new instance of &lt;see cref=&quot;ApplicationRoleConnectionMetadata&quot; /&gt;.
⋮----
/// &lt;param name=&quot;metadata&quot;&gt;The metadata.&lt;/param&gt;
⋮----
///     &lt;para&gt;Gets the metadata.&lt;/para&gt;
///     &lt;para&gt;The &lt;c&gt;key&lt;/c&gt; is the metadata key.&lt;/para&gt;
///     &lt;para&gt;The &lt;c&gt;value&lt;/c&gt; is the string-ified value of the metadata.&lt;/para&gt;
⋮----
///     Adds a metadata.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key to add.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value to add.&lt;/param&gt;
public ApplicationRoleConnectionMetadata AddMetadata(string key, string value)
⋮----
this.Metadata.Add(key, value);
⋮----
///     Removes a metadata by its key.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key to remove.&lt;/param&gt;
public ApplicationRoleConnectionMetadata RemoveMetadata(string key)
⋮----
this.Metadata.Remove(key);
⋮----
///     Gets the KVPs.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public Dictionary&lt;string, string&gt; GetKeyValuePairs()</file><file path="DisCatSharp/Entities/OAuth2/DiscordAuthorizationInformation.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordAuthorizationInformation&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordAuthorizationInformation : ObservableApiObject
⋮----
///     Gets the current application.
⋮----
///     Gets the scopes the user has authorized the application for.
⋮----
///     Gets when the access token expires as raw string.
⋮----
///     Gets when the access token expires.
⋮----
=&gt; DateTimeOffset.TryParse(this.ExpiresRaw, out var expires)
⋮----
: throw new InvalidCastException(&quot;Something went wrong&quot;);
⋮----
///     Gets the user who has authorized, if the user has authorized with the &lt;c&gt;identify&lt;/c&gt; scope.</file><file path="DisCatSharp/Entities/ObservableApiObject.cs">/// &lt;summary&gt;
///     Represents an observable API object that provides functionality for handling
///     additional JSON properties and ignored keys during serialization and deserialization.
/// &lt;/summary&gt;
public abstract class ObservableApiObject
⋮----
///     Gets additional json properties that are not known to the deserializing object.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ObservableApiObject&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;ignored&quot;&gt;
///     A list of JSON property names to be ignored during serialization and deserialization.
/// &lt;/param&gt;
⋮----
this.IgnoredJsonKeys.Add(ignoredKey);
⋮----
///     Gets the client instance this object is tied to.
⋮----
///     Lets JsonConvert set the unknown properties.
⋮----
///     Gets or sets a list of JSON keys that should be ignored during serialization and deserialization.
⋮----
/// &lt;remarks&gt;
///     This property is used to specify keys that are excluded from processing when handling JSON data.
///     It is particularly useful for ignoring fields that are not relevant or should not be modified.
/// &lt;/remarks&gt;</file><file path="DisCatSharp/Entities/SnowflakeObject.cs">/// &lt;summary&gt;
///     Represents an object in Discord API.
/// &lt;/summary&gt;
public abstract class SnowflakeObject : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SnowflakeObject&quot; /&gt; class.
⋮----
///     Gets the ID of this object.
⋮----
///     Gets the date and time this object was created.
⋮----
=&gt; this.Id.GetSnowflakeTime();</file><file path="DisCatSharp/Entities/Sticker/DiscordSticker.cs">/// &lt;summary&gt;
///     Represents a Discord Sticker.
/// &lt;/summary&gt;
public class DiscordSticker : SnowflakeObject, IEquatable&lt;DiscordSticker&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordSticker&quot; /&gt; class.
⋮----
///     Gets the Pack ID of this sticker.
⋮----
///     Gets the Name of the sticker.
⋮----
///     Gets the Description of the sticker.
⋮----
///     Gets the type of sticker.
⋮----
///     For guild stickers, gets the user that made the sticker.
⋮----
///     Gets the guild associated with this sticker, if any.
⋮----
public DiscordGuild Guild =&gt; (this.Discord as DiscordClient).InternalGetCachedGuild(this.GuildId);
⋮----
///     Gets the guild id the sticker belongs too.
⋮----
///     Gets whether this sticker is available. Only applicable to guild stickers.
⋮----
///     Gets the sticker&apos;s sort order, if it&apos;s in a pack.
⋮----
///     Gets the list of tags for the sticker.
⋮----
=&gt; this.InternalTags != null ? this.InternalTags.Split(&apos;,&apos;) : [];
⋮----
///     Gets the asset hash of the sticker.
⋮----
///     Gets the preview asset hash of the sticker.
⋮----
///     Gets the Format type of the sticker.
⋮----
///     Gets the tags of the sticker.
⋮----
///     Gets the url of the sticker.
⋮----
public string Url =&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.STICKERS}/{this.Id}.{(this.FormatType == StickerFormat.Lottie ? &quot;json&quot; : &quot;png&quot;)}&quot;;
⋮----
///     Whether to stickers are equal.
⋮----
/// &lt;param name=&quot;other&quot;&gt;DiscordSticker&lt;/param&gt;
public bool Equals(DiscordSticker other)
⋮----
///     Gets the hash code of the current sticker.
⋮----
/// &lt;returns&gt;The hash code.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.PackId != null ? HashCode.Combine(this.Id.GetHashCode(), this.PackId.GetHashCode()) : HashCode.Combine(this.Id.GetHashCode(), this.GuildId.GetHashCode());
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordSticker&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordSticker&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as ForumPostTag);
⋮----
///     Gets the sticker in readable format.
⋮----
public override string ToString() =&gt; $&quot;Sticker {this.Id}; {this.Name}; {this.FormatType}&quot;;
⋮----
///     Modifies the sticker
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the sticker&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the sticker&lt;/param&gt;
/// &lt;param name=&quot;tags&quot;&gt;The name of a unicode emoji representing the sticker&apos;s expression&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Audit log reason&lt;/param&gt;
/// &lt;returns&gt;A sticker object&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the sticker could not be found.&lt;/exception&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageGuildExpressions&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Sticker does not belong to a guild.&lt;/exception&gt;
public Task&lt;DiscordSticker&gt; ModifyAsync(Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;string&gt; tags, string reason = null) =&gt;
⋮----
? throw new ArgumentException(&quot;This sticker does not belong to a guild.&quot;)
⋮----
? throw new ArgumentException(&quot;Sticker name needs to be between 2 and 30 characters long.&quot;)
⋮----
? throw new ArgumentException(&quot;Sticker description needs to be between 1 and 100 characters long.&quot;)
: tags.HasValue &amp;&amp; !DiscordEmoji.TryFromUnicode(this.Discord, tags.Value, out var emoji)
? throw new ArgumentException(&quot;Sticker tags needs to be a unicode emoji.&quot;)
: this.Discord.ApiClient.ModifyGuildStickerAsync(this.GuildId.Value, this.Id, name, description, tags, reason);
⋮----
///     Deletes the sticker
⋮----
public Task DeleteAsync(string reason = null)
=&gt; this.GuildId.HasValue ? this.Discord.ApiClient.DeleteGuildStickerAsync(this.GuildId.Value, this.Id, reason) : throw new ArgumentException(&quot;The requested sticker is no guild sticker.&quot;);
⋮----
///     The sticker type
⋮----
///     Standard nitro sticker
⋮----
///     Custom guild sticker
⋮----
///     Sticker is a png
⋮----
///     Sticker is a animated png
⋮----
///     Sticker is lottie
⋮----
///     Sticker is a gif</file><file path="DisCatSharp/Entities/Sticker/DiscordStickerPack.cs">/// &lt;summary&gt;
///     Represents a Discord sticker pack.
/// &lt;/summary&gt;
public sealed class DiscordStickerPack : SnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordStickerPack&quot; /&gt; class.
⋮----
///     Gets the stickers contained in this pack.
⋮----
///     Gets the name of this sticker pack.
⋮----
///     Gets the sku id.
⋮----
///     Gets the Id of this pack&apos;s cover sticker.
⋮----
///     Gets the pack&apos;s cover sticker.
⋮----
public Task&lt;DiscordSticker&gt; CoverSticker =&gt; this.Discord.ApiClient.GetStickerAsync(this.CoverStickerId);
⋮----
///     Gets the Id of this pack&apos;s banner.
⋮----
///     Gets the descriptions of this pack.
⋮----
///     Gets the pack&apos;s banner url.
⋮----
public string BannerUrl =&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.APP_ASSETS}{Endpoints.STICKER_APPLICATION}{Endpoints.STORE}/{this.BannerAssetId}.png?size=4096&quot;;</file><file path="DisCatSharp/Entities/Store/DiscordEntitlement.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordEntitlement : SnowflakeObject
⋮----
///     Gets this entitlement&apos;s bound application id.
⋮----
///     Gets this entitlement&apos;s branches.
⋮----
///     Gets whether this entitlement was consumed.
⋮----
///     Gets whether this entitlement was deleted.
⋮----
///     Gets when this entitlement ends as raw string.
⋮----
///     Gets this entitlement&apos;s gift code batch id.
⋮----
///     Gets this entitlement&apos;s gift code flags.
⋮----
///     Gets this entitlement&apos;s gifter user id.
⋮----
///     Gets this entitlement&apos;s bound guild id.
⋮----
///     Gets this entitlement&apos;s parent id.
⋮----
///     Gets this entitlement&apos;s promotion id.
⋮----
///     Gets this entitlement&apos;s bound sku id.
⋮----
///     Gets when this entitlement starts as raw string.
⋮----
///     Gets this entitlement&apos;s subscription id.
⋮----
///     Gets this entitlement&apos;s type.
⋮----
///     Gets this entitlement&apos;s bound user id.
⋮----
///     Gets this entitlement&apos;s bound user.
⋮----
=&gt; this.Discord.GetCachedOrEmptyUserInternal(this.UserId);
⋮----
///     Gets when this entitlement starts.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.StartsAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.StartsAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets when this entitlement ends.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.EndsAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.EndsAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets this entitlement&apos;s bound guild.
⋮----
///     Deletes this entitlement if it&apos;s a test entitlement.
⋮----
public async Task DeleteTestEntitlementsAsync()
=&gt; await (this.Discord as DiscordClient)!.DeleteTestEntitlementAsync(this.Id);
⋮----
///    Consumes this entitlement if it&apos;s consumable.
⋮----
/// &lt;returns&gt;Whether the entitlement was consumed.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the entitlement is not consumable.&lt;/exception&gt;
public async Task&lt;bool&gt; ConsumeAsync()
⋮----
? throw new InvalidOperationException(&quot;You can only consume consumable entitlements.&quot;)
: (this.Consumed.HasValue &amp;&amp; this.Consumed.Value) || await (this.Discord as DiscordClient)!.ConsumeEntitlementAsync(this.Id);</file><file path="DisCatSharp/Entities/Store/DiscordSku.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordSku&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordSku : SnowflakeObject, IEquatable&lt;DiscordSku&gt;
⋮----
///     Gets the sku type.
⋮----
///     Gets the dependent (parent) sku id.
⋮----
///     Gets the application id the sku belongs to.
⋮----
///     Gets the manifest labels.
⋮----
///     Gets the locales.
⋮----
///     Gets the access type.
⋮----
///     Gets the sku name.
⋮----
///     Gets the skus features.
⋮----
///     Gets the skus genres.
⋮----
///     Gets the skus release date.
⋮----
///     Gets the skus legal notice.
⋮----
///     Gets whether the sku is premium.
⋮----
///     Gets the sku slug.
⋮----
///     Gets the sku price.
⋮----
///     Gets the sku flags.
⋮----
///     Gets the product line.
⋮----
///     Gets whether to show a age gate.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordSku&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordSku&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordSku&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordSku&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordSku&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordSku? e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordSku&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordSku&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object? obj)
=&gt; this.Equals(obj as DiscordSku);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordSku&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordSku&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordSku&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First sku to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second sku to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two skus are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordSku&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two skus are not equal.&lt;/returns&gt;
⋮----
///     Gets subscriptions for this sku.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user id to filter for.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;The id to filter before.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;The id to filter after.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The limit.&lt;/param&gt;
/// &lt;returns&gt;A list of subscriptions.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSubscriptionsAsync(ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
=&gt; await (this.Discord as DiscordClient)!.GetSkuSubscriptionsAsync(this.Id, userId, before, after, limit);
⋮----
///     Gets a subscription for this sku.
⋮----
/// &lt;param name=&quot;subscriptionId&quot;&gt;The subscription id to get.&lt;/param&gt;
/// &lt;returns&gt;The subscription if found, &lt;see langword=&quot;null&quot; /&gt; otherwise.&lt;/returns&gt;
public async Task&lt;DiscordSubscription?&gt; GetSubscriptionAsync(ulong subscriptionId)
=&gt; await (this.Discord as DiscordClient)!.GetSkuSubscriptionAsync(this.Id, subscriptionId);
⋮----
///     Creates a test entitlement for this sku.
⋮----
/// &lt;param name=&quot;ownerId&quot;&gt;The owner id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;ownerType&quot;&gt;The owner type to create the entitlement for.&lt;/param&gt;
/// &lt;returns&gt;A partial &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong ownerId, EntitlementOwnerType ownerType)
=&gt; await (this.Discord as DiscordClient)!.CreateTestEntitlementAsync(this.Id, ownerId, ownerType);
⋮----
///     Represents a sku price.
⋮----
public sealed class SkuPrice
⋮----
///     Gets the amount.
⋮----
///     Gets the currency.</file><file path="DisCatSharp/Entities/Store/DiscordStoreSku.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.
/// &lt;/summary&gt;
public class DiscordStoreSku : SnowflakeObject, IEquatable&lt;DiscordStoreSku&gt;
⋮----
///     Gets the store skus summary.
⋮----
///     Gets the store skus sku.
⋮----
///     Gets the store skus description.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordStoreSku&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordStoreSku&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordStoreSku e)
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordStoreSku);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordStoreSku&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First store sku to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second store sku to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two store skus are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordStoreSku&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two store skus are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Store/DiscordSubscription.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordSubscription&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordSubscription : SnowflakeObject
⋮----
///     Gets the id of the user who subscribed.
⋮----
///     Gets the user who subscribed, if they&apos;re in the cache.
⋮----
=&gt; this.Discord.UserCache.GetValueOrDefault(this.UserId);
⋮----
///     Gets the current status of the subscription.
⋮----
///     Gets the list of SKUs the user is subscribed to.
⋮----
///     Gets the list of SKUs that this user will be subscribed to at renewal.
⋮----
///     Gets the list of entitlements granted for this subscription.
⋮----
///     Gets the start of the current subscription period.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CurrentPeriodStartRaw) &amp;&amp; DateTimeOffset.TryParse(this.CurrentPeriodStartRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the end of the current subscription period.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CurrentPeriodEndRaw) &amp;&amp; DateTimeOffset.TryParse(this.CurrentPeriodEndRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets when the subscription was canceled.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.CanceledAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.CanceledAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     &lt;para&gt;Gets the ISO3166-1 alpha-2 country code of the payment source used to purchase the subscription.&lt;/para&gt;
///     &lt;para&gt;Missing unless queried with a private OAuth scope.&lt;/para&gt;</file><file path="DisCatSharp/Entities/User/AvatarDecorationData.cs">/// &lt;summary&gt;
///     Represents a user&apos;s avatar decoration data.
/// &lt;/summary&gt;
public sealed class AvatarDecorationData
⋮----
///     Gets the decoration&apos;s asset hash.
⋮----
///     Gets the user&apos;s avatar decoration url.
⋮----
=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS_DECORATION_PRESETS}/{this.Asset}.png?size=1024&quot;;
⋮----
///     Gets the decoration&apos;s sku id.
⋮----
///     Gets whether and when the decoration expires.
⋮----
=&gt; !string.IsNullOrEmpty(this.ExpiresAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.ExpiresAtRaw, CultureInfo.InvariantCulture, out var dto) ? dto : null;</file><file path="DisCatSharp/Entities/User/DiscordActivity.cs">/// &lt;summary&gt;
///     Represents user status.
/// &lt;/summary&gt;
⋮----
///     User is offline.
⋮----
///     User is online.
⋮----
///     User is idle.
⋮----
///     User asked not to be disturbed.
⋮----
///     User is invisible. They will appear as Offline to anyone but themselves.
⋮----
///     User is streaming.
⋮----
///     Represents a user status converter.
⋮----
internal sealed class UserStatusConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
⋮----
switch (status) // reader.Value can be a string, DateTime or DateTimeOffset (yes, it&apos;s weird)
⋮----
writer.WriteValue(&quot;online&quot;);
⋮----
writer.WriteValue(&quot;idle&quot;);
⋮----
writer.WriteValue(&quot;dnd&quot;);
⋮----
writer.WriteValue(&quot;invisible&quot;);
⋮----
writer.WriteValue(&quot;streaming&quot;);
⋮----
writer.WriteValue(&quot;offline&quot;);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) =&gt;
// Active sessions are indicated with an &quot;online&quot;, &quot;idle&quot;, or &quot;dnd&quot; string per platform. If a user is
// offline or invisible, the corresponding field is not present.
reader.Value?.ToString().ToLowerInvariant() switch // reader.Value can be a string, DateTime or DateTimeOffset (yes, it&apos;s weird)
⋮----
///     Whether this user5 status can be converted.
⋮----
/// &lt;returns&gt;A bool.&lt;/returns&gt;
public override bool CanConvert(Type objectType) =&gt; objectType == typeof(UserStatus);
⋮----
///     Represents a game that a user is playing.
⋮----
public sealed class DiscordActivity
⋮----
///     Creates a new, empty instance of a &lt;see cref=&quot;DiscordActivity&quot; /&gt;.
⋮----
///     Creates a new instance of a &lt;see cref=&quot;DiscordActivity&quot; /&gt; with specified name.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the activity.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;type&quot;&gt;Type of the activity.&lt;/param&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordActivity&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;rawActivity&quot;&gt;The raw activity.&lt;/param&gt;
⋮----
this.UpdateWith(rawActivity);
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other.&lt;/param&gt;
⋮----
///     Gets or sets the partial emoji.
⋮----
///     Gets or sets the id of user&apos;s activity.
⋮----
///     Gets or sets the name of user&apos;s activity.
⋮----
///     Gets or sets the state of user&apos;s activity.
⋮----
///     Gets or sets the stream URL, if applicable.
⋮----
///     Gets or sets platform in this rich presence.
⋮----
///     Gets or sets sync id in this rich presence.
⋮----
///     Gets or sets session_id in this rich presence.
⋮----
///     Gets or sets the activity type.
⋮----
///     Gets the rich presence details, if present.
⋮----
///     Gets the custom status of this activity, if present.
⋮----
///     Updates a activity with an transport activity.
⋮----
internal void UpdateWith(TransportActivity rawActivity)
⋮----
this.RichPresence.UpdateWith(rawActivity);
else this.RichPresence = rawActivity?.IsRichPresence() == true ? new DiscordRichPresence(rawActivity) : null;
⋮----
this.CustomStatus.UpdateWith(rawActivity.State, rawActivity.Emoji);
⋮----
? new DiscordCustomStatus
⋮----
///     Represents details for a custom status activity, attached to a &lt;see cref=&quot;DiscordActivity&quot; /&gt;.
⋮----
public sealed class DiscordCustomStatus
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordCustomStatus&quot; /&gt; class.
⋮----
///     Gets the name of this custom status.
⋮----
///     Gets the state of this custom status.
⋮----
///     Gets the emoji of this custom status, if any.
⋮----
///     Updates a discord status.
⋮----
/// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
internal void UpdateWith(string? state, PartialEmoji? emoji)
⋮----
///     Represents details for Discord rich presence, attached to a &lt;see cref=&quot;DiscordActivity&quot; /&gt;.
⋮----
public sealed class DiscordRichPresence
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordRichPresence&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;rawGame&quot;&gt;The raw game.&lt;/param&gt;
⋮----
this.UpdateWith(rawGame);
⋮----
///     Gets the details of this presence.
⋮----
///     Gets the game state.
⋮----
///     Gets the application for which the rich presence is for.
⋮----
///     Gets the instance status.
⋮----
///     Gets the large image for the rich presence.
⋮----
///     Gets the hover text for large image.
⋮----
///     Gets the small image for the rich presence.
⋮----
///     Gets the hover text for small image.
⋮----
///     Gets the current party size.
⋮----
///     Gets the maximum party size.
⋮----
///     Gets the party ID.
⋮----
///     Gets the buttons.
⋮----
///     Gets the game start timestamp.
⋮----
///     Gets the game end timestamp.
⋮----
///     Gets the secret value enabling users to join your game.
⋮----
///     Gets the secret value enabling users to receive notifications whenever your game state changes.
⋮----
///     Gets the secret value enabling users to spectate your game.
⋮----
///     Updates a game activity with an transport activity.
⋮----
internal void UpdateWith(TransportActivity rawGame)
⋮----
? new DiscordApplication
⋮----
if (rawGame?.Party != null &amp;&amp; ulong.TryParse(rawGame.Party.Id, NumberStyles.Number, CultureInfo.InvariantCulture, out var partyId))
⋮----
if (lid.StartsWith(&quot;spotify:&quot;, StringComparison.Ordinal))
this.LargeImage = new DiscordSpotifyAsset
⋮----
else if (ulong.TryParse(lid, NumberStyles.Number, CultureInfo.InvariantCulture, out var ulid))
this.LargeImage = new DiscordApplicationAsset
⋮----
if (sid.StartsWith(&quot;spotify:&quot;, StringComparison.Ordinal))
this.SmallImage = new DiscordSpotifyAsset
⋮----
else if (ulong.TryParse(sid, NumberStyles.Number, CultureInfo.InvariantCulture, out var usid))
this.SmallImage = new DiscordApplicationAsset
⋮----
///     Determines the type of a user activity.
⋮----
///     Indicates the user is playing a game.
⋮----
///     Indicates the user is streaming a game.
⋮----
///     Indicates the user is listening to something.
⋮----
///     Indicates the user is watching something.
⋮----
///     Indicates the current activity is a custom status.
⋮----
///     Indicates the user is competing in something.</file><file path="DisCatSharp/Entities/User/DiscordCollectibles.cs">/// &lt;summary&gt;
///     Represents a user&apos;s collectibles.
/// &lt;/summary&gt;
public sealed class DiscordCollectibles
⋮----
///     Gets the user&apos;s nameplate, if applicable.</file><file path="DisCatSharp/Entities/User/DiscordConnection.cs">/// &lt;summary&gt;
///     Gets a Discord connection to a 3rd party service.
/// &lt;/summary&gt;
public class DiscordConnection : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordConnection&quot; /&gt; class.
⋮----
///     Gets the id of the connection account
⋮----
///     Gets the username of the connection account.
⋮----
///     &lt;para&gt;Gets the service of the connection.&lt;/para&gt;
///     &lt;list type=&quot;table&quot;&gt;
///         &lt;listheader&gt;
///             &lt;term&gt;Type&lt;/term&gt;
///             &lt;description&gt;Obsolete (Non-assignable)&lt;/description&gt;
///         &lt;/listheader&gt;
///         &lt;item&gt;
///             &lt;term&gt;contacts&lt;/term&gt;
///             &lt;description&gt;false&lt;/description&gt;
///         &lt;/item&gt;
⋮----
///             &lt;term&gt;anazon-music&lt;/term&gt;
⋮----
///             &lt;term&gt;instagram&lt;/term&gt;
⋮----
///             &lt;term&gt;crunchyroll&lt;/term&gt;
⋮----
///             &lt;term&gt;tiktok&lt;/term&gt;
⋮----
///             &lt;term&gt;paypal&lt;/term&gt;
⋮----
///             &lt;term&gt;epicgames&lt;/term&gt;
⋮----
///             &lt;term&gt;bungie&lt;/term&gt;
⋮----
///             &lt;term&gt;ebay&lt;/term&gt;
⋮----
///             &lt;term&gt;twitch&lt;/term&gt;
⋮----
///             &lt;term&gt;steam&lt;/term&gt;
⋮----
///             &lt;term&gt;youtube&lt;/term&gt;
⋮----
///             &lt;term&gt;twitter&lt;/term&gt;
⋮----
///             &lt;term&gt;facebook&lt;/term&gt;
⋮----
///             &lt;term&gt;spotify&lt;/term&gt;
⋮----
///             &lt;term&gt;xbox&lt;/term&gt;
⋮----
///             &lt;term&gt;playstation&lt;/term&gt;
⋮----
///             &lt;term&gt;roblox&lt;/term&gt;
⋮----
///             &lt;term&gt;reddit&lt;/term&gt;
⋮----
///             &lt;term&gt;battlenet&lt;/term&gt;
⋮----
///             &lt;term&gt;github&lt;/term&gt;
⋮----
///             &lt;term&gt;leagueoflegends&lt;/term&gt;
⋮----
///             &lt;term&gt;skype&lt;/term&gt;
///             &lt;description&gt;true&lt;/description&gt;
⋮----
///             &lt;term&gt;samsunggalaxy&lt;/term&gt;
⋮----
///     &lt;/list&gt;
⋮----
///     Gets whether the connection is revoked.
⋮----
///     Gets a collection of partial server integrations.
⋮----
///     Gets whether the connection is verified.
⋮----
///     Gets whether the connection will show a activity.
⋮----
///     Whether the connection will sync friends.
⋮----
///     Whether this connection supports console voice transfer.
///     Currently in beta rollout for XBox. Playstation soon.
⋮----
///     Gets the visibility of the connection.
⋮----
///     Gets the metadata visibility of the connection.
⋮----
///     Gets the client instance this object is tied to.</file><file path="DisCatSharp/Entities/User/DiscordNameplate.cs">/// &lt;summary&gt;
///     Represents a user&apos;s nameplate.
/// &lt;/summary&gt;
public sealed class DiscordNameplate
⋮----
///     Gets the user&apos;s nameplate url.
⋮----
=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ASSETS}{Endpoints.COLLECTIBLES}/{this.Asset}/asset.webm&quot;;
⋮----
///     Gets the nameplate&apos;s asset hash.
⋮----
///     Gets the nameplate&apos;s label.
⋮----
///     Gets the nameplate&apos;s sku id.
⋮----
///     Gets the nameplate&apos;s dominant color.</file><file path="DisCatSharp/Entities/User/DiscordPresence.cs">/// &lt;summary&gt;
///     Represents a user presence.
/// &lt;/summary&gt;
public sealed class DiscordPresence : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPresence&quot; /&gt; class.
⋮----
// TODO: Add broadcast field
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other.&lt;/param&gt;
⋮----
///     Gets the internal activities.
⋮----
///     Gets the discord client.
⋮----
///     Gets the internal user.
⋮----
///     Gets the user that owns this presence.
⋮----
=&gt; this.Discord.GetCachedOrEmptyUserInternal(this.InternalUser.Id);
⋮----
///     Gets the user&apos;s current activity.
⋮----
///     Gets the raw activity.
⋮----
///     Gets the user&apos;s current activities.
⋮----
///     Gets the raw activities.
⋮----
///     Gets this user&apos;s status.
⋮----
///     Gets the guild id for which this presence was set.
⋮----
///     Gets the guild for which this presence was set.
⋮----
///     Gets this user&apos;s platform-dependent status.
⋮----
///     Represents a user with only its id.
⋮----
public sealed class UserWithIdOnly : ObservableApiObject
⋮----
///     Represents a client status.
⋮----
public sealed class DiscordClientStatus : ObservableApiObject
⋮----
///     Gets the user&apos;s status set for an active desktop (Windows, Linux, Mac) application session.
⋮----
///     Gets the user&apos;s status set for an active mobile (iOS, Android) application session.
⋮----
///     Gets the user&apos;s status set for an active web (browser, bot account) application session.</file><file path="DisCatSharp/Entities/User/DiscordPrimaryGuild.cs">/// &lt;summary&gt;
///     Represents a primary guild.
/// &lt;/summary&gt;
public sealed class DiscordPrimaryGuild
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordPrimaryGuild&quot; /&gt; class.
⋮----
///     Gets the identity guild id.
⋮----
///     Gets whether the identity is enabled and shown to everyone.
⋮----
///     Gets the primary guild&apos;s tag.
⋮----
///     Gets the cprimary guild&apos;s badge url
⋮----
=&gt; string.IsNullOrWhiteSpace(this.BadgeHash) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.CLAN_BADGES}/{this.IdentityGuildId?.ToString(CultureInfo.InvariantCulture)}/{this.BadgeHash}.{(this.BadgeHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the primary guild&apos;s badge hash.</file><file path="DisCatSharp/Entities/User/DiscordTeam.cs">/// &lt;summary&gt;
///     Represents a team consisting of users. A team can own an application.
/// &lt;/summary&gt;
public sealed class DiscordTeam : SnowflakeObject, IEquatable&lt;DiscordTeam&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordTeam&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;tt&quot;&gt;The tt.&lt;/param&gt;
⋮----
///     Gets the team&apos;s name.
⋮----
///     Gets the team&apos;s icon hash.
⋮----
///     Gets the team&apos;s icon.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.TEAM_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=1024&quot; : null!;
⋮----
///     Gets the owner of the team.
⋮----
///     Gets the members of this team.
⋮----
///     Compares this team to another team and returns whether they are equal.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Team to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the teams are equal.&lt;/returns&gt;
public bool Equals(DiscordTeam other)
⋮----
///     Compares this team to another object and returns whether they are equal.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare this team to.&lt;/param&gt;
/// &lt;returns&gt;Whether this team is equal to the given object.&lt;/returns&gt;
public override bool Equals(object obj)
⋮----
///     Gets the hash code of this team.
⋮----
/// &lt;returns&gt;Hash code of this team.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Converts this team to its string representation.
⋮----
/// &lt;returns&gt;The string representation of this team.&lt;/returns&gt;
public override string ToString()
⋮----
///     Represents a member of &lt;see cref=&quot;DiscordTeam&quot; /&gt;.
⋮----
public sealed class DiscordTeamMember : IEquatable&lt;DiscordTeamMember&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordTeamMember&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;ttm&quot;&gt;The ttm.&lt;/param&gt;
⋮----
///     Gets the member&apos;s membership status.
⋮----
///     Gets the member&apos;s permissions within the team.
⋮----
///     Gets the member&apos;s role within the team.
///     &lt;para&gt;Can be &lt;c&gt;owner&lt;/c&gt;, &lt;c&gt;admin&lt;/c&gt;, &lt;c&gt;developer&lt;/c&gt; or &lt;c&gt;read-only&lt;/c&gt;.&lt;/para&gt;
///     &lt;para&gt;As per official spec, owner won&apos;t be transmitted via api, so we fake patch it. Thanks discord..&lt;/para&gt;
///     &lt;para&gt;
///         For those interested, here&apos;s the pull request with the owner removal:
///         &lt;see href=&quot;https://github.com/discord/discord-api-docs/pull/6384&quot;&gt;#6384&lt;/see&gt;.
///     &lt;/para&gt;
⋮----
///         For those with access to ddevs internal:
///         &lt;see href=&quot;https://discord.com/channels/613425648685547541/801247546151403531/1144720730613895219&quot;&gt;
///             Message in
///             #api at Discord Developers
///         &lt;/see&gt;
///         .
⋮----
///     Gets the id of the team this member belongs to.
⋮----
///     Gets the name of the team this member belongs to.
⋮----
///     Gets the user who is the team member.
⋮----
///     Compares this team member to another team member and returns whether they are equal.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Team member to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether this team member is equal to the given one.&lt;/returns&gt;
public bool Equals(DiscordTeamMember other)
⋮----
///     Compares this team member to another object and returns whether they are equal.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether this team is equal to given object.&lt;/returns&gt;
⋮----
///     Gets a hash code of this team member.
⋮----
/// &lt;returns&gt;Hash code of this team member.&lt;/returns&gt;
public override int GetHashCode() =&gt; HashCode.Combine(this.User, this.TeamId);
⋮----
///     Converts this team member to their string representation.
⋮----
/// &lt;returns&gt;String representation of this team member.&lt;/returns&gt;
⋮----
///     Signifies the status of user&apos;s team membership.
⋮----
///     Indicates that this user is invited to the team, and is pending membership.
⋮----
///     Indicates that this user is a member of the team.</file><file path="DisCatSharp/Entities/Voice/DiscordSoundboardSound.cs">/// &lt;summary&gt;
///     Represents a soundboard sound in a Discord guild.
/// &lt;/summary&gt;
public sealed class DiscordSoundboardSound : SnowflakeObject
⋮----
/// &lt;inheritdoc cref=&quot;SnowflakeObject.Id&quot; /&gt;
⋮----
///     Gets the name of the soundboard sound.
⋮----
///     Gets the volume of the soundboard sound (0 to 1).
⋮----
///     Gets the emoji id of the soundboard sound&apos;s custom emoji, if applicable.
⋮----
///     Gets the emoji name of the soundboard sound&apos;s standard emoji, if applicable.
⋮----
///     Gets whether this sound can be used.
⋮----
///     Gets the guild id this sound belongs to, if applicable.
⋮----
///     Gets the guild this sound belongs to, if applicable.
⋮----
=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
⋮----
///     Gets the user who created this soundboard sound, if applicable.
⋮----
///     Gets the transport user, if applicable.
⋮----
///     Gets the sound URL (as mp3) of this sound.
⋮----
=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SOUNDBOARD_SOUNDS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.mp3&quot;;
⋮----
///     Gets the mention of the sound to send it in chat.
⋮----
///     Modifies the soundboard sound.
⋮----
/// &lt;param name=&quot;action&quot;&gt;The action to configure the soundboard sound edit model.&lt;/param&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Throws when the soundboard sound cannot be found&lt;/exception&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Throws when the client does not have the &lt;see cref=&quot;Permissions.ManageGuildExpressions&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
/// &lt;returns&gt;The updated &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;DiscordSoundboardSound&gt; ModifyAsync(Action&lt;SoundboardSoundEditModel&gt; action)
⋮----
throw new InvalidOperationException(&quot;You can only edit guild soundboard sounds.&quot;);
⋮----
var mdl = new SoundboardSoundEditModel();
⋮----
return await this.Discord.ApiClient.ModifyGuildSoundboardSoundAsync(
⋮----
).ConfigureAwait(false);
⋮----
///     Deletes the soundboard sound.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The reason for deleting the sound, to be logged in the audit log. Optional.&lt;/param&gt;
⋮----
public Task DeleteSoundboardSoundAsync(string? reason = null)
=&gt; this.GuildId.HasValue ? this.Discord.ApiClient.DeleteGuildSoundboardSoundAsync(this.GuildId.Value, this.Id, reason) : throw new InvalidOperationException(&quot;You can only delete guild soundboard sounds.&quot;);</file><file path="DisCatSharp/Entities/Voice/DiscordVoiceRegion.cs">/// &lt;summary&gt;
///     Represents information about a Discord voice server region.
/// &lt;/summary&gt;
public class DiscordVoiceRegion : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordVoiceRegion&quot; /&gt; class.
⋮----
///     Gets the unique ID for the region.
⋮----
///     Gets the name of the region.
⋮----
///     Gets an example server hostname for this region.
⋮----
///     Gets an example server port for this region.
⋮----
///     Gets whether this region is the most optimal for the current user.
⋮----
///     Gets whether this voice region is deprecated.
⋮----
///     Gets whether this is a custom voice region.
⋮----
///     Gets whether two &lt;see cref=&quot;DiscordVoiceRegion&quot; /&gt;s are equal.
⋮----
/// &lt;param name=&quot;region&quot;&gt;The region to compare with.&lt;/param&gt;
public bool Equals(DiscordVoiceRegion region)
⋮----
///     Whether two regions are equal.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;A voice region.&lt;/param&gt;
public override bool Equals(object obj) =&gt; this.Equals(obj as DiscordVoiceRegion);
⋮----
///     Gets the hash code.
⋮----
public override int GetHashCode() =&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordVoiceRegion&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;left&quot;&gt;First voice region to compare.&lt;/param&gt;
/// &lt;param name=&quot;right&quot;&gt;Second voice region to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two voice regions are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordVoiceRegion&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two voice regions are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Voice/DiscordVoiceState.cs">/// &lt;summary&gt;
///     Represents a Discord voice state.
/// &lt;/summary&gt;
public class DiscordVoiceState : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordVoiceState&quot; /&gt; class.
⋮----
// copy constructor for reduced boilerplate
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;m&quot;&gt;The m.&lt;/param&gt;
⋮----
// Values not filled out are values that are not known from a DiscordMember
⋮----
///     Gets the discord client.
⋮----
///     Gets ID of the guild this voice state is associated with.
⋮----
///     Gets the guild associated with this voice state.
⋮----
///     Gets ID of the channel this user is connected to.
⋮----
///     Gets the channel this user is connected to.
⋮----
=&gt; this.ChannelId is not null &amp;&amp; this.ChannelId.Value != 0 ? this.Discord.InternalGetCachedChannel(this.ChannelId.Value) : null;
⋮----
///     Gets ID of the user to which this voice state belongs.
⋮----
///     Gets the user associated with this voice state.
///     &lt;para&gt;This can be cast to a &lt;see cref=&quot;DisCatSharp.Entities.DiscordMember&quot; /&gt; if this voice state was in a guild.&lt;/para&gt;
⋮----
usr = this.Guild.MembersInternal.GetValueOrDefault(this.UserId);
⋮----
usr ??= this.Discord.GetCachedOrEmptyUserInternal(this.UserId);
⋮----
///     Gets ID of the session of this voice state.
⋮----
///     Gets whether this user is deafened.
⋮----
///     Gets whether this user is muted.
⋮----
///     Gets whether this user is locally deafened.
⋮----
///     Gets whether this user is locally muted.
⋮----
///     Gets whether this user&apos;s camera is enabled.
⋮----
///     Gets whether this user is using the Go Live feature.
⋮----
///     Gets whether the current user has suppressed this user.
⋮----
///     Gets the time at which this user requested to speak.
⋮----
///     Gets the member this voice state belongs to.
⋮----
=&gt; this.Guild!.Members.TryGetValue(this.TransportMember.User!.Id, out var member)
⋮----
///     Gets the transport member.
⋮----
///     Gets whether the voice state is discoverable through user activities.
⋮----
///     Gets a readable voice state string.
⋮----
public override string ToString() =&gt; $&quot;{this.UserId.ToString(CultureInfo.InvariantCulture)} in {(this.GuildId ?? this.Channel.GuildId.Value).ToString(CultureInfo.InvariantCulture)}&quot;;</file><file path="DisCatSharp/Enums/Application/ApplicationCommandHandlerType.cs">/// &lt;summary&gt;
///     Represents the application command handler types.
/// &lt;/summary&gt;
⋮----
///     The app handles the interaction using an interaction token.
⋮----
///     Discord handles the interaction by launching an Activity and sending a follow-up message without coordinating with
///     the app.</file><file path="DisCatSharp/Enums/Application/ApplicationCommandIntegrationTypes.cs">/// &lt;summary&gt;
///     Represents the application command integration types.
/// &lt;/summary&gt;
⋮----
///     Application command is installed for guild (default).
⋮----
///     Application command is installed as user app.</file><file path="DisCatSharp/Enums/Application/ApplicationCommandOptionType.cs">/// &lt;summary&gt;
///     Represents the type of parameter when invoking an interaction.
/// &lt;/summary&gt;
⋮----
///     Whether this parameter is another subcommand.
⋮----
///     Whether this parameter is apart of a subcommand group.
⋮----
///     Whether this parameter is a string.
⋮----
///     Whether this parameter is an integer.
⋮----
///     Whether this parameter is a boolean.
⋮----
///     Whether this parameter is a Discord user.
⋮----
///     Whether this parameter is a Discord channel.
⋮----
///     Whether this parameter is a Discord role.
⋮----
///     Whether this parameter is a mentionable.
⋮----
///     Whether this parameter is a number.
⋮----
///     Whether this parameter is a attachment.</file><file path="DisCatSharp/Enums/Application/ApplicationCommandPermissionType.cs">/// &lt;summary&gt;
///     Represents the type of the application command permission.
/// &lt;/summary&gt;
⋮----
///     The permission is bound to a role.
⋮----
///     The permission is bound to a user.
⋮----
///     The permission is bound to a channel.</file><file path="DisCatSharp/Enums/Application/ApplicationCommandType.cs">/// &lt;summary&gt;
///     Represents the type of an &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationCommand&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
///     Slash commands; a text-based command that shows up when a user types &quot;/&quot;.
⋮----
///     A UI-based command that shows up when you right click or tap on a user.
⋮----
///     A UI-based command that shows up when you right click or tap on a message.
⋮----
///     A UI-based command that represents the primary way to invoke an app&apos;s Activit.</file><file path="DisCatSharp/Enums/Application/ApplicationDiscoverabilityState.cs">/// &lt;summary&gt;
///     Represents the application discoverability state.
/// &lt;/summary&gt;
⋮----
///     This application is ineligible for the application directory
⋮----
///     This application is not listed in the application directory
⋮----
///     This application is listed in the application directory
⋮----
///     This application is featurable in the application directory
⋮----
///     This application has been blocked from appearing in the application directory</file><file path="DisCatSharp/Enums/Application/ApplicationDiscoveryEligibilityFlags.cs">/// &lt;summary&gt;
///     Represents a application discovery flag extensions.
/// &lt;/summary&gt;
public static class ApplicationDiscoveryEligibilityFlagExtensions
⋮----
///     Calculates whether these application discovery flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasApplicationDiscoveryFlag(this ApplicationDiscoveryEligibilityFlags baseFlags, ApplicationDiscoveryEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents the application discoverability eligibility flags.
⋮----
///     Application is verified.
⋮----
///     Application has at least one tag set.
⋮----
///     Application has a description.
⋮----
///     Applications has a terms of service.
⋮----
///     Application has a privacy policy.
⋮----
///     Application has custom install url or install params.
⋮----
///     Application&apos;s name is safe for work.
⋮----
///     Application&apos;s description is safe for work.
⋮----
///     Application has the message content approved or utilizes application commands.
⋮----
///     Application has a support guild set.
⋮----
///     Application&apos;s commands are safe for work.
⋮----
///     Application&apos;s owner has MFA enabled.
⋮----
///     Application&apos;s directory long description is safe for work.
⋮----
///     Application has at least one supported locale set.
⋮----
///     Application&apos;s directory short description is safe for work.
⋮----
///     Application&apos;s role connections metadata is safe for work.
⋮----
///     Application has met all criteria and is eligible for discovery.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Application/ApplicationExplicitContentFilter.cs">/// &lt;summary&gt;
///     Represents the explicit content filter level.
/// &lt;/summary&gt;
⋮----
///     Media content will not be scanned
⋮----
///     Media content will be scanned</file><file path="DisCatSharp/Enums/Application/ApplicationFlags.cs">/// &lt;summary&gt;
///     Represents additional details of an application.
/// &lt;/summary&gt;
⋮----
///     The application has no flags.
⋮----
///     The application is embedded and can be used by users.
///     This was introduced to avoid users using in-dev apps.
⋮----
///     The application is a managed emoji.
⋮----
///     Unknown, relates to in app purchase.
⋮----
///     The application can create group dms.
⋮----
///     Allows the application to access the local RPC server.
⋮----
///     The application has created multiple auto moderation rules.
⋮----
///     The application&apos;s game profile is disabled.
⋮----
///     The application&apos;s OAuth2 credentials are public.
⋮----
///     The application&apos;s activity can be launched without a context.
⋮----
///     The application has limited access to the social layer SDK.
⋮----
///     The application has connected to RPC.
⋮----
///     The application can track presence data.
⋮----
///     The application can track presence data (limited).
⋮----
///     The application can track guild members.
⋮----
///     The application can track guild members (limited).
⋮----
///     The application can track pending guild member verifications (limited).
⋮----
///     The application is embedded.
⋮----
///     The application can track message content.
⋮----
///     The application can track message content (limited).
⋮----
///     Related to embedded applications.
⋮----
///     The application has been migrated to the new application command system.
⋮----
///     The application has registered global application commands.
⋮----
///     Indicates if an app is considered active.
///     This means that it has had any global command executed in the past 30 days.
⋮----
///     Indicates if an application has not had any global application commands used in the last 30 days and has lost the &lt;see cref=&quot;Active&quot;/&gt; flag.
⋮----
///     Allows the app to use Iframe modals.
⋮----
///     Indicates if an app can use the social layer SDK.
⋮----
///     Indicates if an app is promoted by discord.
⋮----
///     Indicates if an app is partnered with discord.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Application/ApplicationInteractionsVersion.cs">/// &lt;summary&gt;
///     Represents the application interactions version.
/// &lt;/summary&gt;
⋮----
///     Only Interaction Create events are sent as documented (default)
⋮----
///     A selection of chosen events are sent</file><file path="DisCatSharp/Enums/Application/ApplicationMonetizationEligibilityFlags.cs">/// &lt;summary&gt;
///     Represents a application monetization eligibility flags extension.
/// &lt;/summary&gt;
public static class ApplicationMonetizationEligibilityFlagExtensions
⋮----
///     Calculates whether these application discovery flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasApplicationMonetizationEligibilityFlag(this ApplicationMonetizationEligibilityFlags baseFlags, ApplicationMonetizationEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents the application monetization eligibility flags.
⋮----
///     This application is verified
⋮----
///     This application is owned by a team
⋮----
///     This application has the message content intent approved or utilizes application commands
⋮----
///     This application has terms of service set
⋮----
///     This application has a privacy policy set
⋮----
///     This application&apos;s name is safe for work
⋮----
///     This application&apos;s description is safe for work
⋮----
///     This application&apos;s role connections metadata is safe for work
⋮----
///     The user is the owner of the team that owns the application
⋮----
///     This application is not quarantined
⋮----
///     The user&apos;s locale is supported by monetization
⋮----
///     The user is old enough to use monetization
⋮----
///     The user has a date of birth defined on their account
⋮----
///     The user has MFA enabled
⋮----
///     The user&apos;s email is verified
⋮----
///     All members of the team that owns the application have verified emails
⋮----
///     All members of the team that owns the application have MFA enabled
⋮----
///     This application has no issues blocking monetization
⋮----
///     The team has a valid payout status
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Application/ApplicationMonetizationState.cs">/// &lt;summary&gt;
///     Represents the application discoverability state.
/// &lt;/summary&gt;
⋮----
///     This application does not have monetization set up
⋮----
///     This application has monetization set up
⋮----
///     This application has been blocked from monetizing</file><file path="DisCatSharp/Enums/Application/ApplicationRoleConnectionMetadataType.cs">/// &lt;summary&gt;
///     Represents the type of an &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationRoleConnectionMetadata&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
///     The metadata value (`integer`) is less than or equal to the guild&apos;s configured value (`integer`).
⋮----
///     The metadata value (`integer`) is greater than or equal to the guild&apos;s configured value (`integer`).
⋮----
///     The metadata value (`integer`) is equal to the guild&apos;s configured value (`integer`).
⋮----
///     The metadata value (`integer`) is not equal to the guild&apos;s configured value (`integer`).
⋮----
///     The metadata value (`ISO8601 string`) is less than or equal to the guild&apos;s configured value (`integer`; `days
///     before current date`).
⋮----
///     The metadata value (`ISO8601 string`) is greater than or equal to the guild&apos;s configured value (`integer`; `days
⋮----
///     The metadata value (`integer`) is equal to the guild&apos;s configured value (`integer`; `1`).
⋮----
///     The metadata value (`integer`) is not equal to the guild&apos;s configured value (`integer`; `1`).</file><file path="DisCatSharp/Enums/Application/ApplicationVerificationEligibilityFlags.cs">/// &lt;summary&gt;
///     Represents an extension for checking application verification eligibility flags.
/// &lt;/summary&gt;
public static class ApplicationVerificationEligibilityFlagExtensions
⋮----
///     Calculates whether these verification eligibility flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasVerificationEligibilityFlag(this ApplicationVerificationEligibilityFlags baseFlags, ApplicationVerificationEligibilityFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents the verification eligibility flags.
⋮----
///     The application has a team.
⋮----
///     The application&apos;s name is considered safe.
⋮----
///     The application&apos;s description is considered safe.
⋮----
///     The application&apos;s role connections metadata is considered safe.
⋮----
///     The application has a terms of service URL set.
⋮----
///     The application has a privacy policy URL set.
⋮----
///     The application has an invite link set.
⋮----
///     The application is not embedded.
⋮----
///     The application has no unapproved intents.
⋮----
///     The user is the owner of the team that owns the application.
⋮----
///     The team owner is verified.
⋮----
///     The user has two-factor authentication enabled.
⋮----
///     The user&apos;s email is verified.
⋮----
///     All team members&apos; emails are verified.
⋮----
///     All team members have two-factor authentication enabled.
⋮----
///     The application has no blocking issues.
⋮----
///     The application is eligible for verification.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Application/ApplicationVerificationState.cs">/// &lt;summary&gt;
///     Represents the application verification state (&lt;see cref=&quot;UserFlags.VerifiedBot&quot; /&gt;).
/// &lt;/summary&gt;
⋮----
///     This application is ineligible for verification
⋮----
///     This application has not yet been applied for verification
⋮----
///     This application has submitted a verification request
⋮----
///     This application has been verified</file><file path="DisCatSharp/Enums/Application/RpcApplicationState.cs">/// &lt;summary&gt;
///     Represents the RPC application state.
/// &lt;/summary&gt;
⋮----
///     The application is disabled or none.
⋮----
///     The application is unsubmitted.
⋮----
///     The application is submitted.
⋮----
///     The application is approved.
⋮----
///     The application is rejected.</file><file path="DisCatSharp/Enums/Application/StoreApplicationState.cs">/// &lt;summary&gt;
///     Represents the store application state.
/// &lt;/summary&gt;
⋮----
///     This application does not have a commerce license
⋮----
///     This application has a commerce license but has not yet submitted a store approval request
⋮----
///     This application has submitted a store approval request
⋮----
///     This application has been approved for the store
⋮----
///     This application has been rejected from the store
⋮----
///     This application is blocked from the store</file><file path="DisCatSharp/Enums/Channel/ChannelType.cs">/// &lt;summary&gt;
///     Represents a channel&apos;s type.
/// &lt;/summary&gt;
⋮----
///     Indicates that this is a text channel.
⋮----
///     Indicates that this is a private channel.
⋮----
///     Indicates that this is a voice channel.
⋮----
///     Indicates that this is a group direct message channel.
⋮----
///     Indicates that this is a channel category.
⋮----
///     Indicates that this is a news channel.
⋮----
///     Indicates that this is a store channel.
⋮----
///     Indicates that this is a temporary sub-channel within a news channel.
⋮----
/// &lt;inheritdoc cref=&quot;NewsThread&quot; /&gt;
⋮----
///     Indicates that this is a temporary sub-channel within a text channel.
⋮----
///     Indicates that this is a temporary sub-channel within a text channel that is only viewable
///     by those invited and those with the MANAGE_THREADS permission.
⋮----
///     Indicates that this is a stage channel.
⋮----
///     Indicates that this is a guild directory channel.
///     This is used for hub guilds (feature for schools).
⋮----
///     Indicates that this is a guild forum channel (Threads only channel).
⋮----
///     Indicates that this is a media channel.
⋮----
///     Indicates that this is a lobby channel.
⋮----
///     Indicates that this is a channel for the &lt;c&gt;Direct Message SDK&lt;/c&gt;.
⋮----
///     Indicates unknown channel type.</file><file path="DisCatSharp/Enums/Channel/DirectoryCategory.cs">/// &lt;summary&gt;
///     Represents a directory entries primary category type.
/// &lt;/summary&gt;
⋮----
///     Indicates that this entry falls under the category Clubs.
⋮----
///     Indicates that this entry falls under the category Classes.
⋮----
///     Indicates that this entry falls under the category Social and Study.
⋮----
///     Indicates that this entry falls under the category Majors and Subjects.
⋮----
///     Indicates that this entry falls under the category Miscellaneous.
⋮----
///     Indicates unknown category type.</file><file path="DisCatSharp/Enums/Channel/OverwriteType.cs">/// &lt;summary&gt;
///     Represents a channel permission overwrite&apos;s type.
/// &lt;/summary&gt;
⋮----
///     Specifies that this overwrite applies to a role.
⋮----
///     Specifies that this overwrite applies to a member.</file><file path="DisCatSharp/Enums/Channel/VideoQualityMode.cs">/// &lt;summary&gt;
///     Represents the video quality mode of a voice channel. This is applicable to voice channels only.
/// &lt;/summary&gt;
⋮----
///     Indicates that the video quality is automatically chosen, or there is no value set.
⋮----
///     Indicates that the video quality is 720p.</file><file path="DisCatSharp/Enums/Core/CooldownBucketType.cs">/// &lt;summary&gt;
///     Defines how are command cooldowns applied.
/// &lt;/summary&gt;
⋮----
///     Denotes that the command will have its cooldown applied globally.
⋮----
///     Denotes that the command will have its cooldown applied per-user globally.
⋮----
///     Denotes that the command will have its cooldown applied per-channel.
⋮----
///     Denotes that the command will have its cooldown applied per-guild. Skipped for DMs.
⋮----
///     Denotes that the command will have its cooldown applied per-member per-guild. Skipped for DMs.</file><file path="DisCatSharp/Enums/Core/DisCatSharpCommandType.cs">/// &lt;summary&gt;
///     Represents the type of a command.
/// &lt;/summary&gt;
⋮----
///     A text command.
⋮----
///     A slash command.
⋮----
///     A user context menu command.
⋮----
///     A message context menu command.
⋮----
///		A autocomplete.
⋮----
///     A special type.</file><file path="DisCatSharp/Enums/Core/DisCatSharpStatisticType.cs">/// &lt;summary&gt;
///     Represents the type of statistic.
/// &lt;/summary&gt;
⋮----
/// Represents the number of guilds.
⋮----
/// Represents the number of users.
⋮----
/// Represents the number of channels.
⋮----
/// Represents the number of threads.
⋮----
/// Represents the number of roles.
⋮----
/// Represents the number of emojis.
⋮----
/// Represents the number of stickers.
⋮----
/// Represents the number of soundboard sounds.
⋮----
/// Represents the number of stage instances.
⋮----
/// Represents the number of scheduled events.</file><file path="DisCatSharp/Enums/Discord/ApiChannel.cs">/// &lt;summary&gt;
///     Represents the api channel.
/// &lt;/summary&gt;
⋮----
///     Use the Stable channel (&lt;c&gt;discord.com&lt;/c&gt;). This is the default.
⋮----
///     Use the PTB channel (&lt;c&gt;ptb.discord.com&lt;/c&gt;).
⋮----
///     Use the Canary channel (&lt;c&gt;canary.discord.com&lt;/c&gt;).
⋮----
///     Use the Staging channel (&lt;c&gt;staging.discord.co&lt;/c&gt;).</file><file path="DisCatSharp/Enums/Discord/DiscordDomain.cs">/// &lt;summary&gt;
///     Core Domains
/// &lt;/summary&gt;
⋮----
///     dis.gd
⋮----
///     discord.co
⋮----
///     discord.com
⋮----
///     discord.design
⋮----
///     discord.dev
⋮----
///     discord.gg
⋮----
///     discord.gift
⋮----
///     discord.media
⋮----
///     discord.new
⋮----
///     discord.store
⋮----
///     discord.tools
⋮----
///     discordapp.com
⋮----
///     discordapp.net
⋮----
///     discordmerch.com
⋮----
///     discordpartygames.com
⋮----
///     discord-activities.com
⋮----
///     discordsays.com
⋮----
///     discordstatus.com
⋮----
///     cdn.discordapp.com
⋮----
///     Other Domains
⋮----
///     airhorn.solutions
⋮----
///     airhornbot.com
⋮----
///     bigbeans.solutions
⋮----
///     watchanimeattheoffice.com
⋮----
///     Unused Domains
⋮----
///     discordapp.io
⋮----
///     discordcdn.com
⋮----
///     Represents a discord domain.
⋮----
public static class DiscordDomain
⋮----
///     Gets a domain.
///     Valid types: &lt;see cref=&quot;CoreDomain&quot; /&gt;, &lt;see cref=&quot;OtherDomain&quot; /&gt; and &lt;see cref=&quot;UnusedDomain&quot; /&gt;.
⋮----
/// &lt;param name=&quot;domainEnum&quot;&gt;The domain type.&lt;/param&gt;
/// &lt;returns&gt;A DomainHelpAttribute.&lt;/returns&gt;
public static DomainHelpAttribute GetDomain(Enum domainEnum)
⋮----
throw new NotSupportedException($&quot;Invalid type. Found: {domainEnum.GetType()} Expected: CoreDomain or OtherDomain or UnusedDomain&quot;);
⋮----
throw new UnauthorizedAccessException(&quot;You don&apos;t have access to this domains&quot;);
⋮----
var memberInfo = domainEnum.GetType().GetMember(domainEnum.ToString()).FirstOrDefault();
⋮----
var attribute = (DomainHelpAttribute)memberInfo.GetCustomAttributes(typeof(DomainHelpAttribute), false).FirstOrDefault();
⋮----
///     Defines a description and url for this domain.
⋮----
public class DomainHelpAttribute : Attribute
⋮----
///     Defines a description and URIs for this domain.
⋮----
/// &lt;param name=&quot;desc&quot;&gt;Description for this domain.&lt;/param&gt;
/// &lt;param name=&quot;domain&quot;&gt;Url for this domain.&lt;/param&gt;
⋮----
///     Gets the Description for this domain.
⋮----
///     Gets the Uri for this domain.
⋮----
///     Gets the Domain for this domain.
⋮----
///     Gets the Url for this domain.</file><file path="DisCatSharp/Enums/Discord/DiscordEvent.cs">/// &lt;summary&gt;
///     Methods marked with this attribute will be registered as event handling methods
///     if the associated type / an associated instance is being registered.
/// &lt;/summary&gt;
⋮----
public class EventAttribute : Attribute
⋮----
///     Gets the event name.
⋮----
///     Initializes a new instance of &lt;see cref=&quot;EventAttribute&quot; /&gt;.
⋮----
/// &lt;param name=&quot;evtn&quot;&gt;
///     &lt;para&gt;The name of the event.&lt;/para&gt;
///     &lt;para&gt;The attributed method&apos;s name will be used if null.&lt;/para&gt;
/// &lt;/param&gt;
⋮----
this.EventName = evtn.ToString();
⋮----
///     Classes marked with this attribute will be considered for event handler registration from an assembly.
⋮----
public class EventHandlerAttribute : Attribute
⋮----
///     All events available in &lt;see cref=&quot;DiscordClient&quot; /&gt; for use with &lt;see cref=&quot;EventAttribute&quot; /&gt;.</file><file path="DisCatSharp/Enums/Discord/DiscordIntents.cs">/// &lt;summary&gt;
///     Represents a discord intent extensions.
/// &lt;/summary&gt;
public static class DiscordIntentExtensions
⋮----
///     Calculates whether these intents have a certain intent.
⋮----
/// &lt;param name=&quot;intents&quot;&gt;The base intents.&lt;/param&gt;
/// &lt;param name=&quot;search&quot;&gt;The intents to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasIntent(this DiscordIntents intents, DiscordIntents search)
⋮----
///     Adds an intent to these intents.
⋮----
/// &lt;param name=&quot;toAdd&quot;&gt;The intents to add.&lt;/param&gt;
⋮----
public static DiscordIntents AddIntent(this DiscordIntents intents, DiscordIntents toAdd)
⋮----
///     Removes an intent from these intents.
⋮----
/// &lt;param name=&quot;toRemove&quot;&gt;The intents to remove.&lt;/param&gt;
⋮----
public static DiscordIntents RemoveIntent(this DiscordIntents intents, DiscordIntents toRemove)
⋮----
///     Whether it has all privileged intents.
⋮----
/// &lt;param name=&quot;intents&quot;&gt;The intents.&lt;/param&gt;
internal static bool HasAllPrivilegedIntents(this DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.GuildMembers | DiscordIntents.GuildPresences | DiscordIntents.MessageContent);
⋮----
///     Whether it has all v9 privileged intents.
⋮----
internal static bool HasAllV9PrivilegedIntents(this DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.GuildMembers | DiscordIntents.GuildPresences);
⋮----
///     Represents gateway intents to be specified for connecting to Discord.
⋮----
///     Whether to include general guild events. Note that you may receive empty message contents if you don&apos;t have the
///     message content intent.
///     &lt;para&gt;
///         These include &lt;see cref=&quot;DiscordClient.GuildCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.GuildDeleted&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildAvailable&quot; /&gt;, &lt;see cref=&quot;DiscordClient.GuildDownloadCompleted&quot; /&gt;,
///     &lt;/para&gt;
⋮----
///         &lt;see cref=&quot;DiscordClient.GuildRoleCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.GuildRoleUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildRoleDeleted&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.ChannelCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.ChannelUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.ChannelDeleted&quot; /&gt;, &lt;see cref=&quot;DiscordClient.ChannelPinsUpdated&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.StageInstanceCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.StageInstanceUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.StageInstanceDeleted&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.ThreadCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.ThreadUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.ThreadDeleted&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.ThreadListSynced&quot; /&gt;, &lt;see cref=&quot;DiscordClient.ThreadMemberUpdated&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.ThreadMembersUpdated&quot; /&gt;.
⋮----
///     Whether to include guild member events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.GuildMemberAdded&quot; /&gt;, &lt;see cref=&quot;DiscordClient.GuildMemberUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildMemberRemoved&quot; /&gt; and &lt;see cref=&quot;DiscordClient.ThreadMembersUpdated&quot; /&gt;.
⋮----
///     &lt;para&gt;This is a privileged intent, and must be enabled on the bot&apos;s developer page.&lt;/para&gt;
⋮----
///     Whether to include guild ban events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.GuildBanAdded&quot; /&gt;, &lt;see cref=&quot;DiscordClient.GuildBanRemoved&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.GuildAuditLogEntryCreated&quot; /&gt;.
⋮----
///     Whether to include guild expression events.
⋮----
///         This includes &lt;see cref=&quot;DiscordClient.GuildEmojisUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildStickersUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundCreated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundDeleted&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundsUpdated&quot; /&gt;.
⋮----
///     &lt;inheritdoc cref=&quot;GuildExpressions&quot; /&gt;.
⋮----
///     Whether to include guild integration events.
///     &lt;para&gt;This includes &lt;see cref=&quot;DiscordClient.GuildIntegrationsUpdated&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild webhook events.
///     &lt;para&gt;This includes &lt;see cref=&quot;DiscordClient.WebhooksUpdated&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild invite events.
///     &lt;para&gt;These include &lt;see cref=&quot;DiscordClient.InviteCreated&quot; /&gt; and &lt;see cref=&quot;DiscordClient.InviteDeleted&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild voice state events.
⋮----
///         This includes &lt;see cref=&quot;DiscordClient.VoiceStateUpdated&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.VoiceChannelEffectSend&quot; /&gt;.
⋮----
///     Whether to include guild presence events.
///     &lt;para&gt;This includes &lt;see cref=&quot;DiscordClient.PresenceUpdated&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild message events. Note that you may receive empty contents if you don&apos;t have the message
///     content intent.
///     You can enable it in the developer portal. If you have a verified bot, you might need to apply for the intent.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.MessageCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.MessageUpdated&quot; /&gt;, and
///         &lt;see cref=&quot;DiscordClient.MessageDeleted&quot; /&gt;.
⋮----
///     Whether to include guild reaction events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.MessageReactionAdded&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.MessageReactionRemoved&quot; /&gt;, &lt;see cref=&quot;DiscordClient.MessageReactionsCleared&quot; /&gt;
⋮----
///     &lt;para&gt;and &lt;see cref=&quot;DiscordClient.MessageReactionRemovedEmoji&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild typing events.
///     &lt;para&gt;These include &lt;see cref=&quot;DiscordClient.TypingStarted&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include general direct message events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.ChannelCreated&quot; /&gt;, &lt;see cref=&quot;DiscordClient.MessageCreated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.MessageUpdated&quot; /&gt;,
⋮----
///     &lt;para&gt;&lt;see cref=&quot;DiscordClient.MessageDeleted&quot; /&gt; and &lt;see cref=&quot;DiscordClient.ChannelPinsUpdated&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;These events only fire for DM channels.&lt;/para&gt;
⋮----
///     Whether to include direct message reaction events.
⋮----
///         &lt;see cref=&quot;DiscordClient.MessageReactionRemoved&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.MessageReactionsCleared&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.MessageReactionRemovedEmoji&quot; /&gt;.
⋮----
///     Whether to include direct message typing events.
///     &lt;para&gt;This includes &lt;see cref=&quot;DiscordClient.TypingStarted&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;This event only fires for DM channels.&lt;/para&gt;
⋮----
///     Whether to include the content of guild messages.
///     See https://support-dev.discord.com/hc/en-us/articles/4404772028055 for more information.
⋮----
///     Whether to include guild scheduled event events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.GuildScheduledEventCreated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildScheduledEventUpdated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.GuildScheduledEventDeleted&quot; /&gt;,
⋮----
///         &lt;see cref=&quot;DiscordClient.GuildScheduledEventUserAdded&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.GuildScheduledEventUserRemoved&quot; /&gt;.
⋮----
// TODO: What is intent 1&lt;&lt;17 - 1&lt;&lt;19?
⋮----
///     Whether to include automod configuration events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.AutomodRuleCreated&quot; /&gt;,
///         &lt;see cref=&quot;DiscordClient.AutomodRuleUpdated&quot; /&gt; and &lt;see cref=&quot;DiscordClient.AutomodRuleDeleted&quot; /&gt;.
⋮----
///     Whether to include automod execution events.
///     &lt;para&gt;These includes &lt;see cref=&quot;DiscordClient.AutomodActionExecuted&quot; /&gt;.&lt;/para&gt;
⋮----
///     Whether to include guild poll vote events.
⋮----
///         These include &lt;see cref=&quot;DiscordClient.MessagePollVoteAdded&quot; /&gt; and
///         &lt;see cref=&quot;DiscordClient.MessagePollVoteRemoved&quot; /&gt;.
⋮----
///     Whether to include direct message poll vote events.
⋮----
///     Includes all unprivileged intents.
⋮----
///         These are all intents excluding &lt;see cref=&quot;GuildMembers&quot; /&gt;, &lt;see cref=&quot;GuildPresences&quot; /&gt; and
///         &lt;see cref=&quot;MessageContent&quot; /&gt;.
⋮----
///     Includes all intents.
⋮----
///         The &lt;see cref=&quot;GuildMembers&quot; /&gt;, &lt;see cref=&quot;GuildPresences&quot; /&gt; and &lt;see cref=&quot;MessageContent&quot; /&gt; intents are
///         privileged, and must be enabled on the bot&apos;s developer page.
⋮----
///         The &lt;see cref=&quot;GuildMembers&quot; /&gt; and &lt;see cref=&quot;GuildPresences&quot; /&gt; intents are privileged, and must be enabled
///         on the bot&apos;s developer page.
⋮----
///     &lt;para&gt;The &lt;see cref=&quot;MessageContent&quot; /&gt; exist only in v10 and is not included here.&lt;/para&gt;</file><file path="DisCatSharp/Enums/Discord/DiscordShortlink.cs">/// &lt;summary&gt;
///     Discord short links.
/// &lt;/summary&gt;
public static class DiscordShortlink
⋮----
///     Gets the shortlink to the support site.
⋮----
public static readonly string Support = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/support&quot;;
⋮----
///     Gets the shortlink to the support site for trust and safety.
⋮----
public static readonly string TrustAndSafety = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/request&quot;;
⋮----
///     Gets the shortlink to the contact form.
⋮----
public static readonly string Contact = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/contact&quot;;
⋮----
///     Gets the shortlink to the bug report form.
⋮----
public static readonly string BugReport = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/bugreport&quot;;
⋮----
///     Gets the shortlink to the translation error form.
⋮----
public static readonly string TranslationError = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/lang-feedback&quot;;
⋮----
///     Gets the shortlink to the stauts site.
⋮----
public static readonly string Status = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/status&quot;;
⋮----
///     Gets the shortlink to the terms of service.
⋮----
public static readonly string Terms = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/terms&quot;;
⋮----
///     Gets the shortlink to the guidelines.
⋮----
public static readonly string Guidelines = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/guidelines&quot;;
⋮----
///     Gets the shortlinkt to DMA.
⋮----
public static readonly string Moderation = $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordMarketing).Url}/moderation&quot;;</file><file path="DisCatSharp/Enums/Discord/GatewayCompressionLevel.cs">/// &lt;summary&gt;
///     Determines at which level should the WebSocket traffic be compressed.
/// &lt;/summary&gt;
⋮----
///     Defines that traffic should not be compressed at all.
⋮----
///     Defines that traffic should be compressed at payload level.
⋮----
///     Defines that entire traffic stream should be compressed.</file><file path="DisCatSharp/Enums/Discord/OAuth.cs">// ReSharper disable InconsistentNaming
⋮----
/// &lt;summary&gt;
///     The oauth scopes.
/// &lt;/summary&gt;
public static class OAuth
⋮----
///     The default scopes for bots.
⋮----
private const string BOT_DEFAULT = &quot;bot applications.commands&quot;; // applications.commands.permissions.update
⋮----
///     The bot minimal scopes.
⋮----
///     The bot only scope.
⋮----
///     The basic identify scopes.
⋮----
///     The extended identify scopes.
⋮----
///     The role connection scope.
⋮----
///     All scopes for bots and identify.
⋮----
///     Resolves the scopes.
⋮----
/// &lt;param name=&quot;scope&quot;&gt;The scope.&lt;/param&gt;
/// &lt;returns&gt;A string representing the scopes.&lt;/returns&gt;
public static string ResolveScopes(OAuthScopes scope) =&gt;
⋮----
///     Scopes: bot applications.commands (Excluding applications.commands.permissions.update for now)
⋮----
///     Scopes: bot applications.commands
⋮----
///     Scopes: bot
⋮----
///     Scopes: identify email
⋮----
///     Scopes: identify email guilds connections
⋮----
///     Scopes: bot applications.commands applications.commands.permissions.update identify email guilds connections
///     role_connections.write
⋮----
///     Scopes: role_connections.write</file><file path="DisCatSharp/Enums/Discord/TokenType.cs">/// &lt;summary&gt;
///     Represents the token type
/// &lt;/summary&gt;
⋮----
///     Bot token type
⋮----
///     Bearer token type (used for oAuth)</file><file path="DisCatSharp/Enums/Guild/AuditLogActionCategory.cs">/// &lt;summary&gt;
///     Indicates audit log action category.
/// &lt;/summary&gt;
⋮----
///     Indicates that this action resulted in creation or addition of an object.
⋮----
///     Indicates that this action resulted in update of an object.
⋮----
///     Indicates that this action resulted in deletion or removal of an object.
⋮----
///     Indicates that this action resulted in something else than creation, addition, update, deletion, or removal of an
///     object.</file><file path="DisCatSharp/Enums/Guild/Automod/AutomodActionType.cs">/// &lt;summary&gt;
///     Represent&apos;s a rule&apos;s action type.
/// &lt;/summary&gt;
⋮----
///     Blocks the content of a message according to the rule.
⋮----
///     Logs user to a specified channel.
⋮----
///     Timeout user for a specified duration.
///     Only valid for Keyword and MentionSpam rules</file><file path="DisCatSharp/Enums/Guild/Automod/AutomodEventType.cs">/// &lt;summary&gt;
///     Represent&apos;s a rule&apos;s flags.
/// &lt;/summary&gt;
⋮----
///     Indicates that this rule should be checked when a member sends or edits a message in the guild.</file><file path="DisCatSharp/Enums/Guild/Automod/AutomodKeywordPresetType.cs">/// &lt;summary&gt;
///     Represents a rule&apos;s keyword preset types.
/// &lt;/summary&gt;
⋮----
///     Words that may be considered forms of swearing or cursing.
⋮----
///     Words that refer to sexually explicit behavior or activity.
⋮----
///     Personal insults or words that may be considered hate speech.</file><file path="DisCatSharp/Enums/Guild/Automod/AutomodTriggerType.cs">/// &lt;summary&gt;
///     Represents a rule&apos;s content type.
/// &lt;/summary&gt;
⋮----
///     Checks if content contains words from a user defined list of keywords.
///     Max. 3 per guild.
⋮----
///     Checks if content contains a suspicious link.
⋮----
///     Checks if content represents generic spam.
///     Max. 1 per guild.
⋮----
///     Checks if content contains words from internal pre-defined wordsets.
⋮----
///     Checks if content contains more unique mentions than allowed.
⋮----
///     Flag messages that may break server rules using OpenAI technology.</file><file path="DisCatSharp/Enums/Guild/BannerType.cs"></file><file path="DisCatSharp/Enums/Guild/DefaultMessageNotifications.cs">/// &lt;summary&gt;
///     Represents default notification level for a guild.
/// &lt;/summary&gt;
⋮----
///     All messages will trigger push notifications.
⋮----
///     Only messages that mention the user (or a role he&apos;s in) will trigger push notifications.</file><file path="DisCatSharp/Enums/Guild/ExplicitContentFilter.cs">/// &lt;summary&gt;
///     Represents the value of explicit content filter in a guild.
/// &lt;/summary&gt;
⋮----
///     Explicit content filter is disabled.
⋮----
///     Only messages from members without any roles are scanned.
⋮----
///     Messages from all members are scanned.</file><file path="DisCatSharp/Enums/Guild/GuildProfileVisibility.cs">/// &lt;summary&gt;
///    Represents the visibility of a guild profile.
/// &lt;/summary&gt;
⋮----
///    Not specified visibility.
⋮----
///    Public visibility.
⋮----
///    Restricted visibility.
⋮----
///    Public with recruitment enabled.</file><file path="DisCatSharp/Enums/Guild/HubType.cs">/// &lt;summary&gt;
///     Represents a guilds hub type.
/// &lt;/summary&gt;
⋮----
///     Indicates that the hub is a default one.
⋮----
///     Indicates that the hub is a high school.
⋮----
///     Indicates that the hub is a college.</file><file path="DisCatSharp/Enums/Guild/JoinRequestStatusType.cs">/// &lt;summary&gt;
///     Represents a join request status type.
/// &lt;/summary&gt;
⋮----
///     Indicates that the request status is unknown.
⋮----
///     Indicates that the request was submitted.
⋮----
///     Indicates that the request was approved.
⋮----
///     Indicates that the request was rejected.</file><file path="DisCatSharp/Enums/Guild/MembershipScreeningFieldType.cs">/// &lt;summary&gt;
///     Represents a membership screening field type.
/// &lt;/summary&gt;
⋮----
///     Specifies the server rules
⋮----
///     Specifies a text input question.
⋮----
///     Specifies a paragraph question.
⋮----
///     Specifies a multiple choice question.</file><file path="DisCatSharp/Enums/Guild/MfaLevel.cs">/// &lt;summary&gt;
///     Represents multi-factor authentication level required by a guild to use administrator functionality.
/// &lt;/summary&gt;
⋮----
///     Multi-factor authentication is not required to use administrator functionality.
⋮----
///     Multi-factor authentication is required to use administrator functionality.</file><file path="DisCatSharp/Enums/Guild/NsfwLevel.cs">// ReSharper disable InconsistentNaming
⋮----
/// &lt;summary&gt;
///     Represents a guild&apos;s content level.
/// &lt;/summary&gt;
⋮----
///     Indicates the guild has no special NSFW level.
⋮----
///     Indicates the guild has extremely suggestive or mature content that would only be suitable for users over 18
⋮----
///     Indicates the guild has no content that could be deemed NSFW. It is SFW.
⋮----
///     Indicates the guild has mildly NSFW content that may not be suitable for users under 18.
⋮----
/// &lt;inheritdoc cref=&quot;AgeRestricted&quot; /&gt;</file><file path="DisCatSharp/Enums/Guild/Onboarding/NewMemberActionType.cs">/// &lt;summary&gt;
///     Represents the new member action type for the server guide.
/// &lt;/summary&gt;
⋮----
///     The member needs to visit the channel.
⋮----
///     The member sends a message in the channel.</file><file path="DisCatSharp/Enums/Guild/Onboarding/OnboardingMode.cs">/// &lt;summary&gt;
///     Represents the onboarding mode.
/// &lt;/summary&gt;
⋮----
///     Counts only Default Channels towards constraints.
⋮----
///     Counts Default Channels and Questions towards constraints.</file><file path="DisCatSharp/Enums/Guild/Onboarding/PromptType.cs">/// &lt;summary&gt;
///     Represents the prompt types for onboarding.
/// &lt;/summary&gt;
⋮----
///     The prompt type is multiple choice.
⋮----
///     The prompt type is a dropdown.</file><file path="DisCatSharp/Enums/Guild/PlayStyle.cs">/// &lt;summary&gt;
///     Represents the play style of a guild.
/// &lt;/summary&gt;
⋮----
///     Social play style.
⋮----
///     Casual play style.
⋮----
///     Competitive play style.
⋮----
///     Creative play style.
⋮----
///     Very hardcore play style.</file><file path="DisCatSharp/Enums/Guild/PremiumTier.cs">/// &lt;summary&gt;
///     Represents a server&apos;s premium tier.
/// &lt;/summary&gt;
⋮----
///     Indicates that this server was not boosted.
⋮----
///     Indicates that this server was boosted two times.
⋮----
///     Indicates that this server was boosted seven times.
⋮----
///     Indicates that this server was boosted fourteen times.
⋮----
///     Indicates an unknown premium tier.</file><file path="DisCatSharp/Enums/Guild/PriceTierType.cs">/// &lt;summary&gt;
///     Represents a price tier type.
/// &lt;/summary&gt;
⋮----
///     Indicates that this is a role subscription.</file><file path="DisCatSharp/Enums/Guild/RoleFlags.cs">/// &lt;summary&gt;
///     Represents additional details of a role.
/// &lt;/summary&gt;
⋮----
///     This role has no flags.
⋮----
///     This role is in a prompt.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Guild/RoleType.cs">/// &lt;summary&gt;
///     Represents the classification of a Discord role.
/// &lt;/summary&gt;
⋮----
///     The role type is unknown.
⋮----
///     A bot or application role.
⋮----
///     A booster role.
⋮----
///     A server product role.
⋮----
///     A premium subscriber role.
⋮----
///     A premium subscriber tier role.
⋮----
///     A premium subscriber tier draft role.
⋮----
///     A role linked to an external platform (e.g., Twitch or YouTube).
⋮----
///     Either an external platform or premium subscriber role. Discord made it harder to distinguish..
⋮----
///     A role connection role.</file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleFrequency.cs">/// &lt;summary&gt;
///     Represents the frequency of a scheduled event&apos;s recurrence.
/// &lt;/summary&gt;
⋮----
///     The scheduled event repeats yearly.
⋮----
///     The scheduled event repeats monthly.
⋮----
///     The scheduled event repeats weekly.
⋮----
///     The scheduled event repeats daily.</file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/RecurrenceRuleWeekday.cs">/// &lt;summary&gt;
///     Represents the days of the week for scheduling recurrent events.
/// &lt;/summary&gt;
⋮----
///     The scheduled event repeats on mondays.
⋮----
///     The scheduled event repeats tuesdays.
⋮----
///     The scheduled event repeats wednesdays.
⋮----
///     The scheduled event repeats thursdays.
⋮----
///     The scheduled event repeats fridays.
⋮----
///     The scheduled event repeats saturdays.
⋮----
///     The scheduled event repeats sundays.</file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventEntityType.cs">/// &lt;summary&gt;
///     Represents the entity type for a scheduled event.
/// &lt;/summary&gt;
⋮----
///     Indicates that the events is hold in a stage instance.
⋮----
///     Indicates that the events is hold in a voice channel.
⋮----
///     Indicates that the events is hold external.
⋮----
///     Unknown.</file><file path="DisCatSharp/Enums/Guild/ScheduledEvent/ScheduledEventStatus.cs">/// &lt;summary&gt;
///     Represents the status for a scheduled event.
/// &lt;/summary&gt;
⋮----
///     Indicates that the event is scheduled.
⋮----
///     Indicates that the event is active.
⋮----
///     Indicates that the event is completed.
⋮----
///     Indicates that the event is canceled.</file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ForumLayout.cs">/// &lt;summary&gt;
///     Represents the layout for posts in a forum channel.
/// &lt;/summary&gt;
⋮----
///     Forum channel will use default layout settings.
⋮----
///     Forum channel will display posts in a list layout.
⋮----
///     Forum channel will display posts in a grid layout.</file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ForumPostSortOrder.cs">/// &lt;summary&gt;
///     Represents the default sort order for posts in a forum channel.
/// &lt;/summary&gt;
⋮----
///     Sort forum posts by activity.
⋮----
///     Sort forum posts by creation time (from most recent to oldest).</file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ThreadAutoArchiveDuration.cs">/// &lt;summary&gt;
///     Represents the auto-archive duration for a thread.
/// &lt;/summary&gt;
⋮----
///     Indicates that the thread will be auto archived after one hour.
⋮----
///     Indicates that the thread will be auto archived after one day / 24 hours.
⋮----
///     Indicates that the thread will be auto archived after three days.
⋮----
///     Indicates that the thread will be auto archived after a week.</file><file path="DisCatSharp/Enums/Guild/ThreadAndForum/ThreadMemberFlags.cs">/// &lt;summary&gt;
///     Represents notification settings for a thread.
/// &lt;/summary&gt;
⋮----
///     Indicates that the notification setting is set to has interacted.
⋮----
///     Indicates that the notification setting is set to all messages.
⋮----
///     Indicates that the notification setting is set to only mentions.
⋮----
///     Indicates that the notification setting is set to none.</file><file path="DisCatSharp/Enums/Guild/VerificationLevel.cs">/// &lt;summary&gt;
///     Represents guild verification level.
/// &lt;/summary&gt;
⋮----
///     No verification. Anyone can join and chat right away.
⋮----
///     Low verification level. Users are required to have a verified email attached to their account in order to be able
///     to chat.
⋮----
///     Medium verification level. Users are required to have a verified email attached to their account, and account age
///     need to be at least 5 minutes in order to be able to chat.
⋮----
///     High verification level. Users are required to have a verified email attached to their account, account age need to
///     be at least 5 minutes, and they need to be in the server for at least 10 minutes in order to be able to chat.
⋮----
///     Highest verification level. Users are required to have a verified phone number attached to their account.</file><file path="DisCatSharp/Enums/Guild/WidgetType.cs">/// &lt;summary&gt;
///     Represents the formats for a guild widget.
/// &lt;/summary&gt;
⋮----
///     The widget is represented in shield format.
///     &lt;para&gt;This is the default widget type.&lt;/para&gt;
⋮----
///     The widget is represented as the first banner type.
⋮----
///     The widget is represented as the second banner type.
⋮----
///     The widget is represented as the third banner type.
⋮----
///     The widget is represented in the fourth banner type.</file><file path="DisCatSharp/Enums/Integration/IntegrationExpireBehavior.cs">/// &lt;summary&gt;
///     Represents the integration expire behavior.
/// &lt;/summary&gt;
⋮----
///     Removes the role from the member.
⋮----
///     Kicks the member.</file><file path="DisCatSharp/Enums/Interaction/ButtonStyle.cs">/// &lt;summary&gt;
///     Represents a button&apos;s style/color.
/// &lt;/summary&gt;
⋮----
///     Blurple button.
⋮----
///     Grey button.
⋮----
///     Green button.
⋮----
///     Red button.
⋮----
///     Link button.
⋮----
///     Premium button.</file><file path="DisCatSharp/Enums/Interaction/IFrameModalSize.cs">/// &lt;summary&gt;
///     Represents an iFrame&apos;s size.
/// &lt;/summary&gt;
⋮----
///     Sends a small iFrame.
⋮----
///     Sends a normal iFrame.
⋮----
///     Sends a big iFrame.</file><file path="DisCatSharp/Enums/Interaction/InteractionCallbackEphemerality.cs">/// &lt;summary&gt;
///     Represents the ephemerality of an interaction callback.
/// &lt;/summary&gt;
⋮----
///     The ephemerality is optional.
⋮----
///     The ephemerality is required.</file><file path="DisCatSharp/Enums/Interaction/InteractionContextType.cs">/// &lt;summary&gt;
///     Represents the interaction context type.
/// &lt;/summary&gt;
⋮----
///     Command can be used in guilds.
⋮----
///     Command can be used in direct messages with the bot.
⋮----
///     Command can be used in group direct messages and direct messages.</file><file path="DisCatSharp/Enums/Interaction/InteractionResponseType.cs">/// &lt;summary&gt;
///     Represents the type of interaction response
/// &lt;/summary&gt;
⋮----
///     Acknowledges a Ping.
⋮----
///     Responds to the interaction with a message.
⋮----
///     Acknowledges an interaction to edit to a response later. The user sees a &quot;thinking&quot; state.
⋮----
///     Acknowledges a component interaction to allow a response later.
⋮----
///     Responds to a component interaction by editing the message it&apos;s attached to.
⋮----
///     Responds to an auto-complete request.
⋮----
///     Responds to the interaction with a modal.
⋮----
///     &lt;para&gt;Responds to the interaction with a message indicating that a premium subscription is required.&lt;/para&gt;
///     &lt;para&gt;
///         &lt;note type=&quot;warning&quot;&gt;Can only be used if you have an associated application subscription sku.&lt;/note&gt;
///     &lt;/para&gt;
⋮----
///         &lt;note type=&quot;warning&quot;&gt;
///             Deprecated. Create normal response instead and use
///             &lt;see cref=&quot;DiscordPremiumButtonComponent&quot; /&gt; with target sku id.
///         &lt;/note&gt;
⋮----
///     &lt;para&gt;Responds to the interaction with an iframe.&lt;/para&gt;
⋮----
///         &lt;note type=&quot;warning&quot;&gt;Can only be used if you are whitelisted..&lt;/note&gt;
⋮----
///     &lt;para&gt;Launch the Activity associated with the app.&lt;/para&gt;
⋮----
///         &lt;note type=&quot;warning&quot;&gt;Can only be used if the app has activities enabled.&lt;/note&gt;</file><file path="DisCatSharp/Enums/Interaction/InteractionType.cs">/// &lt;summary&gt;
///     Represents the type of interaction used.
/// &lt;/summary&gt;
⋮----
///     Sent when registering an HTTP interaction endpoint with Discord. Must be replied to with a Pong.
⋮----
///     An application command.
⋮----
///     A component.
⋮----
///     An autocomplete field.
⋮----
///     A modal component.</file><file path="DisCatSharp/Enums/Interaction/SeparatorSpacingSize.cs">/// &lt;summary&gt;
///     Represents the sperator spacing size of a &lt;see cref=&quot;DisCatSharp.Entities.DiscordSeparatorComponent&quot; /&gt;.
/// &lt;/summary&gt;
⋮----
///     A small spacing size.
⋮----
///     A large spacing size.</file><file path="DisCatSharp/Enums/Interaction/TextComponentStyle.cs">/// &lt;summary&gt;
///     Represents a button&apos;s style/color.
/// &lt;/summary&gt;
⋮----
///     A small text input.
⋮----
///     A paragraph text input.</file><file path="DisCatSharp/Enums/Invite/InviteFlags.cs">/// &lt;summary&gt;
///     Represents a invite flag extensions.
/// &lt;/summary&gt;
public static class InviteFlagExtensions
⋮----
///     Calculates whether these invite flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasInviteFlag(this InviteFlags baseFlags, InviteFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Invite has no flags
⋮----
/// &lt;inheritdoc cref=&quot;IsGuestInvite&quot; /&gt;
⋮----
///     Invite grants temporary guest membership.
///     All channels but the one invited to are hidden and user gets kicked if they leave the voice.
⋮----
///     The invite has been viewed by any user (has been retrieved using the get invite endpoint).
⋮----
///     Invite is enhanced.
⋮----
///     Invite bypasses a guild application.
⋮----
///      The flags are unknown.
⋮----
//AssignableFlagsMask = 9</file><file path="DisCatSharp/Enums/Invite/InviteType.cs">/// &lt;summary&gt;
///     Represents the invite type .
/// &lt;/summary&gt;
⋮----
///     Represents a guild invite.
⋮----
///     Represents a group dm invite.
⋮----
///     Represents a friend invite.</file><file path="DisCatSharp/Enums/Invite/TargetType.cs">/// &lt;summary&gt;
///     Represents the invite type .
/// &lt;/summary&gt;
⋮----
///     Represents a streaming invite.
⋮----
///     Represents a stream invite.
⋮----
///     Represents a activity invite.
⋮----
///     Represents a role subscription invite.
///     Not creatable by bots.
⋮----
///     Represents a promo page generated invite.
///     Not creatable, system generated.</file><file path="DisCatSharp/Enums/Message/LoadingState.cs">/// &lt;summary&gt;
///     Represents the loading state of a URL media resource.
/// &lt;/summary&gt;
⋮----
///     The loading state is unknown.
⋮----
///     The resource is currently loading.
⋮----
///     The resource has successfully loaded.
⋮----
///     The resource was not found.</file><file path="DisCatSharp/Enums/Message/MentionType.cs">/// &lt;summary&gt;
///     Type of mention being made
/// &lt;/summary&gt;
⋮----
///     No mention (wtf?)
⋮----
///     Mentioned Username
⋮----
///     Mentioned Nickname
⋮----
///     Mentioned Channel
⋮----
///     Mentioned Role</file><file path="DisCatSharp/Enums/Message/MessageActivityType.cs">/// &lt;summary&gt;
///     Indicates the type of MessageActivity for the Rich Presence.
/// &lt;/summary&gt;
⋮----
///     Invites the user to join.
⋮----
///     Invites the user to spectate.
⋮----
///     Invites the user to listen.
⋮----
///     Allows the user to request to join.</file><file path="DisCatSharp/Enums/Message/MessageFlags.cs">/// &lt;summary&gt;
///     Represents a message flag extensions.
/// &lt;/summary&gt;
public static class MessageFlagExtensions
⋮----
///     Calculates whether these message flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasMessageFlag(this MessageFlags baseFlags, MessageFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents additional features of a message.
⋮----
///     This message has no flags.
⋮----
///     Whether this message is the original message that was published from a news channel to subscriber channels.
⋮----
///     Whether this message is crossposted (automatically posted in a subscriber channel).
⋮----
///     Whether any embeds in the message are hidden.
⋮----
///     The source message for this crosspost has been deleted.
⋮----
///     The message came from the urgent message system.
⋮----
///     The message has an associated thread, with the same id as the message.
⋮----
///     The message is only visible to the user who invoked the interaction.
⋮----
///     The message is an interaction response and the bot is &quot;thinking&quot;.
⋮----
///     The message is warning that some roles failed to mention in thread.
⋮----
///     The message is indicating that the feed is hidden.
⋮----
///     The message contains a link marked as potential dangerous or absusive.
⋮----
///     The message suppresses channel notifications.
///     Aka. new message indicator.
⋮----
///     The message is a voice message.
⋮----
///     The message has a snapshot (via Message Forwarding).
⋮----
///     The message uses the UI Kit.
⋮----
///     The message was send by a social layer integration.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Message/PollLayoutType.cs">/// &lt;summary&gt;
///     Represents the layout type of a poll.
/// &lt;/summary&gt;
⋮----
///     The default layout type.
⋮----
///     Poll answers are images only.</file><file path="DisCatSharp/Enums/Message/ReferenceType.cs">/// &lt;summary&gt;
///     Represents the message reference type.
/// &lt;/summary&gt;
⋮----
///     A standard reference used by replies.
⋮----
///     Reference used to point to a message at a point in time.</file><file path="DisCatSharp/Enums/Message/TimestampFormat.cs">/// &lt;summary&gt;
///     Denotes the type of formatting to use for timestamps.
/// &lt;/summary&gt;
⋮----
///     A short date. e.g. 18/06/2021.
⋮----
///     A long date. e.g. 18 June 2021.
⋮----
///     A short date and time. e.g. 18 June 2021 03:50.
⋮----
///     A long date and time. e.g. Friday 18 June 2021 03:50.
⋮----
///     A short time. e.g. 03:50.
⋮----
///     A long time. e.g. 03:50:15.
⋮----
///     The time relative to the client. e.g. An hour ago.</file><file path="DisCatSharp/Enums/Message/UnfurledMediaFlags.cs">/// &lt;summary&gt;
///     Represents a unfurled media flag extensions.
/// &lt;/summary&gt;
public static class UnfurledMediaFlagExtensions
⋮----
///     Calculates whether these unfurled media flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasUnfurledMediaFlag(this UnfurledMediaFlags baseFlags, UnfurledMediaFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents additional features of unfurled media.
⋮----
///     This unfurled media has no flags.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Store/EntitlementOwnerType.cs">/// &lt;summary&gt;
///     Represents the test entitlement owner type.
/// &lt;/summary&gt;
⋮----
///     Owner id is a guild.
⋮----
///     Owner id is an user.</file><file path="DisCatSharp/Enums/Store/EntitlementType.cs">/// &lt;summary&gt;
///     Represents the entitlement type.
/// &lt;/summary&gt;
⋮----
///     Entitlement was purchased by user.
⋮----
///     Entitlement for Discord Nitro subscription.
⋮----
///     Entitlement was gifted by developer.
⋮----
///     Entitlement was purchased by a dev in application test mode.
⋮----
///     Entitlement was granted when the SKU was free.
⋮----
///     Entitlement was gifted by another user.
⋮----
///     Entitlement was claimed by user for free as a Nitro Subscriber.
⋮----
///     Entitlement was purchased as an app subscription.
⋮----
///     Entitlement was granted to staff for free.
⋮----
///     Entitlement was granted as a reward for completing a quest.
⋮----
///     Entitlement was redeemed fractionally.
⋮----
///     Entitlement was redeemed using virtual currency.</file><file path="DisCatSharp/Enums/Store/ProductLine.cs">/// &lt;summary&gt;
///     Represents the product line.
/// &lt;/summary&gt;
⋮----
///     Premium product line.
⋮----
///     Boost product line.
⋮----
///     In-app purchase activity product line.
⋮----
///     Guild role product line.
⋮----
///     Guild product line.
⋮----
///     Application product line.
⋮----
///     Collectibles product line.</file><file path="DisCatSharp/Enums/Store/SkuAccessType.cs">/// &lt;summary&gt;
///     Represents the sku access type.
/// &lt;/summary&gt;
⋮----
///     User has full access.
⋮----
///     User has early access.
⋮----
///     Users has vip access.</file><file path="DisCatSharp/Enums/Store/SkuFlags.cs">/// &lt;summary&gt;
///     Represents a sku flag extensions.
/// &lt;/summary&gt;
public static class SkuFlagExtensions
⋮----
///     Calculates whether these sku flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasSkuFlag(this SkuFlags baseFlags, SkuFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents sku flags.
⋮----
///     Whether the SKU is a premium purchase.
⋮----
///     Whether the SKU is free premium content.
⋮----
///     Whether the SKU is available for purchase.
⋮----
///     Whether the SKU is a premium or distribution product.
⋮----
///     Whether the SKU is a premium sticker pack.
⋮----
///     Whether the SKU is a guild role subscription. These are subscriptions made to guilds for premium perks.
⋮----
///     Whether the SKU is a Discord premium subscription or related first-party product.
///     These are subscriptions like Nitro and Server Boosts. These are the only giftable subscriptions.
⋮----
///     Whether the SKU is a application subscription. These are subscriptions made to applications for premium perks bound
///     to a guild.
⋮----
///     to a user.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Store/SkuType.cs">/// &lt;summary&gt;
///     Represents the sku type.
/// &lt;/summary&gt;
⋮----
///     An application sku.
⋮----
///     Durable one-time purchase.
⋮----
///     Consumable one-time purchase.
⋮----
///     A bundle sku.
⋮----
///     Represents a recurring subscription.
⋮----
///     System-generated group for each SUBSCRIPTION SKU created .</file><file path="DisCatSharp/Enums/Store/SubscriptionStatus.cs">/// &lt;summary&gt;
///     Represents the subscription.
/// &lt;/summary&gt;
⋮----
///     Subscription is active.
⋮----
///     Subscription is ending.
⋮----
///     Subscription is inactive.</file><file path="DisCatSharp/Enums/User/ConnectionMetadataVisibilityType.cs">/// &lt;summary&gt;
///     The metadata visibility type of user account connections.
/// &lt;/summary&gt;
⋮----
///     This connections metadata is only visible to the owning user.
⋮----
///     This connections metadata is visible to everyone.</file><file path="DisCatSharp/Enums/User/ConnectionVisibilityType.cs">/// &lt;summary&gt;
///     The visibility type of user account connections.
/// &lt;/summary&gt;
⋮----
///     This connection type is only visible to the owning user.
⋮----
///     This connection is visible to everyone.</file><file path="DisCatSharp/Enums/User/PremiumType.cs">/// &lt;summary&gt;
///     The type of Nitro subscription on a user&apos;s account.
/// &lt;/summary&gt;
⋮----
///     User does not have any perks.
⋮----
///     Includes basic app perks like animated emojis and avatars.
⋮----
///     Includes all app perks.
⋮----
///     Includes basic app perks.</file><file path="DisCatSharp/Enums/User/UserFlags.cs">/// &lt;summary&gt;
///     Represents additional details of a users account.
/// &lt;/summary&gt;
⋮----
///     The user has no flags.
⋮----
///     The user is a Discord employee.
⋮----
///     The user is a Discord partner.
⋮----
///     The user has the HypeSquad badge.
⋮----
///     The user reached the first bug hunter tier.
⋮----
///     The user has SMS recovery for 2FA enabled.
⋮----
///     The user is marked as dismissed Nitro promotion
⋮----
///     The user is a member of house bravery.
⋮----
///     The user is a member of house brilliance.
⋮----
///     The user is a member of house balance.
⋮----
///     The user has the early supporter badge.
⋮----
///     User is a &lt;see cref=&quot;Entities.DiscordTeam&quot; /&gt;.
⋮----
///    User is registered on Discord&apos;s HubSpot customer platform, used for official Discord programs (e.g. partner).
⋮----
///     Whether the user is an official system user.
⋮----
///     Whether the user has unread system messages.
⋮----
///     The user reached the second bug hunter tier.
⋮----
///     The user has a pending deletion for being underage in DOB prompt.
⋮----
///     The user is a verified application.
⋮----
///     The user is a verified bot developer.
⋮----
///     The user is a discord certified moderator.
⋮----
///     The user is a bot and has set an interactions endpoint url.
⋮----
///     The user is disabled for being a spammer.
⋮----
///     Nitro is disabled for user.
///     Used by discord staff instead of forcedNonPremium.
⋮----
///     User is an active developer.
///     Read more here: https://support-dev.discord.com/hc/articles/10113997751447.
⋮----
///     The user is a provisional account used with the social layer integration.
⋮----
///     Account has a high global ratelimit.
⋮----
///     Account has been deleted.
⋮----
///     Account has been disabled for suspicious activity.
⋮----
///     Account was deleted by the user.
⋮----
///     The user has a premium discriminator.
⋮----
///     The user has used the desktop client.
⋮----
///     The user has used the web client.
⋮----
///     The user has used the mobile client.
⋮----
///     The user is currently temporarily or permanently disabled.
⋮----
///     The user has started at least one Gateway session and is now eligible to send messages.
⋮----
///     The user is currently quarantined.
///     The user can&apos;t start new dms and join servers.
///     The user has to appeal via https://dis.gd/appeal.
⋮----
///     The user is eligible for early access to pomelo migration.
⋮----
///     User is a collaborator and has staff permissions.
⋮----
///     User is a restricted collaborator and has staff permissions.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/VersionCheckMode.cs">/// &lt;summary&gt;
///     Represents the version check mode.
/// &lt;/summary&gt;
⋮----
///     Checks for updates on GitHub.
⋮----
///     Checks for updates on NuGet.</file><file path="DisCatSharp/Enums/Voice/AnimationType.cs">/// &lt;summary&gt;
///     Represents a animation type for voice channel effects.
/// &lt;/summary&gt;
⋮----
///     A fun animation, sent by a Nitro subscriber.
⋮----
///     The standard animation.</file><file path="DisCatSharp/Enums/Voice/SpeakingFlags.cs">/// &lt;summary&gt;
///     Represents a speaking flag extensions.
/// &lt;/summary&gt;
public static class SpeakingFlagExtensions
⋮----
///     Calculates whether these speaking flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasSpeakingFlag(this SpeakingFlags baseFlags, SpeakingFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Not speaking.
⋮----
///     Normal transmission of voice audio.
⋮----
///     Transmission of context audio for video, no speaking indicator.
⋮----
///     Priority speaker, lowering audio of other speakers.
⋮----
///     Currently unknown, but likely indicates that the user is not visible in the channel.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/EventArgs/Application/ApplicationCommandEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for application command events.
/// &lt;/summary&gt;
public sealed class ApplicationCommandEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the command that was modified.
⋮----
///     Gets the optional guild of the command.</file><file path="DisCatSharp/EventArgs/Application/ApplicationCommandPermissionsUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for application command permissions update events.
/// &lt;/summary&gt;
public sealed class ApplicationCommandPermissionsUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandPermissionsUpdateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the application command permissions.
⋮----
///     Gets the application command.
⋮----
///     Gets the application id.
⋮----
///     Gets the guild.</file><file path="DisCatSharp/EventArgs/Application/GuildApplicationCommandCountEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for application command events.
/// &lt;/summary&gt;
public sealed class GuildApplicationCommandCountEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildApplicationCommandCountEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the count of slash commands.
⋮----
///     Gets the count of user context menu commands.
⋮----
///     Gets the count of message context menu commands.
⋮----
///     Gets the guild.</file><file path="DisCatSharp/EventArgs/Channel/ChannelCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ChannelCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ChannelCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the channel that was created.
⋮----
///     Gets the guild in which the channel was created.</file><file path="DisCatSharp/EventArgs/Channel/ChannelDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ChannelDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class ChannelDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the channel that was deleted.
⋮----
///     Gets the guild this channel belonged to.</file><file path="DisCatSharp/EventArgs/Channel/ChannelPinsUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ChannelPinsUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ChannelPinsUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelPinsUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets the channel in which the update occurred.
⋮----
///     Gets the timestamp of the latest pin.</file><file path="DisCatSharp/EventArgs/Channel/ChannelUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ChannelUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ChannelUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the post-update channel.
⋮----
///     Gets the pre-update channel.
⋮----
///     Gets the guild in which the update occurred.</file><file path="DisCatSharp/EventArgs/Channel/DMChannelDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.DmChannelDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class DmChannelDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DmChannelDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the direct message channel that was deleted.</file><file path="DisCatSharp/EventArgs/Channel/VoiceChannelStatusUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.VoiceChannelStatusUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class VoiceChannelStatusUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceChannelStatusUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets the channel in which the update occurred.
⋮----
///     Gets the new status.</file><file path="DisCatSharp/EventArgs/ClientErrorEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ClientErrored&quot; /&gt; event.
/// &lt;/summary&gt;
public class ClientErrorEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ClientErrorEventArgs&quot; /&gt; class.
⋮----
///     Gets the exception thrown by the client.
⋮----
///     Gets the name of the event that threw the exception.</file><file path="DisCatSharp/EventArgs/DiscordEventArgs.cs">// Note: this might seem useless, but should we ever need to add a common property or method to all event arg
// classes, it would be useful to already have a base for all of it.
⋮----
/// &lt;summary&gt;
///     Common base for all other &lt;see cref=&quot;DiscordClient&quot; /&gt;-related event argument classes.
/// &lt;/summary&gt;
public abstract class DiscordEventArgs : AsyncEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEventArgs&quot; /&gt; class.
⋮----
this.ServiceProvider = provider.CreateScope().ServiceProvider;
⋮----
///     &lt;para&gt;Gets the service provider.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to an empty service provider.&lt;/para&gt;
⋮----
public IServiceProvider ServiceProvider { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);</file><file path="DisCatSharp/EventArgs/EmbeddedActivityUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.EmbeddedActivityUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class EmbeddedActivityUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;EmbeddedActivityUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild.
⋮----
///     Gets the channel.
⋮----
///     Gets the embedded activity.
⋮----
///     Gets the users in the activity.</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodActionExecutedEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.AutomodActionExecuted&quot; /&gt; event.
/// &lt;/summary&gt;
public class AutomodActionExecutedEventArgs : DiscordEventArgs
⋮----
///     The guild associated with this event.
⋮----
///     The action that was executed.
⋮----
///     The id of the rule the action belongs to.
⋮----
///     The type of trigger of the rule which was executed.
⋮----
///     The member which caused this event.
⋮----
=&gt; this.Guild.Members.TryGetValue(this.UserId, out var member) ? member : this.Guild.GetMemberAsync(this.UserId, true).Result;
⋮----
///     The user id which caused this event.
⋮----
public DiscordChannel? Channel =&gt; this.ChannelId.HasValue ? this.Guild.GetChannel(this.ChannelId.Value) : null;
⋮----
///     Fall-back channel id this event happened in.
⋮----
///     The id of any user message the content belongs to.
///     This will not exist if the message was blocked or content was not part of message.
⋮----
///     The id of any system auto moderation messages posted as a result of this action.
///     This will not exist if the event doesn&apos;t correspond to an action with type SendAlertMessage.
⋮----
///     The user-generated text content.
⋮----
///     The word or phrase configured in the rule that triggered this.
⋮----
///     The substring in the content which triggered the rule.</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodCreateRuleEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.AutomodRuleCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class AutomodRuleCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;AutomodRuleCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the rule that has been created.</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodDeleteRuleEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.AutomodRuleDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class AutomodRuleDeleteEventArgs : DiscordEventArgs
⋮----
///     Gets the rule that has been deleted.</file><file path="DisCatSharp/EventArgs/Guild/Automod/AutomodUpdateRuleEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.AutomodRuleUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class AutomodRuleUpdateEventArgs : DiscordEventArgs
⋮----
///     Gets the rule that has been updated.</file><file path="DisCatSharp/EventArgs/Guild/Ban/GuildBanAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildBanAdded&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildBanAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildBanAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that was banned.
⋮----
///     Gets the guild this member was banned in.</file><file path="DisCatSharp/EventArgs/Guild/Ban/GuildBanRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildBanRemoved&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildBanRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildBanRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that just got unbanned.
⋮----
///     Gets the guild this member was unbanned in.</file><file path="DisCatSharp/EventArgs/Guild/GuildAuditLogEntryCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildAuditLogEntryCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildAuditLogEntryCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildAuditLogEntryCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the audit log entry.
///     Cast to correct type by action type.
⋮----
///     Gets the guild in which the update occurred.</file><file path="DisCatSharp/EventArgs/Guild/GuildCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that was created.</file><file path="DisCatSharp/EventArgs/Guild/GuildDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that was deleted.
⋮----
///     Gets whether the guild is unavailable or not.</file><file path="DisCatSharp/EventArgs/Guild/GuildDownloadCompletedEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildDownloadCompleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildDownloadCompletedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildDownloadCompletedEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;guilds&quot;&gt;The guilds.&lt;/param&gt;
/// &lt;param name=&quot;noGuilds&quot;&gt;Whether the bot isn&apos;t in any guilds..&lt;/param&gt;
/// &lt;param name=&quot;provider&quot;&gt;Service provider.&lt;/param&gt;
⋮----
///     Gets the dictionary of guilds that just finished downloading.
⋮----
///     If &lt;see langword=&quot;true&quot; /&gt;, the bot isn&apos;t in any guilds (yet).</file><file path="DisCatSharp/EventArgs/Guild/GuildEmojisUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildEmojisUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildEmojisUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildEmojisUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the list of emojis after the change.
⋮----
///     Gets the list of emojis before the change.
⋮----
///     Gets the guild in which the update occurred.</file><file path="DisCatSharp/EventArgs/Guild/GuildIntegrationsUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildIntegrationsUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildIntegrationsUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildIntegrationsUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that had its integrations updated.</file><file path="DisCatSharp/EventArgs/Guild/GuildStickersUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents event args for the &lt;see cref=&quot;DiscordClient.GuildStickersUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildStickersUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildStickersUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the list of stickers after the change.
⋮----
///     Gets the list of stickers before the change.
⋮----
///     Gets the guild in which the update occurred.</file><file path="DisCatSharp/EventArgs/Guild/GuildUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild before it was updated.
⋮----
///     Gets the guild after it was updated.</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildIntegrationCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildIntegrationCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildIntegrationCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the integration that was created.
⋮----
///     Gets the guild where the integration was created.</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildIntegrationDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildIntegrationDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildIntegrationDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the integration id which where deleted.
⋮----
///     Gets the guild where the integration which where deleted.
⋮----
///     Gets the application id of the integration which where deleted.</file><file path="DisCatSharp/EventArgs/Guild/Integration/GuildIntegrationUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildIntegrationUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildIntegrationUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildIntegrationUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the integration that was updated.
⋮----
///     Gets the guild where the integration was updated.</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberAdded&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that was added.
⋮----
///     Gets the guild the member was added to.</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberRemoved&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild the member was removed from.
⋮----
///     Gets the member that was removed.</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMembersChunkEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMembersChunked&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMembersChunkEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMembersChunkEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that requested this chunk.
⋮----
///     Gets the collection of members returned from this chunk.
⋮----
///     Gets the current chunk index from the response.
⋮----
///     Gets the total amount of chunks for the request.
⋮----
///     Gets the collection of presences returned from this chunk, if specified.
⋮----
///     Gets the returned Ids that were not found in the chunk, if specified.
⋮----
///     Gets the unique string used to identify the request, if specified.</file><file path="DisCatSharp/EventArgs/Guild/Member/GuildMemberUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets a collection containing post-update roles.
⋮----
///     Gets a collection containing pre-update roles.
⋮----
///     Gets the member&apos;s new nickname.
⋮----
///     Gets the member&apos;s old nickname.
⋮----
///     Gets whether the member had passed membership screening before the update.
⋮----
///     Gets whether the member had passed membership screening after the update.
⋮----
///     Gets whether the member is timed out before the update.
⋮----
///     Gets whether the member is timed out after the update.
⋮----
///     Gets whether the member has unusual dm activity before the update.
⋮----
///     Gets whether the member has unusual dm activity after the update.
⋮----
///     Gets the member that was updated.
⋮----
///     Gets the member&apos;s guild avatar hash before the update.
⋮----
///     Gets the member&apos;s guild avatar URL before the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHashBefore}.{(this.GuildAvatarHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s guild avatar hash after the update.
⋮----
///     Gets the member&apos;s guild avatar URL after the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHashAfter}.{(this.GuildAvatarHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s avatar hash before the update.
⋮----
///     Gets the member&apos;s avatar URL before the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.AvatarHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHashBefore}.{(this.AvatarHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s avatar hash after the update.
⋮----
///     Gets the member&apos;s avatar URL after the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.AvatarHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHashAfter}.{(this.AvatarHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s guild banner hash before the update.
⋮----
///     Gets the member&apos;s guild banner URL before the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHashBefore) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHashBefore}.{(this.GuildBannerHashBefore.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s guild banner hash after the update.
⋮----
///     Gets the member&apos;s guild banner URL after the update.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHashAfter) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.Guild.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Member.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHashAfter}.{(this.GuildBannerHashAfter.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the member&apos;s guild avatar decoration data after the update.
⋮----
///     Gets the member&apos;s guild avatar decoration data before the update.</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildJoinRequestCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildJoinRequestCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildJoinRequestCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the request of the join request that was created.
⋮----
///     Gets the status of the join request.
⋮----
///     Gets the user that created the join request.
⋮----
///     Gets the guild this join request was created for.</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildJoinRequestDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildJoinRequestDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildJoinRequestDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the request ID of the join request that was deleted.
⋮----
///     Gets the user that deleted the join request.
⋮----
///     Gets the guild this join request was deleted from.</file><file path="DisCatSharp/EventArgs/Guild/MemberApplications/GuildJoinRequestUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildJoinRequestUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildJoinRequestUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildJoinRequestUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the request of the join request that was updated.
⋮----
///     Gets the status of the join request.
⋮----
///     Gets the user who&apos;s join request was updated.
⋮----
///     Gets the guild this join request was updated for.</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildRoleCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildRoleCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildRoleCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the role was created.
⋮----
///     Gets the role that was created.</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildRoleDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildRoleDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildRoleDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the role was deleted.
⋮----
///     Gets the role that was deleted.</file><file path="DisCatSharp/EventArgs/Guild/Role/GuildRoleUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildRoleUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildRoleUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildRoleUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets the post-update role.
⋮----
///     Gets the pre-update role.</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildScheduledEventCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildScheduledEventCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildScheduledEventCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the scheduled event that was created.
⋮----
///     Gets the guild in which the scheduled event was created.</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildScheduledEventDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildScheduledEventDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildScheduledEventDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the scheduled event that was deleted.
⋮----
///     Gets the reason of deletion for the scheduled event.
///     Important to determine why and how it was deleted.
⋮----
///     Gets the guild in which the scheduled event was deleted.</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildScheduledEventUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildScheduledEventUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildScheduledEventUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the scheduled event that was updated.
⋮----
///     Gets the old scheduled event that was updated.
⋮----
///     Gets the guild in which the scheduled event was updated.</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildScheduledEventUserAdded&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildScheduledEventUserAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildScheduledEventUserAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the scheduled event.
⋮----
///     Gets the guild.
⋮----
///     Gets the user which has subscribed to this scheduled event.
⋮----
///     Gets the member which has subscribed to this scheduled event.</file><file path="DisCatSharp/EventArgs/Guild/ScheduledEvent/GuildScheduledEventUserRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildScheduledEventUserRemoved&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildScheduledEventUserRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildScheduledEventUserRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the scheduled event.
⋮----
///     Gets the guild.
⋮----
///     Gets the user which has unsubscribed from this scheduled event.
⋮----
///     Gets the member which has unsubscribed from this scheduled event.</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildSoundboardSoundCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildSoundboardSoundCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild this sound belongs to.
⋮----
///     Gets the sound.</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildSoundboardSoundDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildSoundboardSoundDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild this sound belongs to.
⋮----
///     Gets the sound id.
⋮----
///     Gets the sound.</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundsUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundsUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildSoundboardSoundsUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildSoundboardSoundsUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild this sound belongs to.
⋮----
///     Gets the sounds.</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/GuildSoundboardSoundUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildSoundboardSoundUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildSoundboardSoundUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildSoundboardSoundUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild this sound belongs to.
⋮----
///     Gets the sound.</file><file path="DisCatSharp/EventArgs/Guild/Sounboard/SoundboardSoundsEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.SoundboardSounds&quot; /&gt; event.
/// &lt;/summary&gt;
public class SoundboardSoundsEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SoundboardSoundsEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild where the soundboard sounds were received.
⋮----
///     Gets the guild id where the soundboard sounds were received.
⋮----
///     Gets the list of soundboard sounds.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the thread that was created.
⋮----
///     Gets the threads parent channel.
⋮----
///     Gets the guild in which the thread was created.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the thread that was deleted.
⋮----
///     Gets the threads parent channel.
⋮----
///     Gets the guild this thread belonged to.
⋮----
///     Gets the threads type.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadListSyncEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadListSynced&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadListSyncEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadListSyncEventArgs&quot; /&gt; class.
⋮----
///     Gets all thread member objects from the synced threads for the current user, indicating which threads the current
///     user has been added to
⋮----
///     Gets all active threads in the given channels that the current user can access.
⋮----
///     Gets the parent channels whose threads are being synced. If empty, then threads are synced for the guild. May
///     contain channels that have no active threads as well.
⋮----
///     Gets the guild being synced.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadMembersUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadMembersUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadMembersUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadMembersUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the approximate number of members in the thread, capped at 50.
⋮----
///     Gets the users who were removed from the thread.
⋮----
///     Gets the users who were added to the thread.
⋮----
///     Gets the id of the thread.
⋮----
///     Gets the guild.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadMemberUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadMemberUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadMemberUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadMemberUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the thread member that was updated.
⋮----
///     Gets the thread.</file><file path="DisCatSharp/EventArgs/Guild/Thread/ThreadUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ThreadUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class ThreadUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the post-update thread.
⋮----
///     Gets the pre-update thread.
⋮----
///     Gets the threads parent channel.
⋮----
///     Gets the guild in which the thread was updated.</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberTimeoutAdded&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberTimeoutAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberTimeoutAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that was timed out.
⋮----
///     Gets the guild this member was timed out.
⋮----
///     Gets the timeout time.</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberTimeoutRemoved&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberTimeoutRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberTimeoutRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that was affected by the timeout.
⋮----
///     Gets the guild this member was timed out.
⋮----
///     Gets the timeout time before the remove.</file><file path="DisCatSharp/EventArgs/Guild/Timeout/GuildMemberTimeoutUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.GuildMemberTimeoutChanged&quot; /&gt; event.
/// &lt;/summary&gt;
public class GuildMemberTimeoutUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildMemberTimeoutAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the member that was timed out.
⋮----
///     Gets the guild this member was timed out.
⋮----
///     Gets the timeout time before the update.
⋮----
///     Gets the timeout time after the update.</file><file path="DisCatSharp/EventArgs/HeartBeatEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.Heartbeated&quot; /&gt; event.
/// &lt;/summary&gt;
public class HeartbeatEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;HeartbeatEventArgs&quot; /&gt; class.
⋮----
///     Gets the round-trip time of the heartbeat.
⋮----
///     Gets the timestamp of the heartbeat.</file><file path="DisCatSharp/EventArgs/Interaction/ComponentInteractionCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.ComponentInteractionCreated&quot; /&gt;.
/// &lt;/summary&gt;
public class ComponentInteractionCreateEventArgs : InteractionCreateEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ComponentInteractionCreateEventArgs&quot; /&gt; class.
⋮----
///     The Id of the component that was interacted with.
⋮----
///     The user that invoked this interaction.
⋮----
///     The guild this interaction was invoked on, if any.
⋮----
///     The member that invoked this interaction, if any.
⋮----
///     The channel this interaction was invoked in.
⋮----
///     The value(s) selected. Only applicable to SelectMenu components.
⋮----
///     The message this interaction is attached to.</file><file path="DisCatSharp/EventArgs/Interaction/ContextMenuInteractionCreateEventArgs.cs">/// &lt;summary&gt;
///     The context menu interaction create event args.
/// &lt;/summary&gt;
public sealed class ContextMenuInteractionCreateEventArgs : InteractionCreateEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ContextMenuInteractionCreateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     The type of context menu that was used. This is never
///     &lt;see cref=&quot;DisCatSharp.Enums.ApplicationCommandType.ChatInput&quot; /&gt;.
⋮----
///     The user that invoked this interaction. Can be cast to a member if this was on a guild.
⋮----
///     The user this interaction targets, if applicable.
⋮----
///     The message this interaction targets, if applicable.</file><file path="DisCatSharp/EventArgs/Interaction/InteractionCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.InteractionCreated&quot; /&gt;
/// &lt;/summary&gt;
public class InteractionCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InteractionCreateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the interaction data that was invoked.</file><file path="DisCatSharp/EventArgs/Invite/InviteCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.InviteCreated&quot; /&gt;
/// &lt;/summary&gt;
public sealed class InviteCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InviteCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that created the invite.
⋮----
///     Gets the channel that the invite is for.
⋮----
///     Gets the created invite.</file><file path="DisCatSharp/EventArgs/Invite/InviteDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.InviteDeleted&quot; /&gt;
/// &lt;/summary&gt;
public sealed class InviteDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InviteDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that deleted the invite.
⋮----
///     Gets the channel that the invite was for.
⋮----
///     Gets the deleted invite.</file><file path="DisCatSharp/EventArgs/Message/MessageAcknowledgeEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageAcknowledged&quot; /&gt; event.
/// &lt;/summary&gt;
public sealed class MessageAcknowledgeEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageAcknowledgeEventArgs&quot; /&gt; class.
⋮----
///     Gets the message that was acknowledged.
⋮----
///     Gets the channel for which the message was acknowledged.</file><file path="DisCatSharp/EventArgs/Message/MessageBulkDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessagesBulkDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageBulkDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageBulkDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets a collection of the deleted messages.
⋮----
///     Gets the channel in which the deletion occurred.
⋮----
///     Gets the guild in which the deletion occurred.</file><file path="DisCatSharp/EventArgs/Message/MessageCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the message that was created.
⋮----
///     Gets the channel this message belongs to.
⋮----
///     Gets the guild this message belongs to.
⋮----
///     Gets the guild id in case it couldn&apos;t convert.
⋮----
///     Gets the author of the message.
⋮----
///     Gets the collection of mentioned users.
⋮----
///     Gets the collection of mentioned roles.
⋮----
///     Gets the collection of mentioned channels.</file><file path="DisCatSharp/EventArgs/Message/MessageDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the message that was deleted.
⋮----
///     Gets the channel this message belonged to.
⋮----
///     Gets the guild this message belonged to.</file><file path="DisCatSharp/EventArgs/Message/MessageUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the message that was updated.
⋮----
///     Gets the message before it got updated. This property will be null if the message was not cached.
⋮----
///     Gets the channel this message belongs to.
⋮----
///     Gets the guild this message belongs to.
⋮----
///     Gets the guild id in case it couldn&apos;t convert.
⋮----
///     Gets the author of the message.
⋮----
///     Gets the collection of mentioned users.
⋮----
///     Gets the collection of mentioned roles.
⋮----
///     Gets the collection of mentioned channels.</file><file path="DisCatSharp/EventArgs/Message/Polls/MessagePollVoteAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessagePollVoteAdded&quot; /&gt;
/// &lt;/summary&gt;
public sealed class MessagePollVoteAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessagePollVoteAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild of the poll, if it was send in a guild.
⋮----
///     Gets the guild id of the poll, if it was send in a guild.
⋮----
///     Gets the channel of the poll, if it&apos;s in the cache.
⋮----
///     Gets the channel id of the poll.
⋮----
///     Gets the message of the poll, if it&apos;s in the cache.
⋮----
///     Gets the message id of the poll.
⋮----
///     Gets the user who voted.
⋮----
///     Gets the user id who voted.
⋮----
///     Gets the answer id.</file><file path="DisCatSharp/EventArgs/Message/Polls/MessagePollVoteRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessagePollVoteRemoved&quot; /&gt;
/// &lt;/summary&gt;
public sealed class MessagePollVoteRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessagePollVoteRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild of the poll, if it was send in a guild.
⋮----
///     Gets the guild id of the poll, if it was send in a guild.
⋮----
///     Gets the channel of the poll, if it&apos;s in the cache.
⋮----
///     Gets the channel id of the poll.
⋮----
///     Gets the message of the poll, if it&apos;s in the cache.
⋮----
///     Gets the message id of the poll.
⋮----
///     Gets the user who removed their vote.
⋮----
///     Gets the user id who removed their vote.
⋮----
///     Gets the answer id.</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionAddEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageReactionAdded&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageReactionAddEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageReactionAddEventArgs&quot; /&gt; class.
⋮----
///     Gets the message for which the update occurred.
⋮----
///     Gets the channel to which this message belongs.
⋮----
/// &lt;remarks&gt;
///     This will be &lt;c&gt;null&lt;/c&gt; for an uncached channel, which will usually happen for when this event triggers on
///     DM channels in which no prior messages were received or sent.
/// &lt;/remarks&gt;
⋮----
///     The channel id.
⋮----
///     Gets the user who created the reaction.
///     &lt;para&gt;This can be cast to a &lt;see cref=&quot;DisCatSharp.Entities.DiscordMember&quot; /&gt; if the reaction was in a guild.&lt;/para&gt;
⋮----
///     Gets the guild in which the reaction was added.
⋮----
///     Gets the emoji used for this reaction.
⋮----
///     Whether the reaction was added as a burst reaction.</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEmojiEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageReactionRemovedEmoji&quot; /&gt;
/// &lt;/summary&gt;
public sealed class MessageReactionRemoveEmojiEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageReactionRemoveEmojiEventArgs&quot; /&gt; class.
⋮----
///     Gets the channel the removed reactions were in.
⋮----
///     Gets the guild the removed reactions were in.
⋮----
///     Gets the message that had the removed reactions.
⋮----
///     Gets the emoji of the reaction that was removed.</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionRemoveEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageReactionRemoved&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageReactionRemoveEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageReactionRemoveEventArgs&quot; /&gt; class.
⋮----
///     Gets the message for which the update occurred.
⋮----
///     Gets the channel to which this message belongs.
⋮----
/// &lt;remarks&gt;
///     This will be &lt;c&gt;null&lt;/c&gt; for an uncached channel, which will usually happen for when this event triggers on
///     DM channels in which no prior messages were received or sent.
/// &lt;/remarks&gt;
⋮----
///     The channel id.
⋮----
///     Gets the users whose reaction was removed.
⋮----
///     Gets the guild in which the reaction was deleted.
⋮----
///     Gets the emoji used for this reaction.
⋮----
///     Whether the reaction was added as a burst reaction.</file><file path="DisCatSharp/EventArgs/Message/Reaction/MessageReactionsClearEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.MessageReactionsCleared&quot; /&gt; event.
/// &lt;/summary&gt;
public class MessageReactionsClearEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MessageReactionsClearEventArgs&quot; /&gt; class.
⋮----
///     Gets the message for which the update occurred.
⋮----
///     Gets the channel to which this message belongs.
⋮----
/// &lt;remarks&gt;
///     This will be &lt;c&gt;null&lt;/c&gt; for an uncached channel, which will usually happen for when this event triggers on
///     DM channels in which no prior messages were received or sent.
/// &lt;/remarks&gt;
⋮----
///     Gets the guild in which the reactions were cleared.</file><file path="DisCatSharp/EventArgs/PayloadReceivedEventArgs.cs">/// &lt;summary&gt;
///     Represents a gateway payload.
/// &lt;/summary&gt;
public class PayloadReceivedEventArgs : DiscordEventArgs
⋮----
///     Gets the json.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PayloadReceivedEventArgs&quot; /&gt; class.
⋮----
///     The JSON from this payload event.
⋮----
if (string.IsNullOrWhiteSpace(this._json))
this._json = this.PayloadObject.ToString();
⋮----
///     Gets or sets the payload object.
⋮----
///     The name of this event.</file><file path="DisCatSharp/EventArgs/RateLimitExceptionEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.RateLimitHit&quot; /&gt; event.
/// &lt;/summary&gt;
public class RateLimitExceptionEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;HeartbeatEventArgs&quot; /&gt; class.
⋮----
///     Gets the ratelimit exception.
⋮----
///     Gets the called api endpoint.</file><file path="DisCatSharp/EventArgs/ReadyEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.Ready&quot; /&gt; event.
/// &lt;/summary&gt;
public sealed class ReadyEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ReadyEventArgs&quot; /&gt; class.</file><file path="DisCatSharp/EventArgs/Socket/SocketDisconnectEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.SocketClosed&quot; /&gt; event.
/// &lt;/summary&gt;
public class SocketCloseEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SocketCloseEventArgs&quot; /&gt; class.
⋮----
///     Gets the close code sent by remote host.
⋮----
///     Gets the close message sent by remote host.
⋮----
///     Represents arguments for &lt;see cref=&quot;DiscordClient.SocketErrored&quot; /&gt; event.
⋮----
public class SocketErrorEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SocketErrorEventArgs&quot; /&gt; class.
⋮----
///     Gets the exception thrown by websocket client.</file><file path="DisCatSharp/EventArgs/Socket/SocketEventArgs.cs">/// &lt;summary&gt;
///     Represents basic socket event arguments.
/// &lt;/summary&gt;
public class SocketEventArgs : DiscordEventArgs
⋮----
///     Creates a new event argument container.</file><file path="DisCatSharp/EventArgs/Socket/WebSocketMessageEventArgs.cs">/// &lt;summary&gt;
///     Represents base class for raw socket message event arguments.
/// &lt;/summary&gt;
public abstract class SocketMessageEventArgs : AsyncEventArgs
⋮----
///     Represents arguments for text message websocket event.
⋮----
public sealed class SocketTextMessageEventArgs : SocketMessageEventArgs
⋮----
///     Creates a new instance of text message event arguments.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Received message string.&lt;/param&gt;
⋮----
///     Gets the received message string.
⋮----
///     Represents arguments for binary message websocket event.
⋮----
public sealed class SocketBinaryMessageEventArgs : SocketMessageEventArgs
⋮----
///     Creates a new instance of binary message event arguments.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Received message bytes.&lt;/param&gt;
⋮----
///     Gets the received message bytes.</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.StageInstanceCreated&quot; /&gt; event.
/// &lt;/summary&gt;
public class StageInstanceCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;StageInstanceCreateEventArgs&quot; /&gt; class.
⋮----
///     Gets the stage instance that was created.
⋮----
///     Gets the guild in which the stage instance was created.</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.StageInstanceDeleted&quot; /&gt; event.
/// &lt;/summary&gt;
public class StageInstanceDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;StageInstanceDeleteEventArgs&quot; /&gt; class.
⋮----
///     Gets the stage instance that was deleted.
⋮----
///     Gets the guild in which the stage instance was deleted.</file><file path="DisCatSharp/EventArgs/Stage/StageInstanceUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.StageInstanceUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class StageInstanceUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;StageInstanceUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the stage instance that was updated.
⋮----
///     Gets the guild in which the stage instance was updated.</file><file path="DisCatSharp/EventArgs/Store/EntitlementCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.EntitlementCreated&quot; /&gt;
/// &lt;/summary&gt;
public class EntitlementCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;EntitlementCreateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the entitlement that was created.</file><file path="DisCatSharp/EventArgs/Store/EntitlementDeleteEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.EntitlementDeleted&quot; /&gt;
/// &lt;/summary&gt;
public class EntitlementDeleteEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;EntitlementDeleteEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the entitlement that was deleted.</file><file path="DisCatSharp/EventArgs/Store/EntitlementUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.EntitlementUpdated&quot; /&gt;
/// &lt;/summary&gt;
public class EntitlementUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;EntitlementUpdateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the entitlement that was updated.</file><file path="DisCatSharp/EventArgs/Store/SubscriptionCreateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.SubscriptionCreated&quot; /&gt;
/// &lt;/summary&gt;
public class SubscriptionCreateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SubscriptionCreateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the subscription that was created.</file><file path="DisCatSharp/EventArgs/Store/SubscriptionUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.SubscriptionCreated&quot; /&gt;
/// &lt;/summary&gt;
public class SubscriptionUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SubscriptionUpdateEventArgs&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider.&lt;/param&gt;
⋮----
///     Gets the subscription that was updated.</file><file path="DisCatSharp/EventArgs/TypingStartEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.TypingStarted&quot; /&gt; event.
/// &lt;/summary&gt;
public class TypingStartEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TypingStartEventArgs&quot; /&gt; class.
⋮----
///     Gets the channel in which the indicator was triggered.
⋮----
///     Gets the user that started typing.
///     &lt;para&gt;This can be cast to a &lt;see cref=&quot;DisCatSharp.Entities.DiscordMember&quot; /&gt; if the typing occurred in a guild.&lt;/para&gt;
⋮----
///     Gets the guild in which the indicator was triggered.
⋮----
///     Gets the date and time at which the user started typing.</file><file path="DisCatSharp/EventArgs/UnknownEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.UnknownEvent&quot; /&gt; event.
/// &lt;/summary&gt;
public class UnknownEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;UnknownEventArgs&quot; /&gt; class.
⋮----
///     Gets the event&apos;s name.
⋮----
///     Gets the event&apos;s data.</file><file path="DisCatSharp/EventArgs/User/PresenceUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.PresenceUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class PresenceUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PresenceUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the user whose presence was updated.
⋮----
///     Gets the user&apos;s new game.
⋮----
///     Gets the user&apos;s new activitites.
⋮----
///     Gets the user&apos;s status.
⋮----
///     Gets the user&apos;s old presence.
⋮----
///     Gets the user&apos;s new presence.</file><file path="DisCatSharp/EventArgs/User/UserSettingsUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.UserSettingsUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class UserSettingsUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;UserSettingsUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the user whose settings were updated.</file><file path="DisCatSharp/EventArgs/User/UserSpeakingEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for UserSpeaking event.
/// &lt;/summary&gt;
public class UserSpeakingEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;UserSpeakingEventArgs&quot; /&gt; class.
⋮----
///     Gets the users whose speaking state changed.
⋮----
///     Gets the SSRC of the audio source.
⋮----
///     Gets whether this user is speaking.</file><file path="DisCatSharp/EventArgs/User/UserUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.UserUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class UserUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;UserUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the post-update user.
⋮----
///     Gets the pre-update user.</file><file path="DisCatSharp/EventArgs/Voice/VoiceChannelEffectSendEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.VoiceChannelEffectSend&quot; /&gt; event.
/// &lt;/summary&gt;
public class VoiceChannelEffectSendEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceStateUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the user whose voice state was updated.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets the related voice channel.
⋮----
///     Gets the emoji sent, for emoji reactions and soundboard effects.
⋮----
///     Gets the type of emoji animation, for emoji reactions and soundboard effects.
⋮----
///     Gets the ID of the emoji animation, for emoji reactions and soundboard effects.
⋮----
///     Gets the ID of the soundboard sound, for soundboard effects.
⋮----
///     Gets the volume of the soundboard sound, from 0 to 1, for soundboard effects.</file><file path="DisCatSharp/EventArgs/Voice/VoiceServerUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.VoiceServerUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class VoiceServerUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceServerUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild for which the update occurred.
⋮----
///     Gets the new voice endpoint.
⋮----
///     Gets the voice connection token.</file><file path="DisCatSharp/EventArgs/Voice/VoiceStateUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.VoiceStateUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class VoiceStateUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;VoiceStateUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the user whose voice state was updated.
⋮----
///     Gets the guild in which the update occurred.
⋮----
///     Gets the related voice channel.
⋮----
///     Gets the voice state pre-update.
⋮----
///     Gets the voice state post-update.
⋮----
///     Gets the ID of voice session.</file><file path="DisCatSharp/EventArgs/WebhooksUpdateEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments to &lt;see cref=&quot;DiscordClient.WebhooksUpdated&quot; /&gt; event.
/// &lt;/summary&gt;
public class WebhooksUpdateEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;WebhooksUpdateEventArgs&quot; /&gt; class.
⋮----
///     Gets the guild that had its webhooks updated.
⋮----
///     Gets the channel to which the webhook belongs to.</file><file path="DisCatSharp/EventArgs/ZombiedEventArgs.cs">/// &lt;summary&gt;
///     Represents arguments for &lt;see cref=&quot;DiscordClient.Zombied&quot; /&gt; event.
/// &lt;/summary&gt;
public class ZombiedEventArgs : DiscordEventArgs
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ZombiedEventArgs&quot; /&gt; class.
⋮----
///     Gets how many heartbeat failures have occurred.
⋮----
///     Gets whether the zombie event occurred whilst guilds are downloading.</file><file path="DisCatSharp/Exceptions/BadRequestException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when a malformed request is sent.
/// &lt;/summary&gt;
public class BadRequestException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;BadRequestException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
this.Errors = j[&quot;errors&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the error code for this exception.
⋮----
///     Gets the JSON message received.
⋮----
///     Gets the form error responses in JSON format.</file><file path="DisCatSharp/Exceptions/DisCatSharpException.cs">/// &lt;summary&gt;
///     Represents a generic exception thrown by DisCatSharp.
/// &lt;/summary&gt;
public class DisCatSharpException : Exception
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DisCatSharpException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The error message.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;innerException&quot;&gt;The inner exception.&lt;/param&gt;</file><file path="DisCatSharp/Exceptions/DisCatSharpUserException.cs">/// &lt;summary&gt;
///     Represents a generic exception thrown by DisCatSharp because of a user error.
/// &lt;/summary&gt;
public class DisCatSharpUserException : Exception
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DisCatSharpUserException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The error message.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;innerException&quot;&gt;The inner exception.&lt;/param&gt;</file><file path="DisCatSharp/Exceptions/DiscordJsonException.cs">/// &lt;summary&gt;
///     Represents a &lt;see cref=&quot;DiscordJsonException&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordJsonException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordJsonException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;jre&quot;&gt;The JSON reader exception.&lt;/param&gt;
⋮----
///     Gets the line number indicating where the error occurred.
⋮----
/// &lt;value&gt;The line number indicating where the error occurred.&lt;/value&gt;
⋮----
///     Gets the line position indicating where the error occurred.
⋮----
/// &lt;value&gt;The line position indicating where the error occurred.&lt;/value&gt;
⋮----
///     Gets the path to the JSON where the error occurred.
⋮----
/// &lt;value&gt;The path to the JSON where the error occurred.&lt;/value&gt;</file><file path="DisCatSharp/Exceptions/ExceptionFilter.cs">/// &lt;summary&gt;
///     Represents a filter for exceptions that should not be sent to Sentry.
/// &lt;/summary&gt;
public class DisCatSharpExceptionFilter : IExceptionFilter
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DisCatSharpExceptionFilter&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;configuration&quot;&gt;The discord configuration.&lt;/param&gt;
⋮----
///     Gets or sets the configuration.
⋮----
///     Gets whether this filter shoulod track the exception.
⋮----
/// &lt;param name=&quot;ex&quot;&gt;The exception to check.&lt;/param&gt;
public bool Filter(Exception ex)
=&gt; !this.Config.TrackExceptions.Contains(ex.GetType());</file><file path="DisCatSharp/Exceptions/NotFoundException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when a requested resource is not found.
/// &lt;/summary&gt;
public class NotFoundException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;NotFoundException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the JSON received.</file><file path="DisCatSharp/Exceptions/NotIndexedException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when an elastisearch endpoint isn&apos;t finished with indexing yet.
/// &lt;/summary&gt;
public sealed class NotIndexedException : Exception
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;NotIndexedException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the response to the request.
⋮----
///     Gets the error code for this exception.
⋮----
///     Gets the json message.
⋮----
///     Gets the indexed documents count.
⋮----
///     Gets when to retry the request.</file><file path="DisCatSharp/Exceptions/RateLimitException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when too many requests are sent.
/// &lt;/summary&gt;
public class RateLimitException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RateLimitException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the JSON received.</file><file path="DisCatSharp/Exceptions/RequestSizeException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when the request sent to Discord is too large.
/// &lt;/summary&gt;
public class RequestSizeException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RequestSizeException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the JSON received.</file><file path="DisCatSharp/Exceptions/ServerErrorException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when Discord returns an Internal Server Error.
/// &lt;/summary&gt;
public class ServerErrorException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ServerErrorException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the JSON received.</file><file path="DisCatSharp/Exceptions/UnauthorizedException.cs">/// &lt;summary&gt;
///     Represents an exception thrown when requester doesn&apos;t have necessary permissions to complete the request.
/// &lt;/summary&gt;
public class UnauthorizedException : DisCatSharpException
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;UnauthorizedException&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
⋮----
var j = JObject.Parse(response.Response);
⋮----
this.JsonMessage = j[&quot;message&quot;]!.ToString();
⋮----
///     Gets the request that caused the exception.
⋮----
///     Gets the response to the request.
⋮----
///     Gets the JSON received.</file><file path="DisCatSharp/Exceptions/ValidationException.cs">/// &lt;summary&gt;
///     Represents a validation exception thrown by DisCatSharp because of an invalid user input.
/// &lt;/summary&gt;
public sealed class ValidationException : DisCatSharpUserException
⋮----
///     Constructs a new &lt;see cref=&quot;ValidationException&quot; /&gt;.
⋮----
/// &lt;param name=&quot;validatedType&quot;&gt;The validated type.&lt;/param&gt;
/// &lt;param name=&quot;origin&quot;&gt;The validation origin.&lt;/param&gt;
/// &lt;param name=&quot;errorMessage&quot;&gt;The error message.&lt;/param&gt;
⋮----
///     Gets the validated type.
⋮----
///     Gets i.e. the method name, where the exception was thrown for.
⋮----
///     Gets the error message.</file><file path="DisCatSharp/Formatter.cs">/// &lt;summary&gt;
///     Contains markdown formatting helpers.
/// &lt;/summary&gt;
public static class Formatter
⋮----
///     Creates a block of code.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Contents of the block.&lt;/param&gt;
/// &lt;param name=&quot;language&quot;&gt;Language to use for highlighting.&lt;/param&gt;
/// &lt;returns&gt;Formatted block of code.&lt;/returns&gt;
public static string BlockCode(this string content, string language = &quot;&quot;)
⋮----
///     Creates inline code snippet.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Contents of the snippet.&lt;/param&gt;
/// &lt;returns&gt;Formatted inline code snippet.&lt;/returns&gt;
public static string InlineCode(this string content)
⋮----
///     Creates a rendered timestamp.
⋮----
/// &lt;param name=&quot;time&quot;&gt;The time from now.&lt;/param&gt;
/// &lt;param name=&quot;format&quot;&gt;The format to render the timestamp in. Defaults to relative.&lt;/param&gt;
/// &lt;returns&gt;A formatted timestamp.&lt;/returns&gt;
public static string Timestamp(this TimeSpan time, TimestampFormat format = TimestampFormat.RelativeTime)
⋮----
/// &lt;param name=&quot;time&quot;&gt;Timestamp to format.&lt;/param&gt;
⋮----
public static string Timestamp(this DateTimeOffset time, TimestampFormat format = TimestampFormat.RelativeTime)
=&gt; $&quot;&lt;t:{time.ToUnixTimeSeconds()}:{(char)format}&gt;&quot;;
⋮----
/// &lt;returns&gt;A formatted timestamp relative to now.&lt;/returns&gt;
public static string Timestamp(this DateTime time, TimestampFormat format = TimestampFormat.RelativeTime)
=&gt; Timestamp(time.ToUniversalTime() - DateTime.UtcNow, format);
⋮----
///     Creates small subtext.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to subtext.&lt;/param&gt;
/// &lt;returns&gt;Formatted text.&lt;/returns&gt;
public static string Subtext(this string content)
⋮----
///     Creates bold text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to embolden.&lt;/param&gt;
⋮----
public static string Bold(this string content)
⋮----
///     Creates italicized text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to italicize.&lt;/param&gt;
⋮----
public static string Italic(this string content)
⋮----
///     Creates spoiler from text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to spoiler.&lt;/param&gt;
⋮----
public static string Spoiler(this string content)
⋮----
///     Creates underlined text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to underline.&lt;/param&gt;
⋮----
public static string Underline(this string content)
⋮----
///     Creates strikethrough text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to strikethrough.&lt;/param&gt;
⋮----
public static string Strike(this string content)
⋮----
///     Creates a header.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to convert to a header.&lt;/param&gt;
⋮----
public static string Header1(this string content)
⋮----
///     Creates a small header.
⋮----
public static string Header2(this string content)
⋮----
///     Creates a smaller header.
⋮----
public static string Header3(this string content)
⋮----
///     Creates quoted text.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Text to quote.&lt;/param&gt;
⋮----
public static string SingleQuote(this string content)
⋮----
///     Creates a multiline quoted text. Add new lines by using \n.
⋮----
public static string MultiQuote(this string content)
⋮----
///     &lt;para&gt;Creates a simple list.&lt;/para&gt;
///     &lt;para&gt;If you want a indented list, see https://support.discord.com/hc/en-us/articles/210298617.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;content&quot;&gt;Array of strings to transform into a list.&lt;/param&gt;
⋮----
public static string SimpleList(this string[] content)
=&gt; string.Join(&quot;\n&quot;, content.Select(x =&gt; $&quot;- {x}&quot;));
⋮----
///     Creates a URL that won&apos;t create a link preview.
⋮----
/// &lt;param name=&quot;url&quot;&gt;Url to prevent from being previewed.&lt;/param&gt;
/// &lt;returns&gt;Formatted url.&lt;/returns&gt;
public static string EmbedlessUrl(this Uri url)
⋮----
///     Creates a masked link. This link will display as specified text, and alternatively provided alt text.
⋮----
/// &lt;param name=&quot;text&quot;&gt;Text to display the link as.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;Url that the link will lead to.&lt;/param&gt;
/// &lt;param name=&quot;altText&quot;&gt;Alt text to display on hover.&lt;/param&gt;
/// &lt;param name=&quot;embedless&quot;&gt;Whether to supress url embeds.&lt;/param&gt;
⋮----
public static string MaskedUrl(this string text, Uri url, string? altText = null, bool embedless = false)
=&gt; $&quot;[{text}]({(embedless ? EmbedlessUrl(url) : url)}{(!string.IsNullOrWhiteSpace(altText) ? $&quot; \&quot;{altText}\&quot;&quot; : string.Empty)})&quot;;
⋮----
///     Escapes all markdown formatting from specified text.
⋮----
/// &lt;param name=&quot;text&quot;&gt;Text to sanitize.&lt;/param&gt;
/// &lt;returns&gt;Sanitized text.&lt;/returns&gt;
public static string Sanitize(this string text)
=&gt; CommonRegEx.MdSanitizeRegex().Replace(text, m =&gt; $&quot;\\{m.Groups[1].Value}&quot;);
⋮----
///     Removes all markdown formatting from specified text.
⋮----
/// &lt;param name=&quot;text&quot;&gt;Text to strip of formatting.&lt;/param&gt;
/// &lt;returns&gt;Formatting-stripped text.&lt;/returns&gt;
public static string Strip(this string text)
=&gt; CommonRegEx.MdStripRegex().Replace(text, m =&gt; string.Empty);
⋮----
///     Creates a mention for specified user or member. Can optionally specify to resolve nicknames.
⋮----
/// &lt;param name=&quot;user&quot;&gt;User to create mention for.&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;Whether the mention should resolve nicknames or not.&lt;/param&gt;
/// &lt;returns&gt;Formatted mention.&lt;/returns&gt;
public static string Mention(this DiscordUser user, bool nickname = false)
⋮----
? $&quot;&lt;@!{user.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
: $&quot;&lt;@{user.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
⋮----
///     Creates a mention for specified channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to mention.&lt;/param&gt;
⋮----
public static string Mention(this DiscordChannel channel)
=&gt; $&quot;&lt;#{channel.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
⋮----
///     Creates a mention for specified role.
⋮----
/// &lt;param name=&quot;role&quot;&gt;Role to mention.&lt;/param&gt;
⋮----
public static string Mention(this DiscordRole role)
=&gt; $&quot;&lt;@&amp;{role.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
⋮----
///     Creates a custom emoji string.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji to display.&lt;/param&gt;
/// &lt;returns&gt;Formatted emoji.&lt;/returns&gt;
public static string Emoji(this DiscordEmoji emoji)
=&gt; $&quot;&lt;:{emoji.Name}:{emoji.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;;
⋮----
///     Creates a url for using attachments in embeds. This can only be used as an Image URL, Thumbnail URL, Author icon
///     URL or Footer icon URL.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;Name of attached image to display&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static string AttachedImageUrl(this string filename)</file><file path="DisCatSharp/GlobalSuppressions.cs"></file><file path="DisCatSharp/Internals.cs">/// &lt;summary&gt;
///     Internal tools.
/// &lt;/summary&gt;
public static class Internals
⋮----
///     Gets the version of the library
⋮----
///     Gets the permission strings.
⋮----
///     Gets the utf8 encoding
⋮----
///     Gets clyde&apos;s user id.
⋮----
///     Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; is joinable via voice.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
internal static bool IsVoiceJoinable(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage;
⋮----
///     Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; can have threads.
⋮----
internal static bool IsThreadHolder(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Text || channel.Type == ChannelType.News || channel.Type == ChannelType.Forum;
⋮----
///     Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; is related to threads.
⋮----
internal static bool IsThread(this DiscordChannel channel) =&gt; channel.Type == ChannelType.PublicThread || channel.Type == ChannelType.PrivateThread || channel.Type == ChannelType.NewsThread;
⋮----
///     Whether users can write the &lt;see cref=&quot;DiscordChannel&quot; /&gt;.
⋮----
internal static bool IsWritable(this DiscordChannel channel) =&gt; channel.Type is
⋮----
///     Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; is moveable in a parent.
⋮----
internal static bool IsMovableInParent(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage || channel.Type == ChannelType.Text || channel.Type == ChannelType.Forum || channel.Type == ChannelType.News;
⋮----
///     Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; is moveable.
⋮----
internal static bool IsMovable(this DiscordChannel channel) =&gt; channel.Type == ChannelType.Voice || channel.Type == ChannelType.Stage || channel.Type == ChannelType.Text || channel.Type == ChannelType.Category || channel.Type == ChannelType.Forum || channel.Type == ChannelType.News;</file><file path="DisCatSharp/Logging/CompositeDefaultLogger.cs">/// &lt;summary&gt;
///     Represents a composite default logger.
/// &lt;/summary&gt;
internal class CompositeDefaultLogger : ILogger&lt;BaseDiscordClient&gt;
⋮----
///     Gets the loggers.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;CompositeDefaultLogger&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;providers&quot;&gt;The providers.&lt;/param&gt;
⋮----
this._loggers = providers.Select(x =&gt; x.CreateLogger(typeof(BaseDiscordClient).FullName!))
⋮----
.ToList();
⋮----
///     Whether the logger is enabled.
⋮----
/// &lt;param name=&quot;logLevel&quot;&gt;The log level.&lt;/param&gt;
public bool IsEnabled(LogLevel logLevel)
⋮----
///     Logs an event.
⋮----
/// &lt;param name=&quot;eventId&quot;&gt;The event id.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
/// &lt;param name=&quot;exception&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;formatter&quot;&gt;The formatter.&lt;/param&gt;
public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
⋮----
logger.Log(logLevel, eventId, state, exception, formatter);
⋮----
///     Begins the scope.
⋮----
public IDisposable BeginScope&lt;TState&gt;(TState state) where TState : notnull
=&gt; throw new NotImplementedException();</file><file path="DisCatSharp/Logging/DefaultLogger.cs">/// &lt;summary&gt;
///     Represents a default logger.
/// &lt;/summary&gt;
public class DefaultLogger : ILogger&lt;BaseDiscordClient&gt;
⋮----
private static readonly Lock s_lock = new();
⋮----
///     Gets the minimum log level.
⋮----
private readonly LogLevel _minimumLevel;
⋮----
///     Gets the timestamp format.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DefaultLogger&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;minLevel&quot;&gt;The min level.&lt;/param&gt;
/// &lt;param name=&quot;timestampFormat&quot;&gt;The timestamp format.&lt;/param&gt;
⋮----
///     Logs an event.
⋮----
/// &lt;param name=&quot;logLevel&quot;&gt;The log level.&lt;/param&gt;
/// &lt;param name=&quot;eventId&quot;&gt;The event id.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
/// &lt;param name=&quot;exception&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;formatter&quot;&gt;The formatter.&lt;/param&gt;
public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
⋮----
if (!this.IsEnabled(logLevel))
⋮----
Console.Write($&quot;[{DateTimeOffset.Now.ToString(this._timestampFormat)}] [{eventId.Id,-4}/{ename,-12}] &quot;);
⋮----
throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null);
⋮----
Console.Write(logLevel switch
⋮----
_ =&gt; throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null)
⋮----
Console.ResetColor();
⋮----
//The foreground color is off.
⋮----
Console.Write(&quot; &quot;);
⋮----
Console.WriteLine(message);
⋮----
Console.WriteLine(exception);
⋮----
///     Whether the logger is enabled.
⋮----
public bool IsEnabled(LogLevel logLevel)
⋮----
///     Begins the scope.
⋮----
/// &lt;returns&gt;An IDisposable.&lt;/returns&gt;
public IDisposable BeginScope&lt;TState&gt;(TState state) where TState : notnull
=&gt; throw new NotImplementedException();</file><file path="DisCatSharp/Logging/DefaultLoggerFactory.cs">/// &lt;summary&gt;
///     Represents a default logger factory.
/// &lt;/summary&gt;
internal class DefaultLoggerFactory : ILoggerFactory
⋮----
///     Gets the providers.
⋮----
///     Gets whether this logger factory is disposed.
⋮----
///     Adds a provider.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider to be added.&lt;/param&gt;
public void AddProvider(ILoggerProvider provider)
=&gt; this._providers.Add(provider);
⋮----
///     Creates the logger.
⋮----
/// &lt;param name=&quot;categoryName&quot;&gt;The category name.&lt;/param&gt;
public ILogger CreateLogger(string categoryName)
⋮----
? throw new ObjectDisposedException(nameof(DefaultLoggerFactory), &quot;This logger factory is already disposed.&quot;)
⋮----
? throw new ArgumentException($&quot;This factory can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, {typeof(DiscordWebhookClient).FullName} or {typeof(DiscordOAuth2Client).FullName}, not {categoryName}.&quot;, nameof(categoryName))
: new CompositeDefaultLogger(this._providers);
⋮----
///     Disposes the logger.
⋮----
public void Dispose()
⋮----
ObjectDisposedException.ThrowIf(this._isDisposed, this);
⋮----
provider.Dispose();
⋮----
this._providers.Clear();</file><file path="DisCatSharp/Logging/DefaultLoggerProvider.cs">/// &lt;summary&gt;
///     Represents a default logger provider.
/// &lt;/summary&gt;
internal class DefaultLoggerProvider : ILoggerProvider
⋮----
///     Gets the minimum log level.
⋮----
private readonly LogLevel _minimumLevel;
⋮----
///     Gets the timestamp format.
⋮----
///     Gets a value indicating whether this &lt;see cref=&quot;DefaultLoggerProvider&quot; /&gt; is disposed.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DefaultLoggerProvider&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;minLevel&quot;&gt;The min level.&lt;/param&gt;
/// &lt;param name=&quot;timestampFormat&quot;&gt;The timestamp format.&lt;/param&gt;
⋮----
///     Creates the logger.
⋮----
/// &lt;param name=&quot;categoryName&quot;&gt;The category name.&lt;/param&gt;
public ILogger CreateLogger(string categoryName) =&gt;
⋮----
? throw new ObjectDisposedException(nameof(DefaultLoggerProvider), &quot;This logger provider is already disposed.&quot;)
⋮----
? throw new ArgumentException($&quot;This provider can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, {typeof(DiscordWebhookClient).FullName} or {typeof(DiscordOAuth2Client).FullName}.&quot;, nameof(categoryName))
: new DefaultLogger(this._minimumLevel, this._timestampFormat);
⋮----
///     Disposes the logger.
⋮----
public void Dispose()</file><file path="DisCatSharp/Logging/LoggerEvents.cs">/// &lt;summary&gt;
///     Contains well-defined event IDs used by core of DisCatSharp.
/// &lt;/summary&gt;
public static class LoggerEvents
⋮----
///     Miscellaneous events, that do not fit in any other category.
⋮----
///     Events pertaining to startup tasks.
⋮----
///     Events typically emitted whenever WebSocket connections fail or are terminated.
⋮----
///     Events pertaining to Discord-issued session state updates.
⋮----
///     Events emitted when exceptions are thrown in handlers attached to async events.
⋮----
///     Events emitted for various high-level WebSocket receive events.
⋮----
///     Events emitted for various low-level WebSocket receive events.
⋮----
///     Events emitted for various low-level WebSocket send events.
⋮----
///     Events emitted for various WebSocket payload processing failures, typically when deserialization or decoding fails.
⋮----
///     Events pertaining to connection lifecycle, specifically, heartbeats.
⋮----
///     Events pertaining to various heartbeat failures, typically fatal.
⋮----
///     Events pertaining to clean connection closes.
⋮----
///     Events emitted when REST processing fails for any reason.
⋮----
///     Events pertaining to the &lt;see cref=&quot;DiscordShardedClient&quot; /&gt; shard startup.
⋮----
///     Events pertaining to ratelimit exhaustion.
⋮----
///     Events pertaining to ratelimit diagnostics. Typically contain raw bucket info.
⋮----
///     Events emitted when a ratelimit is exhausted and a request is preemptively blocked.
⋮----
///     Events pertaining to audit log processing.
⋮----
///     Events containing raw (but decompressed) payloads, received from Discord Gateway.
⋮----
///     Events containing raw payloads, as they&apos;re being sent to Discord Gateway.
⋮----
///     Events pertaining to Gateway Intents. Typically diagnostic information.
⋮----
///     Events pertaining to autosharded client shard shutdown, clean or otherwise.
⋮----
///     Events pertaining to the &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;&apos;s shards not initializing correctly.
⋮----
///     Events containing raw payloads, as they&apos;re received from Discord&apos;s REST API.
⋮----
///     Events containing raw payloads, as they&apos;re sent to Discord&apos;s REST API.
⋮----
///     Event is rest cleaner.
⋮----
///     Event is rest hash mover.
⋮----
///     Events pertaining to Discord API requests from the &lt;see cref=&quot;DiscordShardedClient&quot; /&gt;.
⋮----
///     Events pertaining to API requests from the &lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt;.
⋮----
///     Events is library side.</file><file path="DisCatSharp/Logging/ShardedLoggerFactory.cs">/// &lt;summary&gt;
///     Represents a sharded logger factory.
/// &lt;/summary&gt;
internal class ShardedLoggerFactory : ILoggerFactory
⋮----
///     Gets the logger.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ShardedLoggerFactory&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;instance&quot;&gt;The instance.&lt;/param&gt;
⋮----
///     Adds a provider.
⋮----
/// &lt;param name=&quot;provider&quot;&gt;The provider to be added.&lt;/param&gt;
public void AddProvider(ILoggerProvider provider)
=&gt; throw new InvalidOperationException(&quot;This is a passthrough logger container, it cannot register new providers.&quot;);
⋮----
///     Creates a logger.
⋮----
/// &lt;param name=&quot;categoryName&quot;&gt;The category name.&lt;/param&gt;
public ILogger CreateLogger(string categoryName) =&gt;
⋮----
? throw new ArgumentException($&quot;This factory can only provide instances of loggers for {typeof(BaseDiscordClient).FullName}, not for {categoryName}&quot;, nameof(categoryName))
⋮----
///     Disposes the logger.
⋮----
public void Dispose()</file><file path="DisCatSharp/MediaTool.cs">/// &lt;summary&gt;
///     Tool to detect media formats and convert from binary data to base64 strings.
/// &lt;/summary&gt;
public sealed class MediaTool : IDisposable
⋮----
///     The PNG magic number.
⋮----
///     The first JPEG magic number.
⋮----
///     The second JPEG magic number.
⋮----
///     The first GIF magic number.
⋮----
///     The second GIF magic number.
⋮----
///     The first WEBP magic number.
⋮----
///     The second WEBP magic number.
⋮----
///     The GIF mask.
⋮----
///     The 32-bit mask.
⋮----
///     The 16-bit mask.
⋮----
///     The MP3 magic number.
⋮----
///     The OGG magic number.
⋮----
private const uint OGG_MAGIC = 0x5367_4F67; // &quot;OggS&quot; in ASCII
⋮----
///     The base64 cache.
⋮----
///     The media format cache.
⋮----
private MediaFormat _mfCache = MediaFormat.Unknown;
⋮----
///     Creates a new media tool from given stream.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;Stream to work with.&lt;/param&gt;
⋮----
ArgumentNullException.ThrowIfNull(stream);
⋮----
throw new ArgumentException(&quot;The stream needs to be both readable and seekable.&quot;, nameof(stream));
⋮----
this.SourceStream.Seek(0, SeekOrigin.Begin);
⋮----
///     Gets the stream this tool is operating on.
⋮----
///     Disposes this media tool.
⋮----
public void Dispose()
⋮----
///     Detects the format of this media.
⋮----
/// &lt;returns&gt;Detected format.&lt;/returns&gt;
public MediaFormat GetFormat()
⋮----
using var br = new BinaryReader(this.SourceStream, Utilities.UTF8, true);
var bgn64 = br.ReadUInt64();
⋮----
if (bgn32 is WEBP_MAGIC_1 &amp;&amp; br.ReadUInt32() is WEBP_MAGIC_2)
⋮----
this.SourceStream.Seek(-2, SeekOrigin.End);
if (br.ReadUInt16() is JPEG_MAGIC_2)
⋮----
// Check for MP3 magic number
if ((bgn32 &amp; 0xFFE0) == MP3_MAGIC) // MP3 has a 11-bit sync word: 0xFFE
⋮----
// Check for OGG magic number
⋮----
throw new InvalidDataException(&quot;The data within the stream was not valid media data.&quot;);
⋮----
///     Converts this media into base64 data format string.
⋮----
/// &lt;returns&gt;Data-scheme base64 string.&lt;/returns&gt;
public string GetBase64()
⋮----
var fmt = this.GetFormat();
var sb = new StringBuilder();
⋮----
sb.Append(&quot;data:&quot;)
.Append(fmt.ToMimeType())
.Append(&quot;;base64,&quot;);
⋮----
br += this.SourceStream.Read(buff, br, (int)this.SourceStream.Length - br);
⋮----
sb.Append(Convert.ToBase64String(buff));
⋮----
return this._b64Cache = sb.ToString();
⋮----
///     Utility function to convert a media stream into a base 64 string.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The stream.&lt;/param&gt;
/// &lt;returns&gt;The base 64 string.&lt;/returns&gt;
public static string Base64FromStream(Stream stream)
⋮----
using var mediatool = new MediaTool(stream);
return mediatool.GetBase64();
⋮----
///     Utility function to convert an optional media stream into an optional base 64 string.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The optional stream.&lt;/param&gt;
/// &lt;returns&gt;The optional base 64 string.&lt;/returns&gt;
public static Optional&lt;string?&gt; Base64FromStream(Optional&lt;Stream?&gt; stream)
⋮----
///     Represents format of a media.
⋮----
///     The format is unknown
⋮----
///     The format is a jpeg
⋮----
///     The format is a png
⋮----
///     The format is a gif
⋮----
///     The format is a webp
⋮----
///     The format will be automatically detected
⋮----
///     The format is an mp3
⋮----
///     The format is an ogg
⋮----
///     Extension methods for MediaFormatt
⋮----
public static class MediaFormattExtensions
⋮----
///     Detects the mime type.
⋮----
/// &lt;param name=&quot;format&quot;&gt;The media format&lt;/param&gt;
/// &lt;returns&gt;The mime type.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;&lt;/exception&gt;
public static string ToMimeType(this MediaFormat format)
⋮----
_ =&gt; throw new InvalidOperationException(&quot;Unknown media format.&quot;)</file><file path="DisCatSharp/Net/Abstractions/AuditLogAbstractions.cs">/// &lt;summary&gt;
///     Represents a audit log user.
/// &lt;/summary&gt;
internal sealed class AuditLogUser
⋮----
///     Gets or sets the username.
⋮----
///     Gets or sets the discriminator.
⋮----
///     Gets or sets the id.
⋮----
///     Gets or sets the avatar hash.
⋮----
///     Represents a audit log webhook.
⋮----
internal sealed class AuditLogWebhook
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the token.
⋮----
///     Gets or sets the guild id.
⋮----
///     Represents a audit log thread metadata.
⋮----
internal sealed class AuditLogThreadMetadata
⋮----
///     Gets whether the thread is archived.
⋮----
///     Gets the threads archive timestamp.
⋮----
///     Gets the threads auto archive duration.
⋮----
///     Gets whether the thread is locked.
⋮----
///     Represents a audit log thread.
⋮----
internal sealed class AuditLogThread
⋮----
///     Gets the thread id.
⋮----
///     Gets the thread guild id.
⋮----
///     Gets the thread parent channel id.
⋮----
///     Gets the thread owner id.
⋮----
///     Gets the thread type.
⋮----
///     Gets the thread name.
⋮----
///     Gets the thread last message id.
⋮----
///     Gets the thread metadata.
⋮----
///     Gets the thread approximate message count.
⋮----
///     Gets the thread member count.
⋮----
///     Gets the thread rate limit per user.
⋮----
///     Represents a audit log scheduled event.
⋮----
internal sealed class AuditLogGuildScheduledEvent
⋮----
///     Gets the scheduled event scheduled start time.
⋮----
///     Gets the scheduled event id.
⋮----
///     Gets the scheduled event guild id.
⋮----
///     Gets the scheduled event channel id.
⋮----
///     Gets the scheduled event creator id.
⋮----
///     Gets the scheduled event name.
⋮----
///     Gets the scheduled event description.
⋮----
///     Gets the scheduled event image.
⋮----
///     Gets the scheduled event scheduled end time.
⋮----
///     Gets the scheduled event status.
⋮----
///     Gets the scheduled event entity type.
⋮----
///     Gets the scheduled event entity id.
⋮----
///     Gets the scheduled event entity metadata.
⋮----
///     Gets the scheduled event sku ids.
⋮----
///     Represents a audit log scheduled event entity metadata.
⋮----
internal sealed class AuditLogGuildScheduledEventEntityMetadata
⋮----
///     Gets the scheduled events external location.
⋮----
///     Represents a audit log integration account.
⋮----
internal sealed class AuditLogIntegrationAccount
⋮----
///     Gets the account id.
⋮----
///     Gets the account name.
⋮----
///     Represents a audit log integration.
⋮----
internal sealed class AuditLogIntegration
⋮----
///     Gets the integration id.
⋮----
///     Gets the integration type.
⋮----
///     Gets the integration name.
⋮----
///     Gets the integration account.
⋮----
///     Represents a audit log action change.
⋮----
internal sealed class AuditLogActionChange
⋮----
// this can be a string or an array
⋮----
///     Gets or sets the old value.
⋮----
///     Gets the old values.
⋮----
///     Gets the old value ulong.
⋮----
///     Gets the old value string.
⋮----
///     Gets or sets the new value.
⋮----
///     Gets the new values.
⋮----
///     Gets the new value ulong.
⋮----
///     Gets the new value string.
⋮----
///     Gets or sets the key.
⋮----
///     Represents a audit log action options.
⋮----
internal sealed class AuditLogActionOptions
⋮----
///     Gets or sets the type.
⋮----
///     Gets or sets the message id.
⋮----
///     Gets or sets the count.
⋮----
///     Gets or sets the delete member days.
⋮----
///     Gets or sets the members removed.
⋮----
///     Represents a audit log action.
⋮----
internal sealed class AuditLogAction
⋮----
///     Gets or sets the target id.
⋮----
///     Gets or sets the user id.
⋮----
///     Gets or sets the action type.
⋮----
///     Gets or sets the changes.
⋮----
///     Gets or sets the options.
⋮----
///     Gets or sets the reason.
⋮----
///     Represents a audit log.
⋮----
internal sealed class AuditLog : ObservableApiObject
⋮----
/*
        /// &lt;summary&gt;
        /// Gets or sets the application commands.
        /// Related to Permissions V2.
        /// &lt;/summary&gt;
        [JsonProperty(&quot;application_commands&quot;)]
        public IReadOnlyList&lt;AuditLogApplicationCommand&gt; ApplicationCommands { get; set; }
        */
⋮----
///     Gets or sets the webhooks.
⋮----
///     Gets or sets the users.
⋮----
///     Gets or sets the entries.
⋮----
///     Gets or sets the scheduled events.
⋮----
///     Gets or sets the threads.
⋮----
///     Gets or sets the integrations.
///     Twitch related.</file><file path="DisCatSharp/Net/Abstractions/ClientProperties.cs">/// &lt;summary&gt;
///     Represents data for identify payload&apos;s client properties.
/// &lt;/summary&gt;
internal sealed class ClientProperties : ObservableApiObject
⋮----
///     Gets the client&apos;s operating system.
⋮----
if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
⋮----
if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
⋮----
if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
⋮----
var plat = RuntimeInformation.OSDescription.ToLowerInvariant();
if (plat.Contains(&quot;freebsd&quot;))
⋮----
if (plat.Contains(&quot;openbsd&quot;))
⋮----
if (plat.Contains(&quot;netbsd&quot;))
⋮----
if (plat.Contains(&quot;dragonfly&quot;))
⋮----
if (plat.Contains(&quot;miros bsd&quot;) || plat.Contains(&quot;mirbsd&quot;))
⋮----
if (plat.Contains(&quot;desktopbsd&quot;))
⋮----
return plat.Contains(&quot;darwin&quot;)
⋮----
: plat.Contains(&quot;unix&quot;)
⋮----
///     Gets the client&apos;s browser.
⋮----
var a = typeof(DiscordClient).GetTypeInfo().Assembly;
var an = a.GetName();
return $&quot;DisCatSharp {an.Version.ToString(4)}&quot;;
⋮----
///     Gets the client&apos;s device.
⋮----
///     Gets the client&apos;s referrer.
⋮----
///     Gets the client&apos;s referring domain.</file><file path="DisCatSharp/Net/Abstractions/FollowedChannelAddPayload.cs">/// &lt;summary&gt;
///     Represents a followed channel add payload.
/// &lt;/summary&gt;
internal sealed class FollowedChannelAddPayload : ObservableApiObject
⋮----
///     Gets or sets the webhook channel id.</file><file path="DisCatSharp/Net/Abstractions/Gateway/DiscordDispatchPayload.cs">/// &lt;summary&gt;
///     The discord dispatch.
/// &lt;/summary&gt;
internal sealed class DiscordDispatchPayload
⋮----
///     Gets or sets the op code.
⋮----
///     Gets or sets the payload.
⋮----
///     Gets or sets the sequence.
⋮----
///     Gets or sets the event name.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayHello.cs">/// &lt;summary&gt;
///     Represents data for a websocket hello payload.
/// &lt;/summary&gt;
internal sealed class GatewayHello
⋮----
///     Gets the target heartbeat interval (in milliseconds) requested by Discord.
⋮----
///     Gets debug data sent by Discord. This contains a list of servers to which the client is connected.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayIdentifyResume.cs">/// &lt;summary&gt;
///     Represents data for websocket identify payload.
/// &lt;/summary&gt;
internal sealed class GatewayIdentify
⋮----
///     Gets or sets the discord client.
⋮----
///     Gets or sets the token used to identify the client to Discord.
⋮----
///     Gets or sets the client&apos;s properties.
⋮----
///     Gets or sets whether to encrypt websocket traffic.
⋮----
///     Gets or sets the member count at which the guild is to be considered large.
⋮----
///     Gets or sets the shard info for this connection.
⋮----
///     Gets or sets the presence for this connection.
⋮----
///     Gets or sets the intent flags for this connection.
⋮----
internal sealed class GatewayResume
⋮----
///     Gets or sets the session id used to resume last session.
⋮----
///     Gets or sets the last received sequence number.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayInfo.cs">/// &lt;summary&gt;
///     Represents information used to identify with Discord.
/// &lt;/summary&gt;
public sealed class GatewayInfo
⋮----
///     Gets the gateway URL for the WebSocket connection.
⋮----
///     Gets the recommended amount of shards.
⋮----
///     Gets the session start limit data.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayOpCode.cs">/// &lt;summary&gt;
///     Specifies an OP code in a gateway payload.
/// &lt;/summary&gt;
⋮----
///     Used for dispatching events.
⋮----
///     Used for pinging the gateway or client, to ensure the connection is still alive.
⋮----
///     Used for initial handshake with the gateway.
⋮----
///     Used to update client status.
⋮----
///     Used to update voice state, when joining, leaving, or moving between voice channels.
⋮----
///     Used for pinging the voice gateway or client, to ensure the connection is still alive.
⋮----
///     Used to resume a closed connection.
⋮----
///     Used to notify the client that it has to reconnect.
⋮----
///     Used to request guild members.
⋮----
///     Used to notify the client about an invalidated session.
⋮----
///     Used by the gateway upon connecting.
⋮----
///     Used to acknowledge a heartbeat.
⋮----
///     Used to request guild synchronization.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayPayload.cs">/// &lt;summary&gt;
///     Represents a websocket payload exchanged between Discord and the client.
/// &lt;/summary&gt;
internal sealed class GatewayPayload : ObservableApiObject
⋮----
///     Gets or sets the OP code of the payload.
⋮----
///     Gets or sets the data of the payload.
⋮----
///     Gets or sets the sequence number of the payload. Only present for OP 0.
⋮----
///     Gets or sets the event name of the payload. Only present for OP 0.</file><file path="DisCatSharp/Net/Abstractions/Gateway/GatewayRequestGuildMembers.cs">/// &lt;summary&gt;
///     Request guild members.
/// &lt;/summary&gt;
internal sealed class GatewayRequestGuildMembers : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GatewayRequestGuildMembers&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
⋮----
///     Gets the guild id.
⋮----
///     Gets the query.
⋮----
///     Gets the limit.
⋮----
///     Gets whether presences should be returned.
⋮----
///     Gets the user ids.
⋮----
///     Gets the nonce.</file><file path="DisCatSharp/Net/Abstractions/Gateway/SoundboardSoundsPayloads.cs">/// &lt;summary&gt;
///     Represents a payload for requesting soundboard sounds for specific guilds.
/// &lt;/summary&gt;
internal sealed class RequestSoundboardSoundsPayload : ObservableApiObject
⋮----
///     Gets or sets the list of guild IDs for which to request soundboard sounds.
⋮----
///     Represents the payload for the soundboard sounds event response.
⋮----
internal sealed class SoundboardSoundsEventPayload : ObservableApiObject
⋮----
///     Gets or sets the guild ID associated with the soundboard sounds.
⋮----
///     Gets or sets the list of soundboard sounds in the guild.</file><file path="DisCatSharp/Net/Abstractions/Gateway/VoiceStateUpdatePayload.cs">/// &lt;summary&gt;
///     The discord voice state update payload.
/// &lt;/summary&gt;
internal sealed class VoiceStateUpdatePayload : ObservableApiObject
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the user id.
⋮----
///     Gets or sets the session id.
⋮----
///     Gets or sets a value indicating whether deafened.
⋮----
///     Gets or sets a value indicating whether muted.</file><file path="DisCatSharp/Net/Abstractions/IOAuth2Payload.cs">/// &lt;summary&gt;
///     Represents a OAuth2 payload.
/// &lt;/summary&gt;
internal interface IOAuth2Payload
⋮----
///     Gets or sets the access token.</file><file path="DisCatSharp/Net/Abstractions/ReadyPayload.cs">/// &lt;summary&gt;
///     Represents data for websocket ready event payload.
/// &lt;/summary&gt;
internal sealed class ReadyPayload : ObservableApiObject
⋮----
///     Creates a new instance of &lt;see cref=&quot;ReadyPayload&quot; /&gt;.
⋮----
///     Gets the gateway version the client is connected to.
⋮----
///     Gets the current user.
⋮----
///     &lt;para&gt;Gets the current shard.&lt;/para&gt;
///     &lt;para&gt;The first &lt;see langword=&quot;int&quot; /&gt; will be the shard id.&lt;/para&gt;
///     &lt;para&gt;The last &lt;see langword=&quot;int&quot; /&gt; will be the total shard count.&lt;/para&gt;
⋮----
///     Gets the session type. Should be always &quot;normal&quot;.
⋮----
///     Gets the current session&apos;s ID.
⋮----
///     The gateway url for resuming connections
⋮----
///     Gets the guilds available for this shard.
///     &lt;para&gt;These will be unavailable at the start.&lt;/para&gt;
⋮----
///     Gets the closest geo ordered rtc regions recommended for the current user.
⋮----
///     Gets the current (detected) location(s).
⋮----
///     Gets the application id and flags.
⋮----
///     Gets debug data sent by Discord. This contains a list of servers to which the client is connected.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestApplicationCommandPayloads.cs">/// &lt;summary&gt;
///     Represents a application command create payload.
/// &lt;/summary&gt;
internal sealed class RestApplicationCommandCreatePayload : ObservableApiObject
⋮----
///     Gets the type.
⋮----
///     Gets the name.
⋮----
///     Gets the name localizations.
⋮----
///     Gets the description.
⋮----
///     Gets the description localizations.
⋮----
///     Gets the options.
⋮----
///     Whether the command is allowed for everyone.
⋮----
///     The command needed permissions.
⋮----
///     Whether the command is marked as NSFW.
⋮----
///     Gets where the command is allowed at.
⋮----
///     Gets the allowed integration types.
⋮----
///     Represents a application command edit payload.
⋮----
internal sealed class RestApplicationCommandEditPayload : ObservableApiObject
⋮----
///     Whether the command is allowed for dms.
⋮----
///     Represents an interaction response payload.
⋮----
internal sealed class RestInteractionResponsePayload : ObservableApiObject
⋮----
///     Gets the data.
⋮----
///     Represents an interaction response modal payload.
⋮----
internal sealed class RestInteractionModalResponsePayload : ObservableApiObject
⋮----
///     Represents an interaction response iFrame payload.
⋮----
internal sealed class RestInteractionIframeResponsePayload : ObservableApiObject
⋮----
///     Represents a followup message create payload.
⋮----
internal sealed class RestFollowupMessageCreatePayload : ObservableApiObject
⋮----
///     Gets the content.
⋮----
///     Get whether the message is tts.
⋮----
///     Gets the embeds.
⋮----
///     Gets the mentions.
⋮----
///     Gets the flags.
⋮----
///     Gets the components.
⋮----
///     Gets attachments.
⋮----
///     Gets or sets the poll request.
⋮----
///     Represents a role connection metadata payload.
⋮----
internal sealed class RestApplicationRoleConnectionMetadataPayload : ObservableApiObject
⋮----
///     Gets the metadata type.
⋮----
///     Gets the metadata key.
⋮----
///     Gets the metadata name.
⋮----
///     Gets the metadata description.
⋮----
///     Gets the metadata name translations.
⋮----
///     Gets the metadata description localizations.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestApplicationPayloads.cs">internal sealed class RestApplicationModifyPayload : ObservableApiObject
⋮----
/// &lt;summary&gt;
///     Gets or sets the description.
/// &lt;/summary&gt;
⋮----
///     Gets or sets the interactions endpoint url.
⋮----
///     Gets or sets the role connections verification url.
⋮----
///     Gets or sets the custom install url.
⋮----
///     Gets or sets the tags.
⋮----
///     Gets or sets the icon base64.
⋮----
///     Gets or sets the cover image base64.
⋮----
///     Gets or sets the application flags.
⋮----
///     Gets or sets the install params.
⋮----
///     Gets or sets the integration types config.
⋮----
///     Represents a application emoji modify payload.
⋮----
internal class RestApplicationEmojiModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the name.
⋮----
///     Represents a application emoji create payload.
⋮----
internal sealed class RestApplicationEmojiCreatePayload : RestApplicationEmojiModifyPayload
⋮----
///     Gets or sets the image b64.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestAutomodRuleModifyPayload.cs">internal sealed class RestAutomodRuleModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestForumPostTagPayloads.cs">/// &lt;summary&gt;
///     Represents the forum tag payload.
/// &lt;/summary&gt;
internal sealed class RestForumPostTagPayloads : ObservableApiObject
⋮----
///     Sets the tags&apos;s new name.
⋮----
///     Sets the tags&apos;s new emoji.
⋮----
///     Sets whether the tag should be mod only.
⋮----
///     Gets the unicode emoji of the forum post tag.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildScheduledEventPayloads.cs">/// &lt;summary&gt;
///     The rest guild scheduled event create payload.
/// &lt;/summary&gt;
internal sealed class RestGuildScheduledEventCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the entity metadata.
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the description.
⋮----
///     Gets or sets the time to schedule the scheduled event.
⋮----
///     Gets or sets the time when the scheduled event is scheduled to end.
⋮----
///     Gets or sets the entity type of the scheduled event.
⋮----
///     Gets or sets the image as base64.
⋮----
///     Gets or sets the recurrence rule.
⋮----
///     Gets or sets the privacy level of the scheduled event.
⋮----
///     The rest guild scheduled event modify payload.
⋮----
internal sealed class RestGuildScheduledEventModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the cover image as base64.
⋮----
///     Gets or sets the status of the scheduled event.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildSoundboardSoundPayloads.cs">/// &lt;summary&gt;
///     Represents a payload for creating a soundboard sound.
/// &lt;/summary&gt;
internal sealed class RestSoundboardSoundCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the name of the soundboard sound.
⋮----
///     Gets or sets the sound data.
⋮----
///     Gets or sets the volume of the soundboard sound (0 to 1).
⋮----
///     Gets or sets the emoji id for the soundboard sound&apos;s custom emoji.
⋮----
///     Gets or sets the emoji name for the soundboard sound&apos;s standard emoji.
⋮----
///     Represents a payload for modifying a soundboard sound.
⋮----
internal sealed class RestSoundboardSoundModifyPayload : ObservableApiObject
⋮----
///     Represents a payload for sending a soundboard sound to a voice channel.
⋮----
internal sealed class RestSendSoundboardSoundPayload : ObservableApiObject
⋮----
///     Gets or sets the ID of the soundboard sound to play.
⋮----
///     Gets or sets the ID of the guild the soundboard sound is from.
///     This field is required when the sound is from a different server.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestOAuth2ApplicationRoleConnectionPayload.cs">/// &lt;summary&gt;
///     Represents the oauth2 application role connection payload.
/// &lt;/summary&gt;
internal sealed class RestOAuth2ApplicationRoleConnectionPayload : ObservableApiObject
⋮----
///     Sets the role connections new platform name.
⋮----
///     Sets the role connections new platform username.
⋮----
///     Sets the role connections new metadata.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStageInstancePayloads.cs">/// &lt;summary&gt;
///     Represents a stage instance create payload.
/// &lt;/summary&gt;
internal sealed class RestStageInstanceCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the topic.
⋮----
///     Gets or sets the associated scheduled event id.
⋮----
///     Whether everyone should be notified about the start.
⋮----
///     Represents a stage instance modify payload.
⋮----
internal sealed class RestStageInstanceModifyPayload : ObservableApiObject</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStickerPayloads.cs">/// &lt;summary&gt;
///     Represents a sticker modify payload.
/// &lt;/summary&gt;
internal sealed class RestStickerModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the description.
⋮----
///     Gets or sets the tags.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestStorePayloads.cs">/// &lt;summary&gt;
///     Represents a test entitlement create payload.
/// &lt;/summary&gt;
internal sealed class TestEntitlementCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the sku to grant entitlement to, as Discord for this value.
⋮----
///     Gets or sets the guild id or user id to grant entitlement to.
⋮----
///     Gets or sets the type of subscription (guild, user).</file><file path="DisCatSharp/Net/Abstractions/Rest/RestUserPayloads.cs">/// &lt;summary&gt;
///     Represents a user dm create payload.
/// &lt;/summary&gt;
internal sealed class RestUserDmCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the recipient.
⋮----
///     Represents a user group dm create payload.
⋮----
internal sealed class RestUserGroupDmCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the access tokens.
⋮----
///     Gets or sets the nicknames.
⋮----
///     Represents a user update current payload.
⋮----
internal sealed class RestUserUpdateCurrentPayload : ObservableApiObject
⋮----
///     Gets or sets the username.
⋮----
///     Gets or sets the avatar base64.
⋮----
///     Gets or sets a value indicating whether avatar set.
⋮----
///     Gets or sets the banner base64.
⋮----
///     Gets or sets a value indicating whether banner set.
⋮----
///     Gets whether the avatar should be serialized.
⋮----
public bool ShouldSerializeAvatarBase64()
⋮----
///     Gets whether the banner should be serialized.
⋮----
public bool ShouldSerializeBannerBase64()
⋮----
///     Represents a user guild.
⋮----
internal sealed class RestUserGuild : ObservableApiObject
⋮----
///     Gets the id.
⋮----
///     Gets the name.
⋮----
///     Gets the icon hash.
⋮----
///     Gets a value indicating whether is owner.
⋮----
///     Gets the permissions.
⋮----
///     Gets the guild features.
⋮----
///     Represents a user guild list payload.
⋮----
internal sealed class RestUserGuildListPayload : ObservableApiObject
⋮----
///     Gets or sets the limit.
⋮----
///     Gets or sets the before.
⋮----
///     Gets or sets the after.</file><file path="DisCatSharp/Net/Abstractions/ShardInfo.cs">/// &lt;summary&gt;
///     Represents data for identify payload&apos;s shard info.
/// &lt;/summary&gt;
⋮----
internal sealed class ShardInfo
⋮----
///     Gets or sets this client&apos;s shard id.
⋮----
///     Gets or sets the total shard count for this token.
⋮----
///     Represents a shard info converter.
⋮----
internal sealed class ShardInfoConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
⋮----
serializer.Serialize(writer, obj);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
⋮----
var arr = this.ReadArrayObject(reader, serializer);
return new ShardInfo
⋮----
///     Reads the array object.
⋮----
private JArray ReadArrayObject(JsonReader reader, JsonSerializer serializer) =&gt;
⋮----
? throw new JsonSerializationException(&quot;Expected array of length 2&quot;)
⋮----
///     Whether this can be converted.
⋮----
public override bool CanConvert(Type objectType) =&gt; objectType == typeof(ShardInfo);</file><file path="DisCatSharp/Net/Abstractions/StatusUpdate.cs">/// &lt;summary&gt;
///     Represents data for websocket status update payload.
/// &lt;/summary&gt;
internal sealed class StatusUpdate : ObservableApiObject
⋮----
///     Gets the activities.
⋮----
///     Gets or sets the unix millisecond timestamp of when the user went idle.
⋮----
///     Gets or sets whether the user is AFK.
⋮----
///     Gets or sets the status of the user.
⋮----
///     Gets the status string of the user.
⋮----
///     Gets or sets the game the user is playing.</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportActivity.cs">/// &lt;summary&gt;
///     Represents a game a user is playing.
/// &lt;/summary&gt;
internal sealed class TransportActivity : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportActivity&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
⋮----
///     Gets or sets the id of user&apos;s activity.
⋮----
///     Gets or sets the name of the game the user is playing.
⋮----
///     Gets or sets the stream URI, if applicable.
⋮----
///     Gets or sets the livestream type.
⋮----
///     Gets or sets the details.
///     &lt;para&gt;This is a component of the rich presence, and, as such, can only be used by regular users.&lt;/para&gt;
⋮----
///     Gets or sets game state.
⋮----
///     Gets the emoji details for a custom status, if any.
⋮----
///     Gets ID of the application for which this rich presence is for.
///     This is a component of the rich presence, and, as such, can only be used by regular users.
⋮----
get =&gt; this.ApplicationIdStr != null ? ulong.Parse(this.ApplicationIdStr, CultureInfo.InvariantCulture) : null;
⋮----
///     Gets or sets the application id string.
⋮----
///     Gets or sets instance status.
⋮----
///     Gets or sets information about the current game&apos;s party.
⋮----
///     Gets or sets information about assets related to this rich presence.
⋮----
///     Gets or sets information about buttons in this rich presence.
⋮----
///     Gets or sets platform in this rich presence.
⋮----
///     Gets or sets sync_id in this rich presence.
⋮----
///     Gets or sets session_id in this rich presence.
⋮----
///     Gets or sets information about current game&apos;s timestamps.
⋮----
///     Gets or sets information about current game&apos;s secret values.
⋮----
///     Whether this activity is a rich presence.
⋮----
public bool IsRichPresence()
⋮----
///     Whether this activity is a custom status.
⋮----
public bool IsCustomStatus()
⋮----
///     Represents information about assets attached to a rich presence.
⋮----
public class PresenceAssets
⋮----
///     Gets the large image asset ID.
⋮----
///     Gets the large image text.
⋮----
///     Gets the small image asset ID.
⋮----
///     Gets the small image text.
⋮----
///     Represents information about rich presence game party.
⋮----
public class GameParty
⋮----
///     Gets the game party ID.
⋮----
///     Gets the size of the party.
⋮----
///     Represents information about party size.
⋮----
public class GamePartySize
⋮----
///     Gets the current number of players in the party.
⋮----
///     Gets the maximum party size.
⋮----
///     Represents information about the game state&apos;s timestamps.
⋮----
public class GameTimestamps
⋮----
///     Gets the time the game has started.
⋮----
=&gt; this.StartInternal != null ? Utilities.GetDateTimeOffsetFromMilliseconds(this.StartInternal.Value, false) : null;
⋮----
///     Gets the time the game is going to end.
⋮----
=&gt; this.EndInternal != null ? Utilities.GetDateTimeOffsetFromMilliseconds(this.EndInternal.Value, false) : null;
⋮----
///     Represents information about secret values for the Join, Spectate, and Match actions.
⋮----
public class GameSecrets
⋮----
///     Gets the secret value for join action.
⋮----
///     Gets the secret value for match action.
⋮----
///     Gets the secret value for spectate action.
⋮----
///     Represents a game party size converter.
⋮----
internal sealed class GamePartySizeConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
⋮----
serializer.Serialize(writer, obj);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
⋮----
var arr = this.ReadArrayObject(reader, serializer);
⋮----
///     Reads the array object.
⋮----
private JArray ReadArrayObject(JsonReader reader, JsonSerializer serializer) =&gt;
⋮----
? throw new JsonSerializationException(&quot;Expected array of length 2&quot;)
⋮----
///     Whether it can convert.
⋮----
public override bool CanConvert(Type objectType) =&gt; objectType == typeof(TransportActivity.GameParty.GamePartySize);</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportApplication.cs">/// &lt;summary&gt;
///     The transport application.
/// &lt;/summary&gt;
internal sealed class TransportApplication : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportApplication&quot; /&gt; class.
⋮----
///     Gets or sets the id.
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the icon hash.
⋮----
///     Gets or sets the description.
⋮----
///     Gets or sets the summary.
⋮----
///     Gets the bot user.
⋮----
///     Whether the bot is public.
⋮----
///     Gets or sets the flags.
⋮----
///     Gets or sets the terms of service url.
⋮----
///     Gets or sets the privacy policy url.
⋮----
///     Gets or sets a value indicating whether the bot requires code grant.
⋮----
///     Gets or sets a value indicating whether the bot is a hook.
⋮----
///     Gets or sets the rpc origins.
⋮----
///     Gets or sets the owner.
⋮----
///     Gets or sets the team.
⋮----
///     Gets or sets the verify key.
⋮----
///     Gets or sets the guild id.
⋮----
///     Gets or sets the partial guild.
⋮----
///     Gets or sets the primary sku id.
⋮----
///     Gets or sets the slug.
⋮----
///     Gets or sets the cover image hash.
⋮----
///     Gets or sets the custom install url.
⋮----
///     Gets or sets the install params.
⋮----
///     Gets or sets the role connection verification entry point.
⋮----
///     Gets or sets the tags.
⋮----
///     Gets or sets the approximate guild count.
⋮----
///     Gets or sets the approximate user install count.
⋮----
///     Gets or sets the interactions endpoint url.
⋮----
///     Gets or sets the integration types config.
⋮----
///     Gets or sets whether the application is monetized.
⋮----
///     Gets or sets whether the application is verified.
⋮----
///     Gets or sets whether the storefront is available.
⋮----
///     Gets or sets the interaction event types.
⋮----
///     Gets or sets the interactions version.
⋮----
///     Gets or sets the explicit content filter level.
⋮----
///     Gets or sets the RPC application state.
⋮----
///     Gets or sets the store application state.
⋮----
///     Gets or sets the verification state.
⋮----
///     Gets or sets whether the integration is public.
⋮----
///     Gets or sets whether the integration requires code grant.
⋮----
///     Gets or sets the discoverability state.
⋮----
///     Gets or sets the discovery eligibility flags.
⋮----
///     Gets or sets the monetization state.
⋮----
///     Gets or sets the verification eligibility flags.
⋮----
///     Gets or sets the monetization eligibility flags.
⋮----
///     Gets or sets the internal guild restriction level.</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportMember.cs">/// &lt;summary&gt;
///     Represents a transport member.
/// &lt;/summary&gt;
internal class TransportMember : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportMember&quot; /&gt; class.
⋮----
///     Gets the avatar hash.
⋮----
///     Gets the guild avatar hash.
⋮----
///     Gets the guild banner hash.
⋮----
///     Gets the guild avatar decoration data.
⋮----
///     Gets the guild bio.
///     This is not available to bots tho.
⋮----
///     Gets the members&apos;s pronouns.
⋮----
///     Gets the user.
⋮----
///     Gets the nickname.
⋮----
///     Gets the roles.
⋮----
///     Gets the joined at.
⋮----
///     Whether this member is deafened.
⋮----
///     Whether this member is muted.
⋮----
///     Gets the premium since.
⋮----
///     Whether this member is marked as pending.
⋮----
///     Gets the timeout time.
⋮----
///     Gets the unusual dm activity time.
⋮----
///     Gets the members flags.
⋮----
///     Gets the members permissions.
⋮----
///     Gets ID of the guild to which this member belongs.</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportTeam.cs">/// &lt;summary&gt;
///     The transport team.
/// &lt;/summary&gt;
internal sealed class TransportTeam : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportTeam&quot; /&gt; class.
⋮----
///     Gets or sets the id.
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the icon hash.
⋮----
///     Gets or sets the owner id.
⋮----
///     Gets or sets the members.
⋮----
///     The transport team member.
⋮----
internal sealed class TransportTeamMember
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportTeamMember&quot; /&gt; class.
⋮----
///     Gets or sets the membership state.
⋮----
///     Gets or sets the permissions.
⋮----
///     Gets the member&apos;s role within the team.
///     &lt;para&gt;Can be &lt;c&gt;owner&lt;/c&gt;, &lt;c&gt;admin&lt;/c&gt;, &lt;c&gt;developer&lt;/c&gt; or &lt;c&gt;read-only&lt;/c&gt;.&lt;/para&gt;
⋮----
///     Gets or sets the team id.
⋮----
///     Gets or sets the user.</file><file path="DisCatSharp/Net/Abstractions/VoiceStateUpdate.cs">/// &lt;summary&gt;
///     Represents data for websocket voice state update payload.
/// &lt;/summary&gt;
internal sealed class VoiceStateUpdate : ObservableApiObject
⋮----
///     Gets or sets the guild for which the user is updating their voice state.
⋮----
///     Gets or sets the channel user wants to connect to. Null if disconnecting.
⋮----
///     Gets or sets whether the client is muted.
⋮----
///     Gets or sets whether the client is deafened.</file><file path="DisCatSharp/Net/ConnectionEndpoint.cs">/// &lt;summary&gt;
///     Represents a network connection endpoint.
/// &lt;/summary&gt;
⋮----
///     Gets or sets the hostname associated with this endpoint.
⋮----
///     Gets or sets the port associated with this endpoint.
⋮----
///     Gets or sets the secured status of this connection.
⋮----
///     Creates a new endpoint structure.
⋮----
/// &lt;param name=&quot;hostname&quot;&gt;Hostname to connect to.&lt;/param&gt;
/// &lt;param name=&quot;port&quot;&gt;Port to use for connection.&lt;/param&gt;
/// &lt;param name=&quot;secured&quot;&gt;Whether the connection should be secured (https/wss).&lt;/param&gt;
⋮----
///     Gets the hash code of this endpoint.
⋮----
/// &lt;returns&gt;Hash code of this endpoint.&lt;/returns&gt;
public readonly override int GetHashCode()
=&gt; 13 + (7 * this.Hostname.GetHashCode()) + (7 * this.Port);
⋮----
///     Gets the string representation of this connection endpoint.
⋮----
/// &lt;returns&gt;String representation of this endpoint.&lt;/returns&gt;
public readonly override string ToString()
⋮----
///     Returns a http string.
⋮----
internal readonly string ToHttpString()
⋮----
///     Returns a web socket string.
⋮----
internal readonly string ToWebSocketString()</file><file path="DisCatSharp/Net/Models/ApplicationCommandEditModel.cs">/// &lt;summary&gt;
///     Represents an application command edit model.
/// &lt;/summary&gt;
public class ApplicationCommandEditModel : ObservableApiObject
⋮----
///     The command&apos;s new description.
⋮----
///     The command&apos;s new name.
⋮----
///     Sets the command&apos;s new name.
⋮----
throw new ArgumentException(&quot;Application command name cannot exceed 32 characters.&quot;, nameof(value));
⋮----
///     Sets the command&apos;s new description.
⋮----
throw new ArgumentException(&quot;Application command description cannot exceed 100 characters.&quot;, nameof(value));
⋮----
///     Sets the command&apos;s name localizations.
⋮----
///     Sets the command&apos;s description localizations.
⋮----
///     Sets the command&apos;s new options.
⋮----
///     Sets the command&apos;s needed permissions.
⋮----
///     Sets the command&apos;s allowed contexts.
⋮----
///     Sets the command&apos;s allowed integration types.
⋮----
///     Sets whether the command is marked as NSFW.</file><file path="DisCatSharp/Net/Models/AutomodRuleEditModel.cs">/// &lt;summary&gt;
///     Represents an automod rule edit model.
/// &lt;/summary&gt;
public class AutomodRuleEditModel : BaseEditModel
⋮----
///     Sets the rule&apos;s new name.
⋮----
///     Sets the rule&apos;s event type.
⋮----
///     Sets the rule&apos;s trigger metadata.
⋮----
///     Sets the rule&apos;s actions.
⋮----
///     Sets whether the rule is enabled.
⋮----
///     Sets the roles exempt from the rule.
⋮----
///     Sets the channels exempt from the rule.</file><file path="DisCatSharp/Net/Models/BaseEditModel.cs">/// &lt;summary&gt;
///     Represents the base edit model.
/// &lt;/summary&gt;
public class BaseEditModel
⋮----
///     Reason given in audit logs</file><file path="DisCatSharp/Net/Models/ChannelEditModel.cs">/// &lt;summary&gt;
///     Represents a channel edit model.
/// &lt;/summary&gt;
public class ChannelEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelEditModel&quot; /&gt; class.
⋮----
///     Sets the channel&apos;s new name.
⋮----
///     Sets the channel&apos;s type.
///     This can only be used to convert between text and news channels.
⋮----
///     Sets the channel&apos;s new position.
⋮----
///     Sets the channel&apos;s new topic.
⋮----
///     Sets whether the channel is to be marked as NSFW.
⋮----
///     &lt;para&gt;Sets the parent of this channel.&lt;/para&gt;
///     &lt;para&gt;
///         This should be channel with &lt;see cref=&quot;DisCatSharp.Entities.DiscordChannel.Type&quot; /&gt; set to
///         &lt;see cref=&quot;ChannelType.Category&quot; /&gt;.
///     &lt;/para&gt;
⋮----
///     Sets the voice channel&apos;s new bitrate.
⋮----
///     &lt;para&gt;Sets the voice channel&apos;s new user limit.&lt;/para&gt;
///     &lt;para&gt;Setting this to 0 will disable the user limit.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the channel&apos;s new slow mode timeout.&lt;/para&gt;
///     &lt;para&gt;Setting this to null or 0 will disable slow mode.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the voice channel&apos;s region override.&lt;/para&gt;
///     &lt;para&gt;Setting this to null will set it to automatic.&lt;/para&gt;
⋮----
///     Sets the voice channel&apos;s video quality.
⋮----
///     Sets this channel&apos;s default duration for newly created threads, in minutes, to automatically archive the thread
///     after recent activity.
⋮----
///     Sets the channel&apos;s permission overwrites.
⋮----
///     Sets the channel&apos;s default forum layout.
⋮----
///     Sets the channel&apos;s flags.</file><file path="DisCatSharp/Net/Models/ForumPostTagEditModel.cs">/// &lt;summary&gt;
///     Represents a tag edit model.
/// &lt;/summary&gt;
public class ForumPostTagEditModel : BaseEditModel
⋮----
///     Sets the tags&apos;s new name.
⋮----
///     Sets the tags&apos;s new emoji.
⋮----
///     Sets whether the tag should be mod only.</file><file path="DisCatSharp/Net/Models/MemberEditModel.cs">/// &lt;summary&gt;
///     Represents a member edit model.
/// &lt;/summary&gt;
public class MemberEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MemberEditModel&quot; /&gt; class.
⋮----
///     New nickname
⋮----
///     New roles
⋮----
///     Whether this user should be muted
⋮----
///     Whether this user should be deafened
⋮----
///     Voice channel to move this user to, set to null to kick</file><file path="DisCatSharp/Net/Models/MembershipScreeningEditModel.cs">/// &lt;summary&gt;
///     Represents a membership screening edit model.
/// &lt;/summary&gt;
public class MembershipScreeningEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MembershipScreeningEditModel&quot; /&gt; class.
⋮----
///     Sets whether membership screening should be enabled for this guild.
⋮----
///     Sets the server description shown in the membership screening form.
⋮----
///     Sets the fields in this membership screening form.</file><file path="DisCatSharp/Net/Models/RoleEditModel.cs">/// &lt;summary&gt;
///     Represents a role edit model.
/// &lt;/summary&gt;
public sealed class RoleEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RoleEditModel&quot; /&gt; class.
⋮----
///     The new role name.
⋮----
///     The new role permissions.
⋮----
///     The new role color.
⋮----
///     The new role colors.
///     &lt;para&gt;
///         When using a holographic role style, the following colors must be set: primary (11127295), secondary
///         (16759788), tertiary (16761760). It cannot be any other value.
///     &lt;/para&gt;
⋮----
///     Whether new role should be hoisted (Shown in the sidebar)
⋮----
///     Whether new role should be mentionable.
⋮----
///     The new role icon.
⋮----
///     The new role icon from unicode emoji.</file><file path="DisCatSharp/Net/Models/ScheduledEventEditModel.cs">/// &lt;summary&gt;
///     Represents a scheduled event edit model.
/// &lt;/summary&gt;
public class ScheduledEventEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ScheduledEventEditModel&quot; /&gt; class.
⋮----
///     Gets or sets the channel.
⋮----
///     Gets or sets the location.
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the description.
⋮----
///     Gets or sets the time to schedule the scheduled event.
⋮----
///     Gets or sets the time when the scheduled event is scheduled to end.
⋮----
///     Gets or sets the entity type of the scheduled event.
⋮----
///     Gets or sets the cover image as base64.
⋮----
///     Gets or sets the status of the scheduled event.
⋮----
///     Gets or sets the recurrence rule.</file><file path="DisCatSharp/Net/Models/SoundboardSoundEditModel.cs">/// &lt;summary&gt;
///     Represents a model for editing a soundboard sound.
/// &lt;/summary&gt;
public sealed class SoundboardSoundEditModel : ObservableApiObject
⋮----
///     Gets the sound&apos;s new name.
⋮----
///     Gets the sound&apos;s new volume.
⋮----
///     Sets the soundboard sound&apos;s new name.
⋮----
throw new ArgumentException(&quot;Soundboard sound name cannot exceed 100 characters.&quot;, nameof(value));
⋮----
///     Sets the soundboard sound&apos;s volume (between 0.0 and 1.0).
⋮----
throw new ArgumentException(&quot;Soundboard sound volume must be between 0.0 and 1.0.&quot;, nameof(value));
⋮----
///     Sets the soundboard sound&apos;s emoji id for a custom emoji.
⋮----
///     Sets the soundboard sound&apos;s emoji name for a standard emoji.</file><file path="DisCatSharp/Net/Models/ThreadEditModel.cs">/// &lt;summary&gt;
///     Represents a thread edit model.
/// &lt;/summary&gt;
public class ThreadEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ThreadEditModel&quot; /&gt; class.
⋮----
///     Sets the thread&apos;s new name.
⋮----
///     Sets the thread&apos;s locked state.
⋮----
///     Sets the thread&apos;s archived state.
⋮----
///     Sets the thread&apos;s auto archive duration.
⋮----
///     Sets the thread&apos;s new user rate limit.
⋮----
///     Sets the thread&apos;s invitable state.
⋮----
///     Whether the thread is pinned within the &lt;see cref=&quot;ChannelType.Forum&quot;&gt;forum&lt;/see&gt; channel.
⋮----
///     Sets the thread&apos;s applied tags.</file><file path="DisCatSharp/Net/Models/WelcomeScreenEditModel.cs">/// &lt;summary&gt;
///     Represents a welcome screen edit model.
/// &lt;/summary&gt;
public class WelcomeScreenEditModel
⋮----
///     Sets whether the welcome screen should be enabled.
⋮----
///     Sets the welcome channels.
⋮----
///     Sets the serer description shown.</file><file path="DisCatSharp/Net/Rest/BaseRestRequest.cs">/// &lt;summary&gt;
///     Represents a request sent over HTTP.
/// &lt;/summary&gt;
public abstract class BaseRestRequest
⋮----
///     Creates a new &lt;see cref=&quot;BaseRestRequest&quot; /&gt; with specified parameters.
⋮----
/// &lt;param name=&quot;client&quot;&gt;&lt;see cref=&quot;DiscordClient&quot; /&gt; from which this request originated.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;Rate limit bucket to place this request in.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;Uri to which this request is going to be sent to.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;Method to use for this request,&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The generic route the request url will use.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;Additional headers for this request.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitWaitOverride&quot;&gt;Override for ratelimit bucket wait time.&lt;/param&gt;
⋮----
headers = headers.Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x.Key, Uri.EscapeDataString(x.Value)))
.ToDictionary(x =&gt; x.Key, x =&gt; x.Value);
⋮----
/// &lt;param name=&quot;client&quot;&gt;&lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt; from which this request originated.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the oauth2 client.
⋮----
///     Gets the request task source.
⋮----
///     Gets the url to which this request is going to be made.
⋮----
///     Gets the HTTP method used for this request.
⋮----
///     Gets the generic path (no parameters) for this request.
⋮----
///     Gets the headers sent with this request.
⋮----
///     Gets the override for the rate limit bucket wait time.
⋮----
///     Gets the rate limit bucket this request is in.
⋮----
///     Asynchronously waits for this request to complete.
⋮----
/// &lt;returns&gt;HTTP response to this request.&lt;/returns&gt;
public Task&lt;RestResponse&gt; WaitForCompletionAsync()
⋮----
///     Sets as completed.
⋮----
/// &lt;param name=&quot;response&quot;&gt;The response to set.&lt;/param&gt;
protected internal void SetCompleted(RestResponse response)
=&gt; this.RequestTaskSource.SetResult(response);
⋮----
///     Sets as faulted.
⋮----
/// &lt;param name=&quot;ex&quot;&gt;The exception to set.&lt;/param&gt;
protected internal void SetFaulted(Exception ex)
=&gt; this.RequestTaskSource.SetException(ex);
⋮----
///     Tries to set as faulted.
⋮----
protected internal bool TrySetFaulted(Exception ex)
=&gt; this.RequestTaskSource.TrySetException(ex);</file><file path="DisCatSharp/Net/Rest/CommonHeaders.cs">/// &lt;summary&gt;
///     Represents common headers used by the Discord API.
/// &lt;/summary&gt;
public static class CommonHeaders
⋮----
///     Gets or sets the ratelimit scope header.
⋮----
///     Gets or sets the ratelimit limit header.
⋮----
///     Gets or sets the ratelimit remaining header.
⋮----
///     Gets or sets the ratelimit reset header.
⋮----
///     Gets or sets the ratelimit reset after header.
⋮----
///     Gets or sets the ratelimit bucket header.
⋮----
///     Gets or sets the ratelimit global header.
⋮----
///     Gets or sets the retry after header.
⋮----
///     Gets or sets the discord locale header.
⋮----
///     Gets or sets the discord timezone header.
⋮----
///     Gets or sets the super properties header.
⋮----
///     Gets or sets the user agent header.
⋮----
///     Gets or sets the authorization header.
⋮----
///     Gets or sets the authorization bearer header prefix.
⋮----
///     Gets or sets the authorization basic header prefix.
⋮----
///     Gets or sets the authorization bot header prefix.
⋮----
///     Gets or sets the connection header.
⋮----
///     Gets or sets the connection type header.
⋮----
///     Gets or sets the keep alive header.
⋮----
///     Gets or sets the audit log reason header.</file><file path="DisCatSharp/Net/Rest/Endpoints.cs">/// &lt;summary&gt;
///     The discord endpoints.
/// &lt;/summary&gt;
public static class Endpoints
⋮----
///     The base discord api uri.
⋮----
///     The base discord canary api uri.
⋮----
///     The base discord ptb api uri.
⋮----
///     The oauth2 endpoint.
⋮----
///     The oauth2 token endpoint.
⋮----
///     The oauth2 revoke endpoint.
⋮----
///     The oauth2 authorize endpoint.
⋮----
///     The applications endpoint.
⋮----
///     The message reactions endpoint.
⋮----
///     The self (@me) endpoint.
⋮----
///     The @original endpoint.
⋮----
///     The permissions endpoint.
⋮----
///     The recipients endpoint.
⋮----
///     The bulk-delete endpoint.
⋮----
///     The integrations endpoint.
⋮----
///     The sync endpoint.
⋮----
///     The prune endpoint.
///     Used for user removal.
⋮----
///     The regions endpoint.
⋮----
///     The connections endpoint.
⋮----
///     The icons endpoint.
⋮----
///     The gateway endpoint.
⋮----
///     The oauth2 auth endpoint.
⋮----
///     The oauth2 login endpoint.
⋮----
///     The channels endpoint.
⋮----
///     The messages endpoint.
⋮----
///     The pinned messages endpoint.
⋮----
///     The users endpoint.
⋮----
///     The guilds endpoint.
⋮----
///     The guild discovery splash endpoint.
⋮----
///     The guild splash endpoint.
⋮----
///     The search endpoint.
⋮----
///     The invites endpoint.
⋮----
///     The roles endpoint.
⋮----
///     The members endpoint.
⋮----
///     The member endpoint.
⋮----
///     The typing endpoint.
///     Triggers a typing indicator inside a channel.
⋮----
///     The avatars endpoint.
⋮----
///     The avatar decorations endpoint.
⋮----
///     The collectibles endpoint.
⋮----
///     The bans endpoint.
⋮----
///     The bulk ban endpoint.
⋮----
///     The webhook endpoint.
⋮----
///     The slack endpoint.
///     Used for &lt;see cref=&quot;Entities.DiscordWebhook&quot; /&gt;.
⋮----
///     The github endpoint.
⋮----
///     The guilds mfa endpoint.
⋮----
///     The bot endpoint.
⋮----
///     The voice endpoint.
⋮----
///     The audit logs endpoint.
⋮----
///     The acknowledge endpoint.
///     Indicates that a message is read.
⋮----
///     The nickname endpoint.
⋮----
///     The assets endpoint.
⋮----
///     The embed endpoint.
⋮----
///     The emojis endpoint.
⋮----
///     The vanity url endpoint.
⋮----
///     The guild preview endpoint.
⋮----
///     The followers endpoint.
⋮----
///     The crosspost endpoint.
⋮----
///     The guild widget endpoint.
⋮----
///     The guild widget json endpoint.
⋮----
///     The guild widget png endpoint.
⋮----
///     The templates endpoint.
⋮----
///     The member verification gate endpoint.
⋮----
///     The slash commands endpoint.
⋮----
///     The interactions endpoint.
⋮----
///     The interaction/command callback endpoint.
⋮----
///     The welcome screen endpoint.
⋮----
///     The voice states endpoint.
⋮----
///     The stage instances endpoint.
⋮----
///     The threads endpoint.
⋮----
///     The public threads endpoint.
⋮----
///     The private threads endpoint.
⋮----
///     The active threads endpoint.
⋮----
///     The archived threads endpoint.
⋮----
///     The thread members endpoint.
⋮----
///     The tags endpoint.
⋮----
///     The guild scheduled events endpoint.
⋮----
///     The guild scheduled events cover image endpoint.
⋮----
///     The stickers endpoint.
⋮----
///     The sticker packs endpoint.
///     Global nitro sticker packs.
⋮----
///     The store endpoint.
⋮----
///     The entitlements endpoint.
⋮----
///     The subscriptions endpoint.
⋮----
///     The app assets endpoint.
⋮----
///     The app icons endpoint.
⋮----
///     The team icons endpoint.
⋮----
///     The channel icons endpoint.
⋮----
///     The banners endpoint.
⋮----
///     The custom banners endpoint.
⋮----
///     The sticker endpoint.
///     This endpoint is the static nitro sticker application.
⋮----
///     The role subscription endpoint.
⋮----
///     The group listings endpoint.
⋮----
///     The subscription listings endpoint.
⋮----
///     The directory entries endpoint.
⋮----
///     The counts endpoint.
⋮----
///     The list endpoint.
⋮----
///     The role icons endpoint.
⋮----
///     The activities endpoint.
⋮----
///     The config endpoint.
⋮----
///     The ephemeral attachments endpoint.
⋮----
///     The attachments endpoint.
⋮----
///     The rpc endpoint.
⋮----
///     The role connections endpoint.
⋮----
///     The role connection endpoint.
⋮----
///     The metadata endpoint.
⋮----
///     The voice status endpoint.
⋮----
///     The incident actions endpoint.
⋮----
///     The new member welcome endpoint.
⋮----
///     The new member actions endpoint.
⋮----
///     The new member action endpoint.
⋮----
///     The application directory endpoint.
⋮----
///     The shared canvas endpoint.
⋮----
///     The lines endpoint.
⋮----
///     The emoji hose endpoint.
⋮----
///     The pincode endpoint.
⋮----
///     The soundboard default sounds endpoint.
⋮----
///     The soundboard sounds endpoint.
⋮----
///     The changelogs endpoint.
⋮----
///     The changelogs desktop JSON endpoint.
⋮----
///     The changelogs mobile JSON endpoint.
⋮----
///     The ownership transfer endpoint.
⋮----
///     The onboarding endpoint.
⋮----
///     The creator monetization endpoint.
⋮----
///     The auto moderation endpoint.
⋮----
///     The clear mention raid endpoint.
⋮----
///     The published listings endpoint.
⋮----
///     The SKUs endpoint.
⋮----
///     The guild home headers endpoint.
⋮----
///     The alert action endpoint.
⋮----
///     The consent endpoint.
⋮----
///     The settings endpoint.
⋮----
///     The inventory endpoint.
⋮----
///     The Clyde settings endpoint.
⋮----
///     The Clyde profiles endpoint.
⋮----
///     The generate personality endpoint.
⋮----
///     The refresh URLs endpoint.
⋮----
///     The polls endpoint.
⋮----
///     The answers endpoint.
⋮----
///     The expire endpoint.
⋮----
///     The clan badges endpoint.
⋮----
///     The clan banners endpoint.
⋮----
///     The members search endpoint.
⋮----
///     The send soundboard sound endpoint.
⋮----
///     The requests endpoint.
⋮----
///     The clans endpoint.
⋮----
///     The consume endpoint.</file><file path="DisCatSharp/Net/Rest/IpEndpoint.cs">/// &lt;summary&gt;
///     Represents a network connection IP endpoint.
/// &lt;/summary&gt;
⋮----
///     Gets or sets the hostname associated with this endpoint.
⋮----
///     Gets or sets the port associated with this endpoint.
⋮----
///     Creates a new IP endpoint structure.
⋮----
/// &lt;param name=&quot;address&quot;&gt;IP address to connect to.&lt;/param&gt;
/// &lt;param name=&quot;port&quot;&gt;Port to use for connection.&lt;/param&gt;</file><file path="DisCatSharp/Net/Rest/MultipartWebRequest.cs">/// &lt;summary&gt;
///     Represents a multipart HTTP request.
/// &lt;/summary&gt;
internal sealed class MultipartWebRequest : BaseRestRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MultipartWebRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;The bucket.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;The headers.&lt;/param&gt;
/// &lt;param name=&quot;values&quot;&gt;The values.&lt;/param&gt;
/// &lt;param name=&quot;files&quot;&gt;The files.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitWaitOverride&quot;&gt;The ratelimit_wait_override.&lt;/param&gt;
/// &lt;param name=&quot;overwriteFileIdStart&quot;&gt;The file id start.&lt;/param&gt;
⋮----
///     Gets the dictionary of values attached to this request.
⋮----
///     Gets the dictionary of files attached to this request.
⋮----
///     Overwrites the file id start.
⋮----
///     Represents a multipart HTTP request for stickers.
⋮----
internal sealed class MultipartStickerWebRequest : BaseRestRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;MultipartStickerWebRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The sticker name.&lt;/param&gt;
/// &lt;param name=&quot;tags&quot;&gt;The sticker tag.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The sticker description.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;file&quot;&gt;The file.&lt;/param&gt;
⋮----
///     Gets the file.
⋮----
///     Gets the name.
⋮----
///     Gets the description.
⋮----
///     Gets the tags.</file><file path="DisCatSharp/Net/Rest/RateLimitBucket.cs">/// &lt;summary&gt;
///     Represents a rate limit bucket.
/// &lt;/summary&gt;
internal sealed class RateLimitBucket : IEquatable&lt;RateLimitBucket&gt;
⋮----
///     Gets the unlimited hash.
⋮----
///     Gets the Id of the ratelimit bucket.
⋮----
///     Gets the ratelimit hash of this bucket.
⋮----
///     Gets whether this bucket has it&apos;s ratelimit determined.
///     &lt;para&gt;This will be &lt;see langword=&quot;false&quot; /&gt; if the ratelimit is determined.&lt;/para&gt;
⋮----
///     If the rate limit is currently being reset.
///     This is a int because booleans can&apos;t be accessed atomically.
///     0 =&gt; False, all other values =&gt; True
⋮----
///     Task to wait for the rate limit test to finish.
⋮----
///     If the initial request for this bucket that is determining the rate limits is currently executing.
⋮----
///     If the rate limits have been determined.
⋮----
///     Rate limit reset in ticks, UTC on the next response after the rate limit has been reset.
⋮----
///     Gets or sets the remaining number of requests to the maximum when the ratelimit is reset.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RateLimitBucket&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;hash&quot;&gt;The hash.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild_id.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;The channel_id.&lt;/param&gt;
/// &lt;param name=&quot;webhookId&quot;&gt;The webhook_id.&lt;/param&gt;
⋮----
///     Gets the Id of the guild bucket.
⋮----
///     Gets the Id of the channel bucket.
⋮----
///     Gets the ID of the webhook bucket.
⋮----
///     Gets or sets the ratelimit hash of this bucket.
⋮----
get =&gt; Volatile.Read(ref this.HashInternal);
⋮----
this.IsUnlimited = value.Contains(s_unlimitedHash);
⋮----
if (this.BucketId is not null &amp;&amp; !this.BucketId.StartsWith(value, StringComparison.Ordinal))
⋮----
this.RouteHashes.Add(id);
⋮----
Volatile.Write(ref this.HashInternal, value);
⋮----
///     Gets the past route hashes associated with this bucket.
⋮----
///     Gets when this bucket was last called in a request.
⋮----
///     Gets the number of uses left before pre-emptive rate limit is triggered.
⋮----
///     Gets the maximum number of uses within a single bucket.
⋮----
///     Gets the timestamp at which the rate limit resets.
⋮----
///     Gets the time interval to wait before the rate limit resets.
⋮----
///     Gets a value indicating whether the ratelimit global.
⋮----
///     Gets the ratelimit scope.
⋮----
///     Gets the time interval to wait before the rate limit resets as offset.
⋮----
///     Checks whether this &lt;see cref=&quot;RateLimitBucket&quot; /&gt; is equal to another &lt;see cref=&quot;RateLimitBucket&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;RateLimitBucket&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;RateLimitBucket&quot; /&gt; is equal to this &lt;see cref=&quot;RateLimitBucket&quot; /&gt;.&lt;/returns&gt;
public bool Equals(RateLimitBucket e) =&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || this.BucketId == e.BucketId);
⋮----
///     Generates an ID for this request bucket.
⋮----
/// &lt;param name=&quot;hash&quot;&gt;Hash for this bucket.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;Guild Id for this bucket.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;Channel Id for this bucket.&lt;/param&gt;
/// &lt;param name=&quot;webhookId&quot;&gt;Webhook Id for this bucket.&lt;/param&gt;
/// &lt;returns&gt;Bucket Id.&lt;/returns&gt;
public static string GenerateBucketId(string hash, string guildId, string channelId, string webhookId)
⋮----
///     Generates the hash key.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;returns&gt;A string.&lt;/returns&gt;
public static string GenerateHashKey(RestRequestMethod method, string route)
⋮----
///     Generates the unlimited hash.
⋮----
public static string GenerateUnlimitedHash(RestRequestMethod method, string route)
⋮----
///     Returns a string representation of this bucket.
⋮----
/// &lt;returns&gt;String representation of this bucket.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;RateLimitBucket&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;RateLimitBucket&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as RateLimitBucket);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;RateLimitBucket&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;RateLimitBucket&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
⋮----
///     Sets remaining number of requests to the maximum when the ratelimit is reset
⋮----
/// &lt;param name=&quot;now&quot;&gt;The datetime offset.&lt;/param&gt;
internal async Task TryResetLimitAsync(DateTimeOffset now)
⋮----
while (Interlocked.CompareExchange(ref this.LimitResetting, 1, 0) != 0)
await Task.Yield();
⋮----
///     Sets the initial values.
⋮----
/// &lt;param name=&quot;max&quot;&gt;The max.&lt;/param&gt;
/// &lt;param name=&quot;usesLeft&quot;&gt;The uses left.&lt;/param&gt;
/// &lt;param name=&quot;newReset&quot;&gt;The new reset.&lt;/param&gt;
internal void SetInitialValues(int max, int usesLeft, DateTimeOffset newReset)</file><file path="DisCatSharp/Net/Rest/RestClient.cs">/// &lt;summary&gt;
///     Represents a client used to make REST requests.
/// &lt;/summary&gt;
⋮----
internal sealed class RestClient : IDisposable
⋮----
///     Gets the bucket cleanup delay.
⋮----
private readonly TimeSpan _bucketCleanupDelay = TimeSpan.FromSeconds(60);
⋮----
///     Gets the discord client.
⋮----
///     Gets the global rate limit event.
⋮----
private readonly AsyncManualResetEvent _globalRateLimitEvent;
⋮----
///     Gets the hashes to buckets.
⋮----
///     Gets the logger.
⋮----
private readonly ILogger _logger;
⋮----
///     Gets the request queue.
⋮----
///     Gets the routes to hashes.
⋮----
///     Gets a value indicating whether use reset after.
⋮----
///     Gets the bucket cleaner token source.
⋮----
///     Gets whether the bucket cleaner is running.
⋮----
///     Gets the cleaner task.
⋮----
///     Gets whether the client is disposed.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RestClient&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
⋮----
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, Utilities.GetFormattedToken(client));
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, client.Configuration.Locale);
if (!string.IsNullOrWhiteSpace(client.Configuration.Timezone))
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, client.Configuration.Timezone);
if (!string.IsNullOrWhiteSpace(client.Configuration.Override))
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, client.Configuration.Override);
⋮----
///     This is for meta-clients, such as the &lt;see cref=&quot;DiscordWebhookClient&quot; /&gt; and &lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt;.
⋮----
/// &lt;param name=&quot;configuration&quot;&gt;The configuration.&lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;The logger.&lt;/param&gt;
⋮----
var httphandler = new HttpClientHandler
⋮----
BaseAddress = new(Utilities.GetApiBaseUri(configuration)),
⋮----
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
⋮----
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_LOCALE, configuration.Locale);
if (!string.IsNullOrWhiteSpace(configuration.Timezone))
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.DISCORD_TIMEZONE, configuration.Timezone);
if (!string.IsNullOrWhiteSpace(configuration.Override))
this.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.SUPER_PROPERTIES, configuration.Override);
⋮----
///     Gets the http client.
⋮----
///     Gets a value indicating whether debug is enabled.
⋮----
///     Disposes the rest client.
⋮----
public void Dispose()
⋮----
this._globalRateLimitEvent.Reset();
⋮----
this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Bucket cleaner task stopped.&quot;);
⋮----
this._routesToHashes.Clear();
this._hashesToBuckets.Clear();
this._requestQueue.Clear();
⋮----
GC.SuppressFinalize(this);
⋮----
///     Gets a ratelimit bucket.
⋮----
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;routeParams&quot;&gt;The route parameters.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;returns&gt;A ratelimit bucket.&lt;/returns&gt;
public RateLimitBucket GetBucket(RestRequestMethod method, string route, object routeParams, out string url)
⋮----
var rparamsProps = routeParams.GetType()
.GetTypeInfo()
⋮----
var val = xp.GetValue(routeParams);
⋮----
DateTime dt =&gt; dt.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture),
DateTimeOffset dto =&gt; dto.ToString(&quot;yyyy-MM-ddTHH:mm:sszzz&quot;, CultureInfo.InvariantCulture),
IFormattable xf =&gt; xf.ToString(null, CultureInfo.InvariantCulture),
_ =&gt; val.ToString()
⋮----
var guildId = rparams.GetValueOrDefault(&quot;guild_id&quot;, &quot;&quot;);
var channelId = rparams.GetValueOrDefault(&quot;channel_id&quot;, &quot;&quot;);
var webhookId = rparams.GetValueOrDefault(&quot;webhook_id&quot;, &quot;&quot;);
⋮----
// Create a generic route (minus major params) key
// ex: POST:/channels/channel_id/messages
var hashKey = RateLimitBucket.GenerateHashKey(method, route);
⋮----
// We check if the hash is present, using our generic route (without major params)
// ex: in POST:/channels/channel_id/messages, out 80c17d2f203122d936070c88c8d10f33
// If it doesn&apos;t exist, we create an unlimited hash as our initial key in the form of the hash key + the unlimited constant
// and assign this to the route to hash cache
// ex: this.RoutesToHashes[POST:/channels/channel_id/messages] = POST:/channels/channel_id/messages:unlimited
var hash = this._routesToHashes.GetOrAdd(hashKey, RateLimitBucket.GenerateUnlimitedHash(method, route));
⋮----
// Next we use the hash to generate the key to obtain the bucket.
// ex: 80c17d2f203122d936070c88c8d10f33:guild_id:506128773926879242:webhook_id
// or if unlimited: POST:/channels/channel_id/messages:unlimited:guild_id:506128773926879242:webhook_id
var bucketId = RateLimitBucket.GenerateBucketId(hash, guildId, channelId, webhookId);
⋮----
// If it&apos;s not in cache, create a new bucket and index it by its bucket id.
var bucket = this._hashesToBuckets.GetOrAdd(bucketId, new RateLimitBucket(hash, guildId, channelId, webhookId));
⋮----
// Cache the routes for each bucket so it can be used for GC later.
if (!bucket.RouteHashes.Contains(bucketId))
bucket.RouteHashes.Add(bucketId);
⋮----
// Add the current route to the request queue, which indexes the amount
// of requests occurring to the bucket id.
_ = this._requestQueue.TryGetValue(bucketId, out var count);
⋮----
// Increment by one atomically due to concurrency
this._requestQueue[bucketId] = Interlocked.Increment(ref count);
⋮----
// Start bucket cleaner if not already running.
⋮----
this._cleanerTask = Task.Run(this.CleanupBucketsAsync, this._bucketCleanerTokenSource.Token);
this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Bucket cleaner task started.&quot;);
⋮----
url = CommonRegEx.HttpRouteRegex().Replace(route, xm =&gt; rparams[xm.Groups[1].Value]);
⋮----
///     Executes the request.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to be executed.&lt;/param&gt;
/// &lt;param name=&quot;targetDebug&quot;&gt;Enables a possible breakpoint in the rest client for debugging purposes.&lt;/param&gt;
public Task ExecuteRequestAsync(BaseRestRequest request, bool targetDebug = false)
=&gt; request is null ? throw new ArgumentNullException(nameof(request)) : this.ExecuteRequestAsync(request, null, null, targetDebug);
⋮----
///     Executes the form data request.
⋮----
public Task ExecuteFormRequestAsync(BaseRestRequest request, bool targetDebug = false)
=&gt; request is null ? throw new ArgumentNullException(nameof(request)) : this.ExecuteFormRequestAsync(request, null, null, targetDebug);
⋮----
///     This is to allow proper rescheduling of the first request from a bucket.
⋮----
/// &lt;param name=&quot;bucket&quot;&gt;The bucket.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitTcs&quot;&gt;The ratelimit task completion source.&lt;/param&gt;
⋮----
private async Task ExecuteFormRequestAsync(BaseRestRequest request, RateLimitBucket? bucket, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool targetDebug = false)
⋮----
ObjectDisposedException.ThrowIf(this._disposed, this);
⋮----
Console.WriteLine(&quot;Meow&quot;);
⋮----
await this._globalRateLimitEvent.WaitAsync().ConfigureAwait(false);
⋮----
ratelimitTcs ??= await this.WaitForInitialRateLimit(bucket).ConfigureAwait(false);
⋮----
if (ratelimitTcs is null) // check rate limit only if we are not the probe request
⋮----
await bucket.TryResetLimitAsync(now).ConfigureAwait(false);
⋮----
// Decrement the remaining number of requests as there can be other concurrent requests before this one finishes and has a chance to update the bucket
if (Interlocked.Decrement(ref bucket.RemainingInternal) &lt; 0)
⋮----
this._logger.LogWarning(LoggerEvents.RatelimitDiag, &quot;Request for {bucket} is blocked. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
⋮----
if (delay &lt; new TimeSpan(-TimeSpan.TicksPerMinute))
⋮----
this._logger.LogError(LoggerEvents.RatelimitDiag, &quot;Failed to retrieve ratelimits - giving up and allowing next request for bucket&quot;);
⋮----
delay = TimeSpan.FromMilliseconds(100);
⋮----
this._logger.LogWarning(LoggerEvents.RatelimitPreemptive, &quot;Preemptive ratelimit triggered - waiting until {ResetDate:yyyy-MM-dd HH:mm:ss zzz} ({Delay:c})&quot;, resetDate, delay);
Task.Delay(delay)
.ContinueWith(_ =&gt; this.ExecuteFormRequestAsync(request, null, null))
.LogTaskFault(this._logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while executing request&quot;);
⋮----
this._logger.LogDebug(LoggerEvents.RatelimitDiag, &quot;Request for {bucket} is allowed. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
⋮----
this._logger.LogDebug(LoggerEvents.RatelimitDiag, &quot;Initial request for {bucket} is allowed. Url: {url}&quot;, bucket.ToString(), request.Url.AbsoluteUri);
⋮----
var req = this.BuildFormRequest(request);
⋮----
this._logger.Log(LogLevel.Trace, LoggerEvents.RestTx, &quot;Rest Form Request Content:\n{Content}&quot;, await req.Content.ReadAsStringAsync()!);
⋮----
var response = new RestResponse();
⋮----
res = await this.HttpClient.SendAsync(req, HttpCompletionOption.ResponseContentRead, CancellationToken.None).ConfigureAwait(false);
⋮----
var bts = await res.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
var txt = Utilities.UTF8.GetString(bts, 0, bts.Length);
⋮----
this._logger.Log(LogLevel.Trace, LoggerEvents.RestRx, &quot;Rest Form Response Content: {Content}&quot;, txt);
⋮----
response.Headers = res.Headers?.ToDictionary(xh =&gt; xh.Key, xh =&gt; string.Join(&quot;\n&quot;, xh.Value), StringComparer.OrdinalIgnoreCase);
⋮----
this._logger.LogError(LoggerEvents.RestError, httpex, &quot;Request to {Url} triggered an HttpException&quot;, request.Url.AbsoluteUri);
request.SetFaulted(httpex);
this.FailInitialRateLimitTest(request, ratelimitTcs);
⋮----
this.UpdateBucket(request, response, ratelimitTcs);
⋮----
ex = new BadRequestException(request, response);
⋮----
ex = new UnauthorizedException(request, response);
⋮----
ex = new NotFoundException(request, response);
⋮----
ex = new RequestSizeException(request, response);
⋮----
ex = new RateLimitException(request, response);
⋮----
// check the limit info and requeue
this.Handle429(response, out var wait, out var global);
⋮----
this._logger.LogError(LoggerEvents.RatelimitHit, &quot;Global ratelimit hit, cooling down for {uri}&quot;, request.Url.AbsoluteUri);
⋮----
await wait.ConfigureAwait(false);
⋮----
// we don&apos;t want to wait here until all the blocked requests have been run, additionally Set can never throw an exception that could be suppressed here
_ = this._globalRateLimitEvent.SetAsync();
⋮----
this.ExecuteRequestAsync(request, bucket, ratelimitTcs)
.LogTaskFault(this._logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while retrying request&quot;);
⋮----
this._logger.LogError(LoggerEvents.RatelimitHit, &quot;Ratelimit hit, requeuing request to {url}&quot;, request.Url.AbsoluteUri);
⋮----
ex = new ServerErrorException(request, response);
⋮----
request.SetFaulted(ex);
⋮----
request.SetCompleted(response);
⋮----
this._logger.LogError(LoggerEvents.RestError, ex, &quot;Request to {Url} triggered an exception&quot;, request.Url.AbsoluteUri);
⋮----
// if something went wrong and we couldn&apos;t get rate limits for the first request here, allow the next request to run
⋮----
if (!request.TrySetFaulted(ex))
⋮----
// Get and decrement active requests in this bucket by 1.
⋮----
_ = this._requestQueue.TryGetValue(bucket.BucketId, out var count);
this._requestQueue[bucket.BucketId] = Interlocked.Decrement(ref count);
⋮----
// If it&apos;s 0 or less, we can remove the bucket from the active request queue,
// along with any of its past routes.
⋮----
if (this._requestQueue.ContainsKey(r))
_ = this._requestQueue.TryRemove(r, out _);
⋮----
private async Task ExecuteRequestAsync(BaseRestRequest request, RateLimitBucket? bucket, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool targetDebug = false)
⋮----
if (ratelimitTcs == null) // check rate limit only if we are not the probe request
⋮----
this._logger.LogWarning(LoggerEvents.RatelimitPreemptive, &quot;Preemptive ratelimit triggered - waiting until {0:yyyy-MM-dd HH:mm:ss zzz} ({1:c}).&quot;, resetDate, delay);
⋮----
.ContinueWith(_ =&gt; this.ExecuteRequestAsync(request, null, null))
⋮----
var req = this.BuildRequest(request);
⋮----
this._logger.Log(LogLevel.Trace, LoggerEvents.RestTx, &quot;Rest Request Content:\n{Content}&quot;, await req.Content.ReadAsStringAsync());
⋮----
var x = await req.Content!.ReadAsStringAsync();
Console.WriteLine(x);
Console.WriteLine(txt);
⋮----
this._logger.Log(LogLevel.Trace, LoggerEvents.RestRx, &quot;Rest Response Content: {Content}&quot;, txt);
⋮----
this._logger.LogError(LoggerEvents.RestError, httpex, &quot;Request to {0} triggered an HttpException&quot;, request.Url.AbsoluteUri);
⋮----
await client.RateLimitHitInternal.InvokeAsync(client, new(client.ServiceProvider)
⋮----
senex.AddSentryContext(&quot;Request&quot;, debugInfo);
this._discord.Sentry.CaptureException(senex);
_ = Task.Run(this._discord.Sentry.FlushAsync);
⋮----
this._logger.LogError(LoggerEvents.RestError, ex, &quot;Request to {0} triggered an exception&quot;, request.Url.AbsoluteUri);
⋮----
///     Fails the initial rate limit test.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;resetToInitial&quot;&gt;Whether to reset to initial values.&lt;/param&gt;
private void FailInitialRateLimitTest(BaseRestRequest request, TaskCompletionSource&lt;bool&gt;? ratelimitTcs, bool resetToInitial = false)
⋮----
//Reset to initial values.
⋮----
this.UpdateHashCaches(request, bucket);
⋮----
// no need to wait on all the potentially waiting tasks
_ = Task.Run(() =&gt; ratelimitTcs?.TrySetResult(false));
⋮----
///     Waits for the initial rate limit.
⋮----
private async Task&lt;TaskCompletionSource&lt;bool&gt;?&gt; WaitForInitialRateLimit(RateLimitBucket bucket)
⋮----
if (Interlocked.CompareExchange(ref bucket.LimitTesting, 1, 0) is 0)
⋮----
// if we got here when the first request was just finishing, we must not create the waiter task as it would signal ExecuteRequestAsync to bypass rate limiting
⋮----
// allow exactly one request to go through without having rate limits available
⋮----
// it can take a couple of cycles for the task to be allocated, so wait until it happens or we are no longer probing for the limits
⋮----
await Task.Yield();
⋮----
await waitTask.ConfigureAwait(false);
⋮----
// if the request failed and the response did not have rate limit headers we have allow the next request and wait again, thus this is a loop here
⋮----
///     Builds the form data request.
⋮----
/// &lt;returns&gt;A http request message.&lt;/returns&gt;
private HttpRequestMessage BuildFormRequest(BaseRestRequest request)
⋮----
var req = new HttpRequestMessage(new(request.Method.ToString()), request.Url);
if (request.Headers is not null &amp;&amp; request.Headers.Any())
⋮----
req.Headers.Add(kvp.Key, kvp.Value);
⋮----
throw new InvalidOperationException();
⋮----
req.Content = new FormUrlEncodedContent(formRequest.FormData);
⋮----
///     Builds the request.
⋮----
private HttpRequestMessage BuildRequest(BaseRestRequest request)
⋮----
case RestRequest nmprequest when !string.IsNullOrWhiteSpace(nmprequest.Payload):
this._logger.LogTrace(LoggerEvents.RestTx, nmprequest.Payload);
⋮----
req.Content = new StringContent(nmprequest.Payload);
⋮----
this._logger.LogTrace(LoggerEvents.RestTx, &quot;&lt;multipart request&gt;&quot;);
⋮----
var boundary = &quot;---------------------------&quot; + DateTime.Now.Ticks.ToString(&quot;x&quot;);
⋮----
req.Headers.Add(CommonHeaders.CONNECTION, CommonHeaders.CONNECTION_KEEP_ALIVE);
req.Headers.Add(CommonHeaders.KEEP_ALIVE, &quot;600&quot;);
⋮----
var content = new MultipartFormDataContent(boundary);
if (mprequest.Values is not null &amp;&amp; mprequest.Values.Any())
⋮----
content.Add(new StringContent(kvp.Value), kvp.Key);
⋮----
if (mprequest.Files is not null &amp;&amp; mprequest.Files.Any())
⋮----
var name = $&quot;files[{fileId.ToString(CultureInfo.InvariantCulture)}]&quot;;
content.Add(new StreamContent(f.Value), name, f.Key);
⋮----
var sc = new StreamContent(mpsrequest.File.Stream);
⋮----
var content = new MultipartFormDataContent(boundary)
⋮----
{ new StringContent(mpsrequest.Name), &quot;name&quot; },
{ new StringContent(mpsrequest.Tags), &quot;tags&quot; }
⋮----
if (!string.IsNullOrEmpty(mpsrequest.Description))
content.Add(new StringContent(mpsrequest.Description), &quot;description&quot;);
⋮----
content.Add(sc, &quot;file&quot;, fileName);
⋮----
///     Handles the HTTP 429 status.
⋮----
/// &lt;param name=&quot;response&quot;&gt;The response.&lt;/param&gt;
/// &lt;param name=&quot;waitTask&quot;&gt;The wait task.&lt;/param&gt;
/// &lt;param name=&quot;global&quot;&gt;If true, global.&lt;/param&gt;
private void Handle429(RestResponse response, out Task? waitTask, out bool global)
⋮----
// handle the wait
if (hs.TryGetValue(CommonHeaders.RETRY_AFTER, out var retryAfterRaw))
⋮----
var retryAfter = TimeSpan.FromSeconds(int.Parse(retryAfterRaw, CultureInfo.InvariantCulture));
waitTask = Task.Delay(retryAfter);
⋮----
// check if global b1nzy
if (hs.TryGetValue(CommonHeaders.RATELIMIT_GLOBAL, out var isGlobal) &amp;&amp; isGlobal.ToLowerInvariant() is &quot;true&quot;)
// global
⋮----
///     Updates the bucket.
⋮----
private void UpdateBucket(BaseRestRequest request, RestResponse response, TaskCompletionSource&lt;bool&gt;? ratelimitTcs)
⋮----
if (response.ResponseCode is not HttpStatusCode.TooManyRequests) // do not fail when ratelimit was or the next request will be scheduled hitting the rate limit again
⋮----
if (hs.TryGetValue(CommonHeaders.RATELIMIT_SCOPE, out var scope))
⋮----
var r1 = hs.TryGetValue(CommonHeaders.RATELIMIT_LIMIT, out var usesMax);
var r2 = hs.TryGetValue(CommonHeaders.RATELIMIT_REMAINING, out var usesLeft);
var r3 = hs.TryGetValue(CommonHeaders.RATELIMIT_RESET, out var reset);
var r4 = hs.TryGetValue(CommonHeaders.RATELIMIT_RESET_AFTER, out var resetAfter);
var r5 = hs.TryGetValue(CommonHeaders.RATELIMIT_BUCKET, out var hash);
⋮----
//If the limits were determined before this request, make the bucket initial again.
⋮----
this.FailInitialRateLimitTest(request, ratelimitTcs, ratelimitTcs is null);
⋮----
var resetTime = new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero).AddSeconds(double.Parse(reset, CultureInfo.InvariantCulture));
⋮----
if (hs.TryGetValue(&quot;Date&quot;, out var rawDate))
serverTime = DateTimeOffset.Parse(rawDate, CultureInfo.InvariantCulture).ToUniversalTime();
⋮----
//var difference = clientTime - serverTime;
//if (Math.Abs(difference.TotalSeconds) &gt;= 1)
////    this.Logger.LogMessage(LogLevel.DebugBaseDiscordClient.RestEventId,  $&quot;Difference between machine and server time: {difference.TotalMilliseconds.ToString(&quot;#,##0.00&quot;, CultureInfo.InvariantCulture)}ms&quot;, DateTime.Now);
//else
//    difference = TimeSpan.Zero;
⋮----
resetDelta = TimeSpan.FromSeconds(request.RateLimitWaitOverride.Value);
⋮----
bucket.ResetAfter = TimeSpan.FromSeconds(double.Parse(resetAfter!, CultureInfo.InvariantCulture));
⋮----
var maximum = int.Parse(usesMax!, CultureInfo.InvariantCulture);
var remaining = int.Parse(usesLeft!, CultureInfo.InvariantCulture);
⋮----
// initial population of the ratelimit data
bucket.SetInitialValues(maximum, remaining, newReset);
⋮----
_ = Task.Run(() =&gt; ratelimitTcs.TrySetResult(true));
⋮----
// only update the bucket values if this request was for a newer interval than the one
// currently in the bucket, to avoid issues with concurrent requests in one bucket
// remaining is reset by TryResetLimit and not the response, just allow that to happen when it is time
⋮----
this.UpdateHashCaches(request, bucket, hash);
⋮----
///     Updates the hash caches.
⋮----
/// &lt;param name=&quot;newHash&quot;&gt;The new hash.&lt;/param&gt;
private void UpdateHashCaches(BaseRestRequest request, RateLimitBucket bucket, string? newHash = null)
⋮----
var hashKey = RateLimitBucket.GenerateHashKey(request.Method, request.Route);
⋮----
if (!this._routesToHashes.TryGetValue(hashKey, out var oldHash))
⋮----
// This is an unlimited bucket, which we don&apos;t need to keep track of.
⋮----
_ = this._routesToHashes.TryRemove(hashKey, out _);
⋮----
_ = this._hashesToBuckets.TryRemove(bucket.BucketId, out _);
⋮----
// Only update the hash once, due to a bug on Discord&apos;s end.
// This will cause issues if the bucket hashes are dynamically changed from the API while running,
// in which case, Dispose will need to be called to clear the caches.
⋮----
this._logger.LogDebug(LoggerEvents.RestHashMover, &quot;Updating hash in {0}: \&quot;{1}\&quot; -&gt; \&quot;{2}\&quot;&quot;, hashKey, oldHash, newHash);
var bucketId = RateLimitBucket.GenerateBucketId(newHash, bucket.GuildId, bucket.ChannelId, bucket.WebhookId);
⋮----
_ = this._routesToHashes.AddOrUpdate(hashKey, newHash, (key, previousHash) =&gt;
⋮----
var oldBucketId = RateLimitBucket.GenerateBucketId(oldHash!, bucket.GuildId, bucket.ChannelId, bucket.WebhookId);
⋮----
// Remove the old unlimited bucket.
_ = this._hashesToBuckets.TryRemove(oldBucketId, out _);
_ = this._hashesToBuckets.AddOrUpdate(bucketId, bucket, (_, _) =&gt; bucket);
⋮----
///     Cleans the buckets.
⋮----
private async Task CleanupBucketsAsync()
⋮----
await Task.Delay(this._bucketCleanupDelay, this._bucketCleanerTokenSource.Token).ConfigureAwait(false);
⋮----
//Check and clean request queue first in case it wasn&apos;t removed properly during requests.
⋮----
var bucket = this._hashesToBuckets.Values.FirstOrDefault(x =&gt; x.RouteHashes.Contains(key));
⋮----
if (bucket is null || bucket.LastAttemptAt.AddSeconds(5) &lt; DateTimeOffset.UtcNow)
_ = this._requestQueue.TryRemove(key, out _);
⋮----
// Don&apos;t remove the bucket if it&apos;s currently being handled by the rest client, unless it&apos;s an unlimited bucket.
if (string.IsNullOrEmpty(value.BucketId) || (this._requestQueue.ContainsKey(value.BucketId) &amp;&amp; !value.IsUnlimited))
⋮----
// Don&apos;t remove the bucket if it&apos;s reset date is less than now + the additional wait time, unless it&apos;s an unlimited bucket.
⋮----
_ = this._hashesToBuckets.TryRemove(key, out _);
⋮----
bucketIdStrBuilder.Append(value.BucketId + &quot;, &quot;);
⋮----
this._logger.LogDebug(LoggerEvents.RestCleaner, &quot;Removed {0} unused bucket{1}: [{2}]&quot;, removedBuckets, removedBuckets &gt; 1 ? &quot;s&quot; : string.Empty, bucketIdStrBuilder.ToString().TrimEnd(&apos;,&apos;, &apos; &apos;));
⋮----
this.Dispose();</file><file path="DisCatSharp/Net/Rest/RestFormRequest.cs">/// &lt;summary&gt;
///     Represents a form data HTTP request.
/// &lt;/summary&gt;
internal sealed class RestFormRequest : BaseRestRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RestRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;The bucket.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;formData&quot;&gt;The form data.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;The headers.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitWaitOverride&quot;&gt;The ratelimit wait override.&lt;/param&gt;
⋮----
///     Gets the form data sent with this request.</file><file path="DisCatSharp/Net/Rest/RestRequest.cs">/// &lt;summary&gt;
///     Represents a non-multipart HTTP request.
/// &lt;/summary&gt;
internal sealed class RestRequest : BaseRestRequest
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RestRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;The bucket.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;The headers.&lt;/param&gt;
/// &lt;param name=&quot;payload&quot;&gt;The payload.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitWaitOverride&quot;&gt;The ratelimit wait override.&lt;/param&gt;
⋮----
///     Gets the payload sent with this request.</file><file path="DisCatSharp/Net/Rest/RestRequestMethod.cs">// ReSharper disable InconsistentNaming
⋮----
/// &lt;summary&gt;
///     Defines the HTTP method to use for an HTTP request.
/// &lt;/summary&gt;
⋮----
///     Defines that the request is a GET request.
⋮----
///     Defines that the request is a POST request.
⋮----
///     Defines that the request is a DELETE request.
⋮----
///     Defines that the request is a PATCH request.
⋮----
///     Defines that the request is a PUT request.
⋮----
///     Defines that the request is a HEAD request.</file><file path="DisCatSharp/Net/Rest/RestResponse.cs">/// &lt;summary&gt;
///     Represents a response sent by the remote HTTP party.
/// &lt;/summary&gt;
public sealed class RestResponse
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;RestResponse&quot; /&gt; class.
⋮----
///     Gets the response code sent by the remote party.
⋮----
///     Gets the headers sent by the remote party.
⋮----
///     Gets the contents of the response sent by the remote party.</file><file path="DisCatSharp/Net/Rest/SessionBucket.cs">/// &lt;summary&gt;
///     Represents the bucket limits for identifying to Discord.
///     &lt;para&gt;This is only relevant for clients that are manually sharding.&lt;/para&gt;
/// &lt;/summary&gt;
public sealed class SessionBucket : ObservableApiObject
⋮----
///     Gets the total amount of sessions per token.
⋮----
///     Gets the remaining amount of sessions for this token.
⋮----
///     Gets the datetime when the &lt;see cref=&quot;Remaining&quot; /&gt; will reset.
⋮----
///     Gets the maximum amount of shards that can boot concurrently.
⋮----
///     Gets the reset after value.
⋮----
///     Returns a readable session bucket string.
⋮----
public override string ToString()</file><file path="DisCatSharp/Net/Serialization/SnowflakeArrayAsDictionaryJsonConverter.cs">/// &lt;summary&gt;
///     Used for a &lt;see cref=&quot;Dictionary{TKey,TValue}&quot; /&gt; or &lt;see cref=&quot;ConcurrentDictionary{TKey,TValue}&quot; /&gt; mapping
///     &lt;see cref=&quot;ulong&quot; /&gt; to any class extending &lt;see cref=&quot;SnowflakeObject&quot; /&gt; (or, as a special case,
///     &lt;see cref=&quot;DiscordVoiceState&quot; /&gt;). When serializing, discards the ulong
///     keys and writes only the values. When deserializing, pulls the keys from &lt;see cref=&quot;SnowflakeObject.Id&quot; /&gt; (or,
///     in the case of &lt;see cref=&quot;DiscordVoiceState&quot; /&gt;, &lt;see cref=&quot;DiscordVoiceState.UserId&quot; /&gt;.
/// &lt;/summary&gt;
internal class SnowflakeArrayAsDictionaryJsonConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
⋮----
writer.WriteNull();
⋮----
var type = value.GetType().GetTypeInfo();
JToken.FromObject(type.GetDeclaredProperty(&quot;Values&quot;)!.GetValue(value)!).WriteTo(writer);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
⋮----
var constructor = objectType.GetTypeInfo().DeclaredConstructors
.FirstOrDefault(e =&gt; !e.IsStatic &amp;&amp; e.GetParameters().Length == 0);
⋮----
// the default name of an indexer is &quot;Item&quot;
var properties = objectType.GetTypeInfo().GetDeclaredProperty(&quot;Item&quot;);
⋮----
var entries = (IEnumerable?)serializer.Deserialize(reader, objectType.GenericTypeArguments[1].MakeArrayType());
⋮----
properties.SetValue(dict, entry, [
⋮----
?? throw new InvalidOperationException($&quot;Type {entry?.GetType()} is not deserializable&quot;)
⋮----
///     Whether the snowflake can be converted.
⋮----
public override bool CanConvert(Type objectType)
⋮----
var genericTypedef = objectType.GetGenericTypeDefinition();
⋮----
return typeof(SnowflakeObject).GetTypeInfo().IsAssignableFrom(valueParam.GetTypeInfo()) ||</file><file path="DisCatSharp/Net/Udp/BaseUdpClient.cs">/// &lt;summary&gt;
///     Creates an instance of a UDP client implementation.
/// &lt;/summary&gt;
/// &lt;returns&gt;Constructed UDP client implementation.&lt;/returns&gt;
⋮----
///     Represents a base abstraction for all UDP client implementations.
⋮----
public abstract class BaseUdpClient
⋮----
///     Configures the UDP client.
⋮----
/// &lt;param name=&quot;endpoint&quot;&gt;Endpoint that the client will be communicating with.&lt;/param&gt;
public abstract void Setup(ConnectionEndpoint endpoint);
⋮----
///     Sends a datagram.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Datagram.&lt;/param&gt;
/// &lt;param name=&quot;dataLength&quot;&gt;Length of the datagram.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public abstract Task SendAsync(byte[] data, int dataLength);
⋮----
///     Receives a datagram.
⋮----
/// &lt;returns&gt;The received bytes.&lt;/returns&gt;
public abstract Task&lt;byte[]&gt; ReceiveAsync();
⋮----
///     Closes and disposes the client.
⋮----
public abstract void Close();</file><file path="DisCatSharp/Net/Udp/DCSUdpClient.cs">/// &lt;summary&gt;
///     The default, native-based UDP client implementation.
/// &lt;/summary&gt;
internal class DcsUdpClient : BaseUdpClient
⋮----
///     Gets the packet queue.
⋮----
///     Gets the cancellation token source.
⋮----
private readonly CancellationTokenSource _tokenSource;
⋮----
///     Gets the client.
⋮----
private UdpClient _client;
⋮----
///     Gets the end point.
⋮----
private ConnectionEndpoint _endPoint;
⋮----
///     Gets the receiver task.
⋮----
private Task _receiverTask;
⋮----
///     Creates a new UDP client instance.
⋮----
///     Gets the cancellation token.
⋮----
///     Configures the UDP client.
⋮----
/// &lt;param name=&quot;endpoint&quot;&gt;Endpoint that the client will be communicating with.&lt;/param&gt;
public override void Setup(ConnectionEndpoint endpoint)
⋮----
this._receiverTask = Task.Run(this.ReceiverLoopAsync, this.TOKEN);
⋮----
///     Sends a datagram.
⋮----
/// &lt;param name=&quot;data&quot;&gt;Datagram.&lt;/param&gt;
/// &lt;param name=&quot;dataLength&quot;&gt;Length of the datagram.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public override Task SendAsync(byte[] data, int dataLength)
=&gt; this._client.SendAsync(data, dataLength, this._endPoint.Hostname, this._endPoint.Port);
⋮----
///     Receives a datagram.
⋮----
/// &lt;returns&gt;The received bytes.&lt;/returns&gt;
public override Task&lt;byte[]&gt; ReceiveAsync() =&gt; Task.FromResult(this._packetQueue.Take(this.TOKEN));
⋮----
///     Closes and disposes the client.
⋮----
public override void Close()
⋮----
this._tokenSource.Cancel();
⋮----
this._client.Close();
⋮----
// Nothing
⋮----
// dequeue all the packets
this._packetQueue.Dispose();
⋮----
///     Receivers the loop.
⋮----
private async Task ReceiverLoopAsync()
⋮----
var packet = await this._client.ReceiveAsync(this.TOKEN).ConfigureAwait(false);
this._packetQueue.Add(packet.Buffer, this.TOKEN);
⋮----
///     Creates a new instance of &lt;see cref=&quot;BaseUdpClient&quot; /&gt;.
⋮----
public static BaseUdpClient CreateNew()
=&gt; new DcsUdpClient();</file><file path="DisCatSharp/Net/WebSocket/IWebSocketClient.cs">/// &lt;summary&gt;
///     Creates an instance of a WebSocket client implementation.
/// &lt;/summary&gt;
/// &lt;param name=&quot;proxy&quot;&gt;Proxy settings to use for the new WebSocket client instance.&lt;/param&gt;
/// &lt;param name=&quot;provider&quot;&gt;Service provider.&lt;/param&gt;
/// &lt;returns&gt;Constructed WebSocket client implementation.&lt;/returns&gt;
⋮----
///     Represents a base abstraction for all WebSocket client implementations.
⋮----
public interface IWebSocketClient : IDisposable
⋮----
///     Gets the proxy settings for this client.
⋮----
///     Gets the collection of default headers to send when connecting to the remote endpoint.
⋮----
///     &lt;para&gt;Gets the service provider.&lt;/para&gt;
⋮----
///     Connects to a specified remote WebSocket endpoint.
⋮----
/// &lt;param name=&quot;uri&quot;&gt;The URI of the WebSocket endpoint.&lt;/param&gt;
Task ConnectAsync(Uri uri);
⋮----
///     Disconnects the WebSocket connection.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
Task DisconnectAsync(int code = 1000, string message = &quot;&quot;);
⋮----
///     Send a message to the WebSocket server.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;
Task SendMessageAsync(string message);
⋮----
///     Adds a header to the default header collection.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the header to add.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Value of the header to add.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation succeeded.&lt;/returns&gt;
bool AddDefaultHeader(string name, string value);
⋮----
///     Removes a header from the default header collection.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the header to remove.&lt;/param&gt;
⋮----
bool RemoveDefaultHeader(string name);
⋮----
///     Triggered when the client connects successfully.
⋮----
///     Triggered when the client is disconnected.
⋮----
///     Triggered when the client receives a message from the remote party.
⋮----
///     Triggered when an error occurs in the client.</file><file path="DisCatSharp/Net/WebSocket/PayloadDecompressor.cs">/// &lt;summary&gt;
///     Represents a payload decompressor.
/// &lt;/summary&gt;
internal sealed class PayloadDecompressor : IDisposable
⋮----
///     The zlib flush.
⋮----
///     The zlib prefix.
⋮----
///     Gets the compressed stream.
⋮----
private readonly MemoryStream _compressedStream;
⋮----
///     Gets the decompressor stream.
⋮----
private readonly DeflateStream _decompressorStream;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PayloadDecompressor&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;compressionLevel&quot;&gt;The compression level.&lt;/param&gt;
⋮----
throw new InvalidOperationException(&quot;Decompressor requires a valid compression mode.&quot;);
⋮----
///     Gets the compression level.
⋮----
///     Disposes the decompressor.
⋮----
public void Dispose()
⋮----
this._compressedStream.Dispose();
⋮----
///     Tries the decompress.
⋮----
/// &lt;param name=&quot;compressed&quot;&gt;The compressed bytes.&lt;/param&gt;
/// &lt;param name=&quot;decompressed&quot;&gt;The decompressed memory stream.&lt;/param&gt;
public bool TryDecompress(ArraySegment&lt;byte&gt; compressed, MemoryStream decompressed)
⋮----
this._compressedStream.Write(compressed.Array, compressed.Offset + 2, compressed.Count - 2);
⋮----
this._compressedStream.Write(compressed.Array, compressed.Offset, compressed.Count);
⋮----
this._compressedStream.Flush();
⋮----
var cspan = compressed.AsSpan();
var suffix = BinaryPrimitives.ReadUInt32BigEndian(cspan[^4..]);
⋮----
zlib.Dispose();
⋮----
zlib.CopyTo(decompressed);
⋮----
this._compressedStream.SetLength(0);</file><file path="DisCatSharp/Net/WebSocket/SocketLock.cs">// Licensed from Clyde.NET
⋮----
/// &lt;summary&gt;
///     Represents a socket lock.
/// &lt;/summary&gt;
internal sealed class SocketLock : IDisposable
⋮----
///     Gets the lock semaphore.
⋮----
private readonly SemaphoreSlim _lockSemaphore;
⋮----
///     Gets or sets the max concurrency.
⋮----
///     Gets the cancel token.
⋮----
///     Gets or sets the timeout cancel source.
⋮----
///     Gets or sets the unlock task.
⋮----
private Task _unlockTask;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;SocketLock&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;appId&quot;&gt;The app id.&lt;/param&gt;
/// &lt;param name=&quot;maxConcurrency&quot;&gt;The max concurrency.&lt;/param&gt;
⋮----
///     Gets the application id.
⋮----
///     Disposes the socket lock.
⋮----
public void Dispose()
⋮----
///     Locks the socket.
⋮----
public async Task LockAsync()
⋮----
await this._lockSemaphore.WaitAsync(CancellationToken.None).ConfigureAwait(false);
⋮----
this._unlockTask = Task.Delay(TimeSpan.FromSeconds(30), this._timeoutCancel.Value);
_ = this._unlockTask.ContinueWith(this.InternalUnlock, TaskContinuationOptions.NotOnCanceled);
⋮----
///     Unlocks the socket after a given timespan.
⋮----
/// &lt;param name=&quot;unlockDelay&quot;&gt;The unlock delay.&lt;/param&gt;
public void UnlockAfter(TimeSpan unlockDelay)
⋮----
return; // it&apos;s not unlockable because it&apos;s post-IDENTIFY or not locked
⋮----
this._timeoutCancelSource.Cancel();
this._timeoutCancelSource.Dispose();
⋮----
this._unlockTask = Task.Delay(unlockDelay, CancellationToken.None);
_ = this._unlockTask.ContinueWith(this.InternalUnlock);
⋮----
///     Waits for the socket lock.
⋮----
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public Task WaitAsync()
=&gt; this._lockSemaphore.WaitAsync();
⋮----
///     Unlocks the socket.
⋮----
/// &lt;param name=&quot;t&quot;&gt;The task.&lt;/param&gt;
private void InternalUnlock(Task t)
=&gt; this._lockSemaphore.Release(this._maxConcurrency);</file><file path="DisCatSharp/Net/WebSocket/WebSocketClient.cs">// weebsocket
// not even sure whether emzi or I posted this. much love, naam.
/// &lt;summary&gt;
///     The default, native-based WebSocket client implementation.
/// &lt;/summary&gt;
public class WebSocketClient : IWebSocketClient
⋮----
///     The outgoing chunk size.
⋮----
private const int OUTGOING_CHUNK_SIZE = 8192; // 8 KiB
⋮----
///     The incoming chunk size.
⋮----
private const int INCOMING_CHUNK_SIZE = 32768; // 32 KiB
⋮----
///     Gets the default headers.
⋮----
///     Gets the sender lock.
⋮----
private readonly SemaphoreSlim _senderLock;
⋮----
///     Gets a value indicating whether this client is closed.
⋮----
///     Gets a value indicating whether this client is connected.
⋮----
///     Gets a value indicating whether this client is disposed.
⋮----
///     Gets the receiver task.
⋮----
///     Gets the receiver token.
⋮----
private CancellationToken _receiverToken;
⋮----
///     Gets the receiver token source, if any.
⋮----
///     Gets the socket token.
⋮----
private CancellationToken _socketToken;
⋮----
///     Gets the socket token source, if any.
⋮----
///     Gets the WebSocket instance.
⋮----
///     Instantiates a new WebSocket client with specified proxy settings.
⋮----
/// &lt;param name=&quot;proxy&quot;&gt;Proxy settings for the client.&lt;/param&gt;
/// &lt;param name=&quot;provider&quot;&gt;Service provider.&lt;/param&gt;
⋮----
///     Gets the proxy settings for this client.
⋮----
///     Gets the collection of default headers to send when connecting to the remote endpoint.
⋮----
///     Gets or sets the service provider.
⋮----
///     Connects to a specified remote WebSocket endpoint.
⋮----
/// &lt;param name=&quot;uri&quot;&gt;The URI of the WebSocket endpoint.&lt;/param&gt;
public async Task ConnectAsync(Uri uri)
⋮----
// Disconnect first
⋮----
await this.DisconnectAsync().ConfigureAwait(false);
⋮----
// Disallow sending messages
await this._senderLock.WaitAsync(CancellationToken.None).ConfigureAwait(false);
⋮----
// This can be null at this point
⋮----
this._ws.Options.SetRequestHeader(k, v);
⋮----
await this._ws.ConnectAsync(uri, this._socketToken).ConfigureAwait(false);
this._receiverTask = Task.Run(this.ReceiverLoopAsync, this._receiverToken);
⋮----
this._senderLock.Release();
⋮----
///     Disconnects the WebSocket connection.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message&lt;/param&gt;
public async Task DisconnectAsync(int code = 1000, string? message = null)
⋮----
// Ensure that messages cannot be sent
⋮----
await this._ws.CloseOutputAsync((WebSocketCloseStatus)code, message, CancellationToken.None).ConfigureAwait(false);
⋮----
await this._receiverTask.ConfigureAwait(false); // Ensure that receiving completed
⋮----
// Cancel all running tasks
⋮----
this._socketTokenSource.Cancel();
⋮----
this._receiverTokenSource.Cancel();
⋮----
///     Send a message to the WebSocket server.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;
public async Task SendMessageAsync(string message)
⋮----
var bytes = Utilities.UTF8.GetBytes(message);
⋮----
var segLen = Math.Min(OUTGOING_CHUNK_SIZE, len - segStart);
⋮----
await this._ws.SendAsync(new(bytes, segStart, segLen), WebSocketMessageType.Text, i == segCount - 1, CancellationToken.None).ConfigureAwait(false);
⋮----
///     Adds a header to the default header collection.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the header to add.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;Value of the header to add.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation succeeded.&lt;/returns&gt;
public bool AddDefaultHeader(string name, string value)
⋮----
///     Removes a header from the default header collection.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the header to remove.&lt;/param&gt;
⋮----
public bool RemoveDefaultHeader(string name)
=&gt; this._defaultHeaders.Remove(name);
⋮----
///     Disposes of resources used by this WebSocket client instance.
⋮----
public void Dispose()
⋮----
this.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
GC.SuppressFinalize(this);
⋮----
///     Receivers the loop.
⋮----
internal async Task ReceiverLoopAsync()
⋮----
await Task.Yield();
⋮----
using var bs = new MemoryStream();
⋮----
// See https://github.com/RogueException/Discord.Net/commit/ac389f5f6823e3a720aedd81b7805adbdd78b66d
// for explanation on the cancellation token
⋮----
WebSocketReceiveResult result;
⋮----
throw new NullReferenceException();
⋮----
result = await this._ws.ReceiveAsync(buffer, CancellationToken.None).ConfigureAwait(false);
⋮----
await bs.WriteAsync(buffer.Array!, 0, result.Count, this._receiverToken);
⋮----
_ = await bs.ReadAsync(resultBytes, 0, resultBytes.Length, this._receiverToken);
⋮----
bs.SetLength(0);
⋮----
await this._connected.InvokeAsync(this, new(this._serviceProvider)).ConfigureAwait(false);
⋮----
await this._messageReceived.InvokeAsync(this, new SocketBinaryMessageEventArgs(resultBytes)).ConfigureAwait(false);
⋮----
await this._messageReceived.InvokeAsync(this, new SocketTextMessageEventArgs(Utilities.UTF8.GetString(resultBytes))).ConfigureAwait(false);
else // close
⋮----
await this._ws.CloseOutputAsync(code, result.CloseStatusDescription, CancellationToken.None).ConfigureAwait(false);
⋮----
await this._disconnected.InvokeAsync(this, new(this._serviceProvider)
⋮----
}).ConfigureAwait(false);
⋮----
await this._exceptionThrown.InvokeAsync(this, new(this._serviceProvider)
⋮----
// Don&apos;t await or you deadlock
// DisconnectAsync waits for this method
_ = this.DisconnectAsync().ConfigureAwait(false);
⋮----
///     Creates a new instance of &lt;see cref=&quot;WebSocketClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;proxy&quot;&gt;Proxy to use for this client instance.&lt;/param&gt;
⋮----
/// &lt;returns&gt;An instance of &lt;see cref=&quot;WebSocketClient&quot; /&gt;.&lt;/returns&gt;
public static IWebSocketClient CreateNew(IWebProxy proxy, IServiceProvider provider)
=&gt; new WebSocketClient(proxy, provider);
⋮----
///     Triggered when the client connects successfully.
⋮----
add =&gt; this._connected.Register(value);
remove =&gt; this._connected.Unregister(value);
⋮----
///     The event for when the client connects successfully.
⋮----
///     Triggered when the client is disconnected.
⋮----
add =&gt; this._disconnected.Register(value);
remove =&gt; this._disconnected.Unregister(value);
⋮----
///     The event for when the client is disconnected.
⋮----
///     Triggered when the client receives a message from the remote party.
⋮----
add =&gt; this._messageReceived.Register(value);
remove =&gt; this._messageReceived.Unregister(value);
⋮----
///     The event for when the client receives a message.
⋮----
///     Triggered when an error occurs in the client.
⋮----
add =&gt; this._exceptionThrown.Register(value);
remove =&gt; this._exceptionThrown.Unregister(value);
⋮----
///     The event for when an error occurs in the client.
⋮----
///     The service provider.
⋮----
private IServiceProvider _serviceProvider;
⋮----
///     Events the error handler.
⋮----
/// &lt;param name=&quot;asyncEvent&quot;&gt;The event.&lt;/param&gt;
/// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
/// &lt;param name=&quot;handler&quot;&gt;The handler.&lt;/param&gt;
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;eventArgs&quot;&gt;The event args.&lt;/param&gt;
private void EventErrorHandler&lt;TArgs&gt;(AsyncEvent&lt;WebSocketClient, TArgs&gt; asyncEvent, Exception ex, AsyncEventHandler&lt;WebSocketClient, TArgs&gt; handler, WebSocketClient sender, TArgs eventArgs)
where TArgs : AsyncEventArgs
=&gt; this._exceptionThrown.InvokeAsync(this, new(this._serviceProvider)
⋮----
}).ConfigureAwait(false).GetAwaiter().GetResult();</file><file path="DisCatSharp/QueryUriBuilder.cs">/// &lt;summary&gt;
///     Represents a query uri builder.
/// &lt;/summary&gt;
internal class QueryUriBuilder
⋮----
///     Gets the query parameters.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;QueryUriBuilder&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;uri&quot;&gt;The uri.&lt;/param&gt;
⋮----
ArgumentNullException.ThrowIfNull(uri);
⋮----
///     Gets the source uri.
⋮----
///     Adds a parameter.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key to be added.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value to be added.&lt;/param&gt;
public QueryUriBuilder AddParameter(string key, string value)
⋮----
this._queryParams.Add(new(key, value));
⋮----
///     Builds the uri.
⋮----
public Uri Build() =&gt;
new UriBuilder(this.SourceUri)
⋮----
Query = this._queryParams.Count is not 0 ? string.Join(&quot;&amp;&quot;, this._queryParams.Select(e =&gt; Uri.EscapeDataString(e.Key) + &apos;=&apos; + Uri.EscapeDataString(e.Value))) : string.Empty
⋮----
///     Returns a readable string.
⋮----
public override string ToString() =&gt; this.Build().ToString();</file><file path="DisCatSharp/ReadOnlyConcurrentDictionary.cs">/// &lt;summary&gt;
///     Read-only view of a given &lt;see cref=&quot;ConcurrentDictionary{TKey,TValue}&quot; /&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     This type exists because &lt;see cref=&quot;ConcurrentDictionary{TKey,TValue}&quot; /&gt; is not an
///     &lt;see cref=&quot;IReadOnlyDictionary{TKey,TValue}&quot; /&gt; in .NET Standard 1.1.
/// &lt;/remarks&gt;
/// &lt;typeparam name=&quot;TKey&quot;&gt;The type of keys in the dictionary.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;TValue&quot;&gt;The type of values in the dictionary.&lt;/typeparam&gt;
⋮----
///     Gets the underlying dictionary.
⋮----
///     Creates a new read-only view of the given dictionary.
⋮----
/// &lt;param name=&quot;underlyingDict&quot;&gt;Dictionary to create a view over.&lt;/param&gt;
⋮----
///     Gets the enumerator.
⋮----
public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator() =&gt; this._underlyingDict.GetEnumerator();
⋮----
IEnumerator IEnumerable.GetEnumerator() =&gt; ((IEnumerable)this._underlyingDict).GetEnumerator();
⋮----
///     Gets the count.
⋮----
///     Contains the key.
⋮----
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
⋮----
public bool ContainsKey(TKey key) =&gt; this._underlyingDict.ContainsKey(key);
⋮----
///     Tries the get value.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
⋮----
public bool TryGetValue(TKey key, out TValue value) =&gt; this._underlyingDict.TryGetValue(key, out value);
⋮----
///     Gets the keys.
⋮----
///     Gets the values.</file><file path="DisCatSharp/ReadOnlySet.cs">/// &lt;summary&gt;
///     Read-only view of a given &lt;see cref=&quot;ISet{T}&quot; /&gt;.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the items in the set.&lt;/typeparam&gt;
⋮----
///     Creates a new read-only view of the given set.
⋮----
/// &lt;param name=&quot;sourceSet&quot;&gt;Set to create a view over.&lt;/param&gt;
⋮----
///     Gets the number of items in the underlying set.
⋮----
///     Returns an enumerator that iterates through this set view.
⋮----
/// &lt;returns&gt;Enumerator for the underlying set.&lt;/returns&gt;
⋮----
public IEnumerator&lt;T&gt; GetEnumerator()
=&gt; this._underlyingSet.GetEnumerator();
⋮----
IEnumerator IEnumerable.GetEnumerator()
=&gt; (this._underlyingSet as IEnumerable).GetEnumerator();</file><file path="DisCatSharp/RingBuffer.cs">/// &lt;summary&gt;
///     A circular buffer collection.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of elements within this ring buffer.&lt;/typeparam&gt;
public class RingBuffer&lt;T&gt; : ICollection&lt;T&gt;
⋮----
///     Gets whether the buffer reached the end.
⋮----
///     Creates a new ring buffer with specified size.
⋮----
/// &lt;param name=&quot;size&quot;&gt;Size of the buffer to create.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot; /&gt;
⋮----
throw new ArgumentOutOfRangeException(nameof(size), &quot;Size must be positive.&quot;);
⋮----
///     Creates a new ring buffer, filled with specified elements.
⋮----
/// &lt;param name=&quot;elements&quot;&gt;Elements to fill the buffer with.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot; /&gt;
⋮----
///     Creates a new ring buffer, filled with specified elements, and starting at specified index.
⋮----
/// &lt;param name=&quot;index&quot;&gt;Starting element index.&lt;/param&gt;
⋮----
if (elements == null || !elements.Any())
throw new ArgumentException(&quot;The collection cannot be null or empty.&quot;, nameof(elements));
⋮----
this.InternalBuffer = elements.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(index), &quot;Index must be less than buffer capacity, and greater than zero.&quot;);
⋮----
///     Gets the current index of the buffer items.
⋮----
///     Gets the capacity of this ring buffer.
⋮----
///     Gets or sets the internal collection of items.
⋮----
///     Gets the number of items in this ring buffer.
⋮----
///     Gets whether this ring buffer is read-only.
⋮----
///     Inserts an item into this ring buffer.
⋮----
/// &lt;param name=&quot;item&quot;&gt;Item to insert.&lt;/param&gt;
public void Add(T item)
⋮----
///     Clears this ring buffer and resets the current item index.
⋮----
public void Clear()
⋮----
this.InternalBuffer.Populate(default);
⋮----
///     Checks whether given item is present in the buffer. This method is not implemented. Use
///     &lt;see cref=&quot;Contains(Func{T, bool})&quot; /&gt; instead.
⋮----
/// &lt;param name=&quot;item&quot;&gt;Item to check for.&lt;/param&gt;
/// &lt;returns&gt;Whether the buffer contains the item.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotImplementedException&quot; /&gt;
public bool Contains(T item) =&gt; throw new NotImplementedException(&quot;This method is not implemented. Use .Contains(predicate) instead.&quot;);
⋮----
///     Copies this ring buffer to target array, attempting to maintain the order of items within.
⋮----
/// &lt;param name=&quot;array&quot;&gt;Target array.&lt;/param&gt;
/// &lt;param name=&quot;index&quot;&gt;Index starting at which to copy the items to.&lt;/param&gt;
public void CopyTo(T[] array, int index)
⋮----
throw new ArgumentException(&quot;Target array is too small to contain the elements from this buffer.&quot;, nameof(array));
⋮----
///     Removes an item from the buffer. This method is not implemented. Use &lt;see cref=&quot;Remove(Func{T, bool})&quot; /&gt; instead.
⋮----
/// &lt;param name=&quot;item&quot;&gt;Item to remove.&lt;/param&gt;
/// &lt;returns&gt;Whether an item was removed or not.&lt;/returns&gt;
public bool Remove(T item) =&gt; throw new NotImplementedException(&quot;This method is not implemented. Use .Remove(predicate) instead.&quot;);
⋮----
///     Returns an enumerator for this ring buffer.
⋮----
/// &lt;returns&gt;Enumerator for this ring buffer.&lt;/returns&gt;
public IEnumerator&lt;T&gt; GetEnumerator() =&gt;
⋮----
? this.InternalBuffer.AsEnumerable().GetEnumerator()
: this.InternalBuffer.Skip(this.CurrentIndex)
.Concat(this.InternalBuffer.Take(this.CurrentIndex))
.GetEnumerator();
⋮----
IEnumerator IEnumerable.GetEnumerator() =&gt; this.GetEnumerator();
⋮----
///     Gets first item from the buffer that matches the predicate.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;Predicate used to find the item.&lt;/param&gt;
/// &lt;param name=&quot;item&quot;&gt;
///     Item that matches the predicate, or default value for the type of the items in this ring buffer, if
///     one is not found.
/// &lt;/param&gt;
/// &lt;returns&gt;Whether an item that matches the predicate was found or not.&lt;/returns&gt;
public bool TryGet(Func&lt;T, bool&gt; predicate, out T item)
⋮----
///     Checks whether given item is present in the buffer using given predicate to find it.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;Predicate used to check for the item.&lt;/param&gt;
⋮----
public bool Contains(Func&lt;T, bool&gt; predicate) =&gt; this.InternalBuffer.Any(predicate);
⋮----
///     Removes an item from the buffer using given predicate to find it.
⋮----
public bool Remove(Func&lt;T, bool&gt; predicate)</file><file path="DisCatSharp/Utilities.cs">/// &lt;summary&gt;
///     Various Discord-related utilities.
/// &lt;/summary&gt;
public static class Utilities
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;Utilities&quot; /&gt; class.
⋮----
var ti = t.GetTypeInfo();
var vals = Enum.GetValues(t).Cast&lt;Permissions&gt;();
⋮----
var xsv = xv.ToString();
var xmv = ti.DeclaredMembers.FirstOrDefault(xm =&gt; xm.Name == xsv);
⋮----
PermissionStrings[xv] = xav?.String ?? xv.ToString();
⋮----
var a = typeof(DiscordClient).GetTypeInfo().Assembly;
⋮----
var v = a.GetName().Version;
⋮----
///     Gets the version of the library.
⋮----
///     Gets or sets the permission strings.
⋮----
///     Gets the utf8 encoding
⋮----
// ReSharper disable once InconsistentNaming
⋮----
///     Gets whether the github version check has finished for given product.
⋮----
///     Gets whether the nuget version check has finished for given product.
⋮----
///     Shorthand method to strip both tokens and IDs.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string to strip tokens and IDs from.&lt;/param&gt;
/// &lt;param name=&quot;stripIds&quot;&gt;Whether to strip ID&apos;s.&lt;/param&gt;
/// &lt;returns&gt;
///     A new string with the tokens replaced with &lt;c&gt;{WEBHOOK_OR_INTERACTION_TOKEN}&lt;/c&gt; and
///     &lt;c&gt;{BOT_OR_USER_TOKEN}&lt;/c&gt; and optionally the ids replaced with &lt;c&gt;{DISCORD_ID}&lt;/c&gt;.
/// &lt;/returns&gt;
public static string? StripTokensAndOptIds(string? str, bool stripIds)
⋮----
///     Removes discord-based tokens from a given string.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string to remove the tokens from.&lt;/param&gt;
⋮----
///     &lt;c&gt;{BOT_OR_USER_TOKEN}&lt;/c&gt;.
⋮----
public static string? StripTokens(string? str)
⋮----
if (string.IsNullOrWhiteSpace(str))
⋮----
str = Regex.Replace(str, @&quot;([a-zA-Z0-9]{68,})&quot;, &quot;{WEBHOOK_OR_INTERACTION_TOKEN}&quot;); // Any alphanumeric string this long is likely to be sensitive information anyways
str = Regex.Replace(str, @&quot;(mfa\.[a-z0-9_-]{20,})|((?&lt;botid&gt;[a-z0-9_-]{23,28})\.(?&lt;creation&gt;[a-z0-9_-]{6,7})\.(?&lt;enc&gt;[a-z0-9_-]{27,}))&quot;, &quot;{BOT_OR_USER_TOKEN}&quot;);
⋮----
///     Removes discord-based ids from a given string.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string to remove the ids from.&lt;/param&gt;
/// &lt;param name=&quot;strip&quot;&gt;Whether to strip discord-based ids.&lt;/param&gt;
/// &lt;returns&gt;A new string with the ids replaced with &lt;c&gt;{DISCORD_ID}&lt;/c&gt;.&lt;/returns&gt;
public static string? StripIds(string? str, bool strip)
⋮----
if (string.IsNullOrWhiteSpace(str) || !strip)
⋮----
str = DiscordRegEx.IdRegex().Replace(str, &quot;{DISCORD_ID}&quot;);
⋮----
///     Adds the specified parameter to the Query String.
⋮----
/// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;paramName&quot;&gt;Name of the parameter to add.&lt;/param&gt;
/// &lt;param name=&quot;paramValue&quot;&gt;Value for the parameter to add.&lt;/param&gt;
/// &lt;returns&gt;Url with added parameter.&lt;/returns&gt;
public static Uri AddParameter(this Uri url, string paramName, string paramValue)
⋮----
var uriBuilder = new UriBuilder(url);
var query = HttpUtility.ParseQueryString(uriBuilder.Query);
⋮----
uriBuilder.Query = query.ToString();
⋮----
///     Gets the api base uri.
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config&lt;/param&gt;
/// &lt;returns&gt;A string.&lt;/returns&gt;
internal static string GetApiBaseUri(DiscordConfiguration? config = null)
⋮----
///     Gets the api uri for.
⋮----
/// &lt;param name=&quot;path&quot;&gt;The path.&lt;/param&gt;
⋮----
/// &lt;returns&gt;An Uri.&lt;/returns&gt;
internal static Uri GetApiUriFor(string path, DiscordConfiguration? config = null)
⋮----
/// &lt;param name=&quot;queryString&quot;&gt;The query string.&lt;/param&gt;
⋮----
internal static Uri GetApiUriFor(string path, string queryString, DiscordConfiguration? config = null)
⋮----
///     Gets the api uri builder for.
⋮----
/// &lt;returns&gt;A QueryUriBuilder.&lt;/returns&gt;
internal static QueryUriBuilder GetApiUriBuilderFor(string path, DiscordConfiguration? config = null)
⋮----
///     Gets the formatted token.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
⋮----
internal static string GetFormattedToken(BaseDiscordClient client)
⋮----
/// &lt;param name=&quot;config&quot;&gt;The config.&lt;/param&gt;
⋮----
internal static string GetFormattedToken(DiscordConfiguration config)
⋮----
_ =&gt; throw new ArgumentException(&quot;Invalid token type specified.&quot;, nameof(config))
⋮----
///     Gets the base headers.
⋮----
/// &lt;returns&gt;A Dictionary.&lt;/returns&gt;
internal static Dictionary&lt;string, string&gt; GetBaseHeaders()
⋮----
///     Gets the user agent.
⋮----
internal static string GetUserAgent()
⋮----
///     Contains the user mentions.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;returns&gt;A bool.&lt;/returns&gt;
internal static bool ContainsUserMentions(string message)
=&gt; DiscordRegEx.UserWithoutNicknameRegex().IsMatch(message);
⋮----
///     Contains the nickname mentions.
⋮----
internal static bool ContainsNicknameMentions(string message)
=&gt; DiscordRegEx.UserWithNicknameRegex().IsMatch(message);
⋮----
///     Contains the channel mentions.
⋮----
internal static bool ContainsChannelMentions(string message)
=&gt; DiscordRegEx.ChannelRegex().IsMatch(message);
⋮----
///     Contains the role mentions.
⋮----
internal static bool ContainsRoleMentions(string message)
=&gt; DiscordRegEx.RoleRegex().IsMatch(message);
⋮----
///     Contains the emojis.
⋮----
internal static bool ContainsEmojis(string message)
=&gt; DiscordRegEx.EmojiRegex().IsMatch(message);
⋮----
///     Gets the user mentions.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message content.&lt;/param&gt;
/// &lt;returns&gt;A list of ulong.&lt;/returns&gt;
internal static IEnumerable&lt;ulong&gt; GetUserMentions(string message)
⋮----
var matches = DiscordRegEx.UserWithOptionalNicknameRegex().Matches(message);
⋮----
select ulong.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture);
⋮----
///     Gets the role mentions.
⋮----
internal static IEnumerable&lt;ulong&gt; GetRoleMentions(string message)
⋮----
var matches = DiscordRegEx.RoleRegex().Matches(message);
⋮----
///     Gets the channel mentions.
⋮----
internal static IEnumerable&lt;ulong&gt; GetChannelMentions(string message)
⋮----
var matches = DiscordRegEx.ChannelRegex().Matches(message);
⋮----
///     Gets the emojis.
⋮----
internal static IEnumerable&lt;ulong&gt; GetEmojis(string message)
⋮----
var matches = DiscordRegEx.EmojiRegex().Matches(message);
⋮----
select ulong.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture);
⋮----
///     Are the valid slash command name.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
⋮----
internal static bool IsValidSlashCommandName(string name)
=&gt; DiscordRegEx.ApplicationCommandNameRegex().IsMatch(name);
⋮----
///     Have the message intents.
⋮----
/// &lt;param name=&quot;intents&quot;&gt;The intents.&lt;/param&gt;
⋮----
internal static bool HasMessageIntents(DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.GuildMessages) || intents.HasIntent(DiscordIntents.DirectMessages);
⋮----
internal static bool HasMessageContentIntents(DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.MessageContent);
⋮----
///     Have the reaction intents.
⋮----
internal static bool HasReactionIntents(DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.GuildMessageReactions) || intents.HasIntent(DiscordIntents.DirectMessageReactions);
⋮----
///     Have the typing intents.
⋮----
internal static bool HasTypingIntents(DiscordIntents intents)
=&gt; intents.HasIntent(DiscordIntents.GuildMessageTyping) || intents.HasIntent(DiscordIntents.DirectMessageTyping);
⋮----
// https://discord.com/developers/docs/topics/gateway#sharding-sharding-formula
⋮----
///     Gets a shard id from a guild id and total shard count.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id the shard is on.&lt;/param&gt;
/// &lt;param name=&quot;shardCount&quot;&gt;The total amount of shards.&lt;/param&gt;
/// &lt;returns&gt;The shard id.&lt;/returns&gt;
public static int GetShardId(ulong guildId, int shardCount)
⋮----
///     Helper method to create a &lt;see cref=&quot;DateTimeOffset&quot; /&gt; from Unix time seconds for targets that do not support this
///     natively.
⋮----
/// &lt;param name=&quot;unixTime&quot;&gt;Unix time seconds to convert.&lt;/param&gt;
/// &lt;param name=&quot;shouldThrow&quot;&gt;Whether the method should throw on failure. Defaults to true.&lt;/param&gt;
/// &lt;returns&gt;Calculated &lt;see cref=&quot;DateTimeOffset&quot; /&gt;.&lt;/returns&gt;
public static DateTimeOffset GetDateTimeOffset(long unixTime, bool shouldThrow = true)
⋮----
return DateTimeOffset.FromUnixTimeSeconds(unixTime);
⋮----
///     Helper method to create a &lt;see cref=&quot;DateTimeOffset&quot; /&gt; from Unix time milliseconds for targets that do not support
///     this natively.
⋮----
/// &lt;param name=&quot;unixTime&quot;&gt;Unix time milliseconds to convert.&lt;/param&gt;
⋮----
public static DateTimeOffset GetDateTimeOffsetFromMilliseconds(long unixTime, bool shouldThrow = true)
⋮----
return DateTimeOffset.FromUnixTimeMilliseconds(unixTime);
⋮----
///     Helper method to calculate Unix time seconds from a &lt;see cref=&quot;DateTimeOffset&quot; /&gt; for targets that do not support
⋮----
/// &lt;param name=&quot;dto&quot;&gt;&lt;see cref=&quot;DateTimeOffset&quot; /&gt; to calculate Unix time for.&lt;/param&gt;
/// &lt;returns&gt;Calculated Unix time.&lt;/returns&gt;
public static long GetUnixTime(DateTimeOffset dto)
=&gt; dto.ToUnixTimeMilliseconds();
⋮----
///     Computes a timestamp from a given snowflake.
⋮----
/// &lt;param name=&quot;snowflake&quot;&gt;Snowflake to compute a timestamp from.&lt;/param&gt;
/// &lt;returns&gt;Computed timestamp.&lt;/returns&gt;
⋮----
public static DateTimeOffset GetSnowflakeTime(this ulong snowflake)
=&gt; DiscordClient.DiscordEpoch.AddMilliseconds(snowflake &gt;&gt; 22);
⋮----
public static DateTimeOffset? GetSnowflakeTime(this ulong? snowflake)
=&gt; snowflake is not null ? DiscordClient.DiscordEpoch.AddMilliseconds(snowflake.Value &gt;&gt; 22) : null;
⋮----
///     Converts this &lt;see cref=&quot;Permissions&quot; /&gt; into human-readable format.
⋮----
/// &lt;param name=&quot;perm&quot;&gt;Permissions enumeration to convert.&lt;/param&gt;
/// &lt;param name=&quot;useNewline&quot;&gt;Whether to seperate permissions by newline. Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;sortAscending&quot;&gt;Whether to sort permissions from a to z. Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;includeValue&quot;&gt;Whether to include the permissions value. Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;shortIfAll&quot;&gt;
///     Whether to show &lt;c&gt;All Permissions&lt;/c&gt;, if the member has all permissions. Defaults to &amp;lt;see
///     langword=&quot;false&quot;/&amp;gt;.
/// &lt;/param&gt;
/// &lt;returns&gt;Human-readable permissions.&lt;/returns&gt;
public static string ToPermissionString(this Permissions perm, bool useNewline = false, bool sortAscending = true, bool includeValue = false, bool shortIfAll = false)
⋮----
if (shortIfAll &amp;&amp; perm.HasPermission(Permissions.All))
⋮----
.Where(xkvp =&gt; xkvp.Key != Permissions.None &amp;&amp; xkvp.Key != Permissions.All &amp;&amp; (perm &amp; xkvp.Key) == xkvp.Key)
.Select(xkvp =&gt; includeValue ? $&quot;{xkvp.Value} ({(long)xkvp.Key})&quot; : xkvp.Value);
⋮----
return string.Join(useNewline ? &quot;\n&quot; : &quot;, &quot;, sortAscending ? strs.OrderBy(xs =&gt; xs) : strs);
⋮----
///     Checks whether this string contains given characters.
⋮----
/// &lt;param name=&quot;str&quot;&gt;String to check.&lt;/param&gt;
/// &lt;param name=&quot;characters&quot;&gt;Characters to check for.&lt;/param&gt;
/// &lt;returns&gt;Whether the string contained these characters.&lt;/returns&gt;
public static bool Contains(this string str, params char[] characters)
=&gt; str.Any(characters.Contains);
⋮----
///     Logs the task fault.
⋮----
/// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;The logger.&lt;/param&gt;
/// &lt;param name=&quot;level&quot;&gt;The level.&lt;/param&gt;
/// &lt;param name=&quot;eventId&quot;&gt;The event id.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;args&quot;&gt;An object array that contains zero or more objects to format.&lt;/param&gt;
internal static void LogTaskFault(this Task task, ILogger? logger, LogLevel level, EventId eventId, string? message, params object?[] args)
⋮----
ArgumentNullException.ThrowIfNull(task);
⋮----
task.ContinueWith(t =&gt; logger.Log(level, eventId, t.Exception, message, args), TaskContinuationOptions.OnlyOnFaulted);
⋮----
///     Deconstructs the.
⋮----
/// &lt;param name=&quot;kvp&quot;&gt;The kvp.&lt;/param&gt;
/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
internal static void Deconstruct&lt;TKey, TValue&gt;(this KeyValuePair&lt;TKey, TValue&gt; kvp, out TKey key, out TValue value)
⋮----
///     Perfoms a version check against github releases.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The base discord client.&lt;/param&gt;
/// &lt;param name=&quot;owner&quot;&gt;The owner of the target github &lt;paramref name=&quot;repository&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;repository&quot;&gt;The target github repository.&lt;/param&gt;
/// &lt;param name=&quot;productName&quot;&gt;The name of the product.&lt;/param&gt;
/// &lt;param name=&quot;includePrerelease&quot;&gt;Whether to include pre-releases in the check.&lt;/param&gt;
/// &lt;param name=&quot;manualVersion&quot;&gt;The manual version string to check.&lt;/param&gt;
/// &lt;param name=&quot;githubToken&quot;&gt;The token to use for private repositories.&lt;/param&gt;
public static Task CheckGitHubVersionAsync(DiscordClient client, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productName = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null, string? githubToken = null)
⋮----
///     Performs a version check against nuget.
⋮----
/// &lt;param name=&quot;packageId&quot;&gt;The id of the package.&lt;/param&gt;
⋮----
public static Task CheckNuGetVersionAsync(DiscordClient client, string packageId = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null)
⋮----
/// &lt;param name=&quot;startupCheck&quot;&gt;Whether this is called on startup.&lt;/param&gt;
/// &lt;param name=&quot;fromShard&quot;&gt;Whether this method got called from a sharded client.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;productNameOrPackageId&quot;&gt;The name of the product or package id, depending on &lt;paramref name=&quot;checkMode&quot; /&gt;.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;checkMode&quot;&gt;
///     Which check mode to use. Can be either &lt;see cref=&quot;VersionCheckMode.GitHub&quot; /&gt; or
///     &lt;see cref=&quot;VersionCheckMode.NuGet&quot; /&gt;. Defaults to &lt;see cref=&quot;VersionCheckMode.NuGet&quot; /&gt;
⋮----
internal static Task CheckVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productNameOrPackageId = &quot;DisCatSharp&quot;, string? manualVersion = null, string? githubToken = null, bool includePrerelease = true, VersionCheckMode checkMode = VersionCheckMode.NuGet)
⋮----
private static async Task CheckGitHubVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string owner = &quot;Aiko-IT-Systems&quot;, string repository = &quot;DisCatSharp&quot;, string productName = &quot;DisCatSharp&quot;, string? manualVersion = null, string? githubToken = null, bool includePrerelease = true)
⋮----
if (startupCheck &amp;&amp; s_gitHubVersionCheckFinishedFor.TryGetValue(productName, out var val) &amp;&amp; val)
⋮----
var currentVersion = version.Split(&apos;-&apos;)[0]!.Split(&apos;+&apos;)[0]!;
var splitVersion = currentVersion.Split(&apos;.&apos;);
var api = Convert.ToInt32(splitVersion[0]);
var major = Convert.ToInt32(splitVersion[1]);
var minor = Convert.ToInt32(splitVersion[2]);
⋮----
ApiConnection apiConnection = githubToken is not null ? new(new Connection(new($&quot;{client.BotLibrary}&quot;, client.VersionString), new InMemoryCredentialStore(new(githubToken)))) : new(new Connection(new($&quot;{client.BotLibrary}&quot;, client.VersionString)));
ReleasesClient releaseClient = new(apiConnection);
⋮----
? (await releaseClient.GetAll(owner, repository, new()
⋮----
})).ToList().FirstOrDefault()
: await releaseClient.GetLatest(owner, repository);
⋮----
client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates. Could not determine remote version&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;);
⋮----
var assetUrl = latest.Assets.FirstOrDefault(x =&gt; x.Name is &quot;RELEASENOTES.md&quot;)?.BrowserDownloadUrl;
⋮----
GitHubClient gitHubClient = new(apiConnection.Connection);
var response = await gitHubClient.Connection.GetRawStream(new(assetUrl), new Dictionary&lt;string, string&gt;
⋮----
releaseNotes = await response.Body.GenerateStringFromStream();
⋮----
var lastGitHubRelease = latest.TagName.Replace(&quot;v&quot;, string.Empty, StringComparison.InvariantCultureIgnoreCase);
var githubSplitVersion = lastGitHubRelease.Split(&apos;.&apos;);
var githubApi = Convert.ToInt32(githubSplitVersion[0]);
var githubMajor = Convert.ToInt32(githubSplitVersion[1]);
var githubMinor = Convert.ToInt32(githubSplitVersion[2]);
⋮----
client.Logger.LogCritical(&quot;[{Type}] Your version of {Product} is outdated!\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version, lastGitHubRelease);
⋮----
client.Logger.LogWarning(&quot;[{Type}] Your version of {Product} is newer than the latest release!\n\tPre-releases are not recommended for production.\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version, lastGitHubRelease);
⋮----
client.Logger.LogInformation(&quot;[{Type}] Your version of {Product} is up to date!\n\tCurrent version: v{CurrentVersion}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, version);
⋮----
if (!string.IsNullOrEmpty(releaseNotes))
client.Logger.LogInformation(&quot;Release Notes:\n{ReleaseNotes}&quot;, releaseNotes);
⋮----
client.Logger.LogWarning(&quot;Could not find any release notes&quot;);
⋮----
client.Logger.LogInformation(&quot;Release notes disabled by config&quot;);
⋮----
client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates for {Product}. Error: {Exception}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, productName, ex);
⋮----
if (!s_gitHubVersionCheckFinishedFor.TryAdd(productName, true) &amp;&amp; s_gitHubVersionCheckFinishedFor.TryGetValue(productName, out _))
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
private static async Task CheckNuGetVersionAsync(BaseDiscordClient client, bool startupCheck, bool fromShard = false, string packageId = &quot;DisCatSharp&quot;, bool includePrerelease = true, string? manualVersion = null)
⋮----
if (startupCheck &amp;&amp; s_nuGetVersionCheckFinishedFor.TryGetValue(packageId, out var val) &amp;&amp; val)
⋮----
var repository = Repository.Factory.GetCoreV3(&quot;https://api.nuget.org/v3/index.json&quot;);
⋮----
var sourceCache = new SourceCacheContext
⋮----
var latestVersions = (await resource.GetLatestVersions(new List&lt;string&gt;
⋮----
packageId.ToLowerInvariant()
}, includePrerelease, false, sourceCache, new NullLogger(), CancellationToken.None))?.ToList();
⋮----
var latestPackageVersion = latestVersions.First(x =&gt; string.Equals(x.Key, packageId, StringComparison.InvariantCultureIgnoreCase)).Value;
⋮----
await using var packageStream = new MemoryStream();
await dResource.CopyNupkgToStreamAsync(
⋮----
new NullLogger(),
⋮----
using var packageReader = new PackageArchiveReader(packageStream);
var nuspecReader = await packageReader.GetNuspecReaderAsync(CancellationToken.None);
releaseNotes = nuspecReader.GetReleaseNotes();
⋮----
var gitLessVersion = version.Split(&apos;+&apos;)[0];
⋮----
NuGetVersion currentPackageVersion = new(gitLessVersion);
⋮----
client.Logger.LogCritical(&quot;[{Type}] Your version of {Product} is outdated!\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion, latestPackageVersion.OriginalVersion);
⋮----
client.Logger.LogWarning(&quot;[{Type}] Your version of {Product} is newer than the latest release!\n\tPre-releases are not recommended for production.\n\tCurrent version: v{CurrentVersion}\n\tLatest version: v{LastGitHubRelease}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion, latestPackageVersion.OriginalVersion);
⋮----
client.Logger.LogInformation(&quot;[{Type}] Your version of {Product} is up to date!\n\tCurrent version: v{CurrentVersion}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, currentPackageVersion.OriginalVersion);
⋮----
client.Logger.LogWarning(&quot;[{Type}] Failed to check for updates for {Product}. Error: {Exception}&quot;, fromShard ? &quot;ShardedClient&quot; : &quot;Client&quot;, packageId, ex);
⋮----
if (!s_nuGetVersionCheckFinishedFor.TryAdd(packageId, true) &amp;&amp; s_nuGetVersionCheckFinishedFor.TryGetValue(packageId, out _))</file><file path="old_solutions/DisCatSharp.sln">Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.31911.260
MinimumVisualStudioVersion = 10.0.40219.1
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp&quot;, &quot;DisCatSharp\DisCatSharp.csproj&quot;, &quot;{EB3D8310-DFAD-4295-97F9-82E253647583}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.VoiceNext&quot;, &quot;DisCatSharp.VoiceNext\DisCatSharp.VoiceNext.csproj&quot;, &quot;{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Solution Items&quot;, &quot;Solution Items&quot;, &quot;{4255B64D-92EC-46B3-BC3B-ED2C3A8073EE}&quot;
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitattributes = .gitattributes
		.gitignore = .gitignore
		BUILDING.md = BUILDING.md
		CONTRIBUTING.md = CONTRIBUTING.md
		LICENSE.md = LICENSE.md
		README.md = README.md
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.CommandsNext&quot;, &quot;DisCatSharp.CommandsNext\DisCatSharp.CommandsNext.csproj&quot;, &quot;{C8ED55FB-E028-468D-955F-1534C20274EF}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Interactivity&quot;, &quot;DisCatSharp.Interactivity\DisCatSharp.Interactivity.csproj&quot;, &quot;{DD32BEC3-0189-479F-86DC-CCF95E5634A9}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;.nuget&quot;, &quot;.nuget&quot;, &quot;{F953F5D0-F0C9-41E6-ADBF-60A76D295899}&quot;
	ProjectSection(SolutionItems) = preProject
		.nuget\NuGet.config = .nuget\NuGet.config
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Build Items&quot;, &quot;Build Items&quot;, &quot;{84464D70-687B-40A8-836D-C4F737698969}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;.github&quot;, &quot;.github&quot;, &quot;{430C28D8-5F85-4D6E-AA68-211549435245}&quot;
	ProjectSection(SolutionItems) = preProject
		.github\CODEOWNERS = .github\CODEOWNERS
		.github\labeler.yml = .github\labeler.yml
		.github\pull_request_template.md = .github\pull_request_template.md
		.github\SECURITY.md = .github\SECURITY.md
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.VoiceNext.Natives&quot;, &quot;DisCatSharp.VoiceNext.Natives\DisCatSharp.VoiceNext.Natives.csproj&quot;, &quot;{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Common&quot;, &quot;DisCatSharp.Common\DisCatSharp.Common.csproj&quot;, &quot;{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.ApplicationCommands&quot;, &quot;DisCatSharp.ApplicationCommands\DisCatSharp.ApplicationCommands.csproj&quot;, &quot;{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Configuration&quot;, &quot;DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot;, &quot;{603287D3-1EF2-47F1-A611-C7F25869DE14}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Configuration.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.Configuration.Tests\DisCatSharp.Configuration.Tests.csproj&quot;, &quot;{E15E88B4-63AD-42DE-B685-D31697C62194}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting&quot;, &quot;DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot;, &quot;{72CCE5D5-926B-432A-876A-065FA2BC9B7B}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.Hosting.Tests\DisCatSharp.Hosting.Tests.csproj&quot;, &quot;{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Hosting.DependencyInjection&quot;, &quot;DisCatSharp.Hosting.DependencyInjection\DisCatSharp.Hosting.DependencyInjection.csproj&quot;, &quot;{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Experimental&quot;, &quot;DisCatSharp.Experimental\DisCatSharp.Experimental.csproj&quot;, &quot;{CF03EADC-E178-45B3-BD72-B6F70B625C8F}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;workflows&quot;, &quot;workflows&quot;, &quot;{D911BF2D-523E-4504-935D-AEDA353305D8}&quot;
	ProjectSection(SolutionItems) = preProject
		.github\workflows\build.yml = .github\workflows\build.yml
		.github\workflows\codeql-analysis.yml = .github\workflows\codeql-analysis.yml
		.github\workflows\create_diagram.yml = .github\workflows\create_diagram.yml
		.github\workflows\documentation.yml = .github\workflows\documentation.yml
		.github\workflows\documentation_test.yml = .github\workflows\documentation_test.yml
		.github\workflows\internal-release.yml = .github\workflows\internal-release.yml
		.github\workflows\labeler.yml = .github\workflows\labeler.yml
		.github\workflows\public-dev-release.yml = .github\workflows\public-dev-release.yml
		.github\workflows\release.yml = .github\workflows\release.yml
		.github\workflows\sentry.yml = .github\workflows\sentry.yml
		.github\workflows\tweet.yml = .github\workflows\tweet.yml
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Targets&quot;, &quot;Targets&quot;, &quot;{4A7E065C-5EAF-4AD0-8002-306FCEEC946C}&quot;
	ProjectSection(SolutionItems) = preProject
		DisCatSharp.Targets\DisCatSharp.targets = DisCatSharp.Targets\DisCatSharp.targets
		DisCatSharp.Targets\InternalsVisibleTo.targets = DisCatSharp.Targets\InternalsVisibleTo.targets
		DisCatSharp.Targets\Library.targets = DisCatSharp.Targets\Library.targets
		DisCatSharp.Targets\NuGet.targets = DisCatSharp.Targets\NuGet.targets
		DisCatSharp.Targets\Package.targets = DisCatSharp.Targets\Package.targets
		DisCatSharp.Targets\TestProject.targets = DisCatSharp.Targets\TestProject.targets
		DisCatSharp.Targets\Version.targets = DisCatSharp.Targets\Version.targets
	EndProjectSection
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Tools&quot;, &quot;Tools&quot;, &quot;{11D25C98-6D11-412C-8016-BE070315326F}&quot;
	ProjectSection(SolutionItems) = preProject
		DisCatSharp.Tools\DisCatSharp.ruleset = DisCatSharp.Tools\DisCatSharp.ruleset
		DisCatSharp.Tools\pack-docs.ps1 = DisCatSharp.Tools\pack-docs.ps1
		DisCatSharp.Tools\rebuild-lib.ps1 = DisCatSharp.Tools\rebuild-lib.ps1
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.EventHandlers.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.EventHandlers.Tests\DisCatSharp.EventHandlers.Tests.csproj&quot;, &quot;{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Tests&quot;, &quot;Tests&quot;, &quot;{267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.SafetyTests&quot;, &quot;DisCatSharp.Tests\SafetyTests\DisCatSharp.SafetyTests.csproj&quot;, &quot;{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Lavalink&quot;, &quot;DisCatSharp.Lavalink\DisCatSharp.Lavalink.csproj&quot;, &quot;{1ADC1D06-3DB8-4741-B740-13161B40CBA3}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.ApplicationCommands.Tests&quot;, &quot;DisCatSharp.Tests\DisCatSharp.ApplicationCommands.Tests\DisCatSharp.ApplicationCommands.Tests.csproj&quot;, &quot;{B4837A35-F5D1-4CF0-941B-961407E3CC36}&quot;
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EB3D8310-DFAD-4295-97F9-82E253647583}.Release|Any CPU.Build.0 = Release|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FB6B9EE9-65FB-4DFB-8D51-06F0BE6C1BA5}.Release|Any CPU.Build.0 = Release|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C8ED55FB-E028-468D-955F-1534C20274EF}.Release|Any CPU.Build.0 = Release|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DD32BEC3-0189-479F-86DC-CCF95E5634A9}.Release|Any CPU.Build.0 = Release|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEC47B41-71E4-41D1-A4F9-BB7C56A1B82B}.Release|Any CPU.Build.0 = Release|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CD84A5C7-C7FF-48CA-B23D-FA726CF80E09}.Release|Any CPU.Build.0 = Release|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AD530FD0-523C-4DE7-9AF6-B9A3785492C2}.Release|Any CPU.Build.0 = Release|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{603287D3-1EF2-47F1-A611-C7F25869DE14}.Release|Any CPU.Build.0 = Release|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E15E88B4-63AD-42DE-B685-D31697C62194}.Release|Any CPU.Build.0 = Release|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{72CCE5D5-926B-432A-876A-065FA2BC9B7B}.Release|Any CPU.Build.0 = Release|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94}.Release|Any CPU.Build.0 = Release|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2D67D1DD-E5B2-40C7-80E2-54D63730E7F0}.Release|Any CPU.Build.0 = Release|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CF03EADC-E178-45B3-BD72-B6F70B625C8F}.Release|Any CPU.Build.0 = Release|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F}.Release|Any CPU.Build.0 = Release|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65}.Release|Any CPU.Build.0 = Release|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1ADC1D06-3DB8-4741-B740-13161B40CBA3}.Release|Any CPU.Build.0 = Release|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B4837A35-F5D1-4CF0-941B-961407E3CC36}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{E15E88B4-63AD-42DE-B685-D31697C62194} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{D02B598A-F0C9-4A8C-B8DE-7C0BAC8C9B94} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{D911BF2D-523E-4504-935D-AEDA353305D8} = {430C28D8-5F85-4D6E-AA68-211549435245}
		{4A7E065C-5EAF-4AD0-8002-306FCEEC946C} = {84464D70-687B-40A8-836D-C4F737698969}
		{11D25C98-6D11-412C-8016-BE070315326F} = {84464D70-687B-40A8-836D-C4F737698969}
		{BE646FCD-8A56-46DC-978D-AC1E0A892A9F} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{9F012C5C-6A47-4E5D-8819-5D2DD0743E65} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
		{B4837A35-F5D1-4CF0-941B-961407E3CC36} = {267EFBFF-ECD2-4686-A5DE-5B642F8A7CCB}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {23F3A981-51B8-4285-A38C-3267F1D25FE7}
	EndGlobalSection
EndGlobal</file><file path="old_solutions/DisCatSharp.Tools/DisCatSharp.Tools.sln">Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.31911.260
MinimumVisualStudioVersion = 10.0.40219.1
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Analyzer&quot;, &quot;DisCatSharp.Analyzer\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot;, &quot;{888F895F-97AB-4B95-86C8-80CE330EE6A2}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Analyzer.Package&quot;, &quot;DisCatSharp.Analyzer\DisCatSharp.Analyzer.Package\DisCatSharp.Analyzer.Package.csproj&quot;, &quot;{A471D5C5-B629-4727-BE7C-F7E7FA832F84}&quot;
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Attributes&quot;, &quot;..\DisCatSharp.Attributes\DisCatSharp.Attributes.csproj&quot;, &quot;{6EB1F99C-22FC-44D8-A1B6-539393C34810}&quot;
EndProject
Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Solution Items&quot;, &quot;Solution Items&quot;, &quot;{6CBDA593-E86C-44F3-9F22-BB5F32D7D48E}&quot;
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		DisCatSharp.ruleset = DisCatSharp.ruleset
	EndProjectSection
EndProject
Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;DisCatSharp.Experimental&quot;, &quot;..\DisCatSharp.Experimental\DisCatSharp.Experimental.csproj&quot;, &quot;{58B4D657-A00E-4C47-B4D6-1EE881E5E387}&quot;
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{888F895F-97AB-4B95-86C8-80CE330EE6A2}.Release|Any CPU.Build.0 = Release|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A471D5C5-B629-4727-BE7C-F7E7FA832F84}.Release|Any CPU.Build.0 = Release|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6EB1F99C-22FC-44D8-A1B6-539393C34810}.Release|Any CPU.Build.0 = Release|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{58B4D657-A00E-4C47-B4D6-1EE881E5E387}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {35117E8E-0076-4CB1-94BD-D3BC0F0A6CCC}
	EndGlobalSection
EndGlobal</file><file path="RELEASENOTES.md">DisCatSharp Release Notes

	- Full support for Components V2
	- Stability Improvements
	- Build-in Statistics
	- Support for .NET 10
	- Improvements for OAuth2 operations

    Breaking

    - **DiscordAttachment**: Renamed `MediaType` to `ContentType` to align with Discord&apos;s API.
    - **DiscordTextComponent**: Switched the position of `customId` and `label` because of nullability.
    - **Application Commands**: Removed `dmPermission` fields, causing DisCatSharp to do weird bulk-updates. Use `allowedContexts` instead.
    - **LavalinkGuildPlayer**: `RemoveQueue` renamed to [`RemoveFromQueue`]((xref:DisCatSharp.Lavalink.Entities.LavalinkGuildPlayer.RemoveFromQueue*)).
    - **Url fields**: Any `Url` fields on objects like `DiscordAttachment`, `DiscordEmbed`, etc., are now of type [`DiscordUri`](xref:DisCatSharp.Entities.DiscordUri) instead of `string`. Use `.ToUri()` to get a `Uri` object or use `.ToString()`.
    - We updated some namespaces in DisCatSharp.Interactivity. You might need to update your imports for some entities and enums.


DisCatSharp.Attributes Release Notes

    - None


DisCatSharp.ApplicationCommands Release Notes

    - Some optimizations


DisCatSharp.CommandsNext Release Notes

    - None

DisCatSharp.Interactivity Release Notes

    - None

DisCatSharp.Common Release Notes

    - None


DisCatSharp.Lavalink Release Notes

    - New queue system. See https://docs.dcs.aitsys.dev/articles/modules/audio/lavalink_v4/queue
    - Support for LavaLyrics plugin


DisCatSharp.VoiceNext Release Notes

    - Will be deprecated 2025 and replaced by DisCatSharp.Voice


DisCatSharp.Experimental Release Notes

    - GCP Attachments
    - Guild Member Search powered by elasticsearch


DisCatSharp.Configuration Release Notes

    - None


DisCatSharp.Hosting Release Notes

    - None


DisCatSharp.Hosting.DependencyInjection Release Notes

    - None</file><file path="DisCatSharp.ApplicationCommands/ApplicationCommandsExtension.cs">// ReSharper disable HeuristicUnreachableCode
⋮----
/// &lt;summary&gt;
///     A class that handles slash commands for a client.
/// &lt;/summary&gt;
public sealed class ApplicationCommandsExtension : BaseExtension
⋮----
///     Configuration for Discord.
⋮----
///     Sets a list of registered commands. The key is the guild id (null if global).
⋮----
///     Sets a list of registered global commands.
⋮----
///     Sets a list of registered guild commands mapped by guild id.
⋮----
///     Gets a list of handled interactions. Fix for double interaction execution bug.
⋮----
///     Fires the application command module ready event.
///     &lt;para&gt;
///         This is fired when the whole module for the &lt;see cref=&quot;DiscordClient&quot; /&gt; finished the startup and
///         registration.
///     &lt;/para&gt;
⋮----
///     Fires the application command module startup finished event.
⋮----
///     Fires the context menu error event.
⋮----
///     Fires the context menu executed event.
⋮----
///     Fires the global application command registered event.
⋮----
///     Fires the guild application command registered event.
⋮----
///     Fires the slash command error event.
⋮----
///     Fires the slash command executed event.
⋮----
///     List of modules to register.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ApplicationCommandsExtension&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;configuration&quot;&gt;The configuration.&lt;/param&gt;
⋮----
///     A list of methods for top level commands.
⋮----
///     List of groups.
⋮----
///     List of groups with subgroups.
⋮----
///     List of context menus.
⋮----
///     List of global commands on discords backend.
⋮----
///     List of guild commands on discords backend.
⋮----
///     Singleton modules.
⋮----
///     Set to true if anything fails when registering.
⋮----
///     Gets a list of registered commands. The key is the guild id (null if global).
⋮----
=&gt; s_registeredCommands.Select(guild =&gt;
⋮----
.Select(parent =&gt; new RegisteredDiscordApplicationCommand(parent)).ToList())).ToList().AsReadOnly();
⋮----
///     Gets a list of registered global commands.
⋮----
///     Gets a list of registered guild commands mapped by guild id.
⋮----
///     Gets the guild ids where the applications.commands scope is missing.
⋮----
///     Gets whether debug is enabled.
⋮----
///     Gets the debug level for the logs.
⋮----
///     Gets the logger.
⋮----
///     Gets whether check through all guilds is enabled.
⋮----
///     Gets whether the registration check should be manually overridden.
⋮----
///     Gets whether interactions should be automatically deffered.
⋮----
///     Whether this module finished the startup.
⋮----
///     Gets the service provider this module was configured with.
⋮----
///     Whether this module is called by an unit test.
⋮----
///     Gets the shard count.
⋮----
///     Gets the count of shards who finished initializing the module.
⋮----
///     Gets whether the finish event was fired.
⋮----
///     Runs setup.
///     &lt;note type=&quot;caution&quot;&gt;DO NOT RUN THIS MANUALLY. DO NOT DO ANYTHING WITH THIS.&lt;/note&gt;
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client to setup on.&lt;/param&gt;
protected internal override void Setup(DiscordClient client)
⋮----
throw new InvalidOperationException(&quot;What did I tell you?&quot;);
⋮----
_ = Task.Run(async () =&gt; await this.UpdateAsync().ConfigureAwait(false));
⋮----
///     Catches all interactions during the startup.
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The interaction create event args.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private async Task CatchInteractionsOnStartup(DiscordClient sender, InteractionCreateEventArgs e)
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Attention: This application is still starting up. Application commands are unavailable for now.&quot;)).ConfigureAwait(false);
⋮----
await Task.Delay(1).ConfigureAwait(false);
⋮----
///     Catches all context menu interactions during the startup.
⋮----
/// &lt;param name=&quot;e&quot;&gt;The context menu interaction create event args.&lt;/param&gt;
private async Task CatchContextMenuInteractionsOnStartup(DiscordClient sender, ContextMenuInteractionCreateEventArgs e)
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral().WithContent(&quot;Attention: This application is still starting up. Context menu commands are unavailable for now.&quot;)).ConfigureAwait(false);
⋮----
///     Fired when the startup is completed.
⋮----
///         Switches the interaction handling from &lt;see cref=&quot;CatchInteractionsOnStartup&quot; /&gt; and
///         &lt;see cref=&quot;CatchContextMenuInteractionsOnStartup&quot; /&gt; to &lt;see cref=&quot;InteractionHandler&quot; /&gt; and
///         &lt;see cref=&quot;ContextMenuHandler&quot; /&gt;.
⋮----
private void FinishedRegistration()
⋮----
///     Cleans the module for a new start of the bot.
///     DO NOT USE IF YOU DON&apos;T KNOW WHAT IT DOES.
⋮----
public void CleanModule()
⋮----
this._updateList.Clear();
s_singletonModules.Clear();
⋮----
CommandMethods.Clear();
GroupCommands.Clear();
ContextMenuCommands.Clear();
SubGroupCommands.Clear();
⋮----
s_registeredCommands.Clear();
GlobalCommandsInternal.Clear();
GuildCommandsInternal.Clear();
s_missingScopeGuildIdsGlobal.Clear();
this.MISSING_SCOPE_GUILD_IDS.Clear();
HandledInteractions.Clear();
⋮----
///     Cleans all guild application commands.
///     &lt;note type=&quot;caution&quot;&gt;You normally don&apos;t need to execute it.&lt;/note&gt;
⋮----
public async Task CleanGuildCommandsAsync()
⋮----
await this.Client.BulkOverwriteGuildApplicationCommandsAsync(guild.Id, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
⋮----
///     Cleans all global application commands.
⋮----
public async Task CleanGlobalCommandsAsync()
=&gt; await this.Client.BulkOverwriteGlobalApplicationCommandsAsync(Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
⋮----
///     Registers all commands from a given assembly. The command classes need to be public to be considered for
///     registration.
⋮----
/// &lt;param name=&quot;assembly&quot;&gt;Assembly to register commands from.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to register it on.&lt;/param&gt;
public void RegisterGuildCommands(Assembly assembly, ulong guildId)
⋮----
var types = assembly.GetTypes().Where(xt =&gt;
⋮----
var xti = xt.GetTypeInfo();
return xti.IsModuleCandidateType() &amp;&amp; !xti.IsNested;
⋮----
this.RegisterGuildCommands(xt, guildId);
⋮----
public void RegisterGlobalCommands(Assembly assembly)
⋮----
this.RegisterGlobalCommands(xt);
⋮----
///     Registers a command class with optional translation setup for a guild.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The command class to register.&lt;/typeparam&gt;
⋮----
/// &lt;param name=&quot;translationSetup&quot;&gt;A callback to setup translations with.&lt;/param&gt;
public void RegisterGuildCommands&lt;T&gt;(ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
=&gt; this._updateList.Add(new(guildId, new(typeof(T), translationSetup)));
⋮----
/// &lt;param name=&quot;type&quot;&gt;The &lt;see cref=&quot;System.Type&quot; /&gt; of the command class to register.&lt;/param&gt;
⋮----
public void RegisterGuildCommands(Type type, ulong guildId, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
⋮----
if (!typeof(ApplicationCommandsModule).IsAssignableFrom(type))
throw new ArgumentException(&quot;Command classes have to inherit from ApplicationCommandsModule&quot;, nameof(type));
⋮----
this._updateList.Add(new(guildId, new(type, translationSetup)));
⋮----
///     Registers a command class with optional translation setup globally.
⋮----
public void RegisterGlobalCommands&lt;T&gt;(Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null) where T : ApplicationCommandsModule
=&gt; this._updateList.Add(new(null, new(typeof(T), translationSetup)));
⋮----
public void RegisterGlobalCommands(Type type, Action&lt;ApplicationCommandsTranslationContext&gt;? translationSetup = null)
⋮----
this._updateList.Add(new(null, new(type, translationSetup)));
⋮----
///     Fired when the application commands module is ready.
⋮----
add =&gt; this._applicationCommandsModuleReady.Register(value);
remove =&gt; this._applicationCommandsModuleReady.Unregister(value);
⋮----
///     Fired when the application commands modules startup is finished.
⋮----
add =&gt; this._applicationCommandsModuleStartupFinished.Register(value);
remove =&gt; this._applicationCommandsModuleStartupFinished.Unregister(value);
⋮----
///     Fired when guild commands are registered on a guild.
⋮----
add =&gt; this._guildApplicationCommandsRegistered.Register(value);
remove =&gt; this._guildApplicationCommandsRegistered.Unregister(value);
⋮----
///     Fired when the global commands are registered.
⋮----
add =&gt; this._globalApplicationCommandsRegistered.Register(value);
remove =&gt; this._globalApplicationCommandsRegistered.Unregister(value);
⋮----
///     Used for RegisterCommands and the &lt;see cref=&quot;DisCatSharp.DiscordClient.Ready&quot; /&gt; event.
⋮----
internal async Task UpdateAsync()
⋮----
this.Client.Logger.Log(LogLevel.Information, &quot;Request to register commands on shard {shard}&quot;, this.Client.ShardId);
⋮----
this.Client.Logger.Log(LogLevel.Information, &quot;Shard {shard} already setup, skipping&quot;, this.Client.ShardId);
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Shard {shard} has {guilds} guilds&quot;, this.Client.ShardId, this.Client.ReadyGuildIds.Count);
⋮----
var globalCommands = IsCalledByUnitTest ? null : (await this.Client.GetGlobalApplicationCommandsAsync(Configuration?.EnableLocalization ?? false).ConfigureAwait(false))?.ToList() ?? null;
⋮----
var guilds = CheckAllGuilds ? this.Client.ReadyGuildIds : this._updateList.Where(x =&gt; x.Key is not null)?.Select(x =&gt; x.Key!.Value).Distinct().ToList();
var wrongShards = guilds is not null &amp;&amp; this.Client.ReadyGuildIds.Count is not 0 ? guilds.Where(x =&gt; !this.Client.ReadyGuildIds.Contains(x)).ToList() : [];
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Some guilds are not on the same shard as the client. Removing them from the update list&quot;);
⋮----
this._updateList.RemoveAll(x =&gt; x.Key == guild);
⋮----
var commandsPending = this._updateList.Select(x =&gt; x.Key).Distinct().ToList();
⋮----
commands = (await this.Client.GetGuildApplicationCommandsAsync(guild, Configuration?.EnableLocalization ?? false).ConfigureAwait(false)).ToList() ?? null;
⋮----
GuildDiscordCommands.Add(guild, [.. commands]);
⋮----
failedGuilds.Add(guild);
⋮----
//Default should be to add the help and slash commands can be added without setting any configuration
//so this should still add the default help
⋮----
this._updateList.Add(new(null, new(typeof(DefaultHelpModule))));
commandsPending = this._updateList.Select(x =&gt; x.Key).Distinct().ToList();
⋮----
this._updateList.Add(new(null, new(typeof(DefaultUserAppsHelpModule))));
⋮----
this._updateList.Remove(new(null, new(typeof(DefaultHelpModule))));
⋮----
GlobalDiscordCommands.AddRange(globalCommands);
⋮----
var entryPointCommand = globalCommands.First(command =&gt; command.Name == &quot;launch&quot;);
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, key.HasValue ? $&quot;Registering commands in guild {key.Value}&quot; : &quot;Registering global commands&quot;);
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Found guild {guild} in shard {shard}!&quot;, key.Value, this.Client.ShardId);
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Registering&quot;);
⋮----
await this.RegisterCommands(this._updateList.Where(x =&gt; x.Key == key).Select(x =&gt; x.Value).ToList(), key).ConfigureAwait(false);
⋮----
s_missingScopeGuildIdsGlobal.AddRange(failedGuilds);
⋮----
this.Client.Logger.Log(LogLevel.Information, &quot;Application command setup finished for shard {ShardId}, enabling receiving&quot;, this.Client.ShardId);
await this._applicationCommandsModuleStartupFinished.InvokeAsync(this, new(Configuration.ServiceProvider)
⋮----
}).ConfigureAwait(false);
this.FinishedRegistration();
⋮----
this.Client.Logger.LogCritical(ex, &quot;There was an error during the application commands setup&quot;);
this.Client.Logger.LogError(ex.Message);
this.Client.Logger.LogError(ex.StackTrace);
⋮----
///     Method for registering commands for a target from modules.
⋮----
/// &lt;param name=&quot;types&quot;&gt;The types.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The optional guild id.&lt;/param&gt;
private async Task RegisterCommands(List&lt;ApplicationCommandsModuleConfiguration&gt; types, ulong? guildId)
⋮----
this.Client.Logger.Log(LogLevel.Information, &quot;Registering commands on shard {shard}&quot;, this.Client.ShardId);
//Initialize empty lists to be added to the global ones at the end
⋮----
//Iterates over all the modules
⋮----
var module = type.GetTypeInfo();
⋮----
var ctx = new ApplicationCommandsTranslationContext(type, module.FullName);
⋮----
//Add module to classes list if it&apos;s a group
⋮----
classes.Add(module);
else if (module.GetMembers(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance).Any(x =&gt; x.IsDefined(typeof(SlashCommandGroupAttribute))))
⋮----
//Otherwise add the extreme nested groups
classes = module.GetMembers(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)
.Where(x =&gt; x.IsDefined(typeof(SlashCommandGroupAttribute)))
.Select(x =&gt; module.GetNestedType(x.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance).GetTypeInfo()).ToList();
⋮----
//Otherwise add the nested groups
classes = module.DeclaredNestedTypes.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandGroupAttribute&gt;() != null).ToList();
⋮----
if (!string.IsNullOrEmpty(ctx.GroupTranslations))
⋮----
var slashGroupsTuple = await NestedCommandWorker.ParseSlashGroupsAsync(type, classes, guildId, groupTranslations).ConfigureAwait(false);
⋮----
unitTestCommands.AddRange(slashGroupsTuple.applicationCommands);
updateList.AddRange(slashGroupsTuple.applicationCommands);
⋮----
foreach (var scg in cmd.Options.Where(x =&gt; x.Type is ApplicationCommandOptionType.SubCommandGroup))
⋮----
cs.Add(new(sc.Name, sc.Description, null, null, sc.RawNameLocalizations, sc.RawDescriptionLocalizations));
⋮----
cs.Add(new(sc.Name, sc.Description, [.. sc.Options], null, sc.RawNameLocalizations, sc.RawDescriptionLocalizations));
cgs.Add(new(scg.Name, scg.Description, cs, null, scg.RawNameLocalizations, scg.RawDescriptionLocalizations));
⋮----
foreach (var sc2 in cmd.Options.Where(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand))
⋮----
cs2.Add(new(sc2.Name, sc2.Description, null, null, sc2.RawNameLocalizations, sc2.RawDescriptionLocalizations));
⋮----
cs2.Add(new(sc2.Name, sc2.Description, [.. sc2.Options], null, sc2.RawNameLocalizations, sc2.RawDescriptionLocalizations));
⋮----
cgwsgs.Add(new(cmd.Name, cmd.Description, cgs, cs2, cmd.Type, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
⋮----
groupTranslation.AddRange(cgwsgs.Select(cgwsg =&gt; JsonConvert.DeserializeObject&lt;GroupTranslator&gt;(JsonConvert.SerializeObject(cgwsg))!));
⋮----
commandTypeSources.AddRange(slashGroupsTuple.commandTypeSources);
⋮----
s_singletonModules.AddRange(slashGroupsTuple.singletonModules);
⋮----
groupCommands.AddRange(slashGroupsTuple.groupCommands);
⋮----
subGroupCommands.AddRange(slashGroupsTuple.subGroupCommands);
⋮----
//Handles methods and context menus, only if the module isn&apos;t a group itself
⋮----
if (!string.IsNullOrEmpty(ctx.SingleTranslations))
⋮----
//Slash commands
var methods = module.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;SlashCommandAttribute&gt;() is not null);
⋮----
var slashCommands = await CommandWorker.ParseBasicSlashCommandsAsync(type, methods, guildId, commandTranslations).ConfigureAwait(false);
⋮----
unitTestCommands.AddRange(slashCommands.applicationCommands);
updateList.AddRange(slashCommands.applicationCommands);
⋮----
foreach (var cmd in slashCommands.applicationCommands.Where(cmd =&gt; cmd.Type is ApplicationCommandType.ChatInput &amp;&amp; (cmd.Options is null || !cmd.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand or ApplicationCommandOptionType.SubCommandGroup))))
⋮----
cs.Add(new(cmd.Name, cmd.Description, null, ApplicationCommandType.ChatInput, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
⋮----
cs.Add(new(cmd.Name, cmd.Description, [.. cmd.Options], ApplicationCommandType.ChatInput, cmd.RawNameLocalizations, cmd.RawDescriptionLocalizations));
⋮----
//translation.AddRange(cs.Select(c =&gt; JsonConvert.DeserializeObject&lt;CommandTranslator&gt;(JsonConvert.SerializeObject(c))!));
⋮----
var json = JsonConvert.SerializeObject(c);
⋮----
translation.Add(obj!);
⋮----
commandTypeSources.AddRange(slashCommands.commandTypeSources);
⋮----
commandMethods.AddRange(slashCommands.commandMethods);
⋮----
//Context Menus
var contextMethods = module.DeclaredMethods.Where(x =&gt; x.GetCustomAttribute&lt;ContextMenuAttribute&gt;() is not null);
⋮----
var contextCommands = await CommandWorker.ParseContextMenuCommands(type, contextMethods, commandTranslations).ConfigureAwait(false);
⋮----
unitTestCommands.AddRange(contextCommands.applicationCommands);
updateList.AddRange(contextCommands.applicationCommands);
⋮----
cs.Add(new(cmd.Name, null, null, cmd.Type));
⋮----
translation.AddRange(cs.Select(c =&gt; JsonConvert.DeserializeObject&lt;CommandTranslator&gt;(JsonConvert.SerializeObject(c))!));
⋮----
commandTypeSources.AddRange(contextCommands.commandTypeSources);
⋮----
contextMenuCommands.AddRange(contextCommands.contextMenuCommands);
⋮----
//Accounts for lifespans
⋮----
s_singletonModules.Add(CreateInstance(module, Configuration.ServiceProvider));
⋮----
this.Client.Logger.LogCritical(ex, &quot;NRE Exception thrown: {msg}\nStack: {stack}&quot;, ex.Message, ex.StackTrace);
⋮----
this.Client.Logger.LogCritical(brex, @&quot;There was an error registering application commands: {res}&quot;, brex.WebResponse.Response);
⋮----
this.Client.Logger.LogCritical(brex1, @&quot;There was an error registering application commands: {res}&quot;, brex1.WebResponse.Response);
⋮----
this.Client.Logger.LogCritical(ex, @&quot;There was an error parsing the application commands&quot;);
⋮----
updateList = updateList.DistinctBy(x =&gt; x.Name).ToList();
⋮----
await this.CheckRegistrationStartup(translation, groupTranslation, guildId);
⋮----
var regCommands = await RegistrationWorker.RegisterGlobalCommandsAsync(this.Client, updateList, EntryPointCommand).ConfigureAwait(false);
⋮----
var actualCommands = regCommands.Distinct().ToList();
commands.AddRange(actualCommands);
GlobalCommandsInternal.AddRange(actualCommands);
⋮----
await this.Client.DeleteGlobalApplicationCommandAsync(cmd.Id).ConfigureAwait(false);
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Could not delete global command {cmdId}. Please clean up manually&quot;, cmd.Id);
⋮----
var regCommands = await RegistrationWorker.RegisterGuildCommandsAsync(this.Client, guildId.Value, updateList).ConfigureAwait(false);
⋮----
GuildCommandsInternal.Add(guildId.Value, actualCommands);
⋮----
if (this.Client.Guilds.TryGetValue(guildId.Value, out var guild))
guild.InternalRegisteredApplicationCommands.AddRange(actualCommands);
⋮----
foreach (var cmd in GuildDiscordCommands.First(x =&gt; x.Key == guildId.Value).Value)
⋮----
await this.Client.DeleteGuildApplicationCommandAsync(guildId.Value, cmd.Id).ConfigureAwait(false);
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Could not delete guild command {cmdId} in guild {guildId}. Please clean up manually&quot;, cmd.Id, guildId.Value);
⋮----
this.Client.Logger.LogError(&quot;Could not register application commands for guild {guildId}.\nError: {exc}&quot;, guildId, ex.JsonMessage);
⋮----
//Creates a guild command if a guild id is specified, otherwise global
//Checks against the ids and adds them to the command method lists
⋮----
if (commandMethods!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var com))
⋮----
if (groupCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var groupCom))
⋮----
if (subGroupCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var subCom))
⋮----
if (contextMenuCommands!.TryGetFirstValueWhere(x =&gt; x.Name == command.Name, out var cmCom))
⋮----
//Adds to the global lists finally
CommandMethods.AddRange(commandMethods.DistinctBy(x =&gt; x.Name));
GroupCommands.AddRange(groupCommands.DistinctBy(x =&gt; x.Name));
SubGroupCommands.AddRange(subGroupCommands.DistinctBy(x =&gt; x.Name));
ContextMenuCommands.AddRange(contextMenuCommands.DistinctBy(x =&gt; x.Name));
⋮----
s_registeredCommands.Add(new(guildId, commands.ToList()));
⋮----
foreach (var app in commandMethods.Select(command =&gt; types.First(t =&gt; t.Type == command.Method.DeclaringType)))
⋮----
await this._guildApplicationCommandsRegistered.InvokeAsync(this, new(Configuration.ServiceProvider)
⋮----
RegisteredCommands = GuildCommandsInternal.FirstOrDefault(c =&gt; c.Key == guildId.Value).Value ?? []
⋮----
await this._globalApplicationCommandsRegistered.InvokeAsync(this, new(Configuration.ServiceProvider)
⋮----
this.Client.Logger.LogCritical(ex, @&quot;There was an general error registering application commands&quot;);
⋮----
s_registeredCommands.Add(new(guildId, unitTestCommands.ToList()));
⋮----
///     Checks the registration startup.
⋮----
/// &lt;param name=&quot;translation&quot;&gt;The optional translations.&lt;/param&gt;
/// &lt;param name=&quot;groupTranslation&quot;&gt;The optional group translations.&lt;/param&gt;
⋮----
private async Task CheckRegistrationStartup(List&lt;CommandTranslator&gt;? translation = null, List&lt;GroupTranslator&gt;? groupTranslation = null, ulong? guildId = null)
⋮----
var fs = File.Create(fileName);
var ms = new MemoryStream();
var writer = new StreamWriter(ms);
await writer.WriteAsync(JsonConvert.SerializeObject(translation.DistinctBy(x =&gt; x.Name), Formatting.Indented)).ConfigureAwait(false);
await writer.FlushAsync().ConfigureAwait(false);
⋮----
await ms.CopyToAsync(fs).ConfigureAwait(false);
await fs.FlushAsync().ConfigureAwait(false);
fs.Close();
await fs.DisposeAsync().ConfigureAwait(false);
ms.Close();
await ms.DisposeAsync().ConfigureAwait(false);
this.Client.Logger.LogInformation(&quot;Exported base translation to {exppath}&quot;, fileName);
⋮----
await writer.WriteAsync(JsonConvert.SerializeObject(groupTranslation.DistinctBy(x =&gt; x.Name), Formatting.Indented)).ConfigureAwait(false);
⋮----
this.Client.Logger.LogError(@&quot;{msg}&quot;, ex.Message);
this.Client.Logger.LogError(@&quot;{stack}&quot;, ex.StackTrace);
⋮----
await this.Client.DisconnectAsync().ConfigureAwait(false);
⋮----
///     Checks whether we finished up the complete startup.
⋮----
private async Task CheckStartupFinishAsync(ApplicationCommandsExtension sender, ApplicationCommandsModuleStartupFinishedEventArgs args)
⋮----
await this._applicationCommandsModuleReady.InvokeAsync(sender, new(Configuration.ServiceProvider)
⋮----
Environment.Exit(0);
⋮----
///     Interaction handler.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The event args.&lt;/param&gt;
private Task InteractionHandler(DiscordClient client, InteractionCreateEventArgs e)
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Got slash interaction on shard {shard}&quot;, this.Client.ShardId);
if (HandledInteractions.Contains(e.Interaction.Id) || (e.Interaction is { GuildId: not null, AuthorizingIntegrationOwners.GuildInstallKey: not null } &amp;&amp; !client.Guilds.ContainsKey(e.Interaction.GuildId.Value)))
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Ignoring, already received or wrong shard&quot;);
return Task.FromResult(true);
⋮----
HandledInteractions.Add(e.Interaction.Id);
⋮----
_ = Task.Run(async () =&gt;
⋮----
//Creates the context
var context = new InteractionContext
⋮----
ResolvedUserMentions = e.Interaction.Data.Resolved?.Users?.Values.ToList() ?? [],
ResolvedRoleMentions = e.Interaction.Data.Resolved?.Roles?.Values.ToList() ?? [],
ResolvedChannelMentions = e.Interaction.Data.Resolved?.Channels?.Values.ToList() ?? [],
ResolvedAttachments = e.Interaction.Data.Resolved?.Attachments?.Values.ToList() ?? [],
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Application commands failed to register properly on startup.&quot;).AsEphemeral()).ConfigureAwait(false);
throw new InvalidOperationException(&quot;Application commands failed to register properly on startup.&quot;);
⋮----
var methods = CommandMethods.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
var groups = GroupCommands.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
var subgroups = SubGroupCommands.Where(x =&gt; x.CommandId == e.Interaction.Data.Id).ToList();
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;An application command was executed, but no command was registered for it.&quot;).AsEphemeral()).ConfigureAwait(false);
throw new InvalidOperationException($&quot;An application command was executed, but no command was registered for it.\n\tCommand name: {e.Interaction.Data.Name}\n\tCommand ID: {e.Interaction.Data.Id}&quot;);
⋮----
var method = methods.First().Method;
⋮----
this.Client.Logger.LogDebug(&quot;Executing {cmd}&quot;, method.Name);
var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options).ConfigureAwait(false);
⋮----
await this.RunCommandAsync(context, method, args).ConfigureAwait(false);
⋮----
var method = groups.First().Methods.First(x =&gt; x.Key == command.Name).Value;
⋮----
var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options[0].Options).ConfigureAwait(false);
⋮----
var group = subgroups.First().SubCommands.First(x =&gt; x.Name == command.Name);
⋮----
var method = group.Methods.First(x =&gt; x.Key == command.Options[0].Name).Value;
⋮----
var args = await this.ResolveInteractionCommandParameters(e, context, method, e.Interaction.Data.Options[0].Options[0].Options).ConfigureAwait(false);
⋮----
throw new ArgumentOutOfRangeException(null, &quot;Could not determine application command type&quot;);
⋮----
await this._slashExecuted.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
await this._slashError.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
this.Client.Logger.LogError(ex, &quot;Error in slash interaction&quot;);
⋮----
throw new InvalidOperationException(&quot;An autocomplete interaction was created, but no command was registered for it&quot;);
⋮----
var focusedOption = e.Interaction.Data.Options.First(o =&gt; o.Focused);
⋮----
var option = method.GetParameters().Skip(1).First(p =&gt; p.GetCustomAttribute&lt;OptionAttribute&gt;().Name == focusedOption.Name);
⋮----
var providerMethod = provider.GetMethod(nameof(IAutocompleteProvider.Provider));
var providerInstance = Activator.CreateInstance(provider);
⋮----
var context = new AutocompleteContext
⋮----
Options = e.Interaction.Data.Options.ToList(),
⋮----
var choices = await ((Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt;)providerMethod.Invoke(providerInstance, [context])).ConfigureAwait(false);
await e.Interaction.CreateResponseAsync(InteractionResponseType.AutoCompleteResult, new DiscordInteractionResponseBuilder().AddAutoCompleteChoices(choices)).ConfigureAwait(false);
⋮----
var group = groups.First().Methods.First(x =&gt; x.Key == command.Name).Value;
⋮----
var focusedOption = command.Options.First(o =&gt; o.Focused);
var option = group.GetParameters().Skip(1).First(p =&gt; p.GetCustomAttribute&lt;OptionAttribute&gt;().Name == focusedOption.Name);
⋮----
Options = command.Options.ToList(),
⋮----
var group = subgroups.First().SubCommands.First(x =&gt; x.Name == command.Name).Methods.First(x =&gt; x.Key == command.Options[0].Name).Value;
⋮----
var focusedOption = command.Options[0].Options.First(o =&gt; o.Focused);
⋮----
Options = command.Options[0].Options.ToList(),
⋮----
this.Client.Logger.LogError(ex, &quot;Error in autocomplete interaction&quot;);
⋮----
throw new ArgumentOutOfRangeException(null, &quot;Received out unknown interaction type&quot;);
⋮----
///     Gets the interaction type from the interaction data.
⋮----
/// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;
⋮----
private static ApplicationCommandFinalType GetInteractionType(DiscordInteractionData data)
⋮----
if (data.Options.All(x =&gt;
⋮----
if (data.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommandGroup))
⋮----
else if (data.Options.Any(x =&gt; x.Type is ApplicationCommandOptionType.SubCommand))
⋮----
///     Context menu handler.
⋮----
private Task ContextMenuHandler(DiscordClient client, ContextMenuInteractionCreateEventArgs e)
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Got context menu interaction on shard {shard}&quot;, this.Client.ShardId);
if (HandledInteractions.Contains(e.Interaction.Id))
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Ignoring, already received&quot;);
⋮----
var context = new ContextMenuContext(e.Type switch
⋮----
_ =&gt; throw new ArgumentOutOfRangeException(nameof(e.Type), &quot;Unknown context menu type&quot;)
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;Context menus failed to register properly on startup.&quot;).AsEphemeral()).ConfigureAwait(false);
throw new InvalidOperationException(&quot;Context menus failed to register properly on startup.&quot;);
⋮----
//Gets the method for the command
var method = ContextMenuCommands.FirstOrDefault(x =&gt; x.CommandId == e.Interaction.Data.Id);
⋮----
await e.Interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(&quot;A context menu command was executed, but no command was registered for it.&quot;).AsEphemeral()).ConfigureAwait(false);
throw new InvalidOperationException(&quot;A context menu command was executed, but no command was registered for it.&quot;);
⋮----
await this.RunCommandAsync(context, method.Method, new[] { context }).ConfigureAwait(false);
⋮----
await this._contextMenuExecuted.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
await this._contextMenuErrored.InvokeAsync(this, new(this.Client.ServiceProvider)
⋮----
///     Runs a command.
⋮----
/// &lt;param name=&quot;context&quot;&gt;The base context.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;The method info.&lt;/param&gt;
/// &lt;param name=&quot;args&quot;&gt;The arguments.&lt;/param&gt;
internal async Task RunCommandAsync(BaseContext context, MethodInfo method, IEnumerable&lt;object&gt; args)
⋮----
this.Client.Logger.Log(ApplicationCommandsLogLevel, &quot;Executing {cmd}&quot;, method.Name);
⋮----
// Create service scope for scoped modules and store in context for disposal
IServiceProvider serviceProvider;
⋮----
context.ServiceScope = Configuration.ServiceProvider.CreateScope();
⋮----
//Accounts for static methods and adds DI with scoped service provider
method.IsStatic ? ActivatorUtilities.CreateInstance(serviceProvider, method.DeclaringType) : CreateInstance(method.DeclaringType, serviceProvider),
⋮----
//Accounts for static methods and adds DI
method.IsStatic ? ActivatorUtilities.CreateInstance(Configuration?.ServiceProvider, method.DeclaringType) : CreateInstance(method.DeclaringType, Configuration?.ServiceProvider),
//If singleton, gets it from the singleton list
ApplicationCommandModuleLifespan.Singleton =&gt; s_singletonModules.First(x =&gt; ReferenceEquals(x.GetType(), method.DeclaringType)),
⋮----
ApplicationCommandsModule module = null;
⋮----
// Slash commands
⋮----
await RunPreexecutionChecksAsync(method, slashContext).ConfigureAwait(false);
⋮----
var shouldExecute = await (module?.BeforeSlashExecutionAsync(slashContext) ?? Task.FromResult(true)).ConfigureAwait(false);
⋮----
await context.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource).ConfigureAwait(false);
await ((Task)method.Invoke(classInstance, args.ToArray())).ConfigureAwait(false);
⋮----
await (module?.AfterSlashExecutionAsync(slashContext) ?? Task.CompletedTask).ConfigureAwait(false);
⋮----
// Context menus
⋮----
await RunPreexecutionChecksAsync(method, contextMenuContext).ConfigureAwait(false);
⋮----
var shouldExecute = await (module?.BeforeContextMenuExecutionAsync(contextMenuContext) ?? Task.FromResult(true)).ConfigureAwait(false);
⋮----
await (module?.AfterContextMenuExecutionAsync(contextMenuContext) ?? Task.CompletedTask).ConfigureAwait(false);
⋮----
// Ensure service scope is properly disposed
⋮----
///     Property injection
⋮----
/// &lt;param name=&quot;t&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;services&quot;&gt;The services.&lt;/param&gt;
internal static object CreateInstance(Type t, IServiceProvider services)
⋮----
var ti = t.GetTypeInfo();
⋮----
.Where(xci =&gt; xci.IsPublic)
.ToArray();
⋮----
throw new ArgumentException(&quot;Specified type does not contain a public constructor or contains more than one public constructor.&quot;);
⋮----
var constructorArgs = constructor.GetParameters();
⋮----
throw new InvalidOperationException(&quot;Dependency collection needs to be specified for parameterized constructors.&quot;);
⋮----
// inject via constructor
⋮----
args[i] = services.GetRequiredService(constructorArgs[i].ParameterType);
⋮----
var moduleInstance = Activator.CreateInstance(t, args);
⋮----
// inject into properties
var props = t.GetRuntimeProperties().Where(xp =&gt; xp.CanWrite &amp;&amp; xp.SetMethod is not null &amp;&amp; !xp.SetMethod.IsStatic &amp;&amp; xp.SetMethod.IsPublic);
⋮----
var service = services.GetService(prop.PropertyType);
⋮----
prop.SetValue(moduleInstance, service);
⋮----
// inject into fields
var fields = t.GetRuntimeFields().Where(xf =&gt; !xf.IsInitOnly &amp;&amp; xf is { IsStatic: false, IsPublic: true });
⋮----
var service = services.GetService(field.FieldType);
⋮----
field.SetValue(moduleInstance, service);
⋮----
///     Resolves the slash command parameters.
⋮----
/// &lt;param name=&quot;e&quot;&gt;The event arguments.&lt;/param&gt;
/// &lt;param name=&quot;context&quot;&gt;The interaction context.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;options&quot;&gt;The options.&lt;/param&gt;
private async Task&lt;List&lt;object?&gt;&gt; ResolveInteractionCommandParameters(InteractionCreateEventArgs e, InteractionContext context, MethodBase method, IReadOnlyList&lt;DiscordInteractionDataOption&gt; options)
⋮----
var parameters = method.GetParameters().Skip(1).ToList();
⋮----
//Accounts for optional arguments without values given
if (parameter.IsOptional &amp;&amp; (options is null || (!options?.Any(x =&gt; x.Name == parameter.GetCustomAttribute&lt;OptionAttribute&gt;()?.Name.ToLower()) ?? true)))
args.Add(parameter.DefaultValue);
⋮----
var option = options.Single(x =&gt; x.Name == parameter.GetCustomAttribute&lt;OptionAttribute&gt;()?.Name.ToLower());
⋮----
args.Add(option.Value.ToString());
⋮----
args.Add(Enum.Parse(parameter.ParameterType, (string)option.Value));
⋮----
args.Add((ulong?)option.Value);
⋮----
args.Add((int?)option.Value);
⋮----
args.Add(null);
⋮----
args.Add(Convert.ToInt64(option.Value));
⋮----
args.Add((bool?)option.Value);
⋮----
args.Add((double?)option.Value);
⋮----
//Checks through resolved
⋮----
e.Interaction.Data.Resolved.Attachments.TryGetValue((ulong)option.Value, out var attachment))
args.Add(attachment);
⋮----
args.Add(new DiscordAttachment
⋮----
e.Interaction.Data.Resolved.Members.TryGetValue((ulong)option.Value, out var member))
args.Add(member);
⋮----
e.Interaction.Data.Resolved.Users.TryGetValue((ulong)option.Value, out var user))
args.Add(user);
⋮----
args.Add(await this.Client.GetUserAsync((ulong)option.Value).ConfigureAwait(false));
⋮----
e.Interaction.Data.Resolved.Channels.TryGetValue((ulong)option.Value, out var channel))
args.Add(channel);
⋮----
args.Add(e.Interaction.Guild.GetChannel((ulong)option.Value));
⋮----
e.Interaction.Data.Resolved.Roles.TryGetValue((ulong)option.Value, out var role))
args.Add(role);
⋮----
args.Add(e.Interaction.Guild.GetRole((ulong)option.Value));
⋮----
if (e.Interaction.Data.Resolved.Channels != null &amp;&amp; e.Interaction.Data.Resolved.Channels.TryGetValue((ulong)option.Value, out var channel))
⋮----
if (e.Interaction.Data.Resolved.Roles != null &amp;&amp; e.Interaction.Data.Resolved.Roles.TryGetValue((ulong)option.Value, out var role))
⋮----
else if (e.Interaction.Data.Resolved.Members != null &amp;&amp; e.Interaction.Data.Resolved.Members.TryGetValue((ulong)option.Value, out var member))
⋮----
else if (e.Interaction.Data.Resolved.Users != null &amp;&amp; e.Interaction.Data.Resolved.Users.TryGetValue((ulong)option.Value, out var user))
⋮----
throw new ArgumentException(&quot;Error resolving mentionable option.&quot;);
⋮----
throw new ArgumentException(&quot;Error resolving interaction.&quot;);
⋮----
///     Runs the pre-execution checks.
⋮----
private static async Task RunPreexecutionChecksAsync(MemberInfo method, BaseContext context)
⋮----
//Gets all attributes from parent classes as well and stuff
⋮----
attributes.AddRange(method.DeclaringType.DeclaringType.DeclaringType.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
attributes.AddRange(method.DeclaringType.DeclaringType.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
⋮----
attributes.AddRange(method.DeclaringType!.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;());
attributes.AddRange(method.GetCustomAttributes&lt;ApplicationCommandCheckBaseAttribute&gt;(true));
⋮----
//Runs the check and adds the result to a list
var result = await att.ExecuteChecksAsync(ctx).ConfigureAwait(false);
dict.Add(att, result);
⋮----
//Checks if any failed, and throws an exception
if (dict.Any(x =&gt; x.Value is false))
throw new SlashExecutionChecksFailedException
⋮----
FailedChecks = dict.Where(x =&gt; x.Value is false).Select(x =&gt; x.Key).ToList()
⋮----
var result = await att.ExecuteChecksAsync(cMctx).ConfigureAwait(false);
⋮----
throw new ContextMenuExecutionChecksFailedException
⋮----
///     Gets the choice attributes from choice provider.
⋮----
/// &lt;param name=&quot;customAttributes&quot;&gt;The custom attributes.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The optional guild id&lt;/param&gt;
private static async Task&lt;List&lt;DiscordApplicationCommandOptionChoice&gt;&gt; GetChoiceAttributesFromProvider(List&lt;ChoiceProviderAttribute&gt; customAttributes, ulong? guildId = null)
⋮----
var method = choiceProviderAttribute.ProviderType.GetMethod(nameof(IChoiceProvider.Provider)) ?? throw new ArgumentException(&quot;ChoiceProviders must inherit from IChoiceProvider.&quot;);
var instance = Activator.CreateInstance(choiceProviderAttribute.ProviderType);
⋮----
// Abstract class offers more properties that can be set
if (choiceProviderAttribute.ProviderType.IsSubclassOf(typeof(ChoiceProvider)))
⋮----
choiceProviderAttribute.ProviderType.GetProperty(nameof(ChoiceProvider.GuildId))
⋮----
choiceProviderAttribute.ProviderType.GetProperty(nameof(ChoiceProvider.Services))
⋮----
//Gets the choices from the method
var result = (await ((Task&lt;IEnumerable&lt;DiscordApplicationCommandOptionChoice&gt;&gt;)method.Invoke(instance, null)!).ConfigureAwait(false)).ToList();
⋮----
choices.AddRange(result);
⋮----
///     Gets the choice attributes from enum parameter.
⋮----
/// &lt;param name=&quot;enumParam&quot;&gt;The enum parameter.&lt;/param&gt;
private static List&lt;DiscordApplicationCommandOptionChoice&gt; GetChoiceAttributesFromEnumParameter(Type enumParam)
=&gt; (from Enum enumValue in Enum.GetValues(enumParam) select new DiscordApplicationCommandOptionChoice(enumValue.GetName(), enumValue.ToString())).ToList();
⋮----
///     Gets the parameter type.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
private static ApplicationCommandOptionType GetParameterType(Type type)
⋮----
: throw new ArgumentException(&quot;Cannot convert type! Argument types must be string, int, long, bool, double, DiscordChannel, DiscordUser, DiscordRole, SnowflakeObject, DiscordAttachment or an Enum.&quot;);
⋮----
///     Gets the choice attributes from parameter.
⋮----
/// &lt;param name=&quot;choiceAttributes&quot;&gt;The choice attributes.&lt;/param&gt;
private static List&lt;DiscordApplicationCommandOptionChoice&gt; GetChoiceAttributesFromParameter(List&lt;ChoiceAttribute&gt; choiceAttributes) =&gt;
⋮----
: choiceAttributes.Select(att =&gt; new DiscordApplicationCommandOptionChoice(att.Name, att.Value)).ToList();
⋮----
///     Parses the parameters.
⋮----
/// &lt;param name=&quot;parameters&quot;&gt;The parameters.&lt;/param&gt;
/// &lt;param name=&quot;commandName&quot;&gt;The command name.&lt;/param&gt;
⋮----
internal static async Task&lt;List&lt;DiscordApplicationCommandOption&gt;&gt; ParseParametersAsync(IEnumerable&lt;ParameterInfo&gt; parameters, string commandName, ulong? guildId)
⋮----
//Gets the attribute
var optionAttribute = parameter.GetCustomAttribute&lt;OptionAttribute&gt;() ?? throw new ArgumentException($&quot;One or more arguments of the command &apos;{commandName}&apos; are missing the Option attribute!&quot;);
⋮----
throw new ArgumentException($&quot;The command &apos;{commandName}&apos; has autocomplete enabled but is missing an autocomplete attribute!&quot;);
⋮----
throw new ArgumentException($&quot;The command &apos;{commandName}&apos; has an autocomplete provider but the option to have autocomplete set to false!&quot;);
⋮----
//Sets the type
⋮----
//Handles choices
//From attributes
var choices = GetChoiceAttributesFromParameter(parameter.GetCustomAttributes&lt;ChoiceAttribute&gt;().ToList());
//From enums
⋮----
//From choice provider
var choiceProviders = parameter.GetCustomAttributes&lt;ChoiceProviderAttribute&gt;().ToList();
⋮----
choices = await GetChoiceAttributesFromProvider(choiceProviders, guildId).ConfigureAwait(false);
⋮----
options.Add(new(optionAttribute.Name, optionAttribute.Description, parameterType, !parameter.IsOptional, choices, null, channelTypes, optionAttribute.Autocomplete, minimumValue, maximumValue, minimumLength: minimumLength, maximumLength: maximumLength));
⋮----
/*
	/// &lt;summary&gt;
	/// &lt;para&gt;Refreshes your commands, used for refreshing choice providers or applying commands registered after the ready event on the discord client.&lt;/para&gt;
	/// &lt;para&gt;Not recommended and should be avoided since it can make slash commands be unresponsive for a while.&lt;/para&gt;
	/// &lt;/summary&gt;
	public async Task RefreshCommandsAsync()
	{
		s_commandMethods.Clear();
		s_groupCommands.Clear();
		s_subGroupCommands.Clear();
		_registeredCommands.Clear();
		s_contextMenuCommands.Clear();
		GlobalDiscordCommands.Clear();
		GuildDiscordCommands.Clear();
		GuildCommandsInternal.Clear();
		GlobalCommandsInternal.Clear();
		GlobalDiscordCommands = null;
		GuildDiscordCommands = null;
		s_errored = false;

		/*if (Configuration != null &amp;&amp; Configuration.EnableDefaultHelp)
		{
			this._updateList.RemoveAll(x =&gt; x.Value.Type == typeof(DefaultHelpModule));
		}*/
/*
		await this.UpdateAsync();
	}*/
⋮----
///     Fires when the execution of a slash command fails.
⋮----
add =&gt; this._slashError.Register(value);
remove =&gt; this._slashError.Unregister(value);
⋮----
///     Fires when the execution of a slash command is successful.
⋮----
add =&gt; this._slashExecuted.Register(value);
remove =&gt; this._slashExecuted.Unregister(value);
⋮----
///     Fires when the execution of a context menu fails.
⋮----
add =&gt; this._contextMenuErrored.Register(value);
remove =&gt; this._contextMenuErrored.Unregister(value);
⋮----
///     Fire when the execution of a context menu is successful.
⋮----
add =&gt; this._contextMenuExecuted.Register(value);
remove =&gt; this._contextMenuExecuted.Unregister(value);
⋮----
///     Holds configuration data for setting up an application command.
⋮----
internal sealed class ApplicationCommandsModuleConfiguration
⋮----
///     Creates a new command configuration.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type of the command module.&lt;/param&gt;
/// &lt;param name=&quot;translations&quot;&gt;The translation setup callback.&lt;/param&gt;
⋮----
///     The type of the command module.
⋮----
///     The translation setup.
⋮----
///     Links a command to its original command module.
⋮----
internal class ApplicationCommandSourceLink
⋮----
///     The command.
⋮----
///     The base/root module the command is contained in.
⋮----
///     The direct group the command is contained in.
⋮----
///     The command method.
⋮----
internal sealed class CommandMethod
⋮----
///     Gets or sets the command id.
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the method.
⋮----
///     The group command.
⋮----
internal sealed class GroupCommand
⋮----
///     Gets or sets the methods.
⋮----
///     The sub group command.
⋮----
internal sealed class SubGroupCommand
⋮----
///     Gets or sets the sub commands.
⋮----
///     The context menu command.
⋮----
internal sealed class ContextMenuCommand
⋮----
///     Represents the default help module.
⋮----
internal sealed class DefaultHelpModule : ApplicationCommandsModule
⋮----
internal async Task DefaultHelpAsync(
⋮----
var globalCommandsTask = ctx.Client.GetGlobalApplicationCommandsAsync();
⋮----
var guildCommandsTask = ctx.Client.GetGuildApplicationCommandsAsync(ctx.Guild.Id);
await Task.WhenAll(globalCommandsTask, guildCommandsTask).ConfigureAwait(false);
applicationCommands = globalCommandsTask.Result.Concat(guildCommandsTask.Result)
.Where(ac =&gt; !ac.Name.Equals(&quot;help&quot;, StringComparison.OrdinalIgnoreCase))
.GroupBy(ac =&gt; ac.Name).Select(x =&gt; x.First())
.ToList();
⋮----
await Task.WhenAll(globalCommandsTask).ConfigureAwait(false);
⋮----
await ctx.EditResponseAsync(new DiscordWebhookBuilder()
.WithContent(&quot;There are no slash commands&quot;)).ConfigureAwait(false);
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder()
.WithContent(&quot;There are no slash commands&quot;).AsEphemeral()).ConfigureAwait(false);
⋮----
if (commandTwoName is not null &amp;&amp; !commandTwoName.Equals(&quot;no_options_for_this_command&quot;))
⋮----
var commandsWithSubCommands = applicationCommands.FindAll(ac =&gt; ac.Options is not null &amp;&amp; ac.Options.Any(op =&gt; op.Type == ApplicationCommandOptionType.SubCommandGroup));
var subCommandParent = commandsWithSubCommands.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
var cmdParent = commandsWithSubCommands.FirstOrDefault(cm =&gt; cm.Options.Any(op =&gt; op.Name.Equals(commandOneName))).Options
.FirstOrDefault(opt =&gt; opt.Name.Equals(commandOneName, StringComparison.OrdinalIgnoreCase));
var cmd = cmdParent.Options.FirstOrDefault(op =&gt; op.Name.Equals(commandTwoName, StringComparison.OrdinalIgnoreCase));
var discordEmbed = new DiscordEmbedBuilder
⋮----
Description = $&quot;{subCommandParent.Mention.Replace(subCommandParent.Name, $&quot;{subCommandParent.Name} {cmdParent.Name} {cmd.Name}&quot;)}: {cmd.Description ?? &quot;No description provided.&quot;}&quot;
⋮----
var commandOptions = cmd.Options.ToList();
var sb = new StringBuilder();
⋮----
sb.Append(&apos;`&apos;).Append(option.Name).Append(&quot;`: &quot;).Append(option.Description ?? &quot;No description provided.&quot;).Append(&apos;\n&apos;);
⋮----
sb.Append(&apos;\n&apos;);
discordEmbed.AddField(new(&quot;Arguments&quot;, sb.ToString().Trim()));
⋮----
.AddEmbed(discordEmbed)).ConfigureAwait(false);
⋮----
await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource,
new DiscordInteractionResponseBuilder().AddEmbed(discordEmbed).AsEphemeral()).ConfigureAwait(false);
⋮----
else if (commandOneName is not null &amp;&amp; commandTwoName is null &amp;&amp; !commandOneName.Equals(&quot;no_options_for_this_command&quot;))
⋮----
var commandsWithOptions = applicationCommands.FindAll(ac =&gt; ac.Options is not null &amp;&amp; ac.Options.All(op =&gt; op.Type == ApplicationCommandOptionType.SubCommand));
var subCommandParent = commandsWithOptions.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
var subCommand = subCommandParent.Options.FirstOrDefault(op =&gt; op.Name.Equals(commandOneName, StringComparison.OrdinalIgnoreCase));
⋮----
Description = $&quot;{subCommandParent.Mention.Replace(subCommandParent.Name, $&quot;{subCommandParent.Name} {subCommand.Name}&quot;)}: {subCommand.Description ?? &quot;No description provided.&quot;}&quot;
⋮----
var commandOptions = subCommand.Options.ToList();
⋮----
await ctx.EditResponseAsync(new DiscordWebhookBuilder().AddEmbed(discordEmbed)).ConfigureAwait(false);
⋮----
var command = applicationCommands.FirstOrDefault(cm =&gt; cm.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
⋮----
.WithContent($&quot;No command called {commandName} in guild {ctx.Guild.Name}&quot;)).ConfigureAwait(false);
⋮----
.WithContent($&quot;No command called {commandName} in guild {ctx.Guild.Name}&quot;).AsEphemeral()).ConfigureAwait(false);
⋮----
}.AddField(new(&quot;Command is NSFW&quot;, command.IsNsfw.ToString()));
⋮----
var commandOptions = command.Options.ToList();
⋮----
public sealed class DefaultHelpAutoCompleteProvider : IAutocompleteProvider
⋮----
public async Task&lt;IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;&gt; Provider(AutocompleteContext context)
⋮----
var globalCommandsTask = context.Client.GetGlobalApplicationCommandsAsync();
⋮----
var guildCommandsTask = context.Client.GetGuildApplicationCommandsAsync(context.Guild.Id);
⋮----
slashCommands = globalCommandsTask.Result.Concat(guildCommandsTask.Result)
⋮----
if (context.Options.Count &gt; 0 &amp;&amp; !string.IsNullOrEmpty(context.Options[0].Value?.ToString()))
slashCommands = slashCommands.Where(ac =&gt; ac.Name.StartsWith(context.Options[0].Value.ToString(), StringComparison.OrdinalIgnoreCase)).ToList();
⋮----
var options = slashCommands.Take(25).Select(sc =&gt; new DiscordApplicationCommandAutocompleteChoice(sc.Name, sc.Name.Trim())).ToList();
return options.AsEnumerable();
⋮----
public sealed class DefaultHelpAutoCompleteLevelOneProvider : IAutocompleteProvider
⋮----
.GroupBy(ac =&gt; ac.Name).Select(x =&gt; x.First());
⋮----
var command = slashCommands.FirstOrDefault(ac =&gt;
ac.Name.Equals(context.Options[0].Value.ToString().Trim(), StringComparison.OrdinalIgnoreCase));
⋮----
options.Add(new(&quot;no_options_for_this_command&quot;, &quot;no_options_for_this_command&quot;));
⋮----
var opt = command.Options.Where(c =&gt; c.Type is ApplicationCommandOptionType.SubCommandGroup or ApplicationCommandOptionType.SubCommand
&amp;&amp; c.Name.StartsWith(context.Options[1].Value.ToString(), StringComparison.InvariantCultureIgnoreCase)).ToList();
options.AddRange(opt.Take(25).Select(option =&gt; new DiscordApplicationCommandAutocompleteChoice(option.Name, option.Name.Trim())));
⋮----
public sealed class DefaultHelpAutoCompleteLevelTwoProvider : IAutocompleteProvider
⋮----
var foundCommand = command.Options.FirstOrDefault(op =&gt; op.Name.Equals(context.Options[1].Value.ToString().Trim(), StringComparison.OrdinalIgnoreCase));
⋮----
var opt = foundCommand.Options.Where(x =&gt; x.Type == ApplicationCommandOptionType.SubCommand &amp;&amp;
x.Name.StartsWith(context.Options[2].Value.ToString(), StringComparison.OrdinalIgnoreCase)).ToList();
⋮----
///     Represents the default user apps help module.
⋮----
internal sealed class DefaultUserAppsHelpModule : ApplicationCommandsModule
⋮----
internal async Task DefaulUserAppstHelpAsync(
⋮----
await globalCommandsTask.ConfigureAwait(false);
⋮----
public sealed class DefaultUserAppsHelpAutoCompleteProvider : IAutocompleteProvider
⋮----
public sealed class DefaultUserAppsHelpAutoCompleteLevelOneProvider : IAutocompleteProvider
⋮----
public sealed class DefaultUserAppsHelpAutoCompleteLevelTwoProvider : IAutocompleteProvider</file><file path="DisCatSharp.Docs/articles/misc/reporting_issues.md">---
uid: misc_reporting_issues
title: Reporting Issues
author: DisCatSharp Team
---

# I broke something, and I need it fixed!

We always try to fix bugs, and make sure that when we release the next version of DisCatSharp, everything is polished and
working. However, DisCatSharp is a large codebase, and we can&apos;t always catch all the bugs, or notice all the regressions
that happen while we fix bugs or implement new issues.

## Issue tracker

If you find a bug, come up with a new idea, or just want to report something, you have multiple ways to do so.

[Discord Guild](https://discord.gg/RXA6u3jxdU &quot;DisCatSharp Support Guild&quot;).
[Issue Tracker](https://github.com/Aiko-IT-Systems/DisCatSharp/issues/new/choose &quot;DisCatSharp Issues&quot;).

When reporting an issue, make sure to include as much detail as possible. If at all possible, please include:

-   Steps to reproduce the issue
-   What were you trying to achieve
-   Expected/actual result
-   Stack traces, exception types, messages
-   Attempted solutions

## Contributing

Lastly, while we understand that not everyone is an expert programmer, we would appreciate it if you could fix any issues you
find and submit a Pull Request on GitHub. This would reduce the amount of work we would have to do.

When contributing, ensure your code matches the style of the rest of the library, and that you test the changes you make, and
catch any possible regressions.</file><file path="DisCatSharp.Docs/articles/topics/components/buttons.md">---
uid: topics_components_buttons
title: Buttons
author: DisCatSharp Team
hasDiscordComponents: true
---

# Introduction

Buttons are a feature in Discord based on the interaction framework appended to the bottom of a message which come in several colors.
You will want to familarize yourself with the [message builder](xref:topics_messagebuilder) as it and similar builder objects will be used throughout this article.

With buttons, you can have up to five buttons in a row, and up to five (5) rows of buttons, for a maximum for 25 buttons per message.
Furthermore, buttons come in two types: regular, and link. Link buttons contain a Url field, and are always grey.

# Buttons Continued

&gt; [!WARNING]
&gt; Component (Button) Ids on buttons should be unique, as this is what&apos;s sent back when a user presses a button.
&gt;
&gt; Link buttons do **not** have a custom id and do **not** send interactions when pressed.

Buttons consist of five parts:

-   Id
-   Style
-   Label
-   Emoji
-   Disabled

The id of the button is a settable string on buttons, and is specified by the developer. Discord sends this id back in the [interaction object](https://discord.dev/interactions/slash-commands#interaction).

Non-link buttons come in four colors, which are known as styles: Blurple, Grey, Green, and Red. Or as their styles are named: Primary, Secondary, Success, and Danger respectively.

How does one construct a button? It&apos;s simple, buttons support constructor and object initialization like so:

```cs
var myButton = new DiscordButtonComponent()
{
    CustomId = &quot;my_very_cool_button&quot;,
    Style = ButtonStyle.Primary,
    Label = &quot;Very cool button!&quot;,
    Emoji = new DiscordComponentEmoji(&quot;😀&quot;)
};
```

This will create a blurple button with the text that reads &quot;Very cool button!&quot;. When a user pushes it, `&quot;my_very_cool_button&quot;` will be sent back as the `Id` property on the event. This is expanded on in the [how to respond to buttons](#responding-to-button-presses).

The label of a button is optional _if_ an emoji is specified. The label can be up to 80 characters in length.
The emoji of a button is a [partial emoji object](https://discord.dev/interactions/message-components#component-object), which means that **any valid emoji is usable**, even if your bot does not have access to it&apos;s origin server.

The disabled field of a button is rather self explanatory. If this is set to true, the user will see a greyed out button which they cannot interact with.

## Adding buttons

&gt; [!NOTE]
&gt; This article will use underscores in button ids for consistency and styling, but spaces are also usable.

Adding buttons to a message is relatively simple. Simply make a builder, and sprinkle some content and the buttons you&apos;d like.

```cs
var builder = new DiscordMessageBuilder();
builder.WithContent(&quot;This message has buttons! Pretty neat innit?&quot;);
```

Well, there&apos;s a builder, but no buttons. What now? Simply make a new button object (`DiscordButtonComponent`) and call `.AddComponents()` on the MessageBuilder.

```cs
var myButton = new DiscordButtonComponent
{
    CustomId = &quot;my_custom_id&quot;,
    Label = &quot;This is a button!&quot;,
    Style = ButtonStyle.Primary,
};

var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has buttons! Pretty neat innit?&quot;)
    .AddComponents(myButton);
```

Now you have a message with a button. Congratulations! It&apos;s important to note that `.AddComponents()` will create a new row with each call, so **add everything you want on one row in one call!**

Buttons can be added in any order you fancy. Lets add 5 to demonstrate each color, and a link button for good measure.

```cs
var builder = new DiscordMessageBuilder()
    .WithContent(&quot;This message has buttons! Pretty neat innit?&quot;)
    .AddComponents(new DiscordComponent[]
    {
        new DiscordButtonComponent(ButtonStyle.Primary, &quot;1_top&quot;, &quot;Primary&quot;),
        new DiscordButtonComponent(ButtonStyle.Secondary, &quot;2_top&quot;, &quot;Secondary&quot;),
        new DiscordButtonComponent(ButtonStyle.Success, &quot;3_top&quot;, &quot;Success&quot;),
        new DiscordButtonComponent(ButtonStyle.Danger, &quot;4_top&quot;, &quot;Danger&quot;),
        new DiscordLinkButtonComponent(&quot;https://some-super-cool.site&quot;, &quot;Link&quot;)
    });
```

As promised, not too complicated. Links however are `DiscordLinkButtonComponent`, which takes a URL as it&apos;s first parameter, and the label. Link buttons can also have an emoji, like regular buttons.

Lets also add a second row of buttons, but disable them, so the user can&apos;t push them all willy-nilly.

```cs
builder.AddComponents(new DiscordComponent[]
{
    new DiscordButtonComponent(ButtonStyle.Primary, &quot;1_top_d&quot;, &quot;Primary&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Secondary, &quot;2_top_d&quot;, &quot;Secondary&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Success, &quot;3_top_d&quot;, &quot;Success&quot;, true),
    new DiscordButtonComponent(ButtonStyle.Danger, &quot;4_top_d&quot;, &quot;Danger&quot;, true),
    new DiscordLinkButtonComponent(&quot;https://some-super-cool.site&quot;, &quot;Link&quot;, true)
});
```

Practically identical, but now with `true` as an extra parameter. This is the `Disabled` property.

Produces a message like such:

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
    Omg buttons! Poggers :3
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot;&gt;Primary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot;&gt;Secondary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;success&quot;&gt;Success&lt;/discord-button&gt;
                &lt;discord-button type=&quot;destructive&quot;&gt;Danger&lt;/discord-button&gt;
                &lt;discord-button url=&quot;https://discord.gg/RXA6u3jxdU&quot;&gt;Link&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot; disabled&gt;Primary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;secondary&quot; disabled&gt;Secondary&lt;/discord-button&gt;
                &lt;discord-button type=&quot;success&quot; disabled&gt;Success&lt;/discord-button&gt;
                &lt;discord-button type=&quot;destructive&quot; disabled&gt;Danger&lt;/discord-button&gt;
                &lt;discord-button url=&quot;https://discord.gg/RXA6u3jxdU&quot; disabled&gt;Link&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
        &lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

Well, that&apos;s all neat, but lets say you want to add an emoji. Being able to use any emoji is pretty neat, after all. That&apos;s also very simple!

```cs
var myButton = new DiscordButtonComponent
(
    ButtonStyle.Primary,
    &quot;emoji_button&quot;,
    &quot;OwO&quot;,
    false,
    new DiscordComponentEmoji(922569846569455646)
);
```

And you&apos;re done! Simply add that to a builder, and when you send, you&apos;ll get a message that has a button with our cute logo!

&lt;discord-messages&gt;
    &lt;discord-message profile=&quot;dcs&quot;&gt;
    What&apos;s this? Emojis in buttons??
        &lt;discord-attachments slot=&quot;components&quot;&gt;
            &lt;discord-action-row&gt;
                &lt;discord-button type=&quot;primary&quot; emoji=&quot;https://cdn.discordapp.com/emojis/922569846569455646.webp?size=96&amp;quality=lossless&quot; emoji-name=&quot;dcs&quot;&gt;OwO&lt;/discord-button&gt;
            &lt;/discord-action-row&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;

## Responding to button presses

When any button is pressed, it will fire the [ComponentInteractionCreated](xref:DisCatSharp.DiscordClient.ComponentInteractionCreated) event.

In the event args, `Id` will be the id of the button you specified. There&apos;s also an `Interaction` property, which contains the interaction the event created. It&apos;s important to respond to an interaction within 3 seconds, or it will time out. Responding after this period will throw a `NotFoundException`.

With buttons, there are two new response types: `DeferredMessageUpdate` and `UpdateMessage`.
using `DeferredMessageUpdate` lets you create followup messages via the [followup message builder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder). The button will return to being in it&apos;s &apos;dormant&apos; state, or it&apos;s &apos;unpushed&apos; state, if you will.

You have 15 minutes from that point to make followup messages. Responding to that interaction looks like this:

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate);
    // Do things.. //
}
```

If you would like to update the message when a button is pressed, however, you&apos;d use `UpdateMessage` instead, and pass a `DiscordInteractionResponseBuilder` with the new content you&apos;d like.

```cs
client.ComponentInteractionCreated += async (s, e) =&gt;
{
    await e.Interaction.CreateResponseAsync(InteractionResponseType.UpdateMessage, new DiscordInteractionResponseBuilder().WithContent(&quot;No more buttons for you &gt;:)&quot;));
}
```

This will update the message, and without the infamous &lt;sub&gt;(edited)&lt;/sub&gt; next to it. Nice.

# Interactivity

Along with the typical `WaitForMessageAsync` and `WaitForReactionAsync` methods provided by interactivity, there are also button implementations as well.

More information about how interactivity works can be found in [the interactivity article](xref:modules_interactivity_introduction)

Since buttons create interactions, there are also two additional properties in the configuration:

-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior
-   @DisCatSharp.Interactivity.InteractivityConfiguration.ResponseMessage

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior is what interactivity will do when handling something that isn&apos;t a valid valid button, in the context of waiting for a specific button. It defaults to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ignore, which will cause the interaction fail.

Alternatively, setting it to @DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Ack will acknowledge the button, and continue waiting.

@DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Respond will reply with an ephemeral message with the aforementioned response message.

@DisCatSharp.Interactivity.InteractivityConfiguration.ResponseBehavior only applies to the overload accepting a string id of the button to wait for.</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_0.md">---
uid: changelogs_v10_10_6_0
title: Version 10.6.0
author: DisCatSharp Team
---

# Upgrade from **10.4.0** to **10.6.0**

&gt; [!IMPORTANT]
&gt; We dropped support for .NET 5 in favor of newer features and major improvements in speed and stability.
&gt;
&gt; We removed previously deprecated fields and methods.
&gt;
&gt; We fixed a major bug with the gateway connection: Previously it wasn&apos;t actually applying the `version`, `encoding`, and `compress` fields, causing the gateway to use the default but deprecated version 6.

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

&gt; [!NOTE]
&gt; With this version, we are re-opening issues on GitHub. We hope that everything goes well and we can keep them open.
&gt; You can continue to use our [Discord server](https://discord.gg/RXA6u3jxdU) for support tho.

---

## Why weren&apos;t there any releases for a long time?

We&apos;ve been focusing on rewriting internals and improving the library.
Most of the changes were considered highly experimental and not ready for public use.

Other reasons were the lack of motivation to write changelogs 😅

---

## What changed?

&lt;br/&gt;

➕ Added [Members](xref:DisCatSharp.Entities.DiscordRole.Members) field to [DiscordRole](xref:DisCatSharp.Entities.DiscordRole).

➕ Added [EnableEmoticons](xref:DisCatSharp.Entities.DiscordIntegration.EnableEmoticons) and [GuildId](xref:DisCatSharp.Entities.DiscordIntegration.GuildId) to [DiscordIntegration](xref:DisCatSharp.Entities.DiscordIntegration).

➕ [Sentry](#sentry-integration) for automatic tracking of library errors and reporting new fields in API payloads.

➕ [Update check on startup](#update-check-on-startup) for new library versions, configurable in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ New configuration field [EnablePayloadReceivedEvent](xref:DisCatSharp.DiscordConfiguration.EnablePayloadReceivedEvent) to work with raw events.

⚠️ Added [ApiChannel](xref:DisCatSharp.DiscordConfiguration.ApiChannel) enum in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration); removed `UseCanary` &amp; `UsePtb`.

➕ [Locale](xref:DisCatSharp.DiscordConfiguration.Locale) and [Timezone](xref:DisCatSharp.DiscordConfiguration.Timezone) settings in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ New methods and constructors for building [DiscordOverwrite](xref:DisCatSharp.Entities.DiscordOverwrite) objects.

🛠️ Caching members now in [DiscordGuild.GetAllMembersAsync()](xref:DisCatSharp.Entities.DiscordGuild.GetAllMembersAsync).

➕ `SubCommandName` &amp; `FullCommandName` to [BaseContext](xref:DisCatSharp.ApplicationCommands.Context.BaseContext).

➕ [UnusualDmActivityUntil](xref:DisCatSharp.Entities.DiscordMember.UnusualDmActivityUntil) in [DiscordMember](xref:DisCatSharp.Entities.DiscordMember).

➕ Incident configs and events on [DiscordGuild](xref:DisCatSharp.Entities.DiscordGuild).

🛠️ Group, subgroup, and subcommand creation for application commands along side each other.

➕ Added support for custom status.

➕ [DiscordOAuth2Client](xref:DisCatSharp.DiscordOAuth2Client) for OAuth2 API interaction.

➕ Support for iframe modals (Currently only midjourney has access to this).

➕ Pagination buttons constants for custom ids.

⚠️ Removed `DiscordEmbedBuilder.AddField(string name, string value, bool inline)`; use [DiscordEmbedBuilder.AddField(DiscordEmbedField field)](xref:DisCatSharp.Entities.DiscordEmbedBuilder.AddField*) instead.

🛠️ [DiscordGuild.BanMemberAsync](xref:DisCatSharp.Entities.DiscordGuild.BanMemberAsync*) now supports [DiscordUser](xref:DisCatSharp.Entities.DiscordUser) as [argument](xref:DisCatSharp.Entities.DiscordGuild.BanMemberAsync*#DisCatSharp_Entities_DiscordGuild_BanMemberAsync_DisCatSharp_Entities_DiscordUser_System_Int32_System_String_).

➕ New channel types and flags.

🛠️ Fixed standalone [DiscordWebhookClient](xref:DisCatSharp.DiscordWebhookClient) methods.

⚠️ [Target](xref:DisCatSharp.Entities.DiscordOverwriteBuilder.Target) of [DiscordOverwriteBuilder](xref:DisCatSharp.Entities.DiscordOverwriteBuilder) changed to `ulong`.

⚠️ Removed Lavalink v1 support; added support for [Lavalink v4](xref:modules_audio_lavalink_v4_intro).

➕ Support for premium apps in [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

➕ Various new permissions and options to generate [PermissionStrings](xref:DisCatSharp.Utilities.ToPermissionString*).

🛠️ Overhauled ApplicationCommands extension.

➕ Default values for select menus in interactions.

⚠️ Removed privacy level settings from stage and scheduled events.

➕ Added support for [team roles](xref:DisCatSharp.Entities.DiscordTeamMember.Role) from the developer portal.

⚠️ Removed `ApplicationCommandRequireOwnerAttribute`; added corresponding team role attributes like `ApplicationCommandRequireTeamAdminAttribute`. This adds support for the [team roles](xref:DisCatSharp.Entities.DiscordTeamMember.Role) in the developer portal.

🛠️ Opus encoder/decoder made public.

⚠️ Renamed `DiscordAttachment.FileName` to [Filename](xref:DisCatSharp.Entities.DiscordAttachment.Filename).

➕ Exposed regexes in `DisCatSharp.Common`.

🛠️ Fixed application commands registration issues.

➕ Added support for application command names in other languages than english.

➕ Added support for GCP attachments.

🛠️ Major overhaul of the DisCatSharp documentation.

---

## Why does this changelog look so small?

We&apos;ve been focusing on rewriting internals and improving the library.

Furthermore we might have added new features we haven&apos;t tracked on our changelog list, we&apos;re gonna add them when we find them again 😅

---

## Key Features

&lt;br/&gt;

### Sentry Integration

&lt;svg alt=&quot;Sentry Logo&quot; class=&quot;css-lfbo6j e10nushx4&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 222 66&quot; width=&quot;400&quot; height=&quot;119&quot; style=&quot;background-color: rgb(88, 70, 116);&quot;&gt;&lt;path d=&quot;M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z M124.32,28.28,109.56,9.22h-3.68V34.77h3.73V15.19l15.18,19.58h3.26V9.22h-3.73ZM87.15,23.54h13.23V20.22H87.14V12.53h14.93V9.21H83.34V34.77h18.92V31.45H87.14ZM71.59,20.3h0C66.44,19.06,65,18.08,65,15.7c0-2.14,1.89-3.59,4.71-3.59a12.06,12.06,0,0,1,7.07,2.55l2-2.83a14.1,14.1,0,0,0-9-3c-5.06,0-8.59,3-8.59,7.27,0,4.6,3,6.19,8.46,7.52C74.51,24.74,76,25.78,76,28.11s-2,3.77-5.09,3.77a12.34,12.34,0,0,1-8.3-3.26l-2.25,2.69a15.94,15.94,0,0,0,10.42,3.85c5.48,0,9-2.95,9-7.51C79.75,23.79,77.47,21.72,71.59,20.3ZM195.7,9.22l-7.69,12-7.64-12h-4.46L186,24.67V34.78h3.84V24.55L200,9.22Zm-64.63,3.46h8.37v22.1h3.84V12.68h8.37V9.22H131.08ZM169.41,24.8c3.86-1.07,6-3.77,6-7.63,0-4.91-3.59-8-9.38-8H154.67V34.76h3.8V25.58h6.45l6.48,9.2h4.44l-7-9.82Zm-10.95-2.5V12.6h7.17c3.74,0,5.88,1.77,5.88,4.84s-2.29,4.86-5.84,4.86Z&quot; fill=&quot;#ffffff&quot; transform=&quot;translate(11, 11)&quot;&gt;&lt;/path&gt;&lt;/svg&gt;

Every developer should at least have heard about [Sentry](https://sentry.io).

They were so kind to provide us with a free business plan 🙏💕

With the integration of Sentry, we&apos;re taking a significant leap forward in proactively managing library errors.

Sentry&apos;s real-time error tracking enables us to identify and rectify issues swiftly, often before they impact users.

This enhancement is not just about fixing bugs faster; it&apos;s about ensuring a seamless and stable experience for everyone using our library.

To enable this feature and help us to improve our library, you need to set up some things in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration):

```cs
DiscordConfiguration configuration = new()
{
    // other settings
    EnableSentry = true, // To generally enable sentry
    AttachUserInfo = true, // To attach the bot id and username to sentry reports
    DeveloperUserId = 32183902178903721, // Set your Discord id here so we can reach out to you if we have questions to a bug. Set null or leave it out to disable this feature.
    FeedbackEmail = &quot;your@email.com&quot;, // Set your email here so we can reach out to you if we have questions to a bug.
    ReportMissingFields = true // To let sentry report missing fields in API payloads
};
```

### Update check on startup

We&apos;ve added a new feature to check for new library versions on startup.

This feature is enabled by default and can be disabled in the [DiscordConfiguration](xref:DisCatSharp.DiscordConfiguration).

You can configure the update check with the following properties:

```cs
DiscordConfiguration configuration = new()
{
    // other settings
    DisableUpdateCheck = true, // To disable the update check on startup
    ShowReleaseNotesInUpdateCheck = false, // To disable the release notes in the update check on startup
    UpdateCheckMode = UpdateCheckMode.GitHub, // To check against GitHub instead of NuGet
    UpdateCheckGitHubToken = &quot;ghp_your_token&quot; // Set this to use a personal access token, in case you&apos;re getting rate limited or you have access to private extensions
};
```

Every official extension supports this too. You currently can&apos;t disable this feature seperatly for extensions.

---

## Future Roadmap

&lt;br/&gt;

### DisCatSharp.Voice (Planned)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Caching System Overhaul (Under Consideration)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved.
We are still in the cenceptual stage for this.

### Audit Log Functionality Enhancement (In Development)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

### Cooldowns for DisCatSharp.ApplicationCommands (Planned)

We are planning to add support for cooldowns in DisCatSharp.ApplicationCommands. This feature would allow developers to set cooldowns for commands, preventing users from spamming commands. While this feature is still in the planning phase, we will provide updates as development progresses.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Mira](https://github.com/TheXorog)
- [Sh1be](https://github.com/xMaxximum)
- [Fabi-Chan](https://github.com/FabiChan99)
- [Licho](https://github.com/Licho1)
- [Drac](https://github.com/DraconicDragon)

## Special Thanks

- [Dziurwa](https://github.com/Dziurwa14) for identifying a major bug in our gateway connection
- [Red Kalab](https://github.com/RedKinda) for being so awesome 💕💕

---</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_2.md">---
uid: changelogs_v10_10_6_2
title: Version 10.6.2
author: DisCatSharp Team
---

# Upgrade from **10.6.0** to **10.6.2**

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

&gt; [!WARNING]
&gt; The last versions including this one have under special circumstates a bug with reactions.
&gt; If you encounter any issues in this direction, disable the reaction intents.

---

## What changed?

&lt;br/&gt;

➕ Added Application Command [Cooldowns](xref:modules_application_commands_cooldowns).

➕ Added [DefaultForumLayout](xref:DisCatSharp.Entities.DiscordChannel.DefaultForumLayout) to [DiscordChannel](xref:DisCatSharp.Entities.DiscordChannel) and it&apos;s methods.

➕ Implemented User Apps! You can now use apps anywhere :3 Articles will follow.

➕ [Nonce](xref:DisCatSharp.Entities.DiscordMessage.Nonce) &amp; [EnforceNonce](xref:DisCatSharp.Entities.DiscordMessage.EnforceNonce) for [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage) and the [DiscordMessageBuilder](xref:DisCatSharp.Entities.DiscordMessageBuilder.WithEnforceNonce*).

➕ Re-implemented the timeout events [GuildMemberTimeoutAdded](xref:DisCatSharp.DiscordClient.GuildMemberTimeoutAdded) &amp; [GuildMemberTimeoutRemoved](xref:DisCatSharp.DiscordClient.GuildMemberTimeoutRemoved). It won&apos;t show the broken audit log informations anymore.

➕ Added [InteractionMetadata](xref:DisCatSharp.Entities.DiscordMessage.InteractionMetadata) to [DiscordMessage](xref:DisCatSharp.Entities.DiscordMessage).

➕ Added [Polls](https://support.discord.com/hc/en-us/articles/22163184112407)! Apps can now send polls, request vote information and get the result. Additionally two gateway events exist which are fired on vote add and vote remove. Articles will follow.

➕ Added [OAuth2AddToGuildAsync](xref:DisCatSharp.Entities.DiscordUser.OAuth2AddToGuildAsync*) to [DiscordUser](xref:DisCatSharp.Entities.DiscordUser).

🛠️ Fixed a bug, causing apps to crash when trying to identify / resume. This was caused by both Discord and us. It seems to still bug out in special cases, we&apos;re on it!

🛠️ Fixed an NRE in GetMentions, which caused messages to throw on construct.

🛠️ Reworked ApplicationCommands &amp; CommandsNext Cooldowns, articles will be updated in near future.

🛠️ The translator entities used for application commands localization are now `public`.

⚠️ Removed `TokenType.User`.

---

## Completed Roadmap

&lt;br/&gt;

### Cooldowns for DisCatSharp.ApplicationCommands (Completed)

We were planning to add support for cooldowns in DisCatSharp.ApplicationCommands. This feature would allow developers to set cooldowns for commands, preventing users from spamming commands. This is now implemented. See [this article](xref:modules_application_commands_cooldowns) for details.

---

## Future Roadmap

&lt;br/&gt;

### Signed Attachment

We added signed attachments previously but it clashed with other attachment types and broke. We will re-introduce the entity at some point soon.

### DisCatSharp.Voice (Planned)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)
A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

### DisCatSharp.CommandNext Revamp (Proposed)

complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mira](https://github.com/TheXorog)
- [LaPepega](https://github.com/LaPepega)
- [Rand](https://github.com/byterand)</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_4.md">---
uid: changelogs_v10_10_6_4
title: Version 10.6.4
author: DisCatSharp Team
---

# Upgrade from **10.6.2** to **10.6.4**

&gt; [!NOTE]
&gt; This version improves the safety of data transmitted to sentry, if enabled.

---

## What changed?

&lt;br/&gt;

➕ Added clan badges

🛠️ Fixed OAuth2 NRE&apos;s

🛠️ Fixed caching issues

➕ Added `avatar_decoration_data` for guild members

➕ Added `dm_spam_detected_at` &amp; `raid_detected_at` in guild incident data

➕ Added bulk ban capabilities ([#482](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/482))

📚 Added Termux Hosting docs ([#490](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/490))

🛠️ Fixed a hosting configuration intent bug ([#498](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/498))

➕ Added additional client-side Sentry filtering ([#495](https://github.com/Aiko-IT-Systems/DisCatSharp/pull/495))

📚 Added Sentry docs

---

## Other important info

&lt;br/&gt;

After we&apos;ve received concerns about the privacy for our users when using Sentry, by Quinch, we&apos;ve investigated possible issues together with the team at Discord.

While we did not find any privacy leaks, we did implemented additional client-side filters to further enhance user safety &amp; privacy.

For that we&apos;ve added a new [article](xref:misc_sentry) about our Sentry integration.

You can read the full report here: [Sentry Safety Report](xref:sec_comp_sentry).

&lt;br/&gt;

Additionally we&apos;ve made updates to our [Code of Conduct](https://github.com/Aiko-IT-Systems/.github/blob/main/CODE_OF_CONDUCT.md) and our [Security Policy](https://github.com/Aiko-IT-Systems/.github/blob/main/SECURITY.md).

We added the following new terms:

**Unacceptable Behavior:** Rude, offensive, or disrespectful behavior, including AI-generated content that does not adhere to our guidelines, will not be tolerated.
**Enforcement:** Violations of our guidelines may result in bans or other appropriate measures.

---

## Future Roadmap

&lt;br/&gt;

### Signed Attachment

We added signed attachments previously but it clashed with other attachment types and broke. We will re-introduce the entity at some point soon.

### DisCatSharp.Voice (Planned)

We&apos;re working on DisCatSharp.Voice which is set to replace the existing DisCatSharp.VoiceNext. It&apos;s planned to have better performance, stability and maintainability than its predecessor. Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use. The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved. We are still in the cenceptual stage for this.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of DisCatSharp.CommandsNext is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mira](https://github.com/TheXorog)
- [KristalliDev](https://github.com/KristalliDev)</file><file path="DisCatSharp.Docs/changelogs/v10/10_6_6.md">---
uid: changelogs_v10_10_6_6
title: Version 10.6.6
author: DisCatSharp Team
---

# Upgrade from **10.6.4** to **10.6.6**

&gt; [!IMPORTANT]
&gt; This version introduces **breaking changes** and numerous enhancements. Please review the details carefully before upgrading.

&gt; [!IMPORTANT]
&gt; We dropped support for .NET 7 in favor of newer features and major improvements in speed and stability.

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

---

## What changed?

&lt;br/&gt;

### ❕ Breaking Changes

- **[DiscordRoleTags](xref:DisCatSharp.Entities.DiscordRoleTags)**: We removed the `IsPremiumSubscriber` and `IsLinkedRole` fields due to an overhaul of the tag system. You can now determine the actual type of role by referencing [DiscordRole.RoleType](xref:DisCatSharp.Entities.DiscordRole.Type). It&apos;s not officially returned by Discord, but instead calculated by analyzing the role tags combinations.
- **[DiscordEmoji.TryFromName](xref:DisCatSharp.Entities.DiscordEmoji.TryFromName*#DisCatSharp_Entities_DiscordEmoji_TryFromName_DisCatSharp_BaseDiscordClient_System_String_System_Boolean_System_Boolean_DisCatSharp_Entities_DiscordEmoji__)**: Additional required parameter `bool includeApplication` was added to match Discord&apos;s changes in handling emoji lookups. This was to account for different emoji types (Unicode, Guild, Application).
- **[TryGetMemberAsync](xref:DisCatSharp.Entities.DiscordGuild.TryGetMemberAsync*) method signature change**: The return type for [`TryGetMemberAsync`](xref:DisCatSharp.Entities.DiscordGuild.TryGetMemberAsync*) was changed from `bool` to `Task&lt;DiscordMember?&gt;` to align with asynchronous patterns and allow for better error handling and member retrieval.
- **ImageTool renamed to [MediaTool](xref:DisCatSharp.MediaTool)**: This was necessary due to the support of additional media types, like MP3 and OGG, for soundboard functionality.
- **ImageFormat renamed to [MediaFormat](xref:DisCatSharp.MediaFormat)**: This was also necessary for the support of additional media types.
- **[DiscordMessage.Components](xref:DisCatSharp.Entities.DiscordMessage.Components) type change**: `IReadOnlyCollection&lt;DiscordActionRowComponent&gt;` was changed to `IReadOnlyCollection&lt;DiscordComponent&gt;` due to Discord allowing new components not necessarily wrapped in action rows, breaking the previous assumption of a static structure.
- **DiscordAttachment flags renamed**: The flag values in [`AttachmentFlags`](xref:DisCatSharp.Enums.AttachmentFlags) were prefixed with `Is` to be consistent with other flag names across the codebase.
- **[DiscordFollowupMessageBuilder](xref:DisCatSharp.Entities.DiscordFollowupMessageBuilder), [DiscordInteractionResponseBuilder](xref:DisCatSharp.Entities.DiscordInteractionResponseBuilder), [DiscordWebhookBuilder](xref:DisCatSharp.Entities.DiscordWebhookBuilder) method renaming**: The `AddMention` and `AddMentions` methods were renamed to `WithAllowedMention` and `WithAllowedMentions` for better clarity and consistency.

### ➕ Additions

#### Added Entities
- [`WaveformConverter`](xref:DisCatSharp.Common.Utilities.WaveformConverter)
- [`WaveformVisualizer`](xref:DisCatSharp.Common.Utilities.WaveformVisualizer)
- [`AudioHelper`](xref:DisCatSharp.Experimental.AudioHelper)
- [`DiscordGuildMemberSearchParams`](xref:DisCatSharp.Experimental.Entities.DiscordGuildMemberSearchParams)
- [`DiscordGuildMemberSearchValidator`](xref:DisCatSharp.Experimental.Entities.DiscordGuildMemberSearchValidator)
- [`DiscordMemberFilter`](xref:DisCatSharp.Experimental.Entities.DiscordMemberFilter)
- [`DiscordMemberPaginationFilter`](xref:DisCatSharp.Experimental.Entities.DiscordMemberPaginationFilter)
- [`DiscordQuery`](xref:DisCatSharp.Experimental.Entities.DiscordQuery)
- [`DiscordRangeQuery`](xref:DisCatSharp.Experimental.Entities.DiscordRangeQuery)
- [`DiscordSafetySignals`](xref:DisCatSharp.Experimental.Entities.DiscordSafetySignals)
- [`DiscordSearchGuildMembersResponse`](xref:DisCatSharp.Experimental.Entities.DiscordSearchGuildMembersResponse)
- [`DiscordSupplementalGuildMember`](xref:DisCatSharp.Experimental.Entities.DiscordSupplementalGuildMember)
- [`DefaultQueueEntry`](xref:DisCatSharp.Lavalink.Entities.DefaultQueueEntry)
- [`LavalinkQueue`](xref:DisCatSharp.Lavalink.LavalinkQueue`1)
- [`DiscordApplicationEmoji`](xref:DisCatSharp.Entities.DiscordApplicationEmoji)
- [`DiscordClanSettings`](xref:DisCatSharp.Entities.DiscordClanSettings) (Not release for bots)
- [`DiscordGuildJoinRequest`](xref:DisCatSharp.Entities.DiscordGuildJoinRequest)
- [`DiscordGuildJoinRequestSearchResult`](xref:DisCatSharp.Entities.DiscordGuildJoinRequestSearchResult) (Not release for bots)
- [`DiscordGuildMembershipScreeningFieldResponse`](xref:DisCatSharp.Entities.DiscordGuildMembershipScreeningFieldResponse)
- [`DiscordRecurrenceRuleNWeekday`](xref:DisCatSharp.Entities.DiscordRecurrenceRuleNWeekday)
- [`DiscordScheduledEventRecurrenceRule`](xref:DisCatSharp.Entities.DiscordScheduledEventRecurrenceRule)
- [`DiscordScheduledEventRecurrenceRuleValidator`](xref:DisCatSharp.Entities.DiscordScheduledEventRecurrenceRuleValidator)
- [`DiscordPremiumButtonComponent`](xref:DisCatSharp.Entities.DiscordPremiumButtonComponent)
- [`DiscordActivityInstance`](xref:DisCatSharp.Entities.DiscordActivityInstance)
- [`DiscordInteractionCallback`](xref:DisCatSharp.Entities.DiscordInteractionCallback)
- [`DiscordInteractionCallbackResponse`](xref:DisCatSharp.Entities.DiscordInteractionCallbackResponse)
- [`DiscordInteractionResource`](xref:DisCatSharp.Entities.DiscordInteractionResource)
- [`DiscordForwardedMessage`](xref:DisCatSharp.Entities.DiscordForwardedMessage)
- [`DiscordMessageSnapshot`](xref:DisCatSharp.Entities.DiscordMessageSnapshot)
- [`DiscordSubscription`](xref:DisCatSharp.Entities.DiscordSubscription)
- [`DiscordSoundboardSound`](xref:DisCatSharp.Entities.DiscordSoundboardSound)
- [`GuildJoinRequestCreateEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestCreateEventArgs)
- [`GuildJoinRequestDeleteEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestDeleteEventArgs)
- [`GuildJoinRequestUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildJoinRequestUpdateEventArgs)
- [`GuildSoundboardSoundCreateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundCreateEventArgs)
- [`GuildSoundboardSoundDeleteEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundDeleteEventArgs)
- [`GuildSoundboardSoundUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundUpdateEventArgs)
- [`GuildSoundboardSoundsUpdateEventArgs`](xref:DisCatSharp.EventArgs.GuildSoundboardSoundsUpdateEventArgs)
- [`SoundboardSoundsEventArgs`](xref:DisCatSharp.EventArgs.SoundboardSoundsEventArgs)
- [`SubscriptionCreateEventArgs`](xref:DisCatSharp.EventArgs.SubscriptionCreateEventArgs)
- [`SubscriptionUpdateEventArgs`](xref:DisCatSharp.EventArgs.SubscriptionUpdateEventArgs)
- [`VoiceChannelEffectSendEventArgs`](xref:DisCatSharp.EventArgs.VoiceChannelEffectSendEventArgs)
- [`DisCatSharpUserException`](xref:DisCatSharp.Exceptions.DisCatSharpUserException)
- [`DiscordJsonException`](xref:DisCatSharp.Exceptions.DiscordJsonException)

#### Added Events
- [`GuildSoundboardSoundCreated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundCreated)
- [`GuildSoundboardSoundUpdated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundUpdated)
- [`GuildSoundboardSoundDeleted`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundDeleted)
- [`GuildSoundboardSoundsUpdated`](xref:DisCatSharp.DiscordClient.GuildSoundboardSoundsUpdated)
- [`SoundboardSounds`](xref:DisCatSharp.DiscordClient.SoundboardSounds)
- [`GuildJoinRequestCreated`](xref:DisCatSharp.DiscordClient.GuildJoinRequestCreated)
- [`GuildJoinRequestUpdated`](xref:DisCatSharp.DiscordClient.GuildJoinRequestUpdated)
- [`GuildJoinRequestDeleted`](xref:DisCatSharp.DiscordClient.GuildJoinRequestDeleted)
- [`VoiceChannelEffectSend`](xref:DisCatSharp.DiscordClient.VoiceChannelEffectSend)
- [`SubscriptionCreated`](xref:DisCatSharp.DiscordClient.SubscriptionCreated)
- [`SubscriptionUpdated`](xref:DisCatSharp.DiscordClient.SubscriptionUpdated)

#### Added Enums
- [`JoinSourceType`](xref:DisCatSharp.Experimental.Enums.JoinSourceType)
- [`MemberSortType`](xref:DisCatSharp.Experimental.Enums.MemberSortType)
- [`ApplicationCommandHandlerType`](xref:DisCatSharp.Enums.ApplicationCommandHandlerType)
- [`ApplicationExplicitContentFilter`](xref:DisCatSharp.Enums.ApplicationExplicitContentFilter)
- [`ApplicationVerificationEligibilityFlags`](xref:DisCatSharp.Enums.ApplicationVerificationEligibilityFlags)
- [`BadgeType`](xref:DisCatSharp.Enums.BadgeType)
- [`BannerType`](xref:DisCatSharp.Enums.BannerType)
- [`JoinRequestStatusType`](xref:DisCatSharp.Enums.JoinRequestStatusType)
- [`PlayStyle`](xref:DisCatSharp.Enums.PlayStyle)
- [`RoleType`](xref:DisCatSharp.Enums.RoleType)
- [`RecurrenceRuleFrequency`](xref:DisCatSharp.Enums.RecurrenceRuleFrequency)
- [`RecurrenceRuleWeekday`](xref:DisCatSharp.Enums.RecurrenceRuleWeekday)
- [`EmbedFlags`](xref:DisCatSharp.Enums.EmbedFlags)
- [`EmbedMediaFlags`](xref:DisCatSharp.Enums.EmbedMediaFlags)
- [`ReferenceType`](xref:DisCatSharp.Enums.ReferenceType)
- [`SubscriptionStatus`](xref:DisCatSharp.Enums.SubscriptionStatus)
- [`AnimationType`](xref:DisCatSharp.Enums.AnimationType)
- [`MediaFormat`](xref:DisCatSharp.MediaFormat)

#### Added Properties
- [`LavalinkTrack.UserData`](xref:DisCatSharp.Lavalink.Entities.LavalinkTrack.UserData)
- [`DiscordClient.RegisteredEventhandlers`](xref:DisCatSharp.DiscordClient.RegisteredEventhandlers)
- [`DiscordConfiguration.HasActivitiesEnabled`](xref:DisCatSharp.DiscordConfiguration.HasActivitiesEnabled)
- [`DiscordConfiguration.ActivityHandlerType`](xref:DisCatSharp.DiscordConfiguration.ActivityHandlerType)
- [`DiscordApplicationCommand.HandlerType`](xref:DisCatSharp.Entities.DiscordApplicationCommand.HandlerType)
- [`DiscordMember.PrimaryGuild`](xref:DisCatSharp.Entities.DiscordMember.PrimaryGuild)
- [`DiscordRoleTags.GuildConnections`](xref:DisCatSharp.Entities.DiscordRoleTags.GuildConnections)
- [`DiscordRoleTags.PremiumSubscriber`](xref:DisCatSharp.Entities.DiscordRoleTags.PremiumSubscriber)
- [`DiscordAttachment.ClipParticipants`](xref:DisCatSharp.Entities.DiscordAttachment.ClipParticipants)
- [`DiscordAttachment.ClipCreatedAt`](xref:DisCatSharp.Entities.DiscordAttachment.ClipCreatedAt)
- [`DiscordMessage.ChannelType`](xref:DisCatSharp.Entities.DiscordMessage.ChannelType)
- [`DiscordMessage.MessageSnapshots`](xref:DisCatSharp.Entities.DiscordMessage.MessageSnapshots)
- [`DiscordMessage.HasMessageReference`](xref:DisCatSharp.Entities.DiscordMessage.HasMessageReference)
- [`DiscordMessage.HasMessageSnapshots`](xref:DisCatSharp.Entities.DiscordMessage.HasMessageSnapshots)
- [`DiscordMessage.SoundboardSounds`](xref:DisCatSharp.Entities.DiscordMessage.SoundboardSounds)
- [`DiscordEntitlement.Branches`](xref:DisCatSharp.Entities.DiscordEntitlement.Branches)
- [`DiscordEntitlement.Consumed`](xref:DisCatSharp.Entities.DiscordEntitlement.Consumed)
- [`DiscordEntitlement.Deleted`](xref:DisCatSharp.Entities.DiscordEntitlement.Deleted)
- [`DiscordEntitlement.GiftCodeBatchId`](xref:DisCatSharp.Entities.DiscordEntitlement.GiftCodeBatchId)
- [`DiscordEntitlement.GiftCodeFlags`](xref:DisCatSharp.Entities.DiscordEntitlement.GiftCodeFlags)
- [`DiscordEntitlement.GifterUserId`](xref:DisCatSharp.Entities.DiscordEntitlement.GifterUserId)
- [`DiscordEntitlement.PromotionId`](xref:DisCatSharp.Entities.DiscordEntitlement.PromotionId)
- [`DiscordEntitlement.SubscriptionId`](xref:DisCatSharp.Entities.DiscordEntitlement.SubscriptionId)
- [`DiscordSubscription.RenewalSkuIds`](xref:DisCatSharp.Entities.DiscordSubscription.RenewalSkuIds)
- [`DiscordSubscription.EntitlementIds`](xref:DisCatSharp.Entities.DiscordSubscription.EntitlementIds)
- [`DiscordSubscription.CurrentPeriodStartsAt`](xref:DisCatSharp.Entities.DiscordSubscription.CurrentPeriodStartsAt)
- [`DiscordSubscription.CurrentPeriodEndsAt`](xref:DisCatSharp.Entities.DiscordSubscription.CurrentPeriodEndsAt)
- [`DiscordSubscription.CanceledAt`](xref:DisCatSharp.Entities.DiscordSubscription.CanceledAt)
- [`DiscordSubscription.Country`](xref:DisCatSharp.Entities.DiscordSubscription.Country)
- [`DiscordUser.PrimaryGuild`](xref:DisCatSharp.Entities.DiscordUser.PrimaryGuild)
- [`DiscordApplication`](xref:DisCatSharp.Entities.DiscordApplication) got extended with additional properties, which are too many to list

#### Added Enum Values
- [`ApplicationCommandType`](xref:DisCatSharp.Enums.ApplicationCommandType)
	- `PrimaryEntryPoint`
- [`ChannelType`](xref:DisCatSharp.Enums.ChannelType)
	- `Lobby`
- [`DiscordEvent`](xref:DisCatSharp.Enums.DiscordEvent)
    - `SubscriptionCreated`
    - `SubscriptionUpdated`
    - `VoiceChannelEffectSend`
    - `GuildSoundboardSoundCreated`
    - `GuildSoundboardSoundUpdated`
    - `GuildSoundboardSoundDeleted`
    - `GuildSoundboardSoundsUpdated`
    - `SoundboardSounds`
    - `GuildJoinRequestCreated`
    - `GuildJoinRequestUpdated`
    - `GuildJoinRequestDeleted`
- [`DiscordIntents`](xref:DisCatSharp.Enums.DiscordIntents)
	- `GuildExpressions`
- [`MemberFlags`](xref:DisCatSharp.Enums.MemberFlags)
    - `AutomodQuarantinedUsername`
    - `DmSettingsUpsellAcknowledged`
    - `AutomodQuarantinedClanTag`
- [`MembershipScreeningFieldType`](xref:DisCatSharp.Enums.MembershipScreeningFieldType)
    - `TextInput`
    - `Paragraph`
    - `MultipleChoice`
- [`Permissions`](xref:DisCatSharp.Enums.DiscordIntents)
	- `UseExternalApps`
- [`ComponentType`](xref:DisCatSharp.Enums.ComponentType)
	- `File`
- [`InteractionResponseType`](xref:DisCatSharp.Enums.DiscordIntents)
	- `LaunchActivity`
- [`AttachmentFlags`](xref:DisCatSharp.Enums.AttachmentFlags)
    - `IsClip`
    - `IsThumbnail`
    - `IsRemix`
    - `IsSpoiler`
    - `IsAnimated`
- [`MessageFlags`](xref:DisCatSharp.Enums.MessageFlags)
	- `HasSnapshots`
- [`MessageType`](xref:DisCatSharp.Enums.MessageType)
    - `PollResult`
    - `ChannelLinkedToLobby`
    - `GiftingPrompt`
    - `GuildJoinRequestAccepted`
    - `GuildJoinRequestRejected`

#### Added Methods
- [`DiscordClient.RequestAndWaitForSoundboardSoundsAsync`](xref:DisCatSharp.DiscordClient.RequestAndWaitForSoundboardSoundsAsync*)
- [`DiscordClient.GetEntitlementAsync`](xref:DisCatSharp.DiscordClient.GetEntitlementAsync*)
- [`DiscordClient.GetSkuSubscriptionsAsync`](xref:DisCatSharp.DiscordClient.GetSkuSubscriptionsAsync*)
- [`DiscordClient.GetSkuSubscriptionAsync`](xref:DisCatSharp.DiscordClient.GetSkuSubscriptionAsync*)
- [`DiscordClient.GetApplicationEmojisAsync`](xref:DisCatSharp.DiscordClient.GetApplicationEmojisAsync*)
- [`DiscordClient.GetApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.GetApplicationEmojiAsync*)
- [`DiscordClient.CreateApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.CreateApplicationEmojiAsync*)
- [`DiscordClient.ModifyApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.ModifyApplicationEmojiAsync*)
- [`DiscordClient.DeleteApplicationEmojiAsync`](xref:DisCatSharp.DiscordClient.DeleteApplicationEmojiAsync*)
- [`DiscordClient.GetStickerPackAsync`](xref:DisCatSharp.DiscordClient.GetStickerPackAsync*)
- [`DiscordClient.ListDefaultSoundboardSoundsAsync`](xref:DisCatSharp.DiscordClient.ListDefaultSoundboardSoundsAsync*)
- [`DiscordChannel.SendSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordChannel.SendSoundboardSoundAsync*)
- [`DiscordEmoji.FromApplicationEmote`](xref:DisCatSharp.Entities.DiscordEmoji.FromApplicationEmote*)
- [`DiscordGuild.GetCurrentMemberVoiceStateAsync`](xref:DisCatSharp.Entities.DiscordGuild.GetCurrentMemberVoiceStateAsync*)
- [`DiscordGuild.CreateSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.CreateSoundboardSoundAsync*)
- [`DiscordGuild.ModifySoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.ModifySoundboardSoundAsync*)
- [`DiscordGuild.DeleteSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.DeleteSoundboardSoundAsync*)
- [`DiscordGuild.GetSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordGuild.GetSoundboardSoundAsync*)
- [`DiscordGuild.ListSoundboardSoundsAsync`](xref:DisCatSharp.Entities.DiscordGuild.ListSoundboardSoundsAsync*)
- [`DiscordMember.GetVoiceStateAsync`](xref:DisCatSharp.Entities.DiscordMember.GetVoiceStateAsync*)
- [`DiscordRoleTags.DetermineRoleType`](xref:DisCatSharp.Entities.DiscordRoleTags.DetermineRoleType*)
- [`DiscordMessage.ForwardMessageAsync`](xref:DisCatSharp.Entities.DiscordMessage.ForwardMessageAsync*)
- [`DiscordUser.OAuth2UpdateApplicationRoleConnectionAsync`](xref:DisCatSharp.Entities.DiscordUser.OAuth2UpdateApplicationRoleConnectionAsync*)
- [`DiscordSoundboardSound.DeleteSoundboardSoundAsync`](xref:DisCatSharp.Entities.DiscordSoundboardSound.DeleteSoundboardSoundAsync*)


### 🛠️ Fixes

- Fixed a rare case where embed fields throw an exception if old embeds are received from Discord
- Fixed an issue with banning members while providing `delete_message_days`/`delete_message_seconds`
- Fixed a possible parser error
- Fixed a rare case where paginations on interactions could fail with `Message not found`
- Fixed component pagination
- Fixed an NRE within events that broke bots: Ensured [`Interaction.Guild`](xref:DisCatSharp.Entities.DiscordInteraction.Guild) falls back to partial guild data when null.
- Fixed an issue where [`ApplicationRoleConnectionMetadata`](xref:DisCatSharp.Entities.OAuth2.ApplicationRoleConnectionMetadata) had only internal constructors
- Fixed invalid API routes for [`UpdateCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.UpdateCurrentUserApplicationRoleConnectionAsync*) and [`GetCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.GetCurrentUserApplicationRoleConnectionAsync*)
- Fixed max poll duration: Increased from `7` days to `32` days (`768` hours) to align with new limits.
- Fixed poll creation on [`EditOriginalResponseAsync`](xref:DisCatSharp.Entities.DiscordInteraction.EditOriginalResponseAsync*): Enabled creating polls when the original response is deferred.
- Fixed a critical NRE in interaction create dispatches
- Fixed a NRE in audit log processing

### ⚠️ Removals

- Removed `AutoCompleteRequest` and `ModalSubmit` from [`ApplicationCommandType`](xref:DisCatSharp.Enums.ApplicationCommandType) due to incorrect implementation.
- Removed `DiscordApplication.Owners`. Use [`DiscordApplication.Members`](xref:DisCatSharp.Entities.DiscordApplication.Members) instead.
- Removed the enum `ExplicitContentFilterLevel`
- Removed `ApplicationCommandRequireDisCatSharpDeveloperAttribute` and `RequireDisCatSharpDeveloperAttribute`

### 📚 Documentation

- New article about [GCP Attachments](xref:experimental_gcp_attachments)
- New article about [ElasticSearch-Based Member Search](xref:experimental_search_guild_members)
- Extended articles about [Lavalink](xref:modules_audio_lavalink_v4_intro), including the recent refactor of the [queue system](xref:modules_audio_lavalink_v4_queue_system)
- Documented more internal and private code to make library development easier.
- Added missing documentation for public code.

---

## Future Roadmap

&lt;br/&gt;

### DisCatSharp.Voice (On Hold)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Audit Log Functionality Enhancement (On Hold)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### Caching System Overhaul (Planned)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved.
We are still in the cenceptual stage for this.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyones needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)
- [Mark Cilia Vincenti](https://github.com/MarkCiliaVincenti)
- [Truong Hoang](https://github.com/hqtruong27)
- [Rand](https://github.com/byterand)
- [Mira](https://github.com/TheXorog)</file><file path="DisCatSharp.Docs/changelogs/v10/10_7_0.md">---
uid: changelogs_v10_10_7_0
title: Version 10.7.0
author: DisCatSharp Team
---

# Upgrade from **10.6.6** to **10.7.0**

&gt; [!IMPORTANT]
&gt; This version introduces **breaking changes**. Please review carefully before upgrading.

&gt; [!NOTE]
&gt; We added support for .NET 10.

&gt; [!WARNING]
&gt; This release contains important bug fixes and improvements.
&gt; We recommend you to upgrade to this version as soon as possible.

&gt; [!WARNING]
&gt; Discord currently has an issue with entitlements for consumables and durables. Entitlements of these types are not returned in interaction events, only on the HTTP API. You can follow this [issue](https://github.com/discord/discord-api-docs/issues/7364) for updates.

---

## Change Highlights

&lt;br/&gt;

This version now supports .NET 10 and includes a variety of new features, bug fixes, and improvements.

Some highlights include:

### Components V2

With this version we officially release support for Components V2. Documentation will follow soon, it&apos;s not yet released by Discord.

All we can say it&apos;s amazing and will be fun to play with!

If you&apos;re already interested about how it works, you can check out my initial documentation [here](https://github.com/Lulalaby/discord-api-docs/compare/main...comp_v2?expand=1).

If you&apos;re using another library, you can check out the implementation status [here](https://discord-lib-devs.notion.site/components-v2-implementation-statuses).

### Statistics

We added built-in statistics to the `DiscordClient` and `DiscordShardedClient`. This will help you to get some basic statistics about your bot.

This includes the number of guilds, channels, users and more.

Here&apos;s an example:

```csharp
[SlashCommand(&quot;stats&quot;, &quot;Statistics about the bot!&quot;), DeferResponseAsync(true)]
public static async Task StatsAsync(InteractionContext ctx)
{
	var statistics = HatsuneMikuBot.ShardedClient.Statistics;
	var averagePing = (int)HatsuneMikuBot.ShardedClient.ShardClients.Values.Average(client =&gt; client.Ping);

	DiscordEmbedBuilder builder = new();
	builder.WithTitle(&quot;Stats&quot;);
	builder.WithDescription($&quot;Some stats about {ctx.Client.CurrentApplication.Name}!&quot;);
	foreach (var (key, value) in statistics)
		builder.AddField(new(key.ToString(), value.ToString().InlineCode(), true));
	builder.AddField(new(&quot;Ping&quot;, $&quot;{averagePing}ms&quot;.InlineCode(), true));
	if (ctx.Client.VersionString.Contains(&apos;+&apos;))
		builder.AddField(new(&quot;Lib (Version)&quot;, $&quot;{ctx.Client.BotLibrary}@{ctx.Client.VersionString}&quot;.MaskedUrl(new($&quot;https://github.com/Aiko-IT-Systems/DisCatSharp/tree/{ctx.Client.VersionString.Split(&apos;+&apos;).Last()}&quot;)), true));
	else
		builder.AddField(new(&quot;Lib (Version)&quot;, $&quot;{ctx.Client.BotLibrary}@{ctx.Client.VersionString}&quot;.MaskedUrl(new($&quot;https://github.com/Aiko-IT-Systems/DisCatSharp/tree/v{ctx.Client.VersionString.Trim()}&quot;)), true));
	builder.AddField(new(&quot;API Channel (Discord)&quot;, ctx.Client.ApiChannel.ToString().InlineCode(), true));
	builder.AddField(new(&quot;API Version (Discord)&quot;, ctx.Client.ApiVersion.InlineCode(), true));
	var lavalinkDefaultSession = ctx.Client.GetLavalink()?.DefaultSession();
	if (lavalinkDefaultSession is not null)
		builder.AddField(new(&quot;Lavalink Version&quot;, $&quot;{await lavalinkDefaultSession.GetLavalinkVersionAsync()}&quot;.InlineCode(), true));
	builder.WithThumbnail(ctx.Client.CurrentUser.AvatarUrl);
	if (ctx.Client.CurrentUser.BannerUrl is not null)
		builder.WithImageUrl(ctx.Client.CurrentUser.BannerUrl);
	await ctx.EditResponseAsync(new DiscordWebhookBuilder().AddEmbed(builder.Build()));
}
```

### Stability Improvements

We fixed some issues with the gateway connections and close code handling to improve the stability of the library.

### RoleType

We recently added `RoleType` to `DiscordRole`. This is meant to determine the type of role in an easier way.

Discord does not support this directly, it&apos;s a library side thing.

Improtant to note: Discords `RoleTags` object is really unstable / broken and changed over the weeks multiple times.

In our best effort we tried to patch it over and over again, but we can&apos;t guarantee that this will work in the future.

---

## What changed?

&lt;br/&gt;

### ❕ Breaking Changes

- **DiscordAttachment**: Renamed `MediaType` to `ContentType` to align with Discord&apos;s API.
- **DiscordTextComponent**: Switched the position of `customId` and `label` because of nullability.
- **Application Commands**: Removed `dmPermission` fields, causing DisCatSharp to do weird bulk-updates. Use `allowedContexts` instead.
- **LavalinkGuildPlayer**: `RemoveQueue` renamed to [`RemoveFromQueue`]((xref:DisCatSharp.Lavalink.Entities.LavalinkGuildPlayer.RemoveFromQueue*)).
- **Url fields**: Any `Url` fields on objects like `DiscordAttachment`, `DiscordEmbed`, etc., are now of type [`DiscordUri`](xref:DisCatSharp.Entities.DiscordUri) instead of `string`. Use `.ToUri()` to get a `Uri` object or use `.ToString()`.
- We updated some namespaces in DisCatSharp.Interactivity. You might need to update your imports for some entities and enums.
- Flags are now of the type `long` instead of `int`.
- Renamed some flags in [`ApplicationFlags`](xref:DisCatSharp.Enums.ApplicationFlags) and [`UserFlags`](xref:DisCatSharp.Enums.UserFlags) to be more consistent with Discord&apos;s API.
- Removed `EntitlementSkuIds` from interaction entities. Discord removed this field from the API. Use `Entitlements` instead.

### ➕ Additions

#### Added Entities

- [`ApplicationCommandRequireSkuEntitlementAttribute`](xref:DisCatSharp.ApplicationCommands.Attributes.ApplicationCommandRequireSkuEntitlementAttribute)

#### Added Enums

- [`RoleType.PremiumSubscriberTierDraft`](xref:DisCatSharp.Enums.RoleType)
- [`RoleType.ExternalPlatformOrPremiumSubscriber`](xref:DisCatSharp.Enums.RoleType)
- [`DisCatSharpStatisticType`](xref:DisCatSharp.Enums.Core.DisCatSharpStatisticType)

#### Added Properties

- [`DiscordClient.ApiChannel`](xref:DisCatSharp.BaseDiscordClient.ApiChannel)
- [`DiscordClient.ApiVersion`](xref:DisCatSharp.BaseDiscordClient.ApiVersion)
- [`DiscordClient.Statistics`](xref:DisCatSharp.BaseDiscordClient.Statistics)
- [`DiscordShardedClient.ApiChannel`](xref:DisCatSharp.DiscordShardedClient.ApiChannel)
- [`DiscordShardedClient.ApiVersion`](xref:DisCatSharp.DiscordShardedClient.ApiVersion)
- [`DiscordShardedClient.Statistics`](xref:DisCatSharp.DiscordShardedClient.Statistics)
- [`DiscordGuild.SoundboardSounds`](xref:DisCatSharp.Entities.DiscordGuild.SoundboardSounds)
- [`DiscordEmoji PaginationEmojis.Left`](xref:DisCatSharp.Interactivity.PaginationEmojis.Left)
- [`DiscordEmoji PaginationEmojis.Right`](xref:DisCatSharp.Interactivity.PaginationEmojis.Right)
- [`DiscordEmoji PaginationEmojis.SkipLeft`](xref:DisCatSharp.Interactivity.PaginationEmojis.SkipLeft)
- [`DiscordEmoji PaginationEmojis.SkipRight`](xref:DisCatSharp.Interactivity.PaginationEmojis.SkipRight)
- [`DiscordEmoji PaginationEmojis.Stop`](xref:DisCatSharp.Interactivity.PaginationEmojis.Stop)
- [`bool DiscordSignedLink.IsSigned`](xref:DisCatSharp.Entities.DiscordSignedLink.IsSigned)
- [`Optional&lt;bool&gt; DiscordRoleTags.IsGuildProductRole`](xref:DisCatSharp.Entities.DiscordRoleTags.IsGuildProductRole)
- [`string? DiscordUnfurledMedia.ContentType`](xref:DisCatSharp.Entities.DiscordUnfurledMedia.ContentType)

#### Added Enum Values

- [`RoleType.PremiumSubscriberTierDraft`](xref:DisCatSharp.Enums.RoleType)
- [`RoleType.ExternalPlatformOrPremiumSubscriber`](xref:DisCatSharp.Enums.RoleType)

#### Added Methods

- [`DiscordClient.ConsumeEntitlementAsync`](xref:DisCatSharp.DiscordClient.ConsumeEntitlementAsync*)
- [`DiscordClient.CreateTestEntitlementAsync`](xref:DisCatSharp.DiscordClient.CreateTestEntitlementAsync*)
- [`DiscordClient.DeleteTestEntitlementAsync`](xref:DisCatSharp.DiscordClient.DeleteTestEntitlementAsync*)
- [`DiscordEntitlement.ConsumeAsync`](xref:DisCatSharp.Entities.DiscordEntitlement.ConsumeAsync*)
- [`DiscordEntitlement.DeleteTestEntitlementsAsync`](xref:DisCatSharp.Entities.DiscordEntitlement.DeleteTestEntitlementsAsync*)
- [`DiscordSku.GetSubscriptionsAsync`](xref:DisCatSharp.Entities.DiscordSku.GetSubscriptionsAsync*)
- [`DiscordSku.GetSubscriptionAsync`](xref:DisCatSharp.Entities.DiscordSku.GetSubscriptionAsync*)
- [`DiscordSku.CreateTestEntitlementAsync`](xref:DisCatSharp.Entities.DiscordSku.CreateTestEntitlementAsync*)
- [`DiscordGuild.GetMemberVoiceStateAsync`](xref:DisCatSharp.Entities.DiscordGuild.GetMemberVoiceStateAsync*)
- [`LavalinkGuildPlayer.GetLyricsAsync`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.GetLyricsAsync*)
- [`LavalinkGuildPlayer.SeekAsync`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.SeekAsync*)
- [`LavalinkGuildPlayer.AddToQueueAt`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.AddToQueueAt*)
- [`LavalinkGuildPlayer.RemoveFromQueueAt`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.RemoveFromQueueAt*)
- [`LavalinkGuildPlayer.RemoveFromQueueAtRange`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.RemoveFromQueueAtRange*)
- [`LavalinkGuildPlayer.SetRepeatMode`](xref:DisCatSharp.Lavalink.LavalinkGuildPlayer.SetRepeatMode*)
- [`LavalinkSession.GetLyricsAsync`](xref:DisCatSharp.Lavalink.LavalinkSession.GetLyricsAsync*)
- [`string.Subtext`](xref:DisCatSharp.Formatter.Subtext*)
- [`DiscordButtonComponent.WithId`](xref:DisCatSharp.Entities.DiscordButtonComponent.WithId*)
- [`DiscordLinkButtonComponent.WithId`](xref:DisCatSharp.Entities.DiscordLinkButtonComponent.WithId*)
- [`DiscordPremiumButtonComponent.WithId`](xref:DisCatSharp.Entities.DiscordPremiumButtonComponent.WithId*)
- [`DiscordActionRowComponent.WithId`](xref:DisCatSharp.Entities.DiscordActionRowComponent.WithId*)
- [`DiscordChannelSelectComponent.WithId`](xref:DisCatSharp.Entities.DiscordChannelSelectComponent.WithId*)
- [`DiscordMentionableSelectComponent.WithId`](xref:DisCatSharp.Entities.DiscordMentionableSelectComponent.WithId*)
- [`DiscordRoleSelectComponent.WithId`](xref:DisCatSharp.Entities.DiscordRoleSelectComponent.WithId*)
- [`DiscordStringSelectComponent.WithId`](xref:DisCatSharp.Entities.DiscordStringSelectComponent.WithId*)
- [`DiscordUserSelectComponent.WithId`](xref:DisCatSharp.Entities.DiscordUserSelectComponent.WithId*)
- [`DiscordTextComponent.WithId`](xref:DisCatSharp.Entities.DiscordTextComponent.WithId*)
- [`DiscordContainerComponent.WithId`](xref:DisCatSharp.Entities.DiscordContainerComponent.WithId*)
- [`DiscordFileDisplayComponent.WithId`](xref:DisCatSharp.Entities.DiscordFileDisplayComponent.WithId*)
- [`DiscordMediaGalleryComponent.WithId`](xref:DisCatSharp.Entities.DiscordMediaGalleryComponent.WithId*)
- [`DiscordSectionComponent.WithId`](xref:DisCatSharp.Entities.DiscordSectionComponent.WithId*)
- [`DiscordSeparatorComponent.WithId`](xref:DisCatSharp.Entities.DiscordSeparatorComponent.WithId*)
- [`DiscordTextDisplayComponent.WithId`](xref:DisCatSharp.Entities.DiscordTextDisplayComponent.WithId*)
- [`DiscordThumbnailComponent.WithId`](xref:DisCatSharp.Entities.DiscordThumbnailComponent.WithId*)

### 🛠️ Fixes

- Fixed naming on `DiscordClient`: `CreateTestEntitlementsAsync` renamed to [`CreateTestEntitlementAsync`](xref:DisCatSharp.DiscordClient.CreateTestEntitlementAsync*) and `DeleteTestEntitlementsAsync` renamed to [`DeleteTestEntitlementAsync`](xref:DisCatSharp.DiscordClient.DeleteTestEntitlementAsync*).
- Fixed the [`Recalculate`](xref:DisCatSharp.Interactivity.InteractivityHelpers.Recalculate*) function for interactivity pages.
- Fixed issues with the `DiscordOAuth2Client`.
- Fixed issues when using the `OAuthWeb` extension to add users to a guild.
- Fixed invalid API routes for [`UpdateCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.UpdateCurrentUserApplicationRoleConnectionAsync*) and [`GetCurrentUserApplicationRoleConnectionAsync`](xref:DisCatSharp.DiscordOAuth2Client.GetCurrentUserApplicationRoleConnectionAsync*).
- Fixed the nullability annotations for some entities.

### ⚠️ Removals

- Removed `ApplicationCommandRequirePremiumAttribute`.

### 📚 Documentation

- Added missing documentation for public code.
- Documented more internal and private code to make library development easier.

---

## Future Roadmap

&lt;br/&gt;

### Audit Log Functionality Enhancement (Next Up)

We want to revamp how we implement the Discord audit log API. This will enhance the functionality and ease-of-use.
The enhancements we are planning are still in the developmental phase and might change.

### DisCatSharp.Voice (On Hold)

We&apos;re working on **DisCatSharp.Voice** which is set to replace the existing **DisCatSharp.VoiceNext**. It&apos;s planned to have better performance, stability and maintainability than its predecessor.
Particularly, this will bring back the receiving of incoming audio. Please note that any details are subject to change as development progresses.

### Caching System Overhaul (On Hold)

A major overhaul of our caching system is planned. The goal of this proposed rewrite is to increase reliability, performance and to add flexibility in how data is stored and retrieved.
We are still in the conceptual stage for this.

### DisCatSharp.CommandNext Revamp (Proposed)

A complete rewrite of **DisCatSharp.CommandsNext** is proposed. We want to rewrite this for improved maintainability and for potential performance and usability improvements.

---

## Feedback and Community Engagement

Your input makes DisCatSharp better! We warmly invite you to share feedback, suggestions, or report bugs.

Talking to us helps shape the future of DisCatSharp, ensuring it meets everyone&apos;s needs and expectations.


- **Join the Conversation:** Have ideas or questions? Join our [Discord community](https://discord.gg/RXA6u3jxdU) to discuss features, get help, or just chat with fellow developers.
- **Contribute:** Interested in contributing? Check out our [GitHub repository](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/CONTRIBUTING.md) to see how you can contribute code, documentation, or report issues.
- **Stay Updated:** Follow our [news channel](https://discord.com/channels/858089281214087179/976624429935251527) on Discord to stay up to date on the latest developments.

Your involvement is invaluable to us, and we look forward to growing and improving DisCatSharp together with you and everyone else!

---

## Contributors

- [Lulalaby](https://github.com/Lulalaby)</file><file path="DisCatSharp.Docs/index.md">---
uid: home
title: DisCatSharp
author: DisCatSharp Team
hasDiscordComponents: true
_disableAffix: true
_disableBreadcrumb: true
_disableNextArticle: true
---

# DisCatSharp ![Stable](https://img.shields.io/nuget/v/DisCatSharp?color=1F8B4C&amp;label=Stable&amp;style=flat-square&amp;logo=Nuget) ![Nightly](https://img.shields.io/nuget/vpre/DisCatSharp?color=AD1457&amp;label=Nightly&amp;style=flat-square&amp;logo=Nuget)

&lt;br/&gt;

## Introduction

&lt;br/&gt;
&lt;discord-messages&gt;
   &lt;discord-message profile=&quot;user_dm&quot;&gt;Hey, I&apos;m searching for a C# library to code discord bots.&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user_dm&quot;&gt;How about DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user_dm&quot;&gt;What is that, do you have an invite?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user_dm&quot;&gt;
        Sure!&lt;br/&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; class=&quot;discord-link external&quot; href=&quot;https://discord.gg/RXA6u3jxdU&quot;&gt;https://discord.gg/RXA6u3jxdU&lt;/a&gt;
		&lt;discord-attachments slot=&quot;attachments&quot;&gt;&lt;discord-invite name=&quot;DisCatSharp&quot; icon=&quot;https://i.imgur.com/sHdXUPx.png&quot; url=&quot;https://discord.gg/RXA6u3jxdU&quot; online=&quot;69&quot; members=&quot;420&quot; verified=&quot;true&quot;&gt;&lt;/discord-invite&gt;&lt;/discord-attachments&gt;
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;
&lt;br/&gt;
&lt;discord-messages&gt;
    &lt;discord-header guild=&quot;DisCatSharp&quot; channel=&quot;general&quot; icon=&quot;https://i.imgur.com/sHdXUPx.png&quot;&gt;This is the main channel of DisCatSharp&lt;/discord-header&gt;
    &lt;discord-system-message type=&quot;join&quot;&gt;
        Welcome, &lt;i style=&quot;color: #00c0ff;&quot;&gt;Discord User&lt;/i&gt;. We hope you brought pizza.
         &lt;discord-reactions slot=&quot;reactions&quot;&gt;
            &lt;discord-reaction interactive=&quot;true&quot; name=&quot;xcatclap&quot; emoji=&quot;https://cdn.discordapp.com/emojis/1059823127271575612.gif&quot; count=&quot;68&quot;&gt;&lt;/discord-reaction&gt;
        &lt;/discord-reactions&gt;
    &lt;/discord-system-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Hey guys, I&apos;m new here!&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_user&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Hey guys, I&apos;m new here!&lt;/discord-reply&gt;Welcome to DisCatSharp! Nice that you made it here &lt;discord-custom-emoji name=&quot;xcatlove&quot; url=&quot;https://cdn.discordapp.com/emojis/1059820726426800158.png&quot;&gt;&lt;/discord-custom-emoji&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs_owner&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Hey guys, I&apos;m new here!&lt;/discord-reply&gt;Welcome! If you need help just ask &lt;discord-custom-emoji name=&quot;AGC_AnimeDance&quot; url=&quot;https://cdn.discordapp.com/emojis/1106244669974790154.gif&quot;&gt;&lt;/discord-custom-emoji&gt;
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;What is DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;What is DisCatSharp?&lt;/discord-reply&gt;
        &lt;discord-bold&gt;DisCatSharp&lt;/discord-bold&gt; or short &lt;discord-bold&gt;DCS&lt;/discord-bold&gt; is an .NET wrapper for the &lt;discord-bold&gt;Discord API&lt;/discord-bold&gt;, originally based off DSharpPlus.&lt;br /&gt;&lt;br /&gt;
        The library has been rewritten to fit quality and API standards.&lt;br /&gt;&lt;br /&gt;
    Furthermore this lib includes many new features of Discord and is pretty fast with keeping up with Discords API.
    &lt;/discord-message&gt;
    &lt;discord-message profile=&quot;user&quot;&gt;Why should I use DisCatSharp?&lt;/discord-message&gt;
    &lt;discord-message profile=&quot;dcs&quot; highlight&gt;
        &lt;discord-reply slot=&quot;reply&quot; profile=&quot;user&quot; mentions&gt;Why should I use DisCatSharp?&lt;/discord-reply&gt;
        If you:&lt;br /&gt;
        - want a library where you get kind and efficient help&lt;br /&gt;
        - would like to have and use the most recent features of the Discord API&lt;br /&gt;
        - are ready to build great things&lt;br /&gt;&lt;br /&gt;
    Then this is the right library for you!
    &lt;/discord-message&gt;
&lt;/discord-messages&gt;
&lt;br/&gt;

## Getting Started

New users probably want to take a look into the [articles](xref:preamble) for quick start guides, tutorials, and examples of use.&lt;br/&gt;
Once you&apos;ve gotten through the articles, head over to the [API Documentation](xref:api_index) for all classes and methods provided by this library.

## Source and Contributors

DisCatSharp is licensed under MIT License, as detailed in the [license](https://github.com/Aiko-IT-Systems/DisCatSharp/blob/main/LICENSE.md) found in the repository.&lt;br/&gt;
The repository containing the source code for this library can be found [here](https://github.com/Aiko-IT-Systems/DisCatSharp). Contributions are welcomed.&lt;br/&gt;

### Sponsors

-   [Dei](https://github.com/DeividasKaza)
-   [Will](https://github.com/villChurch)
-   [SavageVictor](https://github.com/SavageVictor)
-   [Schattenclown](https://github.com/Schattenclown)
-   [FabiChan99](https://github.com/FabiChan99)

### Thanks

Big thanks goes to the following people who helped us without being part of the core team ♥️

-   [Auros Nexus](https://github.com/Auros)
-   [Lunar Starstrum](https://github.com/OoLunar)
-   [Geferon](https://github.com/geferon)
-   [Alice](https://github.com/QuantuChi)
-   [Will](https://github.com/villChurch)
-   [InFTord](https://github.com/InFTord)

### Special Thanks

The special thanks goes to Nagisa. Make sure to check out her [Instagram](https://www.instagram.com/nagisaarts_/) ♥️♥️

The second special thanks goes to [Sentry](https://sentry.io) ([GitHub](https://github.com/getsentry/)) for sponsering us a business account on sentry for error tracking.
You guys are the best 💕⭐

## Open Source License Status

[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=large)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_large)</file><file path="DisCatSharp.Experimental/Entities/DisCatSharpBuilderMethodHooks.cs">/// &lt;summary&gt;
///     Adds methods to &lt;see cref=&quot;DisCatSharpBuilder&quot; /&gt;.
/// &lt;/summary&gt;
public static class DisCatSharpBuilderMethodHooks
⋮----
///     Adds a &lt;see cref=&quot;GcpAttachment&quot; /&gt; to the &lt;typeparamref name=&quot;T&quot;/&gt;.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The &lt;typeparamref name=&quot;T&quot;/&gt; to add the attachment to.&lt;/param&gt;
/// &lt;param name=&quot;gcpAttachment&quot;&gt;The attachment to add.&lt;/param&gt;
/// &lt;param name=&quot;isVoice&quot;&gt;Whether this is a voice message attachment.&lt;/param&gt;
/// &lt;param name=&quot;originalStream&quot;&gt;
///     The voice message&apos;s stream, required if &lt;paramref name=&quot;isVoice&quot; /&gt; is
///     &lt;see langword=&quot;true&quot; /&gt;.
/// &lt;/param&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;The builder type.&lt;/typeparam&gt;
/// &lt;returns&gt;The chained &lt;typeparamref name=&quot;T&quot;/&gt;.&lt;/returns&gt;
public static T AddGcpAttachment&lt;T&gt;(this T builder, GcpAttachmentUploadInformation gcpAttachment, bool isVoice = false, Stream? originalStream = null) where T : DisCatSharpBuilder
⋮----
builder.AttachmentsInternal.Add(new()
⋮----
ArgumentNullException.ThrowIfNull(originalStream, nameof(originalStream));
var (durationSeconds, waveform) = originalStream.GetDurationAndWaveformBytes();
Console.WriteLine($&quot;Waveform length: {waveform.Length} bytes&quot;);
⋮----
///     Adds a manual GCP (Google Cloud Platform) voice message attachment to the &lt;typeparamref name=&quot;T&quot;/&gt;.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;The original filename of the attachment.&lt;/param&gt;
/// &lt;param name=&quot;uploadedFilename&quot;&gt;The filename assigned after upload to GCP.&lt;/param&gt;
/// &lt;param name=&quot;durationSeconds&quot;&gt;The duration of the voice message in seconds.&lt;/param&gt;
/// &lt;param name=&quot;waveform&quot;&gt;A byte-array representing the waveform data for the voice message.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;An optional description for the attachment.&lt;/param&gt;
⋮----
public static T AddManualGcpAttachment&lt;T&gt;(this T builder, string filename, string uploadedFilename, float durationSeconds, byte[] waveform, string? description = null) where T : DisCatSharpBuilder
⋮----
///     Adds a manual voice message attachment to the &lt;typeparamref name=&quot;T&quot;/&gt;.
///     Make sure to use &lt;typeparamref name=&quot;T&quot;/&gt;.AddFile before using this.
⋮----
public static T AddVoiceMessage&lt;T&gt;(this T builder, string filename, float durationSeconds, byte[] waveform, string? description = null) where T : DisCatSharpBuilder</file><file path="DisCatSharp.Experimental/Enums/Guild/JoinSourceType.cs">/// &lt;summary&gt;
///     Represents how a user joined the guild.
/// &lt;/summary&gt;
⋮----
///     The user joined the guild through an unknown source.
⋮----
///     The user was added to the guild by a bot using the guilds.join OAuth2 scope.
⋮----
///     The user was added to the guild by an integration.
⋮----
///     The user joined the guild through guild discovery.
⋮----
///     The user joined the guild through a student hub.
⋮----
///     The user joined the guild through an invite.
⋮----
///     The user joined the guild through a vanity URL.
⋮----
///     The user was accepted into the guild after applying for membership.
⋮----
///     The user joined via a social layer integration linked channel.</file><file path="DisCatSharp.Interactivity/Entities/ModalPage.cs">/// &lt;summary&gt;
///     A modal page.
/// &lt;/summary&gt;
public class ModalPage
⋮----
///     Creates a new modal page for the paginated modal builder.
⋮----
/// &lt;param name=&quot;modal&quot;&gt;The modal to display.&lt;/param&gt;
/// &lt;param name=&quot;openButton&quot;&gt;The button to display to open the current page. This is skipped if possible.&lt;/param&gt;
/// &lt;param name=&quot;openText&quot;&gt;The text to display to open the current page. This is skipped if possible.&lt;/param&gt;
⋮----
this.OpenButton = openButton ?? new DiscordButtonComponent(ButtonStyle.Primary, null, &quot;Open next page&quot;, false, new(DiscordEmoji.FromUnicode(&quot;📄&quot;)));
this.OpenMessage = new DiscordInteractionResponseBuilder().WithContent(openText ?? &quot;`Click the button below to continue to the next page.`&quot;).AsEphemeral();
⋮----
///     The modal that will be displayed.
⋮----
///     The button that will be displayed on the ephemeral message.
⋮----
///     The ephemeral message to display for this page.</file><file path="DisCatSharp.Interactivity/Entities/Page.cs">/// &lt;summary&gt;
///     The page.
/// &lt;/summary&gt;
public class Page
⋮----
///     &lt;para&gt;Initializes a new instance of the &lt;see cref=&quot;Page&quot; /&gt; class.&lt;/para&gt;
///     &lt;para&gt;You need to specify at least &lt;paramref name=&quot;content&quot; /&gt; or &lt;paramref name=&quot;embed&quot; /&gt; or both.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
/// &lt;param name=&quot;embed&quot;&gt;The embed.&lt;/param&gt;
⋮----
if (string.IsNullOrEmpty(content) &amp;&amp; embed is null)
throw new ArgumentException(&quot;You need to specify at least content or embed or both.&quot;);
⋮----
///     Gets or sets the content.
⋮----
///     Gets or sets the embed.</file><file path="DisCatSharp.Interactivity/Entities/PaginatedModalResponse.cs">/// &lt;summary&gt;
///     A response from the paginated modal response
/// &lt;/summary&gt;
public class PaginatedModalResponse
⋮----
///     The responses. The key is the customid of each component.
⋮----
///     The select menu responses. The key is the customid of each component.
⋮----
///     The last interaction. This is automatically replied to with a ephemeral &quot;thinking&quot; state. Use
///     EditOriginalResponseAsync to modify this.
⋮----
///     Whether the interaction timed out.</file><file path="DisCatSharp.Interactivity/Entities/PaginationEmojis.cs">/// &lt;summary&gt;
///     The pagination emojis.
/// &lt;/summary&gt;
public sealed class PaginationEmojis
⋮----
///     Gets or sets the left emoji.
⋮----
///     Gets or sets the right emoji.
⋮----
///     Gets or sets the skip left emoji.
⋮----
///     Gets or sets the skip right emoji.
⋮----
///     Gets or sets the stop emoji.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;PaginationEmojis&quot; /&gt; class.
⋮----
this.Left = DiscordEmoji.FromUnicode(&quot;◀&quot;);
this.Right = DiscordEmoji.FromUnicode(&quot;▶&quot;);
this.SkipLeft = DiscordEmoji.FromUnicode(&quot;⏮&quot;);
this.SkipRight = DiscordEmoji.FromUnicode(&quot;⏭&quot;);
this.Stop = DiscordEmoji.FromUnicode(&quot;⏹&quot;);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/ButtonPaginationRequest.cs">/// &lt;summary&gt;
///     The button pagination request.
/// &lt;/summary&gt;
internal class ButtonPaginationRequest : IPaginationRequest
⋮----
private readonly ButtonPaginationBehavior _behaviorBehavior;
private readonly PaginationButtons _buttons;
private readonly DiscordMessage _message;
⋮----
private readonly CancellationToken _token;
private readonly DiscordUser _user;
private readonly PaginationBehaviour _wrapBehavior;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ButtonPaginationRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
/// &lt;param name=&quot;behavior&quot;&gt;The behavior.&lt;/param&gt;
/// &lt;param name=&quot;buttonBehavior&quot;&gt;The button behavior.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;The buttons.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The token.&lt;/param&gt;
⋮----
this._pages.AddRange(pages);
⋮----
this._token.Register(() =&gt; this._tcs.TrySetResult(false));
⋮----
///     Gets the page count.
⋮----
///     Gets the page.
⋮----
public Task&lt;Page&gt; GetPageAsync()
⋮----
var page = Task.FromResult(this._pages[this._index]);
⋮----
this._buttons.SkipLeft.Disable();
this._buttons.Left.Disable();
this._buttons.Right.Disable();
this._buttons.SkipRight.Disable();
this._buttons.Stop.Enable();
⋮----
///     Skips the left.
⋮----
public Task SkipLeftAsync()
⋮----
///     Skips the right.
⋮----
public Task SkipRightAsync()
⋮----
///     Gets the next page.
⋮----
public Task NextPageAsync()
⋮----
this._index = Math.Min(this._index, this.PageCount - 1);
⋮----
///     Gets the previous page.
⋮----
public Task PreviousPageAsync()
⋮----
this._index = Math.Max(this._index, 0);
⋮----
///     Gets the emojis.
⋮----
public Task&lt;PaginationEmojis&gt; GetEmojisAsync()
=&gt; Task.FromException&lt;PaginationEmojis&gt;(new NotSupportedException(&quot;Emojis aren&apos;t supported for this request.&quot;));
⋮----
///     Gets the buttons.
⋮----
public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
⋮----
///     Gets the message.
⋮----
public Task&lt;DiscordMessage&gt; GetMessageAsync()
=&gt; Task.FromResult(this._message);
⋮----
///     Gets the user.
⋮----
public Task&lt;DiscordUser&gt; GetUserAsync()
=&gt; Task.FromResult(this._user);
⋮----
///     Gets the task completion source.
⋮----
public Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
=&gt; Task.FromResult(this._tcs);
⋮----
///     Does the cleanup.
⋮----
public async Task DoCleanupAsync()
⋮----
var builder = new DiscordMessageBuilder();
⋮----
var buttons = this._buttons.ButtonArray.Select(b =&gt; b.Disable());
⋮----
builder.WithContent(page.Content);
⋮----
builder.AddEmbed(page.Embed);
builder.AddComponents(buttons);
⋮----
await builder.ModifyAsync(this._message).ConfigureAwait(false);
⋮----
await this._message.DeleteAsync().ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/EventHandling/Components/Requests/InteractionPaginationRequest.cs">/// &lt;summary&gt;
///     The interaction pagination request.
/// &lt;/summary&gt;
internal class InteractionPaginationRequest : IPaginationRequest
⋮----
private readonly ButtonPaginationBehavior _behaviorBehavior;
private readonly PaginationButtons _buttons;
private readonly DiscordMessage _message;
⋮----
private readonly CancellationToken _token;
private readonly DiscordUser _user;
private readonly PaginationBehaviour _wrapBehavior;
⋮----
private CancellationTokenSource _interactionCts;
⋮----
private DiscordInteraction _lastInteraction;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InteractionPaginationRequest&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;interaction&quot;&gt;The interaction.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
/// &lt;param name=&quot;behavior&quot;&gt;The behavior.&lt;/param&gt;
/// &lt;param name=&quot;behaviorBehavior&quot;&gt;The behavior behavior.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;The buttons.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The token.&lt;/param&gt;
⋮----
this._pages.AddRange(pages);
⋮----
this.RegenerateCts(interaction);
this._token.Register(() =&gt; this._tcs.TrySetResult(false));
⋮----
///     Gets the page count.
⋮----
///     Gets the page.
⋮----
public Task&lt;Page&gt; GetPageAsync()
⋮----
var page = Task.FromResult(this._pages[this._index]);
⋮----
_ = this._buttons.ButtonArray.Select(b =&gt; b.Disable());
this._buttons.Stop.Enable();
⋮----
///     Skips the left page.
⋮----
public Task SkipLeftAsync()
⋮----
///     Skips the right page.
⋮----
public Task SkipRightAsync()
⋮----
///     Gets the next page.
⋮----
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public Task NextPageAsync()
⋮----
this._index = Math.Min(this._index, this.PageCount - 1);
⋮----
///     Gets the previous page.
⋮----
public Task PreviousPageAsync()
⋮----
this._index = Math.Max(this._index, 0);
⋮----
///     Gets the emojis.
⋮----
public Task&lt;PaginationEmojis&gt; GetEmojisAsync()
=&gt; Task.FromException&lt;PaginationEmojis&gt;(new NotSupportedException(&quot;Emojis aren&apos;t supported for this request.&quot;));
⋮----
///     Gets the buttons.
⋮----
public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
⋮----
///     Gets the message.
⋮----
public Task&lt;DiscordMessage&gt; GetMessageAsync()
=&gt; Task.FromResult(this._message);
⋮----
///     Gets the user.
⋮----
public Task&lt;DiscordUser&gt; GetUserAsync()
=&gt; Task.FromResult(this._user);
⋮----
///     Gets the task completion source.
⋮----
public Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
=&gt; Task.FromResult(this._tcs);
⋮----
///     Cleanup.
⋮----
public async Task DoCleanupAsync()
⋮----
var builder = new DiscordWebhookBuilder();
⋮----
.Select(b =&gt; new DiscordButtonComponent(b))
.Select(b =&gt; b.Disable());
⋮----
builder.WithContent(page.Content);
⋮----
builder.AddEmbed(page.Embed);
builder.AddComponents(buttons);
⋮----
await this._lastInteraction.EditOriginalResponseAsync(builder).ConfigureAwait(false);
⋮----
await this._lastInteraction.DeleteOriginalResponseAsync().ConfigureAwait(false);
⋮----
///     Regenerates the cts.
⋮----
internal void RegenerateCts(DiscordInteraction interaction)
⋮----
this._interactionCts = new(TimeSpan.FromSeconds((60 * 15) - 5));
this._interactionCts.Token.Register(() =&gt; this._tcs.TrySetResult(false));
⋮----
public Task&lt;DiscordInteraction&gt; GetLastInteractionAsync() =&gt; Task.FromResult(this._lastInteraction);</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/IPaginationRequest.cs">/// &lt;summary&gt;
///     The pagination request.
/// &lt;/summary&gt;
public interface IPaginationRequest
⋮----
///     Returns the number of pages.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
⋮----
///     Returns the current page.
⋮----
Task&lt;Page&gt; GetPageAsync();
⋮----
///     Tells the request to set its index to the first page.
⋮----
Task SkipLeftAsync();
⋮----
///     Tells the request to set its index to the last page.
⋮----
Task SkipRightAsync();
⋮----
///     Tells the request to increase its index by one.
⋮----
Task NextPageAsync();
⋮----
///     Tells the request to decrease its index by one.
⋮----
Task PreviousPageAsync();
⋮----
///     Requests the message buttons from the pagination request.
⋮----
/// &lt;returns&gt;The buttons.&lt;/returns&gt;
Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync();
⋮----
///     Requests message emojis from pagination request.
⋮----
Task&lt;PaginationEmojis&gt; GetEmojisAsync();
⋮----
///     Gets pagination message from this request.
⋮----
Task&lt;DiscordMessage&gt; GetMessageAsync();
⋮----
///     Gets the user this pagination applies to.
⋮----
Task&lt;DiscordUser&gt; GetUserAsync();
⋮----
///     Get this request&apos;s Task Completion Source.
⋮----
Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync();
⋮----
///     Tells the request to perform cleanup.
⋮----
Task DoCleanupAsync();</file><file path="DisCatSharp.Interactivity/EventHandling/Requests/PaginationRequest.cs">/// &lt;summary&gt;
///     The pagination request.
/// &lt;/summary&gt;
internal class PaginationRequest : IPaginationRequest
⋮----
private readonly PaginationBehaviour _behaviour;
private readonly CancellationTokenSource _ct;
private readonly PaginationEmojis _emojis;
private readonly DiscordMessage _message;
⋮----
private readonly TimeSpan _timeout;
private readonly DiscordUser _user;
⋮----
///     Creates a new Pagination request
⋮----
/// &lt;param name=&quot;message&quot;&gt;Message to paginate&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;User to allow control for&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;Behaviour during pagination&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;Behavior on pagination end&lt;/param&gt;
/// &lt;param name=&quot;emojis&quot;&gt;Emojis for this pagination object&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;Timeout time&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;Pagination pages&lt;/param&gt;
⋮----
this._ct.Token.Register(() =&gt; this._tcs.TrySetResult(true));
⋮----
///     Gets the pagination deletion.
⋮----
///     Gets the page count.
⋮----
///     Gets the page async.
⋮----
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public async Task&lt;Page&gt; GetPageAsync()
⋮----
await Task.Yield();
⋮----
///     Skips the left async.
⋮----
public async Task SkipLeftAsync()
⋮----
///     Skips the right async.
⋮----
public async Task SkipRightAsync()
⋮----
///     Nexts the page async.
⋮----
public async Task NextPageAsync()
⋮----
///     Previous the page async.
⋮----
public async Task PreviousPageAsync()
⋮----
///     Gets the buttons async.
⋮----
/// &lt;returns&gt;
///     &lt;see cref=&quot;NotSupportedException&quot; /&gt;
/// &lt;/returns&gt;
public Task&lt;IEnumerable&lt;DiscordButtonComponent&gt;&gt; GetButtonsAsync()
=&gt; throw new NotSupportedException(&quot;This request does not support buttons.&quot;);
⋮----
///     Gets the emojis async.
⋮----
public async Task&lt;PaginationEmojis&gt; GetEmojisAsync()
⋮----
///     Gets the message async.
⋮----
public async Task&lt;DiscordMessage&gt; GetMessageAsync()
⋮----
///     Gets the user async.
⋮----
public async Task&lt;DiscordUser&gt; GetUserAsync()
⋮----
///     Dos the cleanup async.
⋮----
public async Task DoCleanupAsync()
⋮----
await this._message.DeleteAllReactionsAsync().ConfigureAwait(false);
⋮----
await this._message.DeleteAsync().ConfigureAwait(false);
⋮----
///     Gets the task completion source async.
⋮----
public async Task&lt;TaskCompletionSource&lt;bool&gt;&gt; GetTaskCompletionSourceAsync()
⋮----
this.Dispose();
⋮----
///     Disposes this PaginationRequest.
⋮----
public void Dispose()
⋮----
this._ct.Dispose();</file><file path="DisCatSharp.Interactivity/Extensions/ChannelExtensions.cs">/// &lt;summary&gt;
///     Interactivity extension methods for &lt;see cref=&quot;DisCatSharp.Entities.DiscordChannel&quot; /&gt;.
/// &lt;/summary&gt;
public static class ChannelExtensions
⋮----
///     Waits for the next message sent in this channel that satisfies the predicate.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to monitor.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;A predicate that should return &lt;see langword=&quot;true&quot; /&gt; if a message matches.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Overrides the timeout set in &lt;see cref=&quot;InteractivityConfiguration.Timeout&quot; /&gt;&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
///     Thrown if interactivity is not enabled for the client associated with the
///     channel.
/// &lt;/exception&gt;
public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, Func&lt;DiscordMessage, bool&gt; predicate, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(channel).WaitForMessageAsync(msg =&gt; msg.ChannelId == channel.Id &amp;&amp; predicate(msg), timeoutOverride);
⋮----
///     Waits for the next message sent in this channel.
⋮----
public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, TimeSpan? timeoutOverride = null)
=&gt; channel.GetNextMessageAsync(msg =&gt; true, timeoutOverride);
⋮----
///     Waits for the next message sent in this channel from a specific user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The target user.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; GetNextMessageAsync(this DiscordChannel channel, DiscordUser user, TimeSpan? timeoutOverride = null)
=&gt; channel.GetNextMessageAsync(msg =&gt; msg.Author.Id == user.Id, timeoutOverride);
⋮----
///     Waits for a specific user to start typing in this channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The target channel.&lt;/param&gt;
⋮----
public static Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(this DiscordChannel channel, DiscordUser user, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(channel).WaitForUserTypingAsync(user, channel, timeoutOverride);
⋮----
///     Sends a new paginated message.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Target channel.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user that will be able to control the pages.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;A collection of &lt;see cref=&quot;Page&quot; /&gt; to display.&lt;/param&gt;
/// &lt;param name=&quot;emojis&quot;&gt;Pagination emojis.&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;Pagination behaviour (when hitting max and min indices).&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;Deletion behaviour.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override timeout period.&lt;/param&gt;
⋮----
public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationEmojis emojis, PaginationBehaviour? behaviour = default, PaginationDeletion? deletion = default, TimeSpan? timeoutOverride = null)
=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, emojis, behaviour, deletion, timeoutOverride);
⋮----
///     Sends a new paginated message with buttons.
⋮----
/// &lt;param name=&quot;buttons&quot;&gt;Pagination buttons (leave null to default to ones on configuration).&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;Pagination behaviour.&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;Deletion behaviour&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;A custom cancellation token that can be cancelled at any point.&lt;/param&gt;
⋮----
public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, buttons, behaviour, deletion, token);
⋮----
/// &lt;inheritdoc
///     cref=&quot;SendPaginatedMessageAsync(DiscordChannel, DiscordUser, IEnumerable{Page}, PaginationButtons, PaginationBehaviour?, ButtonPaginationBehavior?, CancellationToken)&quot; /&gt;
public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
=&gt; channel.SendPaginatedMessageAsync(user, pages, default, behaviour, deletion, token);
⋮----
public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
=&gt; GetInteractivity(channel).SendPaginatedMessageAsync(channel, user, pages, buttons, timeoutOverride, behaviour, deletion);
⋮----
///     Sends the paginated message async.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;behaviour&quot;&gt;The behaviour.&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;The deletion.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public static Task SendPaginatedMessageAsync(this DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
=&gt; channel.SendPaginatedMessageAsync(user, pages, default, timeoutOverride, behaviour, deletion);
⋮----
///     Retrieves an interactivity instance from a channel instance.
⋮----
internal static InteractivityExtension GetInteractivity(DiscordChannel channel)
⋮----
var interactivity = client.GetInteractivity();
⋮----
return interactivity ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);</file><file path="DisCatSharp.Interactivity/Extensions/InteractionExtensions.cs">/// &lt;summary&gt;
///     The interaction extensions.
/// &lt;/summary&gt;
public static class InteractionExtensions
⋮----
///     Sends a paginated message in response to an interaction.
///     &lt;para&gt;
///         &lt;b&gt;Pass the interaction directly. Interactivity will ACK it.&lt;/b&gt;
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;interaction&quot;&gt;The interaction to create a response to.&lt;/param&gt;
/// &lt;param name=&quot;deferred&quot;&gt;Whether the interaction was deferred.&lt;/param&gt;
/// &lt;param name=&quot;ephemeral&quot;&gt;Whether the response should be ephemeral.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user to listen for button presses from.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages to paginate.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;Optional: custom buttons&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;Pagination behaviour.&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;Deletion behaviour&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;A custom cancellation token that can be cancelled at any point.&lt;/param&gt;
public static Task SendPaginatedResponseAsync(this DiscordInteraction interaction, bool deferred, bool ephemeral, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons buttons = null, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
⋮----
///     Sends multiple modals to the user with a prompt to open the next one.
⋮----
///         &lt;b&gt;
///             After the last modal, this method automatically responds with the thinking state. Use
///             &lt;see cref=&quot;DiscordInteraction.EditOriginalResponseAsync(DiscordWebhookBuilder, DisCatSharp.Enums.Core.ModifyMode)&quot; /&gt; to interact with the
///             response.
///         &lt;/b&gt;
⋮----
/// &lt;param name=&quot;modals&quot;&gt;The modal pages.&lt;/param&gt;
/// &lt;param name=&quot;timeOutOverride&quot;&gt;A custom timeout. (Default: 15 minutes)&lt;/param&gt;
/// &lt;returns&gt;A read-only dictionary with the customid of the components as the key.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Is thrown when no modals are defined.&lt;/exception&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Is thrown when interactivity is not enabled for the client/shard.&lt;/exception&gt;
public static async Task&lt;PaginatedModalResponse&gt; CreatePaginatedModalResponseAsync(this DiscordInteraction interaction, IReadOnlyList&lt;ModalPage&gt; modals, TimeSpan? timeOutOverride = null)
⋮----
throw new ArgumentException(&quot;You have to set at least one page&quot;);
⋮----
var interactivity = client.GetInteractivity() ?? throw new InvalidOperationException($&quot;Interactivity is not enabled for this {(client.IsShard ? &quot;shard&quot; : &quot;client&quot;)}.&quot;);
⋮----
timeOutOverride ??= TimeSpan.FromMinutes(15);
⋮----
var modal = b.Modal.WithCustomId(Guid.NewGuid().ToString());
⋮----
var originalResponse = (await previousInteraction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, b.OpenMessage.AddComponents(b.OpenButton)).ConfigureAwait(false)).Message;
var modalOpen = await interactivity.WaitForButtonAsync(originalResponse, new List&lt;DiscordButtonComponent&gt;
⋮----
}, timeOutOverride).ConfigureAwait(false);
⋮----
_ = previousInteraction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(b.OpenMessage.Content).AddComponents(b.OpenButton.Disable()));
⋮----
await modalOpen.Result.Interaction.CreateInteractionModalResponseAsync(modal).ConfigureAwait(false);
⋮----
await previousInteraction.CreateInteractionModalResponseAsync(modal).ConfigureAwait(false);
⋮----
var modalResult = await interactivity.WaitForModalAsync(modal.CustomId, timeOutOverride).ConfigureAwait(false);
⋮----
foreach (var submissions in modalResult.Result.Interaction.Data.ModalComponents.OfType&lt;DiscordLabelComponent&gt;().Where(x =&gt; x.Component is DiscordTextInputComponent).Select(s =&gt; s.Component as DiscordTextInputComponent))
caughtResponses.Add(submissions.CustomId, submissions.Value);
⋮----
foreach (var submissions in modalResult.Result.Interaction.Data.ModalComponents.OfType&lt;DiscordLabelComponent&gt;().Where(x =&gt; x.Component is DiscordStringSelectComponent).Select(s =&gt; s.Component as DiscordStringSelectComponent))
caughtSelectResponses.Add(submissions.CustomId, submissions.SelectedValues);
⋮----
await previousInteraction.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource, new DiscordInteractionResponseBuilder().AsEphemeral()).ConfigureAwait(false);</file><file path="DisCatSharp.Interactivity/Helpers/InteractivityHelpers.cs">/// &lt;summary&gt;
///     Provides helper methods for interactivity features.
/// &lt;/summary&gt;
public static class InteractivityHelpers
⋮----
///     Recalculates the pages to include a footer with the current page number and total page count.
⋮----
/// &lt;param name=&quot;pages&quot;&gt;The list of pages to recalculate.&lt;/param&gt;
/// &lt;returns&gt;A new list of pages with updated footers.&lt;/returns&gt;
public static List&lt;Page&gt; Recalculate(this List&lt;Page&gt; pages)
⋮----
foreach (var page in pages.Where(p =&gt; p.Embed is not null))
⋮----
ArgumentNullException.ThrowIfNull(page.Embed);
var replaceEmbed = new DiscordEmbedBuilder(page.Embed).WithFooter($&quot;Page {pageCount}/{pages.Count}&quot;);
recalulatedPages.Add(new(embed: replaceEmbed));</file><file path="DisCatSharp.Interactivity/InteractivityConfiguration.cs">/// &lt;summary&gt;
///     Configuration class for your Interactivity extension
/// &lt;/summary&gt;
public sealed class InteractivityConfiguration
⋮----
///     Creates a new instance of &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;.
⋮----
///     Creates a new instance of &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;, copying the properties of another
///     configuration.
⋮----
/// &lt;param name=&quot;other&quot;&gt;Configuration the properties of which are to be copied.&lt;/param&gt;
⋮----
if (this.ResponseBehavior is InteractionResponseBehavior.Respond &amp;&amp; string.IsNullOrWhiteSpace(this.ResponseMessage))
throw new ArgumentException($&quot;{nameof(this.ResponseMessage)} cannot be null, empty, or whitespace when {nameof(this.ResponseBehavior)} is set to respond.&quot;);
⋮----
///     &lt;para&gt;Sets the default interactivity action timeout.&lt;/para&gt;
///     &lt;para&gt;Defaults to 1 minute.&lt;/para&gt;
⋮----
public TimeSpan Timeout { internal get; set; } = TimeSpan.FromMinutes(1);
⋮----
///     What to do after the poll ends
⋮----
///     Emojis to use for pagination
⋮----
///     Buttons to use for pagination.
⋮----
///     Whether interactivity should ACK buttons that are pushed.
⋮----
///     How to handle buttons after pagination ends.
⋮----
///     How to handle pagination. Defaults to WrapAround.
⋮----
///     How to handle pagination deletion. Defaults to DeleteEmojis.
⋮----
///     How to handle invalid interactions. Defaults to Ignore.
⋮----
///     The message to send to the user when processing invalid interactions. Ignored if &lt;see cref=&quot;ResponseBehavior&quot; /&gt; is
///     not set to &lt;see cref=&quot;DisCatSharp.Interactivity.Enums.InteractionResponseBehavior.Respond&quot; /&gt;.</file><file path="DisCatSharp.Interactivity/InteractivityExtension.cs">/// &lt;summary&gt;
///     Extension class for DisCatSharp.Interactivity
/// &lt;/summary&gt;
public class InteractivityExtension : BaseExtension
⋮----
private ComponentEventWaiter _componentEventWaiter;
⋮----
private ComponentPaginator _compPaginator;
⋮----
private ModalEventWaiter _modalEventWaiter;
⋮----
private Paginator _paginator;
⋮----
private Poller _poller;
⋮----
private ReactionCollector _reactionCollector;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;InteractivityExtension&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;cfg&quot;&gt;The configuration.&lt;/param&gt;
⋮----
///     Gets the config.
⋮----
///     Setups the Interactivity Extension.
⋮----
/// &lt;param name=&quot;client&quot;&gt;Discord client.&lt;/param&gt;
protected internal override void Setup(DiscordClient client)
⋮----
///     Makes a poll and returns poll results.
⋮----
/// &lt;param name=&quot;m&quot;&gt;Message to create poll on.&lt;/param&gt;
/// &lt;param name=&quot;emojis&quot;&gt;Emojis to use for this poll.&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;What to do when the poll ends.&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;Override timeout period.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public async Task&lt;ReadOnlyCollection&lt;PollEmoji&gt;&gt; DoPollAsync(DiscordMessage m, IEnumerable&lt;DiscordEmoji&gt; emojis, PollBehaviour? behaviour = default, TimeSpan? timeout = null)
⋮----
if (!Utilities.HasReactionIntents(this.Client.Configuration.Intents))
throw new InvalidOperationException(&quot;No reaction intents are enabled.&quot;);
⋮----
if (!emojis.Any())
throw new ArgumentException(&quot;You need to provide at least one emoji for a poll!&quot;);
⋮----
await m.CreateReactionAsync(em).ConfigureAwait(false);
⋮----
var res = await this._poller.DoPollAsync(new(m, timeout ?? this.Config.Timeout, emojis)).ConfigureAwait(false);
⋮----
var thisMember = await m.Channel.Guild.GetMemberAsync(this.Client.CurrentUser.Id).ConfigureAwait(false);
⋮----
if (pollBehaviour == PollBehaviour.DeleteEmojis &amp;&amp; m.Channel.PermissionsFor(thisMember).HasPermission(Permissions.ManageMessages))
await m.DeleteAllReactionsAsync().ConfigureAwait(false);
⋮----
return new(res.ToList());
⋮----
///     Waits for any button in the specified collection to be pressed.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to wait on.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;A collection of buttons to listen for.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override the timeout period in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;A &lt;see cref=&quot;InteractivityResult{T}&quot; /&gt; with the result of button that was pressed, if any.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
///     Thrown when attempting to wait for a message that is not authored by the
///     current user.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Thrown when the message does not contain a button with the specified Id, or any
///     buttons at all.
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, IEnumerable&lt;DiscordButtonComponent&gt; buttons, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForButtonAsync(message, buttons, this.GetCancellationToken(timeoutOverride));
⋮----
/// &lt;param name=&quot;token&quot;&gt;A custom cancellation token that can be cancelled at any point.&lt;/param&gt;
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, IEnumerable&lt;DiscordButtonComponent&gt; buttons, CancellationToken token)
⋮----
throw new InvalidOperationException(&quot;Interaction events are only sent to the application that created them.&quot;);
⋮----
if (!buttons.Any())
throw new ArgumentException(&quot;You must specify at least one button to listen for.&quot;);
⋮----
throw new ArgumentException(&quot;Provided message does not contain any components.&quot;);
⋮----
if (!message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).Any(c =&gt; c.Type is ComponentType.Button))
throw new ArgumentException(&quot;Provided Message does not contain any button components.&quot;);
⋮----
.WaitForMatchAsync(new(message,
⋮----
buttons.Any(b =&gt; b.CustomId == c.Id), token)).ConfigureAwait(false);
⋮----
///     Waits for a user modal submit.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id of the modal to wait for.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override the timeout period specified in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;A &lt;see cref=&quot;InteractivityResult{T}&quot; /&gt; with the result of the modal.&lt;/returns&gt;
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForModalAsync(string customId, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForModalAsync(customId, this.GetCancellationToken(timeoutOverride));
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForModalAsync(string customId, CancellationToken token)
⋮----
.WaitForModalMatchAsync(new(customId, c =&gt; c.Interaction.Type is InteractionType.ModalSubmit, token))
.ConfigureAwait(false);
⋮----
///     Waits for any button on the specified message to be pressed.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to wait for the button on.&lt;/param&gt;
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForButtonAsync(message, this.GetCancellationToken(timeoutOverride));
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, CancellationToken token)
⋮----
throw new ArgumentException(&quot;Message does not contain any button components.&quot;);
⋮----
var ids = message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).Select(c =&gt; c.CustomId);
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; ids.Contains(c.Id), token))
⋮----
///     Waits for any button on the specified message to be pressed by the specified user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to wait for the button press from.&lt;/param&gt;
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, DiscordUser user, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForButtonAsync(message, user, this.GetCancellationToken(timeoutOverride));
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, DiscordUser user, CancellationToken token)
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; c.User == user, token))
⋮----
///     Waits for a button with the specified Id to be pressed.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the button to wait for.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A &lt;see cref=&quot;InteractivityResult{T}&quot; /&gt; with the result of the operation.&lt;/returns&gt;
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, string id, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForButtonAsync(message, id, this.GetCancellationToken(timeoutOverride));
⋮----
/// &lt;param name=&quot;token&quot;&gt;Override the timeout period specified in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;.&lt;/param&gt;
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, string id, CancellationToken token)
⋮----
if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).OfType&lt;DiscordButtonComponent&gt;().All(c =&gt; c.CustomId != id))
throw new ArgumentException($&quot;Message does not contain button with Id of &apos;{id}&apos;.&quot;);
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; c.Id == id, token))
⋮----
///     Waits for any button to be interacted with.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;The predicate to filter interactions by.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override the timeout specified in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;&lt;/param&gt;
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForButtonAsync(message, predicate, this.GetCancellationToken(timeoutOverride));
⋮----
/// &lt;param name=&quot;token&quot;&gt;
///     A token to cancel interactivity with at any time. Pass &lt;see cref=&quot;CancellationToken.None&quot; /&gt; to
///     wait indefinitely.
/// &lt;/param&gt;
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForButtonAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, CancellationToken token)
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType is ComponentType.Button &amp;&amp; predicate(c), token))
⋮----
///     Waits for any dropdown to be interacted with.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to wait for.&lt;/param&gt;
/// &lt;param name=&quot;predicate&quot;&gt;A filter predicate.&lt;/param&gt;
/// &lt;param name=&quot;selectType&quot;&gt;The &lt;see cref=&quot;ComponentType&quot;&gt;type&lt;/see&gt; of the select menu.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the Provided message does not contain any dropdowns&lt;/exception&gt;
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForSelectAsync(message, predicate, selectType, this.GetCancellationToken(timeoutOverride));
⋮----
///     A token that can be used to cancel interactivity. Pass &lt;see cref=&quot;CancellationToken.None&quot; /&gt; to
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, Func&lt;ComponentInteractionCreateEventArgs, bool&gt; predicate, ComponentType selectType, CancellationToken token)
⋮----
if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).All(c =&gt; c.Type != selectType))
throw new ArgumentException(&quot;Message does not contain any select components.&quot;);
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType == selectType &amp;&amp; predicate(c), token))
⋮----
///     Waits for a dropdown to be interacted with.
⋮----
/// &lt;remarks&gt;This is here for backwards-compatibility and will internally create a cancellation token.&lt;/remarks&gt;
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Id of the dropdown to wait on.&lt;/param&gt;
⋮----
///     Thrown when the message does not have any dropdowns or any dropdown with the
///     specified Id.
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForSelectAsync(message, id, selectType, this.GetCancellationToken(timeoutOverride));
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, string id, ComponentType selectType, CancellationToken token)
⋮----
if (message.Components.OfType&lt;DiscordActionRowComponent&gt;().SelectMany(c =&gt; c.Components).OfType&lt;DiscordBaseSelectComponent&gt;().All(c =&gt; c.CustomId != id))
throw new ArgumentException($&quot;Message does not contain select component with Id of &apos;{id}&apos;.&quot;);
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Interaction.Data.ComponentType == selectType &amp;&amp; c.Id == id, token))
⋮----
///     Waits for a dropdown to be interacted with by a specific user.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to wait on.&lt;/param&gt;
⋮----
public Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, DiscordUser user, string id, ComponentType selectType, TimeSpan? timeoutOverride = null)
=&gt; this.WaitForSelectAsync(message, user, id, selectType, this.GetCancellationToken(timeoutOverride));
⋮----
public async Task&lt;InteractivityResult&lt;ComponentInteractionCreateEventArgs&gt;&gt; WaitForSelectAsync(DiscordMessage message, DiscordUser user, string id, ComponentType selectType, CancellationToken token)
⋮----
throw new ArgumentException($&quot;Message does not contain select with Id of &apos;{id}&apos;.&quot;);
⋮----
.WaitForMatchAsync(new(message, c =&gt; c.Id == id &amp;&amp; c.User == user, token)).ConfigureAwait(false);
⋮----
///     Waits for a specific message.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;Predicate to match.&lt;/param&gt;
/// &lt;param name=&quot;timeoutOverride&quot;&gt;Override timeout period.&lt;/param&gt;
public async Task&lt;InteractivityResult&lt;DiscordMessage&gt;&gt; WaitForMessageAsync(
⋮----
if (!Utilities.HasMessageIntents(this.Client.Configuration.Intents))
throw new InvalidOperationException(&quot;No message intents are enabled.&quot;);
⋮----
var returns = await this._messageCreatedWaiter.WaitForMatchAsync(new(x =&gt; predicate(x.Message), timeout)).ConfigureAwait(false);
⋮----
///     Wait for a specific reaction.
⋮----
public async Task&lt;InteractivityResult&lt;MessageReactionAddEventArgs&gt;&gt; WaitForReactionAsync(
⋮----
var returns = await this._messageReactionAddWaiter.WaitForMatchAsync(new(predicate, timeout)).ConfigureAwait(false);
⋮----
///     For this Event you need the &lt;see cref=&quot;DiscordIntents.GuildMessageReactions&quot; /&gt; intent specified in
///     &lt;seealso cref=&quot;DiscordConfiguration.Intents&quot; /&gt;
⋮----
/// &lt;param name=&quot;message&quot;&gt;Message reaction was added to.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;User that made the reaction.&lt;/param&gt;
⋮----
=&gt; await this.WaitForReactionAsync(x =&gt; x.User.Id == user.Id &amp;&amp; x.Message.Id == message.Id, timeoutOverride).ConfigureAwait(false);
⋮----
///     Waits for a specific reaction.
⋮----
=&gt; await this.WaitForReactionAsync(x =&gt; predicate(x) &amp;&amp; x.User.Id == user.Id &amp;&amp; x.Message.Id == message.Id, timeoutOverride).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;predicate to match.&lt;/param&gt;
⋮----
=&gt; await this.WaitForReactionAsync(x =&gt; predicate(x) &amp;&amp; x.User.Id == user.Id, timeoutOverride).ConfigureAwait(false);
⋮----
///     Waits for a user to start typing.
⋮----
/// &lt;param name=&quot;user&quot;&gt;User that starts typing.&lt;/param&gt;
/// &lt;param name=&quot;channel&quot;&gt;Channel the user is typing in.&lt;/param&gt;
⋮----
public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(
⋮----
if (!Utilities.HasTypingIntents(this.Client.Configuration.Intents))
throw new InvalidOperationException(&quot;No typing intents are enabled.&quot;);
⋮----
var returns = await this._typingStartWaiter.WaitForMatchAsync(
⋮----
public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForUserTypingAsync(DiscordUser user, TimeSpan? timeoutOverride = null)
⋮----
///     Waits for any user to start typing.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to type in.&lt;/param&gt;
⋮----
public async Task&lt;InteractivityResult&lt;TypingStartEventArgs&gt;&gt; WaitForTypingAsync(DiscordChannel channel, TimeSpan? timeoutOverride = null)
⋮----
///     Collects reactions on a specific message.
⋮----
/// &lt;param name=&quot;m&quot;&gt;Message to collect reactions on.&lt;/param&gt;
⋮----
public async Task&lt;ReadOnlyCollection&lt;Reaction&gt;&gt; CollectReactionsAsync(DiscordMessage m, TimeSpan? timeoutOverride = null)
⋮----
var collection = await this._reactionCollector.CollectAsync(new(m, timeout)).ConfigureAwait(false);
⋮----
///     Waits for specific event args to be received. Make sure the appropriate &lt;see cref=&quot;DiscordIntents&quot; /&gt; are
///     registered, if needed.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
/// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
⋮----
public async Task&lt;InteractivityResult&lt;T&gt;&gt; WaitForEventArgsAsync&lt;T&gt;(Func&lt;T, bool&gt; predicate, TimeSpan? timeoutOverride = null) where T : AsyncEventArgs
⋮----
var res = await waiter.WaitForMatchAsync(new(predicate, timeout)).ConfigureAwait(false);
⋮----
///     Collects the event arguments.
⋮----
public async Task&lt;ReadOnlyCollection&lt;T&gt;&gt; CollectEventArgsAsync&lt;T&gt;(Func&lt;T, bool&gt; predicate, TimeSpan? timeoutOverride = null) where T : AsyncEventArgs
⋮----
var res = await waiter.CollectMatchesAsync(new(predicate, timeout)).ConfigureAwait(false);
⋮----
///     Sends a paginated message with buttons.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to send it on.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;User to give control.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;
///     Pagination buttons (pass null to use buttons defined in &lt;see cref=&quot;InteractivityConfiguration&quot; /&gt;
///     ).
⋮----
/// &lt;param name=&quot;behaviour&quot;&gt;Pagination behaviour.&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;Deletion behaviour.&lt;/param&gt;
⋮----
public async Task SendPaginatedMessageAsync(
⋮----
bts.SkipLeft.Disable();
bts.Left.Disable();
⋮----
var page = pages.First();
var builder = new DiscordMessageBuilder();
⋮----
builder.WithContent(page.Content);
⋮----
builder.AddEmbed(page.Embed);
builder.AddComponents(bts.ButtonArray.ToList());
⋮----
var message = await builder.SendAsync(channel).ConfigureAwait(false);
⋮----
var req = new ButtonPaginationRequest(message, user, bhv, del, bts, pages, token == default ? this.GetCancellationToken() : token);
⋮----
await this._compPaginator.DoPaginationAsync(req).ConfigureAwait(false);
⋮----
public Task SendPaginatedMessageAsync(
⋮----
=&gt; this.SendPaginatedMessageAsync(channel, user, pages, buttons, behaviour, deletion, this.GetCancellationToken(timeoutOverride));
⋮----
///     Sends the paginated message.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;behaviour&quot;&gt;The behaviour.&lt;/param&gt;
/// &lt;param name=&quot;deletion&quot;&gt;The deletion.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The token.&lt;/param&gt;
/// &lt;returns&gt;A Task.&lt;/returns&gt;
public Task SendPaginatedMessageAsync(DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
=&gt; this.SendPaginatedMessageAsync(channel, user, pages, default, behaviour, deletion, token);
⋮----
public Task SendPaginatedMessageAsync(DiscordChannel channel, DiscordUser user, IEnumerable&lt;Page&gt; pages, TimeSpan? timeoutOverride, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default)
=&gt; this.SendPaginatedMessageAsync(channel, user, pages, default, timeoutOverride, behaviour, deletion);
⋮----
///     Sends a paginated message.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to send paginated message in.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;pages&quot;&gt;Pages.&lt;/param&gt;
/// &lt;param name=&quot;emojis&quot;&gt;Pagination emojis.&lt;/param&gt;
/// &lt;param name=&quot;behaviour&quot;&gt;Pagination behaviour (when hitting max and min indices).&lt;/param&gt;
⋮----
var m = await builder.SendAsync(channel).ConfigureAwait(false);
⋮----
var pRequest = new PaginationRequest(m, user, bhv, del, ems, timeout, pages);
⋮----
await this._paginator.DoPaginationAsync(pRequest).ConfigureAwait(false);
⋮----
///     Sends a paginated message in response to an interaction.
///     &lt;para&gt;
///         &lt;b&gt;Pass the interaction directly. Interactivity will ACK it.&lt;/b&gt;
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;interaction&quot;&gt;The interaction to create a response to.&lt;/param&gt;
/// &lt;param name=&quot;deferred&quot;&gt;Whether the interaction was deferred.&lt;/param&gt;
/// &lt;param name=&quot;ephemeral&quot;&gt;Whether the response should be ephemeral.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user to listen for button presses from.&lt;/param&gt;
/// &lt;param name=&quot;pages&quot;&gt;The pages to paginate.&lt;/param&gt;
/// &lt;param name=&quot;buttons&quot;&gt;Optional: custom buttons.&lt;/param&gt;
⋮----
public async Task SendPaginatedResponseAsync(DiscordInteraction interaction, bool deferred, bool ephemeral, DiscordUser user, IEnumerable&lt;Page&gt; pages, PaginationButtons? buttons = null, PaginationBehaviour? behaviour = default, ButtonPaginationBehavior? deletion = default, CancellationToken token = default)
⋮----
if (pages.Count() is 1)
⋮----
bts.SkipRight.Disable();
⋮----
bts.Stop.Disable();
bts.Right.Disable();
⋮----
DiscordMessage message;
⋮----
var builder = new DiscordWebhookBuilder();
⋮----
message = await interaction.EditOriginalResponseAsync(builder).ConfigureAwait(false);
⋮----
var builder = new DiscordInteractionResponseBuilder();
⋮----
builder = builder.AsEphemeral();
message = (await interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, builder).ConfigureAwait(false)).Message!;
⋮----
var req = new InteractionPaginationRequest(interaction, message, user, bhv, del, bts, pages, token);
⋮----
///     Waits for a custom pagination request to finish.
///     This does NOT handle removing emojis after finishing for you.
⋮----
/// &lt;param name=&quot;request&quot;&gt;The request to wait for.&lt;/param&gt;
public async Task WaitForCustomPaginationAsync(IPaginationRequest request)
=&gt; await this._paginator.DoPaginationAsync(request).ConfigureAwait(false);
⋮----
///     Waits for custom button-based pagination request to finish.
///     &lt;br /&gt;
///     This does
///     &lt;i&gt;
///         &lt;b&gt;not&lt;/b&gt;
///     &lt;/i&gt;
///     invoke &lt;see cref=&quot;DisCatSharp.Interactivity.EventHandling.IPaginationRequest.DoCleanupAsync&quot; /&gt;.
⋮----
public async Task WaitForCustomComponentPaginationAsync(IPaginationRequest request)
=&gt; await this._compPaginator.DoPaginationAsync(request).ConfigureAwait(false);
⋮----
///     Generates pages from a string, and puts them in message content.
⋮----
/// &lt;param name=&quot;input&quot;&gt;Input string.&lt;/param&gt;
/// &lt;param name=&quot;splitType&quot;&gt;How to split input string.&lt;/param&gt;
⋮----
public IEnumerable&lt;Page&gt; GeneratePagesInContent(string input, SplitType splitType = SplitType.Character)
⋮----
if (string.IsNullOrEmpty(input))
throw new ArgumentException(&quot;You must provide a string that is not null or empty!&quot;);
⋮----
split = [.. this.SplitString(input, 500)];
⋮----
var subsplit = input.Split(&apos;\n&apos;);
⋮----
split.Add(s);
⋮----
if (split.All(x =&gt; x != s))
⋮----
result.Add(new($&quot;Page {page}:\n{s}&quot;));
⋮----
///     Generates pages from a string, and puts them in message embeds.
⋮----
/// &lt;param name=&quot;embedBase&quot;&gt;Base embed for output embeds.&lt;/param&gt;
public IEnumerable&lt;Page&gt; GeneratePagesInEmbed(string input, SplitType splitType = SplitType.Character, DiscordEmbedBuilder? embedBase = null)
⋮----
var embed = embedBase ?? new DiscordEmbedBuilder();
⋮----
result.Add(new(null, new DiscordEmbedBuilder(embed).WithDescription(s).WithFooter($&quot;Page {page}/{split.Count}&quot;)));
⋮----
///     Splits the string.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string.&lt;/param&gt;
/// &lt;param name=&quot;chunkSize&quot;&gt;The chunk size.&lt;/param&gt;
private List&lt;string&gt; SplitString(string str, int chunkSize)
⋮----
var size = Math.Min(len - i, chunkSize);
res.Add(str.Substring(i, size));
⋮----
///     Gets the cancellation token.
⋮----
/// &lt;param name=&quot;timeout&quot;&gt;The timeout.&lt;/param&gt;
private CancellationToken GetCancellationToken(TimeSpan? timeout = null) =&gt; new CancellationTokenSource(timeout ?? this.Config.Timeout).Token;
⋮----
///     Handles an invalid interaction.
⋮----
/// &lt;param name=&quot;interaction&quot;&gt;The interaction.&lt;/param&gt;
private async Task HandleInvalidInteraction(DiscordInteraction interaction)
⋮----
InteractionResponseBehavior.Ack =&gt; interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate),
InteractionResponseBehavior.Respond =&gt; interaction.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new()
⋮----
_ =&gt; throw new ArgumentException(&quot;Unknown enum value.&quot;)
⋮----
await at.ConfigureAwait(false);</file><file path="DisCatSharp.Lavalink/LavalinkJson.cs">/// &lt;summary&gt;
///     Represents a custom json (de-)serializer.
/// &lt;/summary&gt;
internal static class LavalinkJson
⋮----
///     The &lt;see cref=&quot;JsonSerializerSettings&quot; /&gt; with an &lt;see cref=&quot;Newtonsoft.Json.Serialization.IContractResolver&quot; /&gt;
///     for &lt;see cref=&quot;Optional&quot; /&gt; types.
⋮----
private static readonly JsonSerializerSettings s_setting = new()
⋮----
ContractResolver = new DisCatSharpContractResolver()
⋮----
///     Deserializes the JSON to the specified .NET type using &lt;see cref=&quot;s_setting&quot; /&gt;.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The type of the object to deserialize to.&lt;/typeparam&gt;
/// &lt;param name=&quot;value&quot;&gt;The object to deserialize.&lt;/param&gt;
/// &lt;returns&gt;The deserialized object from the JSON string.&lt;/returns&gt;
⋮----
public static T? DeserializeObject&lt;T&gt;(string value)
⋮----
///     Serializes the specified object to a JSON string using formatting and &lt;see cref=&quot;s_setting&quot; /&gt;.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The object to serialize.&lt;/param&gt;
/// &lt;param name=&quot;formatting&quot;&gt;Indicates how the output should be formatted. Defaults to &lt;see cref=&quot;Formatting.Indented&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;A JSON string representation of the object.&lt;/returns&gt;
⋮----
public static string SerializeObject(object? value, Formatting formatting = Formatting.None)
=&gt; JsonConvert.SerializeObject(value, formatting, s_setting);</file><file path="DisCatSharp.Targets/InternalsVisibleTo.targets">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
	&lt;ItemGroup&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.ApplicationCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.CommandsNext&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Common&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Configuration&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Configuration.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.CopilotTests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.EventHandlers.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting.DependencyInjection&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Hosting.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Interactivity&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Lavalink&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.LavalinkV1&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Phabricator&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Support&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.SafetyTests.Internal&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.ApplicationCommands.Tests&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.VoiceNext&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.VoiceNext.Natives&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.DevTools&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.DocsGenerator&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.StaffApps&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Experimental&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.OAuth2Web&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.TwoFactorCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions.SimpleMusicCommands&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Nyaw&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;MikuSharp&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Microsoft.DocAsCode&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Microsoft.DocAsCode.Metadata.ManagedReference&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;ProjectMakoto&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;SidePlus_AuthBot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;SidePlus_Helper&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Cache_Design&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Extensions&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Bots.DocBot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;DisCatSharp.Bots.DocBot.Bot&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;BeluBOT&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;BeluGANG&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;AITSYS.Pycord&quot; /&gt;
		&lt;InternalsVisibleTo Include=&quot;Rawr&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.SafetyTests/HttpTest.cs">public class HttpTests
⋮----
public void BuiltInRestClientEnsureNoAuthorization()
⋮----
DiscordClient client = new(new()
⋮----
var action = () =&gt; client.RestClient.DefaultRequestHeaders.GetValues(&quot;Authorization&quot;).ToString();
action.Should()
⋮----
.WithMessage(&quot;The given header was not found.&quot;);
⋮----
client.RestClient.DefaultRequestHeaders.Add(&quot;Authorization&quot;, &quot;not_so_secret_manual_token&quot;);
var action2 = () =&gt; client.RestClient.DefaultRequestHeaders.GetValues(&quot;Authorization&quot;).ToString();
action2.Should()</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.CodeFixes/DisCatSharp.Analyzer.CodeFixes.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
		&lt;RootNamespace&gt;DisCatSharp.Analyzer&lt;/RootNamespace&gt;
		&lt;IncludeSymbols&gt;True&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.14.0&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; PrivateAssets=&quot;All&quot; IncludeInPackage=&quot;true&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Compile Update=&quot;CodeFixResources.Designer.cs&quot; DesignTime=&quot;True&quot; AutoGen=&quot;True&quot; DependentUpon=&quot;CodeFixResources.resx&quot; /&gt;
		&lt;EmbeddedResource Update=&quot;CodeFixResources.resx&quot; Generator=&quot;ResXFileCodeGenerator&quot; LastGenOutput=&quot;CodeFixResources.Designer.cs&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer.Package/DisCatSharp.Analyzer.Package.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
		&lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;
		&lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt;
		&lt;GenerateBindingRedirectsOutputType&gt;true&lt;/GenerateBindingRedirectsOutputType&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;Title&gt;DisCatSharp Analyzer&lt;/Title&gt;
		&lt;PackageId&gt;DisCatSharp.Analyzer&lt;/PackageId&gt;
		&lt;PackageVersion&gt;1.0.0.0&lt;/PackageVersion&gt;
		&lt;Authors&gt;AITSYS&lt;/Authors&gt;
		&lt;PackageIcon&gt;logo-pride.png&lt;/PackageIcon&gt;
		&lt;RepositoryUrl&gt;https://github.com/Aiko-IT-Systems/DisCatSharp&lt;/RepositoryUrl&gt;
		&lt;RestoreProjectStyle&gt;PackageReference&lt;/RestoreProjectStyle&gt;
		&lt;PackageProjectUrl&gt; https://docs.dcs.aitsys.dev/vs/&lt;/PackageProjectUrl&gt;
		&lt;PackageLicenseExpression /&gt;
		&lt;PackageLicenseFile&gt;LICENSE.md&lt;/PackageLicenseFile&gt;
		&lt;PackageRequireLicenseAcceptance&gt;false&lt;/PackageRequireLicenseAcceptance&gt;
		&lt;Description&gt;DisCatSharp Analyzer - a recommended developer dependency to make writing bots in DisCatSharp easier.

This package provides various custom analyzer rules specific for DisCatSharp. You can read more about the rules here: https://docs.dcs.aitsys.dev/vs/.
We also provide certain codefixes if we introduce breaking changes in the future.

Please install it to ensure we can do our changes, and you can receive our updates &amp;lt;3&lt;/Description&gt;
		&lt;PackageReleaseNotes&gt;$([System.IO.File]::ReadAllText(&quot;$(MSBuildProjectDirectory)/../../../RELEASENOTES.md&quot;))&lt;/PackageReleaseNotes&gt;
		&lt;Copyright&gt;Copyright 2022-2025 AITSYS&lt;/Copyright&gt;
		&lt;PackageTags&gt;Analyzer, analyzers, DisCatSharp, DCS&lt;/PackageTags&gt;
		&lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
		&lt;NoPackageAnalysis&gt;true&lt;/NoPackageAnalysis&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
		&lt;ProduceReferenceAssembly&gt;false&lt;/ProduceReferenceAssembly&gt;
		&lt;TargetsForTfmSpecificContentInPackage&gt;$(TargetsForTfmSpecificContentInPackage);AddNuGetDlls&lt;/TargetsForTfmSpecificContentInPackage&gt;
		&lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;
		&lt;RepositoryType&gt;git&lt;/RepositoryType&gt;
		&lt;IncludeSymbols&gt;True&lt;/IncludeSymbols&gt;
		&lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Include=&quot;..\..\..\DisCatSharp.Logos\logo-pride.png&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\..\..\LICENSE.md&quot;&gt;
			&lt;Pack&gt;True&lt;/Pack&gt;
			&lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
		&lt;None Include=&quot;..\..\..\README.md&quot;&gt;
		  &lt;Pack&gt;True&lt;/Pack&gt;
		  &lt;PackagePath&gt;\&lt;/PackagePath&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;
	&lt;Target Name=&quot;AddNuGetDlls&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&gt;
		&lt;JoinItems Left=&quot;@(ResolvedCompileFileDefinitions)&quot; LeftKey=&quot;NuGetPackageId&quot; LeftMetadata=&quot;*&quot; Right=&quot;@(PackageReference)&quot; RightKey=&quot;&quot; RightMetadata=&quot;*&quot; ItemSpecToUse=&quot;Left&quot;&gt;
			&lt;Output TaskParameter=&quot;JoinResult&quot; ItemName=&quot;_PackagesToPack&quot; /&gt;
		&lt;/JoinItems&gt;

		&lt;ItemGroup&gt;
			&lt;_PackagesToPack Remove=&quot;@(_PackagesToPack)&quot; Condition=&quot;%(NuGetPackageId) == &apos;NETStandard.Library&apos;&quot; /&gt;
			&lt;_PackagesToPack Remove=&quot;@(_PackagesToPack)&quot; Condition=&quot;%(_PackagesToPack.IncludeInPackage) != &apos;true&apos;&quot; /&gt;
		&lt;/ItemGroup&gt;

		&lt;Message Importance=&quot;High&quot; Text=&quot;Adding DLLs from the following packages: @(_PackagesToPack-&gt;&apos;%(NuGetPackageId)&apos;)&quot; /&gt;
		&lt;ItemGroup&gt;
			&lt;None Include=&quot;@(_PackagesToPack)&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; /&gt;
			&lt;None Include=&quot;$(OutputPath)\DisCatSharp.Analyzer.dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; /&gt;
			&lt;None Include=&quot;$(OutputPath)\DisCatSharp.Analyzer.CodeFixes.dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; /&gt;
		&lt;/ItemGroup&gt;
	&lt;/Target&gt;
	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer.CodeFixes\DisCatSharp.Analyzer.CodeFixes.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Analyzer\DisCatSharp.Analyzer.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; PrivateAssets=&quot;All&quot; IncludeInPackage=&quot;true&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;tools\*.ps1&quot; CopyToOutputDirectory=&quot;PreserveNewest&quot; Pack=&quot;true&quot; PackagePath=&quot;&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp/Entities/Channel/DiscordChannelMention.cs">/// &lt;summary&gt;
/// Represents a channel mention object in a Discord message.
/// &lt;/summary&gt;
public class DiscordChannelMention
⋮----
/// Gets the ID of the channel.
⋮----
/// Gets the ID of the guild containing the channel.
⋮----
/// Gets the type of the channel.
⋮----
/// Gets the name of the channel.</file><file path="DisCatSharp/Entities/Embed/DiscordEmbed.cs">/// &lt;summary&gt;
///     Represents a discord embed.
/// &lt;/summary&gt;
public sealed class DiscordEmbed : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmbed&quot; /&gt; class.
⋮----
///     Gets the embed&apos;s title.
⋮----
///     &lt;para&gt;Gets the embed&apos;s type.&lt;/para&gt;
///     &lt;list type=&quot;table&quot;&gt;
///         &lt;listheader&gt;
///             &lt;term&gt;Type&lt;/term&gt;
///             &lt;description&gt;Description&lt;/description&gt;
///         &lt;/listheader&gt;
///         &lt;item&gt;
///             &lt;term&gt;rich&lt;/term&gt;
///             &lt;description&gt;generic embed rendered from embed attributes&lt;/description&gt;
///         &lt;/item&gt;
⋮----
///             &lt;term&gt;image&lt;/term&gt;
///             &lt;description&gt;image embed&lt;/description&gt;
⋮----
///             &lt;term&gt;video&lt;/term&gt;
///             &lt;description&gt;video embed&lt;/description&gt;
⋮----
///             &lt;term&gt;gifv&lt;/term&gt;
///             &lt;description&gt;animated gif image embed rendered as a video embed&lt;/description&gt;
⋮----
///             &lt;term&gt;article&lt;/term&gt;
///             &lt;description&gt;article embed&lt;/description&gt;
⋮----
///             &lt;term&gt;link&lt;/term&gt;
///             &lt;description&gt;link embed&lt;/description&gt;
⋮----
///             &lt;term&gt;poll_result&lt;/term&gt;
///             &lt;description&gt;poll result embed&lt;/description&gt;
⋮----
///             &lt;term&gt;auto_moderation_message&lt;/term&gt;
///             &lt;description&gt;auto moderation embed&lt;/description&gt;
⋮----
///     &lt;/list&gt;
⋮----
///     Gets the embed&apos;s description.
⋮----
///     Gets the embed&apos;s url.
⋮----
///     Gets the embed&apos;s timestamp.
⋮----
///     Gets the embed&apos;s color.
⋮----
///     Gets the embed&apos;s footer.
⋮----
///     Gets the embed&apos;s image.
⋮----
///     Gets the embed&apos;s thumbnail.
⋮----
///     Gets the embed&apos;s video.
⋮----
///     Gets the embed&apos;s provider.
⋮----
///     Gets the embed&apos;s author.
⋮----
///     Gets the embed&apos;s fields.
⋮----
///     Gets the embed&apos;s flags.
⋮----
///     Gets the content scan version.</file><file path="DisCatSharp/Entities/Emoji/DiscordEmoji.Mapping.cs">// &lt;auto-generated&gt;
//     This file was generated by gen-emoji-mappings.ps1. Do not edit manually.
// &lt;/auto-generated&gt;
⋮----
/// &lt;summary&gt;
///     Represents discord emoji.
/// &lt;/summary&gt;
public partial class DiscordEmoji
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmoji&quot; /&gt; class.
⋮----
///     Gets a mapping of :name: =&gt; unicode.
⋮----
///     Gets a mapping of unicode =&gt; :name:.
⋮----
///     Gets a mapping of :alias_name: =&gt; :name:.</file><file path="DisCatSharp/Entities/Emoji/DiscordUnicodeEmoji.cs">// &lt;auto-generated&gt;
//     This file was generated by gen-emoji-mappings.ps1. Do not edit manually.
// &lt;/auto-generated&gt;
⋮----
/// &lt;summary&gt;
///     Represents a discord unicode emoji.
/// &lt;/summary&gt;
public class DiscordUnicodeEmoji</file><file path="DisCatSharp/Entities/Guild/DiscordMember.cs">/// &lt;summary&gt;
///     Represents a Discord guild member.
/// &lt;/summary&gt;
public class DiscordMember : DiscordUser, IEquatable&lt;DiscordMember&gt;
⋮----
///     Gets the avatar hash.
⋮----
///     Gets the guild id for this member.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMember&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;mbr&quot;&gt;The mbr.&lt;/param&gt;
⋮----
///     Gets the members avatar hash.
⋮----
///     Gets the members avatar URL.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildAvatarHash) ? this.User.AvatarUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.AVATARS}/{this.GuildAvatarHash}.{(this.GuildAvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the members banner hash.
⋮----
///     Gets the members banner URL.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.GuildBannerHash) ? this.User.BannerUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILDS}/{this.GuildId.ToString(CultureInfo.InvariantCulture)}{Endpoints.USERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}{Endpoints.BANNERS}/{this.GuildBannerHash}.{(this.GuildBannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the members guild avatar decoration data.
⋮----
///     The color of this member&apos;s banner. Mutually exclusive with &lt;see cref=&quot;GuildBannerHash&quot; /&gt;.
⋮----
///     Gets this member&apos;s nickname.
⋮----
///     Gets the members guild bio.
///     This is not available to bots tho.
⋮----
///     Gets the members&apos;s pronouns.
⋮----
///     Gets the members flags.
⋮----
///     Gets this member&apos;s display name.
⋮----
///     List of role ids
⋮----
///     Gets the list of roles associated with this member.
///     &lt;note type=&quot;warning&quot;&gt;This will throw if accessed for an oauth2 constructed member.&lt;/note&gt;
⋮----
=&gt; this.RoleIds.Select(id =&gt; this.Guild.GetRole(id)).Where(x =&gt; x is not null).ToList()!;
⋮----
///     Gets the color associated with this user&apos;s top color-giving role, otherwise 0 (no color).
⋮----
var role = this.Roles.OrderByDescending(xr =&gt; xr.Position).FirstOrDefault(xr =&gt; xr.Color.Value is not 0);
⋮----
///     Date the user joined the guild
⋮----
///     Date the user started boosting this server
⋮----
///     Date until the can communicate again.
⋮----
///     Datetime until unusual dm activity time happened.
⋮----
///     Whether the user has their communication disabled.
⋮----
=&gt; this.CommunicationDisabledUntil is not null &amp;&amp; this.CommunicationDisabledUntil.Value.ToUniversalTime() &gt; DateTime.UtcNow;
⋮----
=&gt; this.UnusualDmActivityUntil is not null &amp;&amp; this.UnusualDmActivityUntil.Value.ToUniversalTime() &gt; DateTime.UtcNow;
⋮----
///     If the user is deafened
⋮----
///     If the user is muted
⋮----
///     Whether the user has not passed the guild&apos;s Membership Screening requirements yet.
⋮----
///     Gets this member&apos;s voice state.
⋮----
=&gt; this.Discord.Guilds[this.GuildId].VoiceStates.GetValueOrDefault(this.Id);
⋮----
///     Gets the guild of which this member is a part of.
⋮----
///     Gets whether this member is the Guild owner.
⋮----
///     Gets the member&apos;s position in the role hierarchy, which is the member&apos;s highest role&apos;s position. Returns
///     &lt;see cref=&quot;int.MaxValue&quot; /&gt; for the guild&apos;s owner.
⋮----
: this.Roles.Max(x =&gt; x.Position);
⋮----
///     Gets the permissions for the current member.
⋮----
=&gt; this.InteractionPermissions ?? this.GetPermissions();
⋮----
/// &lt;inheritdoc /&gt;
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordMember&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordMember&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordMember&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordMember&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordMember&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordMember e)
⋮----
///     Sets this member&apos;s voice mute status.
⋮----
/// &lt;param name=&quot;mute&quot;&gt;Whether the member is to be muted.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.MuteMembers&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the member does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task SetMuteAsync(bool mute, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, mute, default, default, default, this.MemberFlags, reason);
⋮----
///     Manually verifies the member to bypass the Membership Screening requirements.
⋮----
public Task VerifyAsync(string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, default, default, true, this.MemberFlags, reason);
⋮----
///     Manually unverifies the member to not bypass the Membership Screening requirements anymore.
⋮----
public Task UnverifyAsync(string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, default, default, false, this.MemberFlags, reason);
⋮----
///     Sets this member&apos;s voice deaf status.
⋮----
/// &lt;param name=&quot;deaf&quot;&gt;Whether the member is to be deafened.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.DeafenMembers&quot; /&gt; permission.
⋮----
public Task SetDeafAsync(bool deaf, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.GuildId, this.Id, default, default, default, deaf, default, default, this.MemberFlags, reason);
⋮----
///     Modifies this member.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this member.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageNicknames&quot; /&gt; permission.
⋮----
public async Task ModifyAsync(Action&lt;MemberEditModel&gt; action)
⋮----
var mdl = new MemberEditModel();
⋮----
throw new ArgumentException(&quot;Given channel is not a voice or stage channel.&quot;, nameof(action));
⋮----
await this.Discord.ApiClient.ModifyCurrentMemberNicknameAsync(this.Guild.Id, mdl.Nickname.Value,
mdl.AuditLogReason).ConfigureAwait(false);
⋮----
await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, Optional.None,
mdl.Roles.Map(e =&gt; e.Select(xr =&gt; xr.Id)), mdl.Muted, mdl.Deafened,
mdl.VoiceChannel.Map(e =&gt; e?.Id), default, this.MemberFlags, mdl.AuditLogReason).ConfigureAwait(false);
⋮----
await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, mdl.Nickname,
⋮----
///     Disconnects the member from their current voice channel.
⋮----
public async Task DisconnectFromVoiceAsync()
=&gt; await this.ModifyAsync(x =&gt; x.VoiceChannel = null!).ConfigureAwait(false);
⋮----
///     Adds a timeout to a member.
⋮----
/// &lt;param name=&quot;until&quot;&gt;The datetime offset to time out the user. Up to 28 days.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ModerateMembers&quot; /&gt; permission.
⋮----
public Task TimeoutAsync(DateTimeOffset until, string? reason = null)
=&gt; until.Subtract(DateTimeOffset.UtcNow).Days &gt; 28 ? throw new ArgumentException(&quot;Timeout can not be longer than 28 days&quot;) : this.Discord.ApiClient.ModifyTimeoutAsync(this.Guild.Id, this.Id, until, reason);
⋮----
/// &lt;param name=&quot;until&quot;&gt;The timespan to time out the user. Up to 28 days.&lt;/param&gt;
⋮----
public Task TimeoutAsync(TimeSpan until, string? reason = null)
=&gt; this.TimeoutAsync(DateTimeOffset.UtcNow + until, reason);
⋮----
/// &lt;param name=&quot;until&quot;&gt;The datetime to time out the user. Up to 28 days.&lt;/param&gt;
⋮----
public Task TimeoutAsync(DateTime until, string? reason = null)
=&gt; this.TimeoutAsync(until.ToUniversalTime() - DateTime.UtcNow, reason);
⋮----
///     Removes the timeout from a member.
⋮----
public Task RemoveTimeoutAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyTimeoutAsync(this.Guild.Id, this.Id, null, reason);
⋮----
///     Grants a role to the member.
⋮----
/// &lt;param name=&quot;role&quot;&gt;Role to grant.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt;
⋮----
public Task GrantRoleAsync(DiscordRole role, string? reason = null)
=&gt; this.Discord.ApiClient.AddGuildMemberRoleAsync(this.Guild.Id, this.Id, role.Id, reason);
⋮----
///     Revokes a role from a member.
⋮----
/// &lt;param name=&quot;role&quot;&gt;Role to revoke.&lt;/param&gt;
⋮----
public Task RevokeRoleAsync(DiscordRole role, string? reason = null)
=&gt; this.Discord.ApiClient.RemoveGuildMemberRoleAsync(this.Guild.Id, this.Id, role.Id, reason);
⋮----
///     Sets the member&apos;s roles to ones specified.
⋮----
/// &lt;param name=&quot;roles&quot;&gt;Roles to set.&lt;/param&gt;
⋮----
public Task ReplaceRolesAsync(IEnumerable&lt;DiscordRole&gt; roles, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, this.Id, default,
Optional.Some(roles.Select(xr =&gt; xr.Id)), default, default, default, default, this.MemberFlags, reason);
⋮----
///     Bans this member from their guild.
⋮----
/// &lt;param name=&quot;deleteMessageDays&quot;&gt;How many days to remove messages from.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.BanMembers&quot; /&gt;
⋮----
public Task BanAsync(int deleteMessageDays = 0, string? reason = null)
=&gt; this.Guild.BanMemberAsync(this, deleteMessageDays, reason);
⋮----
///     Unbans this member from their guild.
⋮----
/// &lt;exception cref=&quot;Exceptions.UnauthorizedException&quot;&gt;
⋮----
///     &lt;see cref=&quot;Permissions.BanMembers&quot; /&gt; permission.
⋮----
public Task UnbanAsync(string? reason = null)
=&gt; this.Guild.UnbanMemberAsync(this, reason);
⋮----
///     Kicks this member from their guild.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.KickMembers&quot; /&gt;
⋮----
public Task RemoveAsync(string? reason = null)
=&gt; this.Discord.ApiClient.RemoveGuildMemberAsync(this.GuildId, this.Id, reason);
⋮----
///     Moves this member to the specified voice channel
⋮----
/// &lt;param name=&quot;channel&quot;&gt;&lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.MoveMembers&quot; /&gt;
⋮----
public Task PlaceInAsync(DiscordChannel channel)
=&gt; channel.PlaceMemberAsync(this);
⋮----
///     Gets the member&apos;s voice state.
⋮----
public async Task&lt;DiscordVoiceState?&gt; GetVoiceStateAsync()
=&gt; await this.Discord.ApiClient.GetMemberVoiceStateAsync(this.Guild.Id, this.Id);
⋮----
///     Updates the member&apos;s suppress state in a stage channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel the member is currently in.&lt;/param&gt;
/// &lt;param name=&quot;suppress&quot;&gt;Toggles the member&apos;s suppress state.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the channel in not a voice channel.&lt;/exception&gt;
public async Task UpdateVoiceStateAsync(DiscordChannel channel, bool? suppress)
⋮----
throw new ArgumentException(&quot;Voice state can only be updated in a stage channel.&quot;);
⋮----
await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, channel.Id, suppress).ConfigureAwait(false);
⋮----
///     Makes the user a speaker.
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the user is not inside an stage channel.&lt;/exception&gt;
⋮----
public async Task MakeSpeakerAsync()
⋮----
throw new ArgumentException(&quot;Voice state can only be updated when the user is inside an stage channel.&quot;);
⋮----
await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, vs.Channel.Id, false).ConfigureAwait(false);
⋮----
///     Moves the user to audience.
⋮----
public async Task MoveToAudienceAsync()
⋮----
await this.Discord.ApiClient.UpdateUserVoiceStateAsync(this.Guild.Id, this.Id, vs.Channel.Id, true).ConfigureAwait(false);
⋮----
///     Calculates permissions in a given channel for this member.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to calculate permissions for.&lt;/param&gt;
/// &lt;returns&gt;Calculated permissions for this member in the channel.&lt;/returns&gt;
public Permissions PermissionsIn(DiscordChannel channel)
=&gt; channel.PermissionsFor(this);
⋮----
///     Get&apos;s the current member&apos;s roles based on the sum of the permissions of their given roles.
⋮----
private Permissions GetPermissions()
⋮----
// assign @everyone permissions
⋮----
// assign permissions from member&apos;s roles (in order)
perms |= this.Roles.Aggregate(Permissions.None, (c, role) =&gt; c | role.Permissions);
⋮----
// Administrator grants all permissions and cannot be overridden
⋮----
///     Returns a string representation of this member.
⋮----
/// &lt;returns&gt;String representation of this member.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordMember&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordMember&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordMember);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordMember&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordMember&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
⋮----
hash = (hash * 7) + this.Id.GetHashCode();
hash = (hash * 7) + this.GuildId.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordMember&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First member to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second member to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two members are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordMember&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two members are not equal.&lt;/returns&gt;
⋮----
///     Gets the user.
⋮----
=&gt; this.Discord?.UserCache.TryGetValue(this.Id, out var user) ?? false ? user : this.ManualUser;
⋮----
///     Sets the user when converting a json object to &lt;see cref=&quot;DiscordMember&quot; /&gt; while not having access to the user
///     cache.
⋮----
///     Gets this member&apos;s username.
⋮----
///     Gets the member&apos;s 4-digit discriminator.
⋮----
///     Gets the member&apos;s username with discriminator.
⋮----
///     Gets the member&apos;s username with global name.
⋮----
///     Gets the member&apos;s global name.
⋮----
///     Gets the member&apos;s user avatar hash.
⋮----
///     Gets the member&apos;s user banner hash.
⋮----
///     Gets the member&apos;s user avatar decoration data.
⋮----
///     Gets the member&apos;s primary guild.
⋮----
///     Gets whether the member is a bot.
⋮----
///     &lt;para&gt;Whether this user account is migrated to the new username system.&lt;/para&gt;
///     &lt;para&gt;Learn more at &lt;see href=&quot;https://dis.gd/usernames&quot;&gt;dis.gd/usernames&lt;/see&gt;.&lt;/para&gt;
⋮----
///     Gets whether the member is an official Discord system user.
⋮----
///     Gets the member&apos;s email address.
///     &lt;para&gt;This is only present in OAuth.&lt;/para&gt;
⋮----
///     Gets whether the member has multi-factor authentication enabled.
⋮----
///     Gets whether the member is verified.
⋮----
///     Gets the member&apos;s chosen language
⋮----
///     Gets the user&apos;s flags.
⋮----
///     Gets the member&apos;s flags for OAuth.</file><file path="DisCatSharp/Entities/Guild/DiscordRole.cs">/// &lt;summary&gt;
///     Represents a discord role, to which users can be assigned.
/// &lt;/summary&gt;
public sealed class DiscordRole : SnowflakeObject, IEquatable&lt;DiscordRole&gt;
⋮----
///     Gets the role unicode_emoji.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordRole&quot; /&gt; class.
⋮----
///     Gets the name of this role.
⋮----
///     Gets the version number for this role.
⋮----
///     Gets the description of this role.
⋮----
///     Gets the color of this role.
⋮----
///     Gets whether this role is hoisted.
⋮----
///     Gets the position of this role in the role hierarchy.
⋮----
///     Gets the permissions set for this role.
⋮----
///     Gets whether this role is managed by an integration.
⋮----
///     Gets whether this role is mentionable.
⋮----
///     Gets the tags this role has.
⋮----
///     Determines the type of role based on its tags.
⋮----
///     Gets the role icon&apos;s hash.
⋮----
///     Gets the role icon&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ROLE_ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.png?size=64&quot; : null;
⋮----
///     Gets the unicode emoji.
⋮----
=&gt; this.UnicodeEmojiString != null ? DiscordEmoji.FromName(this.Discord, $&quot;:{this.UnicodeEmojiString}:&quot;, false) : null;
⋮----
///     Gets the guild this role belongs to.
⋮----
///     Gets the role flags.
⋮----
/// Gets the role colors.
⋮----
///     Gets a mention string for this role. If the role is mentionable, this string will mention all the users that belong
///     to this role.
⋮----
=&gt; this.Mention();
⋮----
///     Gets a list of members that have this role. Requires ServerMembers Intent.
⋮----
=&gt; this.Guild.Members.Where(x =&gt; x.Value.RoleIds.Any(x =&gt; x == this.Id)).ToList();
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordRole&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordRole&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordRole&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordRole&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordRole&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordRole e)
⋮----
///     Checks whether this role has specific permissions.
⋮----
/// &lt;param name=&quot;permission&quot;&gt;Permissions to check for.&lt;/param&gt;
/// &lt;returns&gt;Whether the permissions are allowed or not.&lt;/returns&gt;
public PermissionLevel CheckPermission(Permissions permission)
⋮----
///     Returns a string representation of this role.
⋮----
/// &lt;returns&gt;String representation of this role.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordRole&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordRole&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordRole);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordRole&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordRole&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordRole&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First role to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second role to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two roles are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordRole&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two roles are not equal.&lt;/returns&gt;
⋮----
///     Modifies this role&apos;s position.
⋮----
/// &lt;param name=&quot;position&quot;&gt;New position&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason why we moved it&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the role does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task ModifyPositionAsync(int position, string? reason = null)
⋮----
var roles = this.Guild.Roles.Values.OrderByDescending(xr =&gt; xr.Position)
.Select(x =&gt; new RestGuildRoleReorderPayload
⋮----
return this.Discord.ApiClient.ModifyGuildRolePositionAsync(this.GuildId, roles, reason);
⋮----
///     Updates this role.
⋮----
/// &lt;param name=&quot;name&quot;&gt;New role name.&lt;/param&gt;
/// &lt;param name=&quot;permissions&quot;&gt;New role permissions.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;New role color.&lt;/param&gt;
/// &lt;param name=&quot;hoist&quot;&gt;New role hoist.&lt;/param&gt;
/// &lt;param name=&quot;mentionable&quot;&gt;Whether this role is mentionable.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Audit log reason.&lt;/param&gt;
⋮----
public Task ModifyAsync(string name = null, Permissions? permissions = null, DiscordColor? color = null, bool? hoist = null, bool? mentionable = null, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildRoleAsync(this.GuildId, this.Id, name, permissions, color?.Value, null, hoist, mentionable, Optional.None, Optional.None, reason);
⋮----
/// &lt;param name=&quot;action&quot;&gt;The action.&lt;/param&gt;
/// &lt;exception cref=&quot;Exceptions.UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt; permission.
⋮----
public Task ModifyAsync(Action&lt;RoleEditModel&gt; action)
⋮----
var mdl = new RoleEditModel();
⋮----
canContinue = this.Guild.Features.HasFeature(GuildFeaturesEnum.CanSetRoleIcons);
⋮----
true when mdl.Icon.Value != null =&gt; MediaTool.Base64FromStream(mdl.Icon),
⋮----
.MapOrNull(e =&gt; e.Id == 0
⋮----
: throw new ArgumentException(&quot;Emoji must be unicode&quot;));
⋮----
throw new ArgumentException(&quot;When using a holographic role style, the following colors must be set: primary (11127295), secondary (16759788) &amp; tertiary (16761760). It cannot be any other value&quot;);
⋮----
return canContinue ? this.Discord.ApiClient.ModifyGuildRoleAsync(this.GuildId, this.Id, mdl.Name, mdl.Permissions, mdl.Color?.Value, mdl.Colors, mdl.Hoist, mdl.Mentionable, iconb64, emoji, mdl.AuditLogReason) : throw new NotSupportedException(&quot;Cannot modify role icon. Guild needs boost tier two.&quot;);
⋮----
///     Deletes this role.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason as to why this role has been deleted.&lt;/param&gt;
⋮----
public Task DeleteAsync(string? reason = null)
=&gt; this.Discord.ApiClient.DeleteRoleAsync(this.GuildId, this.Id, reason);
⋮----
///     Represents a role&apos;s colors.
⋮----
public sealed class DiscordRoleColors
⋮----
///     Gets the primary color. Is the same as &lt;see cref=&quot;DiscordRole.Color&quot; /&gt;.
⋮----
///     Gets the secondary color. Uses for gradient style.
⋮----
///     Gets the tertiary color. This only applies to the &lt;c&gt;holographic&lt;/c&gt; role style and must have the value
///     &lt;c&gt;16761760&lt;/c&gt;.</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPrompt.cs">/// &lt;summary&gt;
///     Represents an onboarding prompt.
/// &lt;/summary&gt;
public sealed class DiscordOnboardingPrompt : SnowflakeObject
⋮----
///     Constructs a new onboarding prompt.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The prompt ID. Starts at &lt;c&gt;0&lt;/c&gt; unless provided by Discord.&lt;/param&gt;
/// &lt;param name=&quot;title&quot;&gt;The prompt title.&lt;/param&gt;
/// &lt;param name=&quot;options&quot;&gt;The prompt options.&lt;/param&gt;
/// &lt;param name=&quot;singleSelect&quot;&gt;Whether the prompt is single select. Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether the prompt is required. Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;inOnboarding&quot;&gt;Whether the prompt is shown in onboarding. Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The prompt type. Defaults to &lt;see cref=&quot;PromptType.MultipleChoice&quot; /&gt;.&lt;/param&gt;
⋮----
///     Gets the title.
⋮----
///     Gets the prompt options.
⋮----
///     Gets whether the prompt is single select.
⋮----
///     Gets whether the prompt is required.
⋮----
///     Gets whether the prompt is shown on join in the onboarding.
⋮----
///     Gets the prompt time.</file><file path="DisCatSharp/Entities/Guild/ThreadAndForum/ForumPostTag.cs">/// &lt;summary&gt;
///     Represents a discord forum post tag.
/// &lt;/summary&gt;
public class ForumPostTag : NullableSnowflakeObject, IEquatable&lt;ForumPostTag&gt;
⋮----
///     Gets the channel this tag belongs to.
⋮----
internal DiscordChannel Channel;
⋮----
///     Gets the channel id this tag belongs to.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ForumPostTag&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The tags name.&lt;/param&gt;
/// &lt;param name=&quot;emojiId&quot;&gt;The tags emoji id. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;emojiName&quot;&gt;The tags emoji name (unicode emoji). Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;moderated&quot;&gt;Whether this tag can only be applied by moderators. Defaults to &lt;see langword=&quot;false&quot; /&gt;.&lt;/param&gt;
⋮----
///     Gets the name of this forum post tag.
⋮----
///     Gets the emoji id of the forum post tag.
⋮----
///     Gets the unicode emoji of the forum post tag.
⋮----
///     Gets whether the tag can only be used by moderators.
⋮----
///     Gets the emoji.
⋮----
=&gt; this.UnicodeEmojiString != null ? DiscordEmoji.FromName(this.Discord, $&quot;:{this.UnicodeEmojiString}:&quot;, false) : DiscordEmoji.FromGuildEmote(this.Discord, this.EmojiId.Value);
⋮----
///     Checks whether this &lt;see cref=&quot;ForumPostTag&quot; /&gt; is equal to another &lt;see cref=&quot;ForumPostTag&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;ForumPostTag&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;ForumPostTag&quot; /&gt; is equal to this &lt;see cref=&quot;ForumPostTag&quot; /&gt;.&lt;/returns&gt;
public bool Equals(ForumPostTag e)
⋮----
///     Modifies the tag.
⋮----
/// &lt;exception cref=&quot;NotImplementedException&quot;&gt;This method is currently not implemented.&lt;/exception&gt;
public async Task&lt;ForumPostTag&gt; ModifyAsync(Action&lt;ForumPostTagEditModel&gt; action)
⋮----
var mdl = new ForumPostTagEditModel();
⋮----
var res = await this.Discord.ApiClient.ModifyForumChannelAsync(this.ChannelId, null, null, null, null, null, null, this.Channel.InternalAvailableTags.Where(x =&gt; x.Id != this.Id).ToList().Append(new()
⋮----
}).ToList(), null, null, null, null, null, null, null, null, null, mdl.AuditLogReason);
return res.InternalAvailableTags.First(x =&gt; x.Id == this.Id);
⋮----
///     Deletes the tag.
⋮----
public Task DeleteAsync(string reason = null)
=&gt; this.Discord.ApiClient.ModifyForumChannelAsync(this.ChannelId, null, null, null, null, null, null, this.Channel.InternalAvailableTags.Where(x =&gt; x.Id != this.Id).ToList(), null, null, null, null, null, null, null, null, null, reason);
⋮----
///     Checks whether this &lt;see cref=&quot;ForumPostTag&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;ForumPostTag&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as ForumPostTag);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;ForumPostTag&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;ForumPostTag&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;ForumPostTag&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First forum post tag to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second forum post tag to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two forum post tags are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordEmoji&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two forum post tags are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Entities/Interaction/Components/Button/DiscordButtonComponent.cs">/// &lt;summary&gt;
///     Represents a button that can be pressed. Fires &lt;see cref=&quot;DisCatSharp.DiscordClient.ComponentInteractionCreated&quot; /&gt;
///     event when pressed.
/// &lt;/summary&gt;
public sealed class DiscordButtonComponent : DiscordBaseButtonComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordButtonComponent&quot; /&gt;.
⋮----
///     Constructs a new button based on another button.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The button to copy.&lt;/param&gt;
⋮----
///     Constructs a new button with the specified options.
⋮----
/// &lt;param name=&quot;style&quot;&gt;The style/color of the button.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the button. This is sent back when a user presses it.&lt;/param&gt;
/// &lt;param name=&quot;label&quot;&gt;
///     The text to display on the button, up to 80 characters. Can be left blank if
///     &lt;paramref name=&quot;emoji&quot; /&gt;is set.
/// &lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this button should be initialized as being disabled. User sees a greyed out button that
///     cannot be interacted with.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to add to the button. This is required if &lt;paramref name=&quot;label&quot; /&gt; is empty or null.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Is thrown when neither the &lt;paramref name=&quot;emoji&quot; /&gt; nor the
///     &lt;paramref name=&quot;label&quot; /&gt; is set.
/// &lt;/exception&gt;
⋮----
throw new InvalidEnumArgumentException(&quot;Can not use link or premium style on this type of button&quot;);
⋮----
this.CustomId = customId ?? Guid.NewGuid().ToString();
⋮----
this.Label = label ?? throw new ArgumentException(&quot;Label can only be null if emoji is set.&quot;);
⋮----
///     The style of the button.
⋮----
///     The text to apply to the button. If this is not specified &lt;see cref=&quot;Emoji&quot; /&gt; becomes required.
⋮----
///     Whether this button can be pressed.
⋮----
///     The emoji to add to the button. Can be used in conjunction with a label, or as standalone. Must be added if label
///     is not specified.
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordButtonComponent Enable()
=&gt; this.SetState(false);
⋮----
///     Disables this component.
⋮----
public DiscordButtonComponent Disable()
=&gt; this.SetState(true);
⋮----
///     Enables or disables this component.
⋮----
/// &lt;param name=&quot;disabled&quot;&gt;Whether this component should be disabled.&lt;/param&gt;
⋮----
public DiscordButtonComponent SetState(bool disabled)
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordButtonComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/DiscordActionRowComponent.cs">/// &lt;summary&gt;
///     &lt;para&gt;Represents an action row holding interactable components like &lt;see cref=&quot;DiscordButtonComponent&quot; /&gt; and &lt;see cref=&quot;DiscordBaseSelectComponent&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;Can hold up to 5 components.&lt;/para&gt;
/// &lt;/summary&gt;
public sealed class DiscordActionRowComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordActionRowComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;components&quot;&gt;List of components&lt;/param&gt;
⋮----
this.Components = components.ToList().AsReadOnly();
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordActionRowComponent&quot; /&gt; class.
⋮----
///     The components contained within the action row.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordActionRowComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordFileDisplayComponent.cs">/// &lt;summary&gt;
///     Represents a file display component.
/// &lt;/summary&gt;
public sealed class DiscordFileDisplayComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordFileDisplayComponent&quot; /&gt;.
⋮----
///     Constructs a new file display component based on another file display component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The file display component to copy.&lt;/param&gt;
⋮----
///     Constructs a new file display component field with the specified options.
⋮----
/// &lt;param name=&quot;url&quot;&gt;The file url. Only supports attachments (&lt;c&gt;attachment://&lt;/c&gt;).&lt;/param&gt;
/// &lt;param name=&quot;spoiler&quot;&gt;Whether this file should be marked as spoiler.&lt;/param&gt;
⋮----
ArgumentException.ThrowIfNullOrEmpty(url);
if (!url.StartsWith(&quot;attachment://&quot;, StringComparison.Ordinal))
throw new ArgumentException(&quot;File URL must start with &apos;attachment://&apos;.&quot;, nameof(url));
⋮----
///     Gets the file.
⋮----
///     Gets the file size.
⋮----
///     Gets the file name.
⋮----
///     Gets whether this file should be marked as spoiler.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordFileDisplayComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/ILabelComponent.cs">/// &lt;summary&gt;
///     Represents a (potential) label component.
/// &lt;/summary&gt;</file><file path="DisCatSharp/Entities/Interaction/DiscordInteraction.cs">/// &lt;summary&gt;
///     Represents an interaction that was invoked.
/// &lt;/summary&gt;
public sealed class DiscordInteraction : SnowflakeObject
⋮----
///     Gets the type of interaction invoked.
⋮----
///     Gets the command data for this interaction.
⋮----
///     Gets the ID of the guild that invoked this interaction, if any.
⋮----
///     Gets the guild that invoked this interaction.
⋮----
///     Gets the partial guild from the interaction.
⋮----
///     Gets the ID of the channel that invoked this interaction.
⋮----
///     Gets the channel that invoked this interaction.
⋮----
[JsonIgnore] // TODO: Is now also partial &quot;channel&quot;
⋮----
=&gt; (this.Discord as DiscordClient).InternalGetCachedChannel(this.ChannelId) ?? (DiscordChannel)(this.Discord as DiscordClient).InternalGetCachedThread(this.ChannelId) ?? (this.Guild is null
? new DiscordDmChannel
⋮----
: new DiscordChannel
⋮----
///     Gets the user that invoked this interaction.
///     &lt;para&gt;This can be cast to a &lt;see cref=&quot;DisCatSharp.Entities.DiscordMember&quot; /&gt; if created in a guild.&lt;/para&gt;
⋮----
///     Gets the continuation token for responding to this interaction.
⋮----
///     Gets the version number for this interaction type.
⋮----
///     Gets the ID of the application that created this interaction.
⋮----
///     The message this interaction was created with, if any.
⋮----
///     Gets the invoking user locale.
⋮----
///     Gets the guild locale if applicable.
⋮----
///     Gets the attachment size limit in bytes.
⋮----
///     Gets the applications permissions.
⋮----
///     &lt;para&gt;Gets the entitlements.&lt;/para&gt;
⋮----
///     Gets which integrations authorized the interaction.
⋮----
///     Gets the interaction&apos;s calling context.
⋮----
///     Creates a response to this interaction.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type of the response.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The data, if any, to send.&lt;/param&gt;
/// &lt;param name=&quot;modifyMode&quot;&gt;The modify mode. Only useful for &lt;see cref=&quot;InteractionResponseType.UpdateMessage&quot;/&gt;.&lt;/param&gt;
/// &lt;returns&gt;
///     The created &lt;see cref=&quot;DiscordMessage&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if &lt;paramref name=&quot;type&quot; /&gt; creates no
///     content.
/// &lt;/returns&gt;
public async Task&lt;DiscordInteractionCallbackResponse&gt; CreateResponseAsync(InteractionResponseType type, DiscordInteractionResponseBuilder? builder = null, ModifyMode modifyMode = ModifyMode.Update)
⋮----
builder.DoConditionalReplace();
return await this.Discord.ApiClient.CreateInteractionResponseAsync(this.Id, this.Token, type, builder);
⋮----
///     Creates a modal response to this interaction.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The data to send.&lt;/param&gt;
public Task CreateInteractionModalResponseAsync(DiscordInteractionModalBuilder builder)
=&gt; this.Type is not InteractionType.Ping &amp;&amp; this.Type is not InteractionType.ModalSubmit ? this.Discord.ApiClient.CreateInteractionModalResponseAsync(this.Id, this.Token, InteractionResponseType.Modal, builder) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with a modal.&quot;);
⋮----
///     Creates an iframe response to this interaction.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;title&quot;&gt;The title of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;modalSize&quot;&gt;The size of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;iFramePath&quot;&gt;The path of the iframe. Uses %application_id%.discordsays.com/&lt;c&gt;:iframe_path&lt;/c&gt;.&lt;/param&gt;
public Task CreateInteractionIframeResponseAsync(string customId, string title, IframeModalSize modalSize = IframeModalSize.Normal, string? iFramePath = null)
=&gt; this.Type is not InteractionType.Ping ? this.Discord.ApiClient.CreateInteractionIframeResponseAsync(this.Id, this.Token, InteractionResponseType.Iframe, customId, title, modalSize, iFramePath) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with an iframe.&quot;);
⋮----
///     Gets the original interaction response.
⋮----
/// &lt;returns&gt;The original message that was sent. This &lt;b&gt;does not work on ephemeral messages.&lt;/b&gt;&lt;/returns&gt;
public Task&lt;DiscordMessage&gt; GetOriginalResponseAsync()
=&gt; this.Discord.ApiClient.GetOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token);
⋮----
///     Edits the original interaction response.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The webhook builder.&lt;/param&gt;
/// &lt;param name=&quot;modifyMode&quot;&gt;The modify mode.&lt;/param&gt;
/// &lt;returns&gt;The edited &lt;see cref=&quot;DiscordMessage&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;DiscordMessage&gt; EditOriginalResponseAsync(DiscordWebhookBuilder builder, ModifyMode modifyMode = ModifyMode.Update)
⋮----
// TODO: This might not work if i.e. the original response was deferred and edited.
⋮----
builder.Validate(isInteractionResponse: true);
⋮----
var attachments = this.Discord.ApiClient.GetOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token).Result.Attachments;
⋮----
builder.AttachmentsInternal.AddRange(attachments);
⋮----
return await this.Discord.ApiClient.EditOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token, builder).ConfigureAwait(false);
⋮----
///     Deletes the original interaction response.
⋮----
/// &gt;
public Task DeleteOriginalResponseAsync()
=&gt; this.Discord.ApiClient.DeleteOriginalInteractionResponseAsync(this.Discord.CurrentApplication.Id, this.Token);
⋮----
///     Creates a follow-up message to this interaction.
⋮----
/// &lt;returns&gt;The created &lt;see cref=&quot;DiscordMessage&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;DiscordMessage&gt; CreateFollowupMessageAsync(DiscordFollowupMessageBuilder builder)
⋮----
builder.Validate();
⋮----
return await this.Discord.ApiClient.CreateFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, builder).ConfigureAwait(false);
⋮----
///     Gets a follow-up message.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The id of the follow-up message.&lt;/param&gt;
public Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong messageId)
=&gt; this.Discord.ApiClient.GetFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId);
⋮----
///     Edits a follow-up message.
⋮----
public async Task&lt;DiscordMessage&gt; EditFollowupMessageAsync(ulong messageId, DiscordWebhookBuilder builder, ModifyMode modifyMode = ModifyMode.Update)
⋮----
builder.MentionsInternal ??= this.GetFollowupMessageAsync(messageId).Result.GetMentions();
builder.Validate(isFollowup: true);
⋮----
var attachments = this.Discord.ApiClient.GetFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId).Result.Attachments;
⋮----
return await this.Discord.ApiClient.EditFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId, builder).ConfigureAwait(false);
⋮----
///     Deletes a follow-up message.
⋮----
public Task DeleteFollowupMessageAsync(ulong messageId)
=&gt; this.Discord.ApiClient.DeleteFollowupMessageAsync(this.Discord.CurrentApplication.Id, this.Token, messageId);</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionData.cs">/// &lt;summary&gt;
///     Represents the inner data payload of a &lt;see cref=&quot;DiscordInteraction&quot; /&gt;.
/// &lt;/summary&gt;
public sealed class DiscordInteractionData : SnowflakeObject
⋮----
///     Gets the name of the invoked interaction.
⋮----
///     Gets the parameters and values of the invoked interaction.
⋮----
///     Gets the submitted modal components.
⋮----
///     &lt;para&gt;
///         If you want to get the components, use &lt;see cref=&quot;DiscordInteraction&quot; /&gt;.
///         &lt;see cref=&quot;DiscordInteraction.Message&quot; /&gt;.&lt;see cref=&quot;DiscordMessage.Components&quot; /&gt; instead.
///     &lt;/para&gt;
⋮----
.SelectMany(x =&gt; x.Components.OfType&lt;DiscordTextInputComponent&gt;())
.ToList()
.AsReadOnly();
⋮----
///     Gets the Discord snowflake objects resolved from this interaction&apos;s arguments.
⋮----
///     The Id of the component that invoked this interaction, if applicable.
⋮----
///     The Id of the target. Applicable for context menus.
⋮----
///     The type of component that invoked this interaction, if applicable.
⋮----
///     Gets the values of the interaction.
⋮----
///     Gets the type of the interaction.
⋮----
///     Gets the Id of the guild this interaction was invoked in, if any.</file><file path="DisCatSharp/Entities/Message/DiscordAttachment.cs">/// &lt;summary&gt;
///     Represents an attachment for a message.
/// &lt;/summary&gt;
public class DiscordAttachment : NullableSnowflakeObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordAttachment&quot; /&gt; class.
⋮----
///     Gets the name of the file.
⋮----
///     Gets the title of the file.
⋮----
///     Gets the description of the file.
⋮----
///     Gets the media, or MIME, type of the file.
⋮----
///     Gets the categorized media type of the file.
⋮----
return !string.IsNullOrWhiteSpace(this.Filename) &amp;&amp; this.Filename.Equals(&quot;voice_message.ogg&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; GetMediaTypeFromContentType(this.ContentType) is MediaType.Audio
⋮----
///     Gets the high-level Discord media type category of the file.
⋮----
/// 	Gets the media type of the file as a string.
⋮----
/// &lt;param name=&quot;contentType&quot;&gt;The content type of the file.&lt;/param&gt;
/// &lt;returns&gt;The media type of the file.&lt;/returns&gt;
private static MediaType GetMediaTypeFromContentType(string? contentType)
⋮----
if (string.IsNullOrWhiteSpace(contentType))
⋮----
var slash = contentType.IndexOf(&apos;/&apos;);
⋮----
var type = contentType[..slash].ToLowerInvariant();
⋮----
///     Gets the file size in bytes.
⋮----
///     Gets the URL of the file.
⋮----
///     Gets the proxied URL of the file.
⋮----
///     Gets the height. Applicable only if the attachment is an image.
⋮----
///     Gets the width. Applicable only if the attachment is an image.
⋮----
///     Gets the uploaded filename if the attachment was uploaded via GCP.
⋮----
///     Gets whether this attachment is ephemeral.
///     Ephemeral attachments will automatically be removed after a set period of time.
///     Ephemeral attachments on messages are guaranteed to be available as long as the message itself exists.
⋮----
///     &lt;para&gt;The duration in seconds of the audio file (currently only for voice messages).&lt;/para&gt;
///     &lt;para&gt;
///         Only presented when the message flags include &lt;see cref=&quot;MessageFlags.IsVoiceMessage&quot; /&gt; and for the attached
///         voice message.
///     &lt;/para&gt;
⋮----
///     &lt;para&gt;The base64 encoded byte-array representing a sampled waveform (currently only for voice messages).&lt;/para&gt;
⋮----
///     Gets the attachment flags.
⋮----
///     Gets the placeholder.
⋮----
///     Gets the placeholder version.
⋮----
///     Gets the loading state.
⋮----
///     Gets the clip participant, if applicable.
⋮----
=&gt; this.ClipParticipantsInternal?.Select(part =&gt; new DiscordUser(part)).ToList();
⋮----
///     Gets the clip&apos;s creation timestamp.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.ClipCreatedAtRaw) &amp;&amp; DateTimeOffset.TryParse(this.ClipCreatedAtRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the clip&apos;s creation timestamp as raw string.
⋮----
///     Gets the clip application, if applicable and recognized.
⋮----
=&gt; this.ApplicationInternal is not null ? new DiscordApplication(this.ApplicationInternal) : null;
⋮----
///     Visualizes the &lt;see cref=&quot;WaveForm&quot; /&gt; as image.
⋮----
/// &lt;param name=&quot;colorful&quot;&gt;Whether to use a colorful image. Defaults to &lt;see langword=&quot;true&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;
///     A waveform visualizer object, or &lt;see langword=&quot;nulL&quot; /&gt; if &lt;see cref=&quot;WaveForm&quot; /&gt; is &lt;see langword=&quot;nulL&quot; /&gt;
///     .
/// &lt;/returns&gt;
public WaveformVisualizer? VisualizeWaveForm(bool colorful = true)
⋮----
? new WaveformVisualizer().WithWaveformByteData(this.WaveForm).CreateColorfulWaveformImage()
: new WaveformVisualizer().WithWaveformByteData(this.WaveForm).CreateWaveformImage()</file><file path="DisCatSharp/Entities/Message/DiscordUnfurledMedia.cs">/// &lt;summary&gt;
///     Represents a unfurled media.
/// &lt;/summary&gt;
public class DiscordUnfurledMedia : ObservableApiObject
⋮----
///     Constructs a new empty &lt;see cref=&quot;DiscordUnfurledMedia&quot; /&gt;.
⋮----
///     Gets the URL of the unfurled media.
⋮----
///     Gets the proxied URL of the unfurled media.
⋮----
///     Gets the media, or MIME, type of the unfurled media.
⋮----
///     Gets the height, if applicable.
⋮----
///     Gets the width, if applicable.
⋮----
///     Gets the flags.
⋮----
///     Gets the placeholder.
⋮----
///     Gets the placeholder version.
⋮----
///     Gets the loading state.
⋮----
/// 	Gets the attachment id when uploaded and referenced through &lt;c&gt;attachment://&lt;/c&gt;.</file><file path="DisCatSharp/Entities/Optional.cs">/// &lt;summary&gt;
///     Helper methods for instantiating an &lt;see cref=&quot;Optional{T}&quot; /&gt;.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
///     This class only serves to provide &lt;see cref=&quot;Some{T}&quot; /&gt; and &lt;see cref=&quot;None&quot; /&gt;
///     as utility that supports type inference.
/// &lt;/remarks&gt;
public static class Optional
⋮----
///     Provided for easy creation of empty &lt;see cref=&quot;Optional{T}&quot; /&gt;s.
⋮----
public static readonly None None = new();
⋮----
///     Creates a new &lt;see cref=&quot;Optional{T}&quot; /&gt; with specified value and valid state.
⋮----
/// &lt;param name=&quot;value&quot;&gt;Value to populate the optional with.&lt;/param&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of the value.&lt;/typeparam&gt;
/// &lt;returns&gt;Created optional.&lt;/returns&gt;
public static Optional&lt;T&gt; Some&lt;T&gt;(T value)
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
/// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
⋮----
public static Optional&lt;T?&gt; FromNullable&lt;T&gt;([AllowNull] T? value)
⋮----
///     Unit type for creating an empty &lt;see cref=&quot;Optional{T}&quot; /&gt;s.
⋮----
///     Used internally to make serialization more convenient, do NOT change this, do NOT implement this yourself.
⋮----
public interface IOptional
⋮----
///     Gets a whether it has a value.
⋮----
///     Gets the raw value.
⋮----
///     Must NOT throw InvalidOperationException.
⋮----
///     Represents a wrapper which may or may not have a value.
⋮----
///     Static empty &lt;see cref=&quot;Optional&quot; /&gt;.
⋮----
///     Gets whether this &lt;see cref=&quot;Optional{T}&quot; /&gt; has a value.
⋮----
///     Gets the value of this &lt;see cref=&quot;Optional{T}&quot; /&gt;.
⋮----
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;If this &lt;see cref=&quot;Optional{T}&quot; /&gt; has no value.&lt;/exception&gt;
public T Value =&gt; this.HasValue ? this._val : throw new InvalidOperationException(&quot;Value is not set.&quot;);
⋮----
private readonly T _val;
⋮----
///     Creates a new &lt;see cref=&quot;Optional{T}&quot; /&gt; with specified value.
⋮----
/// &lt;param name=&quot;value&quot;&gt;Value of this option.&lt;/param&gt;
⋮----
///     Performs a mapping operation on the current &lt;see cref=&quot;Optional{T}&quot; /&gt;, turning it into an Optional holding a
///     &lt;typeparamref name=&quot;TOut&quot; /&gt; instance if the source optional contains a value; otherwise, returns an
///     &lt;see cref=&quot;Optional{T}&quot; /&gt; of that same type with no value.
⋮----
/// &lt;param name=&quot;mapper&quot;&gt;The mapping function to apply on the current value if it exists&lt;/param&gt;
/// &lt;typeparam name=&quot;TOut&quot;&gt;The type of the target value returned by &lt;paramref name=&quot;mapper&quot; /&gt;&lt;/typeparam&gt;
/// &lt;returns&gt;
///     An &lt;see cref=&quot;Optional{T}&quot; /&gt; containing a value denoted by calling &lt;paramref name=&quot;mapper&quot; /&gt; if the current
///     &lt;see cref=&quot;Optional{T}&quot; /&gt; contains a value; otherwise, an empty &lt;see cref=&quot;Optional{T}&quot; /&gt; of the target
///     type.
/// &lt;/returns&gt;
public Optional&lt;TOut&gt; Map&lt;TOut&gt;(Func&lt;T, TOut&gt; mapper)
⋮----
///     Maps to &lt;see cref=&quot;None&quot; /&gt; for &lt;see cref=&quot;None&quot; /&gt;, to &lt;code&gt;default&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; and to the
///     mapped value otherwise./&gt;
⋮----
/// &lt;typeparam name=&quot;TOut&quot;&gt;The type to map to.&lt;/typeparam&gt;
/// &lt;param name=&quot;mapper&quot;&gt;The function that does the mapping of the non-null &lt;typeparamref name=&quot;T&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;The mapped value.&lt;/returns&gt;
public Optional&lt;TOut&gt; MapOrNull&lt;TOut&gt;(Func&lt;T, TOut&gt; mapper)
⋮----
///     Gets the value of the &lt;see cref=&quot;Optional{T}&quot; /&gt; or a specified value, if the &lt;see cref=&quot;Optional{T}&quot; /&gt; has no
///     value.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The value to return if this has no value.&lt;/param&gt;
/// &lt;returns&gt;Either the value of the &lt;see cref=&quot;Optional{T}&quot; /&gt; if present or the provided value.&lt;/returns&gt;
public T ValueOr(T other)
⋮----
///     Gets the value of the &lt;see cref=&quot;Optional{T}&quot; /&gt; or the default value for &lt;typeparamref name=&quot;T&quot; /&gt;, if the
///     &lt;see cref=&quot;Optional{T}&quot; /&gt; has no value.
⋮----
/// &lt;returns&gt;Either the value of the &lt;see cref=&quot;Optional{T}&quot; /&gt; if present or the type&apos;s default value.&lt;/returns&gt;
public T ValueOrDefault()
=&gt; this.ValueOr(default);
⋮----
///     Gets the &lt;see cref=&quot;Optional&quot; /&gt;&apos;s value, or throws the provided exception if it&apos;s empty.
⋮----
/// &lt;param name=&quot;err&quot;&gt;The exception to throw if the optional is empty.&lt;/param&gt;
/// &lt;returns&gt;The value of the &lt;see cref=&quot;Optional&quot; /&gt;, if present.&lt;/returns&gt;
public T Expect(Exception err)
⋮----
///     Gets the &lt;see cref=&quot;Optional&quot; /&gt;&apos;s value, or throws a standard exception with the provided string if it&apos;s
///     empty.
⋮----
/// &lt;param name=&quot;str&quot;&gt;The string provided to the exception.&lt;/param&gt;
⋮----
public T Expect(string str) =&gt; this.Expect(new InvalidOperationException(str));
⋮----
///     Checks if this has a value and tests the predicate if it does.
⋮----
/// &lt;param name=&quot;predicate&quot;&gt;The predicate to test if this has a value.&lt;/param&gt;
/// &lt;returns&gt;True if this has a value and the predicate is fulfilled, false otherwise.&lt;/returns&gt;
public bool HasValueAnd(Predicate&lt;T&gt; predicate)
⋮----
///     Returns a string representation of this optional value.
⋮----
/// &lt;returns&gt;String representation of this optional value.&lt;/returns&gt;
public override string ToString() =&gt; $&quot;Optional&lt;{typeof(T)}&gt; ({this.Map(x =&gt; x.ToString()).ValueOr(&quot;&lt;no value&gt;&quot;)})&quot;;
⋮----
///     Checks whether this &lt;see cref=&quot;Optional{T}&quot; /&gt; (or its value) are equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;Optional{T}&quot; /&gt; or its value.&lt;/returns&gt;
public override bool Equals(object obj) =&gt;
⋮----
T t =&gt; this.Equals(t),
Optional&lt;T&gt; opt =&gt; this.Equals(opt),
⋮----
///     Checks whether this &lt;see cref=&quot;Optional{T}&quot; /&gt; is equal to another &lt;see cref=&quot;Optional{T}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;Optional{T}&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;Optional{T}&quot; /&gt; is equal to this &lt;see cref=&quot;Optional{T}&quot; /&gt;.&lt;/returns&gt;
public bool Equals(Optional&lt;T&gt; e) =&gt; (!this.HasValue &amp;&amp; !e.HasValue) || (this.HasValue == e.HasValue &amp;&amp; this.Value.Equals(e.Value));
⋮----
///     Checks whether the value of this &lt;see cref=&quot;Optional{T}&quot; /&gt; is equal to specified object.
⋮----
/// &lt;param name=&quot;e&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to the value of this &lt;see cref=&quot;Optional{T}&quot; /&gt;.&lt;/returns&gt;
public bool Equals(T e)
⋮----
///     Gets the hash code for this &lt;see cref=&quot;Optional{T}&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;Optional{T}&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Map(x =&gt; x.GetHashCode()).ValueOrDefault();
⋮----
///     Creates an empty optional.
⋮----
=&gt; opt1.Equals(opt2);
⋮----
=&gt; !opt1.Equals(opt2);
⋮----
=&gt; opt.Equals(t);
⋮----
=&gt; !opt.Equals(t);
⋮----
///     Represents an optional json converter.
⋮----
internal sealed class OptionalJsonConverter : JsonConverter
⋮----
///     Writes the json.
⋮----
/// &lt;param name=&quot;writer&quot;&gt;The writer.&lt;/param&gt;
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;serializer&quot;&gt;The serializer.&lt;/param&gt;
public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
⋮----
// we don&apos;t check for HasValue here since it&apos;s checked in OptionalJsonContractResolver
⋮----
// JToken.FromObject will throw if `null` so we manually write a null value.
⋮----
// you can read serializer.NullValueHandling here, but unfortunately you can **not** skip serialization
// here, or else you will get a nasty JsonWriterException, so we just ignore its value and manually
// write the null.
writer.WriteToken(JsonToken.Null);
⋮----
// convert the value to a JSON object and write it to the property value.
JToken.FromObject(val).WriteTo(writer);
⋮----
///     Reads the json.
⋮----
/// &lt;param name=&quot;reader&quot;&gt;The reader.&lt;/param&gt;
/// &lt;param name=&quot;objectType&quot;&gt;The object type.&lt;/param&gt;
/// &lt;param name=&quot;existingValue&quot;&gt;The existing value.&lt;/param&gt;
⋮----
public override object ReadJson(
⋮----
var constructor = objectType.GetTypeInfo().DeclaredConstructors
.FirstOrDefault(e =&gt; e.GetParameters()[0].ParameterType == genericType);
⋮----
return constructor.Invoke([serializer.Deserialize(reader, genericType)]);
⋮----
///     Whether it can convert.
⋮----
public override bool CanConvert(Type objectType) =&gt; objectType.GetTypeInfo().ImplementedInterfaces.Contains(typeof(IOptional));</file><file path="DisCatSharp/Entities/User/DisplayNameStyles.cs">/// &lt;summary&gt;
///		Represents the display name styles for a user.
/// &lt;/summary&gt;
public class DisplayNameStyles
⋮----
///		Represents the font style for the display name.
⋮----
///		Represents the effect style for the display name.
⋮----
///		Represents the raw color styles for the display name.
⋮----
///		Represents the color styles for the display name.
⋮----
=&gt; [.. this.ColorsInternal.Select(c =&gt; new DiscordColor(c))];</file><file path="DisCatSharp/Enums/Channel/ChannelFlags.cs">/// &lt;summary&gt;
///     Represents a channel flag extensions.
/// &lt;/summary&gt;
public static class ChannelFlagExtensions
⋮----
///     Calculates whether these channeö flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasChannelFlag(this ChannelFlags baseFlags, ChannelFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents a channel&apos;s flags.
⋮----
///     Indicates that this channel is removed from the guilds home feed / from highlights.
///     Applicable for &lt;see cref=&quot;ChannelType&quot; /&gt; Text, Forum and News.
⋮----
///     Indicates that this thread is pinned to the top of its parent forum channel.
///     Forum channel thread only.
⋮----
///     Indicates that this channel is removed from the active now within the guilds home feed.
///     Applicable for &lt;see cref=&quot;ChannelType&quot; /&gt; Text, News, Thread, Forum, Stage and Voice.
⋮----
///     Indicates that the channel requires users to select at least one &lt;see cref=&quot;ForumPostTag&quot; /&gt;.
///     Only applicable for &lt;see cref=&quot;ChannelType.Forum&quot; /&gt;.
⋮----
///     Indicated that this channel is spam.
⋮----
///     Indicated that this channel is a guild resource channel.
⋮----
///     Indicated that clyde has access to this thread.
⋮----
///     Unknown what this flag does. Releates to clyde thread?
⋮----
///     Indicates that this channel is a media channel.
⋮----
///     Indicates that ai powered summaries are disabled for this channel.
⋮----
///     Currently unknown.
⋮----
///     Indicates that this channel is part of a role subscription template preview.
⋮----
///     Hides the media download options for &lt;see cref=&quot;ChannelType.GuildMedia&quot; /&gt; channels.
⋮----
///     Channel is a interview channel for a guild join request (gdm style, with application details).
⋮----
///     Channel is obfuscated.
⋮----
///     Indicates that this channel is a moderator report channel.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Channel/TagMatching.cs">/// &lt;summary&gt;
/// Represents the tag matching mode for a forum channel.
/// &lt;/summary&gt;
⋮----
/// At least one tag must match (&quot;match_some&quot;).
⋮----
/// All tags must match (&quot;match_all&quot;).</file><file path="DisCatSharp/Enums/Core/ModifyMode.cs">/// &lt;summary&gt;
///    Represents the mode used by a &lt;see cref=&quot;Entities.Core.DisCatSharpBuilder&quot;/&gt; for updating a message.
/// &lt;/summary&gt;
⋮----
///    Denotes that the message will only update explicitly set fields, leaving others unchanged.
⋮----
///    Denotes that the entire message will be replaced as if it were a new message.</file><file path="DisCatSharp/Enums/Guild/AuditLogActionType.cs">/// &lt;summary&gt;
///     Represents type of the action that was taken in given audit log event.
/// &lt;/summary&gt;
⋮----
///     Indicates an invalid action type.
⋮----
///     Indicates that the guild was updated.
⋮----
///     Indicates that the channel was created.
⋮----
///     Indicates that the channel was updated.
⋮----
///     Indicates that the channel was deleted.
⋮----
///     Indicates that the channel permission overwrite was created.
⋮----
///     Indicates that the channel permission overwrite was updated.
⋮----
///     Indicates that the channel permission overwrite was deleted.
⋮----
///     Indicates that the user was kicked.
⋮----
///     Indicates that users were pruned.
⋮----
///     Indicates that the user was banned.
⋮----
///     Indicates that the user was unbanned.
⋮----
///     Indicates that the member was updated.
⋮----
///     Indicates that the member&apos;s roles were updated.
⋮----
///     Indicates that the member has moved to another voice channel.
⋮----
///     Indicates that the member has disconnected from a voice channel.
⋮----
///     Indicates that a bot was added to the guild.
⋮----
///     Indicates that the role was created.
⋮----
///     Indicates that the role was updated.
⋮----
///     Indicates that the role was deleted.
⋮----
///     Indicates that the invite was created.
⋮----
///     Indicates that the invite was updated.
⋮----
///     Indicates that the invite was deleted.
⋮----
///     Indicates that the webhook was created.
⋮----
///     Indicates that the webook was updated.
⋮----
///     Indicates that the webhook was deleted.
⋮----
///     Indicates that an emoji was created.
⋮----
///     Indicates that an emoji was updated.
⋮----
///     Indicates that an emoji was deleted.
⋮----
///     Indicates that the message was deleted.
⋮----
///     Indicates that messages were bulk-deleted.
⋮----
///     Indicates that a message was pinned.
⋮----
///     Indicates that a message was unpinned.
⋮----
///     Indicates that an integration was created.
⋮----
///     Indicates that an integration was updated.
⋮----
///     Indicates that an integration was deleted.
⋮----
///     Indicates that an stage instance was created.
⋮----
///     Indicates that an stage instance was updated.
⋮----
///     Indicates that an stage instance was deleted.
⋮----
///     Indicates that an sticker was created.
⋮----
///     Indicates that an sticker was updated.
⋮----
///     Indicates that an sticker was deleted.
⋮----
///     Indicates that an event was created.
⋮----
///     Indicates that an event was updated.
⋮----
///     Indicates that an event was deleted.
⋮----
///     Indicates that an thread was created.
⋮----
///     Indicates that an thread was updated.
⋮----
///     Indicates that an thread was deleted.
⋮----
///     Indicates that the permissions for an application command was updated.
⋮----
///     Indicates that a new automod rule has been added.
⋮----
///     Indicates that a automod rule has been updated.
⋮----
///     Indicates that a automod rule has been deleted.
⋮----
///     Indicates that automod blocked a message.
⋮----
///     Indicates that automod flagged a message.
⋮----
///     Indicates that automod timed out a user.
⋮----
///     Indicates that automod quarantined a user.</file><file path="DisCatSharp/Enums/Guild/BadgeType.cs">/// &lt;summary&gt;
/// Represents the badge type for a guild member or entity.
/// &lt;/summary&gt;</file><file path="DisCatSharp/Enums/Guild/MemberFlags.cs">/// &lt;summary&gt;
///     Represents a member flag extensions.
/// &lt;/summary&gt;
public static class MemberFlagExtensions
⋮----
///     Calculates whether these member flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasMemberFlag(this MemberFlags baseFlags, MemberFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents additional details of a member account.
⋮----
///     Member has no flags.
⋮----
///     Member has left and rejoined the guild.
⋮----
///     Member has completed onboarding.
⋮----
///     Member bypasses guild verification requirements.
⋮----
///     Member has started onboarding.
⋮----
///     Member is a guest.
///     Temporary members that are not in the guild.
⋮----
///     Member has started home actions.
⋮----
///     Member has completed home actions.
⋮----
///     Member&apos;s username, display name, or nickname is blocked by AutoMod.
⋮----
/// &lt;inheritdoc cref=&quot;AutomodQuarantinedUsername&quot; /&gt;
⋮----
///     Member&apos;s user or guild bio is blocked by AutoMod.
⋮----
///     Member has dismissed the DM settings upsell.
⋮----
///     Member&apos;s server tag is blocked by AutoMod.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Guild/Permission.cs">/// &lt;summary&gt;
///     Represents permission methods.
/// &lt;/summary&gt;
public static class PermissionMethods
⋮----
///     Gets the full permissions enum (long).
⋮----
///     Calculates whether this permission set contains the given permission.
⋮----
/// &lt;param name=&quot;p&quot;&gt;The permissions to calculate from.&lt;/param&gt;
/// &lt;param name=&quot;permission&quot;&gt;The permission you want to check.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasPermission(this Permissions p, Permissions permission)
=&gt; p.HasFlag(Permissions.Administrator) || (p &amp; permission) == permission;
⋮----
///     Grants permissions.
⋮----
/// &lt;param name=&quot;p&quot;&gt;The permissions to add to.&lt;/param&gt;
/// &lt;param name=&quot;grant&quot;&gt;The permission to add.&lt;/param&gt;
⋮----
public static Permissions Grant(this Permissions p, Permissions grant) =&gt; p | grant;
⋮----
///     Revokes permissions.
⋮----
/// &lt;param name=&quot;p&quot;&gt;The permissions to take from.&lt;/param&gt;
/// &lt;param name=&quot;revoke&quot;&gt;The permission to take.&lt;/param&gt;
⋮----
public static Permissions Revoke(this Permissions p, Permissions revoke) =&gt; p &amp; ~revoke;
⋮----
///     Whether a permission is allowed, denied or unset
⋮----
///     Said permission is Allowed
⋮----
///     Said permission is Denied
⋮----
///     Said permission is Unset
⋮----
///     Bitwise permission flags.
⋮----
///     Indicates no permissions given.
⋮----
///     Indicates all permissions are granted.
⋮----
///     Allows creation of instant channel invites.
⋮----
///     Allows kicking members.
⋮----
///     Allows banning and unbanning members.
⋮----
///     Enables full access on a given guild. This also overrides other permissions.
⋮----
///     Allows managing channels.
⋮----
///     Allows managing the guild.
⋮----
///     Allows adding reactions to messages.
⋮----
///     Allows viewing audit log entries.
⋮----
///     Allows the use of priority speaker.
⋮----
///     Allows the user to go live.
⋮----
///     Allows accessing text and voice channels. Disabling this permission hides channels.
⋮----
///     Allows sending messages (does not allow sending messages in threads).
⋮----
///     Allows sending text-to-speech messages.
⋮----
///     Allows managing messages of other users.
⋮----
///     Allows embedding content in messages.
⋮----
///     Allows uploading files.
⋮----
///     Allows reading message history.
⋮----
///     Allows using @everyone and @here mentions.
⋮----
///     Allows using emojis from external servers, such as twitch or nitro emojis.
⋮----
///     Allows to view guild insights.
⋮----
///     Allows connecting to voice chat.
⋮----
///     Allows speaking in voice chat.
⋮----
///     Allows muting other members in voice chat.
⋮----
///     Allows deafening other members in voice chat.
⋮----
///     Allows moving voice chat members.
⋮----
///     Allows using voice activation in voice chat. Revoking this will usage of push-to-talk.
⋮----
///     Allows changing of own nickname.
⋮----
///     Allows managing nicknames of other members.
⋮----
///     Allows managing roles in a guild.
⋮----
///     Allows managing webhooks in a guild.
⋮----
///     Allows managing guild emojis, stickers and soundboard sounds.
⋮----
///     Allows the user to use slash commands.
⋮----
///     Allows for requesting to speak in stage channels.
⋮----
///     Allows managing guild events.
⋮----
///     Allows for deleting and archiving threads, and viewing all private threads.
⋮----
///     Allows for creating threads.
⋮----
///     Allows for creating private threads.
⋮----
///     Allows the usage of custom stickers from other servers.
⋮----
///     Allows for sending messages in threads.
⋮----
///     Allows for launching activities (applications with the `EMBEDDED` flag) in a voice channel.
⋮----
///     Allows to perform limited moderation actions (timeout).
⋮----
///     Allows to view creator monetization insights.
⋮----
///     Allows to use soundboard sounds in voice channels.
⋮----
///     Allows to create guild emojis, stickers and soundboard sounds.
⋮----
///     Allows to create guild events.
⋮----
///     Allows the usage of custom soundboard sounds from other servers.
⋮----
///     Allows members to send voice messages.
⋮----
///     Allows members to interact with the Clyde AI bot.
⋮----
///     Allows members to create and edit voice channel status.
⋮----
///     Allows members to send polls.
⋮----
///     Allows user-installed apps to send public responses.
///     When disabled, users will still be allowed to use their apps but the responses will be ephemeral.
///     This only applies to apps not also installed to the server.
⋮----
///     Allows pinning messages.
⋮----
///      The flags are unknown.
⋮----
///     Defines a readable name for this permission.
⋮----
public sealed class PermissionStringAttribute : Attribute
⋮----
/// &lt;param name=&quot;str&quot;&gt;Readable name for this permission.&lt;/param&gt;
⋮----
///     Gets the readable name for this permission.</file><file path="DisCatSharp/Enums/Guild/SystemChannelFlags.cs">/// &lt;summary&gt;
///     Represents a system channel flags extension.
/// &lt;/summary&gt;
public static class SystemChannelFlagsExtension
⋮----
///     Calculates whether these system channel flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flag to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasSystemChannelFlag(this SystemChannelFlags baseFlags, SystemChannelFlags flag)
⋮----
/// &lt;inheritdoc cref=&quot;HasSystemChannelFlag(SystemChannelFlags, SystemChannelFlags)&quot; /&gt;
public static bool HasSystemChannelFlag(this SystemChannelFlags? baseFlags, SystemChannelFlags flag)
⋮----
///     Represents settings for a guild&apos;s system channel.
⋮----
///     Member join messages are disabled.
⋮----
///     Server boost messages are disabled.
⋮----
///     Server setup tips are disabled.
⋮----
///     Suppress member join sticker replies.
⋮----
///     Role subscription purchase messages are disabled.
⋮----
///     Suppress role subscription purchase sticker replies.
⋮----
///     Suppress deadchat channel prompts.
⋮----
///     Suppress UGC added notifications.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Interaction/ComponentType.cs">/// &lt;summary&gt;
///     Represents a type of component.
/// &lt;/summary&gt;
⋮----
///     A row of components.
⋮----
///     A button.
⋮----
///     A select menu to select strings.
⋮----
///     A text input.
⋮----
///     A select menu to select users.
⋮----
///     A select menu to select roles.
⋮----
///     A select menu to select menu to select users and roles.
⋮----
///     A select menu to select channels.
⋮----
///     A section.
⋮----
///     A text display.
⋮----
///     A thumbnail.
⋮----
///     A media gallery.
⋮----
///     A file.
⋮----
///     A separator.
⋮----
///     Cannot be used by bots.
⋮----
///     A container.
⋮----
///     A label.</file><file path="DisCatSharp/Enums/Message/AttachmentFlags.cs">/// &lt;summary&gt;
///     Represents a attachment flag extensions.
/// &lt;/summary&gt;
public static class AttachmentFlagExtensions
⋮----
///     Calculates whether these attachment flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasAttachmentFlag(this AttachmentFlags baseFlags, AttachmentFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents additional features of a attachment.
⋮----
///     This attachment has no flags.
⋮----
///     This attachment is a clip.
⋮----
///     This attachment is a thumbnail.
⋮----
///     This attachment was edited with remix (https://support.discord.com/hc/en-us/articles/15145601963031).
⋮----
///     This attachment is a spoiler.
⋮----
///     This attachment contains explicit media.
⋮----
///     This attachment is animated.
⋮----
///     This attachment contains gore content.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Message/DiscordMediaType.cs">/// &lt;summary&gt;
///     Represents a high-level Discord media type category for attachments.
/// &lt;/summary&gt;
⋮----
///     Uncategorized or unknown type.
⋮----
///     File types such as text and model files.
⋮----
///     Media types such as video and image files.
⋮----
///     Audio types such as audio and voice messages.
⋮----
///     Executable or application files.</file><file path="DisCatSharp/Enums/Message/EmbedFlags.cs">/// &lt;summary&gt;
///     Represents a embed flag extensions.
/// &lt;/summary&gt;
public static class EmbedFlagExtensions
⋮----
///     Calculates whether these embed flags contain a specific flag.
⋮----
/// &lt;param name=&quot;baseFlags&quot;&gt;The existing flags.&lt;/param&gt;
/// &lt;param name=&quot;flag&quot;&gt;The flags to search for.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static bool HasEmbedFlag(this EmbedFlags baseFlags, EmbedFlags flag) =&gt; (baseFlags &amp; flag) == flag;
⋮----
///     Represents additional features of a embed.
⋮----
///     This embed has no flags.
⋮----
///     This embed contains explicit media.
⋮----
///     This embed is a content inventory entry.
⋮----
///     This embed contains gore content.
⋮----
///      The flags are unknown.</file><file path="DisCatSharp/Enums/Message/MediaType.cs">/// &lt;summary&gt;
///     Represents a categorized media type for attachments.
/// &lt;/summary&gt;
⋮----
///     Unknown or unrecognized media type.
⋮----
///     Media type for Discord voice messages (special case, e.g., voice_message.ogg).
⋮----
///     Media type for application data (e.g., application/json, application/pdf).
⋮----
///     Media type for audio data (e.g., audio/mpeg, audio/ogg).
⋮----
///     Media type for font data (e.g., font/woff, font/ttf).
⋮----
///     Media type for haptics data (e.g., haptics/ivs).
⋮----
///     Media type for image data (e.g., image/png, image/jpeg).
⋮----
///     Media type for model data (e.g., model/gltf+json, model/3mf).
⋮----
///     Media type for message data (e.g., message/rfc822).
⋮----
///     Media type for multipart data (e.g., multipart/form-data).
⋮----
///     Media type for text data (e.g., text/plain, text/html).
⋮----
///     Media type for video data (e.g., video/mp4, video/webm).</file><file path="DisCatSharp/Enums/Message/MessageType.cs">/// &lt;summary&gt;
///     Represents the type of a message.
/// &lt;/summary&gt;
⋮----
///     Indicates a regular message.
⋮----
///     Message indicating a recipient was added to a group direct message or a thread channel.
⋮----
///     Message indicating a recipient was removed from a group direct message or a thread channel.
⋮----
///     Message indicating a call.
⋮----
///     Message indicating a group direct message or thread channel rename.
⋮----
///     Message indicating a group direct message channel icon change.
⋮----
///     Message indicating a user pinned a message to a channel.
⋮----
///     Message indicating a guild member joined. Most frequently seen in newer, smaller guilds.
⋮----
///     Message indicating a member nitro boosted a guild.
⋮----
///     Message indicating a guild reached tier one of nitro boosts.
⋮----
///     Message indicating a guild reached tier two of nitro boosts.
⋮----
///     Message indicating a guild reached tier three of nitro boosts.
⋮----
///     Message indicating a user followed a news channel.
⋮----
///     Message indicating a user is streaming in a guild.
⋮----
///     Message indicating a guild was removed from guild discovery.
⋮----
///     Message indicating a guild was re-added to guild discovery.
⋮----
///     Message indicating that a guild has failed to meet guild discovery requirements for a week.
⋮----
///     Message indicating that a guild has failed to meet guild discovery requirements for 3 weeks.
⋮----
///     Message indicating a thread was created.
⋮----
///     Message indicating a user replied to another user.
⋮----
///     Message indicating an slash command was invoked.
⋮----
///     Message indicating a new was message sent as the first message in threads that are started from an existing message
///     in the parent channel.
⋮----
///     Message reminding you to invite people to help you build the server.
⋮----
///     Message indicating an context menu command was invoked.
⋮----
///     Message indicating the guilds automod acted.
⋮----
///     Message indicating that a member purchased a role subscription.
⋮----
///     Unknown.
⋮----
///     Message indicating that a stage started.
⋮----
///     Message indicating that a stage ended.
⋮----
///     Message indicating that a user is now a stage speaker.
⋮----
///     Message indicating that a user in a stage raised there hand (Request to speak).
⋮----
///     Message indicating that a stage topic was changed.
⋮----
///     Message indicating that a member purchased a application premium subscription.
⋮----
///     Message indicating that a private channel integration was added.
⋮----
///     Message indicating that a private channel integration was removed.
⋮----
///     This message is a premium referral.
⋮----
///     Message indicating that the guild incident alert mode was enabled.
⋮----
///     Message indicating that the guild incident alert mode was disabled.
⋮----
///     Message indicating that a raid was reported.
⋮----
///     Message indicating a false alarm was reported.
⋮----
///     Message indicating that a guild deadchat revive prompt was sent.
⋮----
///     Message indicating a custom gift.
⋮----
///     Message indicating a guild gaming stats prompt.
⋮----
///     Message indicating a poll was created.
⋮----
///     Message indicating that a user bought something from the server shop.
⋮----
///     Message indicating a voice hangout invite.
⋮----
///     Message indicating a polls result are in.
⋮----
///     Message indicating a changelog.
⋮----
///     Message indicating a nitro notification.
⋮----
///     Message indicating that a channel was linked to a lobby.
⋮----
///     Message indicating a gifting prompt.
⋮----
///     Message indicating a in game message nux.
⋮----
///     Message indicating a guild join request was accepted.
⋮----
/// &lt;inheritdoc cref=&quot;GuildJoinRequestAcceptNotification&quot; /&gt;
⋮----
///     Message indicating a guild join request was rejected.
⋮----
/// &lt;inheritdoc cref=&quot;GuildJoinRequestRejectNotification&quot; /&gt;
⋮----
///     Message indicating a guild join request was withdrawn.
⋮----
///     Message indicating a voice channel was upgraded to HD streaming.
⋮----
///     Message indicating a chat wallpaper was set.
⋮----
///     Message indicating a chat wallpaper was removed.
⋮----
///     Message indicating a report to mod deleted message.
⋮----
///     Message indicating a report to mod timeout user.
⋮----
///     Message indicating a report to mod kick user.
⋮----
///     Message indicating a report to mod ban user.
⋮----
///     Message indicating a report to mod closed report.
⋮----
///     Message indicating an emoji was added.</file><file path="DisCatSharp/Enums/User/DisplayNameEffect.cs">/// &lt;summary&gt;
/// Represents the display name effect for a user.
/// &lt;/summary&gt;
⋮----
/// Solid effect.
⋮----
/// Gradient effect.
⋮----
/// Neon effect.
⋮----
/// Toon effect.
⋮----
/// Pop effect.
⋮----
/// Glow effect.</file><file path="DisCatSharp/Net/Abstractions/Rest/RestGuildPayloads.cs">/// &lt;summary&gt;
///     The reason action.
/// &lt;/summary&gt;
internal interface IReasonAction
⋮----
///     Gets or sets the reason.
⋮----
///     Represents a guild modify payload.
⋮----
internal sealed class RestGuildModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the icon base64.
⋮----
///     Gets or sets the verification level.
⋮----
///     Gets or sets the default message notifications.
⋮----
///     Gets or sets the splash base64.
⋮----
///     Gets or sets the banner base64.
⋮----
///     Gets or sets the home header base64.
⋮----
///     Gets or sets the discovery splash base64.
⋮----
///     Gets or sets the afk channel id.
⋮----
///     Gets or sets the afk timeout.
⋮----
///     Gets or sets the mfa level.
⋮----
///     Gets or sets the explicit content filter.
⋮----
///     Gets or sets the system channel id.
⋮----
///     Gets or sets the safety alerts channel id.
⋮----
///     Gets or sets the system channel flags.
⋮----
///     Gets or sets the rules channel id.
⋮----
///     Gets or sets the public updates channel id.
⋮----
///     Gets or sets the preferred locale.
⋮----
///     Gets or sets the description.
⋮----
///     Gets or sets whether the premium progress bar should be enabled.
⋮----
///     Represents a guild mfa level modify payload.
⋮----
internal sealed class RestGuildMfaLevelModifyPayload : ObservableApiObject
⋮----
///     Represents a guild community modify payload.
⋮----
internal sealed class RestGuildFeatureModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the features.
⋮----
internal sealed class RestGuildSafetyModifyPayload : ObservableApiObject
⋮----
internal sealed class RestGuildCommunityModifyPayload : ObservableApiObject
⋮----
///     Represents guild inventory settings.
⋮----
internal sealed class RestGuildInventoryModifyPayload : ObservableApiObject
⋮----
///     Gets or sets whether anyone is allowed to use and collect this guild&apos;s emojis.
⋮----
///     Represents guild incidents actions.
⋮----
internal sealed class RestGuildIncidentActionsModifyPayload : ObservableApiObject
⋮----
///     Gets until when invites are disabled.
⋮----
///     Gets until when direct messages are disabled.
⋮----
///     Represents guild onboarding settings.
⋮----
internal sealed class RestGuildOnboardingModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the prompts shown during onboarding and in customize community.
⋮----
///     Gets or sets the channel ids that members get opted into automatically.
⋮----
///     Gets or sets whether onboarding is enabled in the guild.
⋮----
///     Gets or sets the mode of onboarding.
⋮----
///     Represents guild server guide settings.
⋮----
internal sealed class RestGuildServerGuideModifyPayload : ObservableApiObject
⋮----
///     Gets or sets whether server guide is enabled in the guild.
⋮----
///     Gets or sets the server guide welcome message.
⋮----
///     Gets or sets the new member actions.
⋮----
///     Gets or sets the resource channels.
⋮----
///     Represents a guild member add payload.
⋮----
internal sealed class RestGuildMemberAddPayload : IOAuth2Payload
⋮----
///     Gets or sets the nickname.
⋮----
///     Gets or sets the roles.
⋮----
///     Gets or sets a value indicating whether mute.
⋮----
///     Gets or sets a value indicating whether deaf.
⋮----
///     Gets or sets the access token.
⋮----
///     Represents a guild channel reorder payload.
⋮----
internal sealed class RestGuildChannelReorderPayload : ObservableApiObject
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets or sets the position.
⋮----
///     Represents a guild channel new parent payload.
⋮----
internal sealed class RestGuildChannelNewParentPayload : ObservableApiObject
⋮----
///     Gets or sets the parent id.
⋮----
///     Gets or sets a value indicating whether lock permissions.
⋮----
///     Represents a guild channel no parent payload.
⋮----
internal sealed class RestGuildChannelNoParentPayload : ObservableApiObject
⋮----
///     Represents a guild role reorder payload.
⋮----
internal sealed class RestGuildRoleReorderPayload
⋮----
///     Gets or sets the role id.
⋮----
///     Represents a guild member modify payload.
⋮----
internal sealed class RestGuildMemberModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the role ids.
⋮----
///     Gets or sets the mute.
⋮----
///     Gets or sets the deafen.
⋮----
///     Gets or sets the voice channel id.
⋮----
///     Represents a guild member timeout modify payload.
⋮----
internal sealed class RestGuildMemberTimeoutModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the date until the member can communicate again.
⋮----
///     Represents a guild role payload.
⋮----
internal sealed class RestGuildRolePayload : ObservableApiObject
⋮----
///     Gets or sets the permissions.
⋮----
///     Gets or sets the color.
⋮----
///     Gets or sets the colors.
⋮----
///     Gets or sets a value indicating whether hoist.
⋮----
///     Gets or sets a value indicating whether mentionable.
⋮----
///     Role colors.
⋮----
public sealed class RoleColors
⋮----
///     Gets the primary color. Is the same as &lt;see cref=&quot;DiscordRole.Color&quot; /&gt;.
⋮----
///     Gets the secondary color. Uses for gradient style.
⋮----
///     Gets the tertiary color. This only applies to the &lt;c&gt;holographic&lt;/c&gt; role style and must have the value
///     &lt;c&gt;16761760&lt;/c&gt;.
⋮----
///     Represents a guild prune result payload.
⋮----
internal sealed class RestGuildPruneResultPayload : ObservableApiObject
⋮----
///     Gets or sets the pruned.
⋮----
///     Represents a guild integration attach payload.
⋮----
internal sealed class RestGuildIntegrationAttachPayload : ObservableApiObject
⋮----
///     Gets or sets the type.
⋮----
///     Gets or sets the id.
⋮----
///     Represents a guild join request update payload.
⋮----
internal sealed class RestGuildJoinRequestUpdatePayload : ObservableApiObject
⋮----
///     Gets or sets the action.
⋮----
///     Represents a guild integration modify payload.
⋮----
internal sealed class RestGuildIntegrationModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the expire behavior.
⋮----
///     Gets or sets the expire grace period.
⋮----
///     Gets or sets a value indicating whether enable emoticons.
⋮----
///     Represents a guild emoji modify payload.
⋮----
internal class RestGuildEmojiModifyPayload : ObservableApiObject
⋮----
///     Represents a guild emoji create payload.
⋮----
internal class RestGuildEmojiCreatePayload : RestGuildEmojiModifyPayload
⋮----
///     Gets or sets the image b64.
⋮----
///     Represents a guild widget settings payload.
⋮----
internal class RestGuildWidgetSettingsPayload : ObservableApiObject
⋮----
///     Gets or sets a value indicating whether enabled.
⋮----
///     Represents a guild template create or modify payload.
⋮----
internal class RestGuildTemplateCreateOrModifyPayload : ObservableApiObject
⋮----
///     Represents a guild membership screening form modify payload.
⋮----
internal class RestGuildMembershipScreeningFormModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the enabled.
⋮----
///     Gets or sets the fields.
⋮----
///     Represents a guild welcome screen modify payload.
⋮----
internal class RestGuildWelcomeScreenModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the welcome channels.
⋮----
///     Represents a guild update current user voice state payload.
⋮----
internal class RestGuildUpdateCurrentUserVoiceStatePayload : ObservableApiObject
⋮----
///     Gets or sets a value indicating whether suppress.
⋮----
///     Gets or sets the request to speak timestamp.
⋮----
///     Represents a guild update user voice state payload.
⋮----
internal class RestGuildUpdateUserVoiceStatePayload : ObservableApiObject
⋮----
///     Represents a guild ban payload.
⋮----
internal sealed class RestGuildBanPayload : ObservableApiObject
⋮----
///     Gets or sets the delete message seconds.
⋮----
///     Represents a guild bulk ban payload.
⋮----
internal sealed class RestGuildBulkBanPayload : ObservableApiObject
⋮----
///     Gets or sets the user ids.</file><file path="DisCatSharp/Net/Abstractions/Transport/TransportUser.cs">/// &lt;summary&gt;
///     Represents a transport user.
/// &lt;/summary&gt;
internal class TransportUser : ObservableApiObject
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportUser&quot; /&gt; class.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;TransportUser&quot; /&gt; class from an existing &lt;see cref=&quot;TransportUser&quot; /&gt;.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other transport user.&lt;/param&gt;
⋮----
///     Gets the id.
⋮----
///     Gets the username.
⋮----
///     Gets this user&apos;s global name.
⋮----
///     Gets or sets the discriminator.
⋮----
///     Gets the username with discriminator.
⋮----
///     Gets the username with the global name.
⋮----
///     Gets the avatar hash.
⋮----
///     Gets the user&apos;s avatar decoration data.
⋮----
///     Gets the user&apos;s collectibles.
⋮----
///     Gets the banner hash.
⋮----
///     Gets the banner color.
⋮----
///     Gets the users theme colors.
⋮----
///     Gets a value indicating whether is bot.
⋮----
///     Gets a value indicating whether is system.
⋮----
///     Gets a value indicating whether mfa enabled.
⋮----
///     Gets a value indicating whether verified.
⋮----
///     Gets the email.
⋮----
///     Gets the premium type.
⋮----
///     Gets the locale.
⋮----
///     Gets the OAuth flags.
⋮----
///     Gets the flags.
⋮----
///     Gets the users bio.
///     This is not available to bots tho.
⋮----
///     Gets the users primary guild.
⋮----
///     Gets the users pronouns.
⋮----
///		Gets the user&apos;s display name styles.</file><file path="DisCatSharp/Net/Models/ForumChannelEditModel.cs">/// &lt;summary&gt;
///     Represents a forum channel edit model.
/// &lt;/summary&gt;
public class ForumChannelEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;ChannelEditModel&quot; /&gt; class.
⋮----
///     Sets the channel&apos;s new name.
⋮----
///     Sets the channel&apos;s new position.
⋮----
///     Sets the channel&apos;s new topic.
⋮----
///     Sets the channel&apos;s new template.
///     &lt;note type=&quot;warning&quot;&gt;This is not yet released and won&apos;t be applied by library.&lt;/note&gt;
⋮----
///     Sets whether the channel is to be marked as NSFW.
⋮----
///     Sets the available tags.
⋮----
///     Sets the default reaction emoji.
⋮----
///     Sets the default forum post sort order
⋮----
///     Sets the default forum layout
⋮----
///     Sets the default tag matching setting for this forum channel.
⋮----
///     &lt;para&gt;Sets the parent of this channel.&lt;/para&gt;
///     &lt;para&gt;
///         This should be channel with &lt;see cref=&quot;DisCatSharp.Entities.DiscordChannel.Type&quot; /&gt; set to
///         &lt;see cref=&quot;ChannelType.Category&quot; /&gt;.
///     &lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the voice channel&apos;s new user limit.&lt;/para&gt;
///     &lt;para&gt;Setting this to 0 will disable the user limit.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the channel&apos;s new slow mode timeout.&lt;/para&gt;
///     &lt;para&gt;Setting this to null or 0 will disable slow mode.&lt;/para&gt;
⋮----
///     &lt;para&gt;Sets the channel&apos;s new post slow mode timeout.&lt;/para&gt;
⋮----
///     Sets this channel&apos;s default duration for newly created threads, in minutes, to automatically archive the thread
///     after recent activity.
⋮----
///     Sets the channel&apos;s permission overwrites.
⋮----
///     Sets the channel&apos;s flags.</file><file path="DisCatSharp/Net/Models/GuildEditModel.cs">/// &lt;summary&gt;
///     Represents a guild edit model.
/// &lt;/summary&gt;
public class GuildEditModel : BaseEditModel
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;GuildEditModel&quot; /&gt; class.
⋮----
///     The new guild name.
⋮----
///     The new guild icon.
⋮----
///     The new guild verification level.
⋮----
///     The new guild default message notification level.
⋮----
///     The new guild MFA level.
⋮----
///     The new guild explicit content filter level.
⋮----
///     The new AFK voice channel.
⋮----
///     The new AFK timeout time in seconds.
⋮----
///     The new guild splash.
⋮----
///     The new guild system channel.
⋮----
///     The guild system channel flags.
⋮----
///     The guild description.
⋮----
///     The new guild rules channel.
⋮----
///     The new guild public updates channel.
⋮----
///     The new guild preferred locale.
⋮----
///     The new banner of the guild
⋮----
///     The new discovery splash image of the guild
⋮----
///     The new home header of the guild.
⋮----
///     Whether the premium progress bar should be enabled</file><file path="DisCatSharp/Net/Serialization/DiscordComponentJsonConverter.cs">/// &lt;summary&gt;
///     Represents a discord component json converter.
/// &lt;/summary&gt;
internal sealed class DiscordComponentJsonConverter : JsonConverter
⋮----
/// &lt;inheritdoc /&gt;
⋮----
public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
=&gt; throw new NotImplementedException();
⋮----
public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
⋮----
var job = JObject.Load(reader);
var type = job[&quot;type&quot;]?.ToObject&lt;ComponentType&gt;() ?? throw new ArgumentException($&quot;Value {reader} does not have a component type specifier&quot;);
DiscordComponent cmp = type switch
⋮----
ComponentType.ActionRow =&gt; new DiscordActionRowComponent(),
ComponentType.Button when (string?)job[&quot;url&quot;] is not null =&gt; new DiscordLinkButtonComponent(),
ComponentType.Button when (string?)job[&quot;sku_id&quot;] is not null =&gt; new DiscordPremiumButtonComponent(),
ComponentType.Button =&gt; new DiscordButtonComponent(),
ComponentType.StringSelect =&gt; new DiscordStringSelectComponent(),
ComponentType.TextInput =&gt; new DiscordTextInputComponent(),
ComponentType.UserSelect =&gt; new DiscordUserSelectComponent(),
ComponentType.RoleSelect =&gt; new DiscordRoleSelectComponent(),
ComponentType.MentionableSelect =&gt; new DiscordMentionableSelectComponent(),
ComponentType.ChannelSelect =&gt; new DiscordChannelSelectComponent(),
ComponentType.Section =&gt; new DiscordSectionComponent(),
ComponentType.TextDisplay =&gt; new DiscordTextDisplayComponent(),
ComponentType.Thumbnail =&gt; new DiscordThumbnailComponent(),
ComponentType.MediaGallery =&gt; new DiscordMediaGalleryComponent(),
ComponentType.File =&gt; new DiscordFileDisplayComponent(),
ComponentType.Separator =&gt; new DiscordSeparatorComponent(),
ComponentType.Label =&gt; new DiscordLabelComponent(),
⋮----
// Populate the existing component with the values in the JObject. This avoids a recursive JsonConverter loop
using var jreader = job.CreateReader();
serializer.Populate(jreader, cmp);
⋮----
public override bool CanConvert(Type objectType)
=&gt; typeof(DiscordComponent).IsAssignableFrom(objectType);</file><file path="DisCatSharp/Net/Serialization/DiscordJson.cs">/// &lt;summary&gt;
///     Represents discord json.
/// &lt;/summary&gt;
public static class DiscordJson
⋮----
///     Gets the serializer.
⋮----
private static readonly JsonSerializer s_serializer = JsonSerializer.CreateDefault(new()
⋮----
ContractResolver = new DisCatSharpContractResolver()
⋮----
/// &lt;summary&gt;Serializes the specified object to a JSON string.&lt;/summary&gt;
/// &lt;param name=&quot;value&quot;&gt;The object to serialize.&lt;/param&gt;
/// &lt;returns&gt;A JSON string representation of the object.&lt;/returns&gt;
public static string SerializeObject(object value)
⋮----
///     Deserializes the specified JSON string to an object.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The type&lt;/typeparam&gt;
/// &lt;param name=&quot;json&quot;&gt;The received json.&lt;/param&gt;
/// &lt;param name=&quot;discord&quot;&gt;The discord client.&lt;/param&gt;
public static T DeserializeObject&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : ObservableApiObject
⋮----
///     Deserializes the specified JSON string to an object of the type &lt;see cref=&quot;IEnumerable{T}&quot; /&gt;.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The enumerable type.&lt;/typeparam&gt;
⋮----
public static T DeserializeIEnumerableObject&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : IEnumerable&lt;ObservableApiObject&gt;
⋮----
/// &lt;summary&gt;Populates an object with the values from a JSON node.&lt;/summary&gt;
/// &lt;param name=&quot;value&quot;&gt;The token to populate the object with.&lt;/param&gt;
/// &lt;param name=&quot;target&quot;&gt;The object to populate.&lt;/param&gt;
public static void PopulateObject(JToken value, object target)
⋮----
using var reader = value.CreateReader();
s_serializer.Populate(reader, target);
⋮----
///     Converts this token into an object, passing any properties through extra
///     &lt;see cref=&quot;Newtonsoft.Json.JsonConverter&quot; /&gt;s if needed.
⋮----
/// &lt;param name=&quot;token&quot;&gt;The token to convert&lt;/param&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type to convert to&lt;/typeparam&gt;
/// &lt;returns&gt;The converted token&lt;/returns&gt;
public static T ToDiscordObject&lt;T&gt;(this JToken token)
⋮----
///     Serializes the object.
⋮----
/// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;jsonSerializer&quot;&gt;The json serializer.&lt;/param&gt;
private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
⋮----
var stringWriter = new StringWriter(new(), CultureInfo.InvariantCulture);
using (var jsonTextWriter = new JsonTextWriter(stringWriter))
⋮----
jsonSerializer.Serialize(jsonTextWriter, value, type);
⋮----
return stringWriter.ToString();
⋮----
///     Handles &lt;see cref=&quot;DiscordJson&quot; /&gt; errors.
⋮----
/// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
/// &lt;param name=&quot;e&quot;&gt;The error event args.&lt;/param&gt;
⋮----
private static void DiscordJsonErrorHandler(object? sender, ErrorEventArgs e, BaseDiscordClient? discord)
⋮----
discord.Logger.LogError(e.ErrorContext.Error, &quot;{msg}\n\n{raw}&quot;, sentryMessage, e.ErrorContext.OriginalObject);
⋮----
SentryEvent sentryEvent = new(new DiscordJsonException(jre))
⋮----
Message = Utilities.StripTokensAndOptIds(sentryMessage, discord.Configuration.EnableDiscordIdScrubber)
⋮----
sentryEvent.SetFingerprint(BaseDiscordClient.GenerateSentryFingerPrint(sentryEvent));
⋮----
Id = discord.CurrentUser.Id.ToString(),
⋮----
var sid = discord.Sentry.CaptureEvent(sentryEvent);
_ = Task.Run(discord.Sentry.FlushAsync);
⋮----
discord.Logger.LogInformation(&quot;DiscordJson exception reported to sentry with id {sid}&quot;, sid.ToString());
⋮----
private static T DeserializeObjectInternal&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : ObservableApiObject
⋮----
ArgumentNullException.ThrowIfNull(json, nameof(json));
⋮----
var obj = JsonConvert.DeserializeObject&lt;T&gt;(json, new JsonSerializerSettings
⋮----
ContractResolver = new DisCatSharpContractResolver(),
⋮----
if (!discord.Configuration.ReportMissingFields || !obj.AdditionalProperties.Any())
⋮----
var sentryMessage = &quot;Found missing properties in api response for &quot; + obj.GetType().Name;
⋮----
if (obj.IgnoredJsonKeys.Count is not 0 &amp;&amp; obj.IgnoredJsonKeys.Any(x =&gt; x == ap.Key))
⋮----
discord.Logger.LogInformation(&quot;{sentry}&quot;, sentryMessage);
discord.Logger.LogDebug(&quot;{json}&quot;, json);
⋮----
sentryFields.Add(ap.Key);
⋮----
discord.Logger.LogInformation(&quot;Found field {field} on {object}&quot;, ap.Key, obj.GetType().Name);
⋮----
var sentryJson = JsonConvert.SerializeObject(sentryFields);
⋮----
SentryEvent sentryEvent = new()
⋮----
sentryEvent.SetExtra(&quot;Found Fields&quot;, sentryJson);
⋮----
discord.Logger.LogInformation(&quot;Missing fields reported to sentry with id {sid}&quot;, sid.ToString());
⋮----
private static T DeserializeIEnumerableObjectInternal&lt;T&gt;(string? json, BaseDiscordClient? discord) where T : IEnumerable&lt;ObservableApiObject&gt;
⋮----
if (!discord.Configuration.ReportMissingFields || !obj.Any(x =&gt; x.AdditionalProperties.Any()))
⋮----
var first = obj.First();
var sentryMessage = &quot;Found missing properties in api response for &quot; + first.GetType().Name;
⋮----
if (first.IgnoredJsonKeys.Count is not 0 &amp;&amp; first.IgnoredJsonKeys.Any(x =&gt; x == ap.Key))
⋮----
discord.Logger.LogInformation(&quot;Found field {field} on {object}&quot;, ap.Key, first.GetType().Name);</file><file path="LICENSE.md">The MIT License (MIT)

Copyright (c) 2021-2025 AITSYS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

# Package licenses for DisCatSharp
Parts of this package are not provided under DisCatSharp&apos;s license. Said
licenses are listed here.


## Package base
[Original license reading](https://github.com/DSharpPlus/DSharpPlus/blob/547192dc580a991db52ce66bdebfacc3a701f82d/LICENSE)

&gt; The following license applies to code copied from DSharpPlus up to commit [`547192d`](https://github.com/DSharpPlus/DSharpPlus/tree/547192dc580a991db52ce66bdebfacc3a701f82d).
&gt; DisCatSharp includes code originally authored by the DSharpPlus maintainers, under the MIT License as stated below.

```
The MIT License (MIT)

Copyright (c) 2015 Mike Santiago

Copyright (c) 2016-2021 DSharpPlus Development Team


Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Opus
[Original license reading](https://github.com/xiph/opus/blob/master/COPYING)

```
Copyright 2001-2011 Xiph.Org, Skype Limited, Octasic,
                    Jean-Marc Valin, Timothy B. Terriberry,
                    CSIRO, Gregory Maxwell, Mark Borgerding,
                    Erik de Castro Lopo

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Opus is subject to the royalty-free patent licenses which are
specified at:

Xiph.Org Foundation:
https://datatracker.ietf.org/ipr/1524/

Microsoft Corporation:
https://datatracker.ietf.org/ipr/1914/

Broadcom Corporation:
https://datatracker.ietf.org/ipr/1526/
```

## Libsodium
[Original license reading](https://github.com/jedisct1/libsodium/blob/master/LICENSE)

```
/*
 * ISC License
 *
 * Copyright (c) 2013-2020
 * Frank Denis &lt;j at pureftpd dot org&gt;
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
```


## DisCatSharp.Common
```
Copyright 2021-2025 AITSYS

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

## DisCatSharp.Common Source

This code originates from [Emzi0767&apos;s Common](https://github.com/Emzi0767/Common) at commit [`44bd7d5`](https://github.com/Emzi0767/Common/blob/44bd7d520e6929833d0c12251a1e715b8ccb90c5/LICENSE.TXT), where it was licensed under the Apache License 2.0.

Please note: this license was later changed to AGPL-3.0 (commit `1c693b2`) and subsequently LGPL-3.0 (commit `b7c7e48`). However, DisCatSharp.Common was derived **before** either change, and only uses code from before the license switch.

```
Copyright 2020-2021 Emzi0767

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-

Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/


TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

    &quot;License&quot; shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    &quot;Legal Entity&quot; shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    &quot;control&quot; means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    &quot;Source&quot; form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    &quot;Object&quot; form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    &quot;Work&quot; shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    &quot;Contribution&quot; shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, &quot;submitted&quot;
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as &quot;Not a Contribution.&quot;

    &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and

    (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS
```</file><file path="NOTICE.md">NOTICE

This software contains code derived from:
- DSharpPlus (MIT License) at commit [`547192d`](https://github.com/DSharpPlus/DSharpPlus/tree/547192dc580a991db52ce66bdebfacc3a701f82d)
- Emzi0767/Common at commit [`44bd7d5`](https://github.com/Emzi0767/Common/blob/44bd7d520e6929833d0c12251a1e715b8ccb90c5) (Apache 2.0 License)
- opus (BSD-like License)
- libsodium (ISC License)</file><file path="README.md">[![Build](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/build.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/build.yml) [![Documentation](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/documentation.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/documentation.yml) [![CodeQL](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/Aiko-IT-Systems/DisCatSharp/actions/workflows/codeql-analysis.yml) [![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=shield)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_shield)

[![GitHub last commit](https://img.shields.io/github/last-commit/Aiko-IT-Systems/DisCatSharp?label=Last%20Commit&amp;style=flat-square&amp;logo=github)](https://aitsys.dev/source/DisCatSharp/history/) [![GitHub commit activity](https://img.shields.io/github/commit-activity/w/Aiko-IT-Systems/DisCatSharp?label=Commit%20Activity&amp;style=flat-square&amp;logo=github)](https://github.com/Aiko-IT-Systems/DisCatSharp/commits/main)
[![GitHub pull requests](https://img.shields.io/github/issues-pr/Aiko-IT-Systems/DisCatSharp?label=PRs&amp;style=flat-square&amp;logo=github&amp;logo=gitub)](https://github.com/Aiko-IT-Systems/DisCatSharp/pulls) ![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/Aiko-IT-Systems/DisCatSharp?label=Size&amp;style=flat-square&amp;logo=github)

![Stable](https://img.shields.io/nuget/v/DisCatSharp?color=1F8B4C&amp;label=Stable&amp;style=flat-square&amp;logo=Nuget) ![Nightly](https://img.shields.io/nuget/vpre/DisCatSharp?color=AD1457&amp;label=Nightly&amp;style=flat-square&amp;logo=Nuget)

----

# DisCatSharp
## A Discord App Library written in C# for .NET

----

# News

## New

- Full support for Components V2
- Stability Improvements
- Build-in Statistics
- Support for .NET 10
- Improvements for OAuth2 operations

## Breaking

- **DiscordAttachment**: Renamed `MediaType` to `ContentType` to align with Discord&apos;s API.
- **DiscordTextComponent**: Switched the position of `customId` and `label` because of nullability.
- **Application Commands**: Removed `dmPermission` fields, causing DisCatSharp to do weird bulk-updates. Use `allowedContexts` instead.
- **LavalinkGuildPlayer**: `RemoveQueue` renamed to [`RemoveFromQueue`]((xref:DisCatSharp.Lavalink.Entities.LavalinkGuildPlayer.RemoveFromQueue*)).
- **Url fields**: Any `Url` fields on objects like `DiscordAttachment`, `DiscordEmbed`, etc., are now of type [`DiscordUri`](xref:DisCatSharp.Entities.DiscordUri) instead of `string`. Use `.ToUri()` to get a `Uri` object or use `.ToString()`.
- We updated some namespaces in DisCatSharp.Interactivity. You might need to update your imports for some entities and enums.

----

# About

## Why DisCatSharp?

If you:
- want a library where you get kind and efficient help
- would like to have and use the most recent features of the Discord API
- are ready to build great things

Then this is the right place for you!

## What Happened With The History

We&apos;ve squashed the history of DisCatSharp due to it&apos;s clone size and cluttered history.
The original history can be seen in the releases / tags and at https://github.com/Aiko-IT-Systems/DisCatSharp.Backup (Archived version *before* the squash).

## Installing

You can install the library from the following sources:
- [NuGet](https://www.nuget.org/profiles/DisCatSharp)
- [GitHub](https://github.com/orgs/Aiko-IT-Systems/packages?tab=packages&amp;q=DisCatSharp)

## Documentation

The documentation is available at [docs.dcs.aitsys.dev](https://docs.dcs.aitsys.dev).

Alternative hosts for our docs are:
- Backup Host [backup-docs.dcs.aitsys.dev](https://backup-docs.dcs.aitsys.dev)


## Bugs or Feature requests?

Either join our official support guild at https://discord.gg/RXA6u3jxdU, open an [issue](https://github.com/Aiko-IT-Systems/DisCatSharp/issues/new/choose) or write us an email at [bugs@aitsys.dev](mailto:bugs@aitsys.dev).

&lt;!-- All requests are tracked at [aitsys.dev](https://aitsys.dev/proje&lt;ct/view/1/). We currently don&apos;t do that for reasons --&gt;

## Tutorials / Examples

* [Howto](https://docs.dcs.aitsys.dev/articles/getting_started/bot_account.html)
* [Examples](https://github.com/Aiko-IT-Systems/DisCatSharp.Examples)
* [Template App(:warning:Outdated)](https://github.com/Aiko-IT-Systems/DisCatSharp.TemplateApp)
* [Public Support App for DisCatSharp Server](https://github.com/Aiko-IT-Systems/DisCatSharp.Support)

## Visual Studio Tools
* [DisCatSharp Analyzer Docs](https://docs.dcs.aitsys.dev/vs/index)
* [Snippets for Visual Studio](https://github.com/Aiko-IT-Systems/DisCatSharp.Snippets)

----

## NuGet Packages

### Main

| Package                         | Stable                                                                                                           | Nightly                                                                                                                             |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp                     | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.svg?label=&amp;logo=nuget&amp;style=flat-square)                     | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)                     |
| DisCatSharp.ApplicationCommands | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.ApplicationCommands.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.ApplicationCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |
| DisCatSharp.CommandsNext        | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.CommandsNext.svg?label=&amp;logo=nuget&amp;style=flat-square)        | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.CommandsNext.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)        |
| DisCatSharp.Interactivity       | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Interactivity.svg?label=&amp;logo=nuget&amp;style=flat-square)       | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Interactivity.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)       |

### Voice

| Package                       | Stable                                                                                                         | Nightly                                                                                                                           |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Lavalink          | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Lavalink.svg?label=&amp;logo=nuget&amp;style=flat-square)          | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Lavalink.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)          |
| DisCatSharp.VoiceNext         | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.VoiceNext.svg?label=&amp;logo=nuget&amp;style=flat-square)         | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.VoiceNext.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)         |
| DisCatSharp.VoiceNext.Natives | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.VoiceNext.Natives.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.VoiceNext.Natives.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |

### Hosting

| Package                                 | Stable                                                                                                                   | Nightly                                                                                                                                     |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Configuration               | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Configuration.svg?label=&amp;logo=nuget&amp;style=flat-square)               | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Configuration.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square)               |
| DisCatSharp.Hosting                     | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Hosting.svg?label=&amp;logo=nuget&amp;style=flat-square)                     | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Hosting.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square)                     |
| DisCatSharp.Hosting.DependencyInjection | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Hosting.DependencyInjection.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Hosting.DependencyInjection.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square) |

### Templates

| Package                                                                                         | Stable                                                                                                        | Nightly                                                                                                                          |
| ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| [DisCatSharp.ProjectTemplates](https://github.com/Aiko-IT-Systems/DisCatSharp.ProjectTemplates) | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.ProjectTemplates.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.ProjectTemplates.svg?label=&amp;logo=nuget&amp;color=%23ff1493&amp;style=flat-square) |

### Development / Commons

| Package                | Stable                                                                                                  | Nightly                                                                                                                    |
| ---------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Attributes | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Attributes.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Attributes.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |
| DisCatSharp.Common     | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Common.svg?label=&amp;logo=nuget&amp;style=flat-square)     | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Common.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)     |
| DisCatSharp.Analyzer   | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Analyzer.svg?label=&amp;logo=nuget&amp;style=flat-square)   | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Analyzer.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)   |

### [Extensions](https://github.com/Aiko-IT-Systems/DisCatSharp.Extensions)

| Package                                    | Stable                                                                                                                      | Nightly                                                                                                                                        |
| ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| DisCatSharp.Extensions.TwoFactorCommands   | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.TwoFactorCommands.svg?label=&amp;logo=nuget&amp;style=flat-square)   | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.TwoFactorCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)   |
| DisCatSharp.Extensions.OAuth2Web           | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.OAuth2Web.svg?label=&amp;logo=nuget&amp;style=flat-square)           | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.OAuth2Web.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493)           |
| DisCatSharp.Extensions.SimpleMusicCommands | ![NuGet](https://img.shields.io/nuget/v/DisCatSharp.Extensions.SimpleMusicCommands.svg?label=&amp;logo=nuget&amp;style=flat-square) | ![NuGet](https://img.shields.io/nuget/vpre/DisCatSharp.Extensions.SimpleMusicCommands.svg?label=&amp;logo=nuget&amp;style=flat-square&amp;color=%23ff1493) |


----

## Sponsors (Current &amp; Past)

- [Dei](https://github.com/DeividasKaza)
- [Will](https://github.com/villChurch)
- [SavageVictor](https://github.com/SavageVictor)
- [Schattenclown](https://github.com/Schattenclown)
- [FabiChan99](https://github.com/FabiChan99)

## Thanks

Big thanks goes to the following people who helped us without being part of the core team ♥️
- [Auros Nexus](https://github.com/Auros)
- [Lunar Starstrum](https://github.com/OoLunar)
- [Geferon](https://github.com/geferon)
- [Alice](https://github.com/QuantuChi)
- [Will](https://github.com/villChurch)
- [InFTord](https://github.com/InFTord)

## Special Thanks

The special thanks goes to Nagisa. Make sure to check out her [Instagram](https://www.instagram.com/nagisaarts_/) ♥️♥️

The second special thanks goes to [Sentry](https://sentry.io) ([GitHub](https://github.com/getsentry/)) for sponsering us a business account on sentry for error tracking.
You guys are the best 💕⭐

## Open Source License Status

[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2FAiko-IT-Systems%2FDisCatSharp.svg?type=large)](https://app.fossa.com/reports/d18d903c-f217-4d82-a7ec-e113fb147275?ref=badge_large)</file><file path="DisCatSharp.ApplicationCommands/Context/BaseContext.cs">/// &lt;summary&gt;
///     Represents a base context for application command contexts.
/// &lt;/summary&gt;
public class BaseContext : DisCatSharpCommandContext
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;BaseContext&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The command type.&lt;/param&gt;
⋮----
///     Gets the interaction that was created.
⋮----
///     Gets the guild this interaction was executed in.
⋮----
///     Gets the channel this interaction was executed in.
⋮----
///     Gets the user which executed this interaction.
⋮----
///     Gets the member which executed this interaction, or null if the command is in a DM.
⋮----
///     Gets the application command module this interaction was created in.
⋮----
///     Gets the token for this interaction.
⋮----
///     Gets the id for this interaction.
⋮----
///     Gets the full command string, including the subcommand.
⋮----
=&gt; $&quot;{this.CommandName}{(string.IsNullOrWhiteSpace(this.SubCommandName) ? &quot;&quot; : $&quot; {this.SubCommandName}&quot;)}{(string.IsNullOrWhiteSpace(this.SubSubCommandName) ? &quot;&quot; : $&quot; {this.SubSubCommandName}&quot;)}&quot;;
⋮----
///     Gets the invoking user locale.
⋮----
///     Gets the guild locale if applicable.
⋮----
///     Gets the attachment size limit in bytes.
⋮----
///     Gets the applications permissions.
⋮----
///     &lt;para&gt;Gets the entitlements.&lt;/para&gt;
///     &lt;para&gt;This is related to premium subscriptions for bots.&lt;/para&gt;
///     &lt;para&gt;
///         &lt;note type=&quot;warning&quot;&gt;Can only be used if you have an associated application subscription sku.&lt;/note&gt;
///     &lt;/para&gt;
⋮----
///     Gets the type of this interaction.
⋮----
///     &lt;para&gt;Gets the service provider.&lt;/para&gt;
///     &lt;para&gt;This allows passing data around without resorting to static members.&lt;/para&gt;
///     &lt;para&gt;Defaults to an empty service provider.&lt;/para&gt;
⋮----
public IServiceProvider Services { get; internal set; } = new ServiceCollection().BuildServiceProvider(true);
⋮----
///     Gets or sets the service scope for this command execution.
///     Used internally for proper disposal of scoped services.
⋮----
///     Creates a response to this interaction.
⋮----
///         You must create a response within 3 seconds of this interaction being executed; if the command has the
///         potential to take more than 3 seconds, create a
///         &lt;see cref=&quot;InteractionResponseType.DeferredChannelMessageWithSource&quot; /&gt; at the start, and edit the response
///         later.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type of the response.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The data to be sent, if any.&lt;/param&gt;
/// &lt;param name=&quot;modifyMode&quot;&gt;The modify mode. Only useful for &lt;see cref=&quot;InteractionResponseType.UpdateMessage&quot;/&gt;.&lt;/param&gt;
/// &lt;returns&gt;
///     The created &lt;see cref=&quot;DiscordMessage&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if &lt;paramref name=&quot;type&quot; /&gt; creates no
///     content.
/// &lt;/returns&gt;
public async Task&lt;DiscordInteractionCallbackResponse&gt; CreateResponseAsync(InteractionResponseType type, DiscordInteractionResponseBuilder? builder = null, ModifyMode modifyMode = ModifyMode.Update)
=&gt; await this.Interaction.CreateResponseAsync(type, builder, modifyMode);
⋮----
///     Creates a modal response to this interaction.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The data to send.&lt;/param&gt;
public Task CreateModalResponseAsync(DiscordInteractionModalBuilder builder)
=&gt; this.Interaction.Type is not InteractionType.Ping &amp;&amp; this.Interaction.Type is not InteractionType.ModalSubmit ? this.Interaction.CreateInteractionModalResponseAsync(builder) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with a modal.&quot;);
⋮----
///     Creates an iframe response to this interaction.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;title&quot;&gt;The title of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;modalSize&quot;&gt;The size of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;iFramePath&quot;&gt;The path of the iframe.&lt;/param&gt;
public Task CreateInteractionIframeResponseAsync(string customId, string title, IframeModalSize modalSize = IframeModalSize.Normal, string? iFramePath = null)
=&gt; this.Interaction.Type is not InteractionType.Ping ? this.Interaction.CreateInteractionIframeResponseAsync(customId, title, modalSize, iFramePath) : throw new NotSupportedException(&quot;You can&apos;t respond to a PING with an iframe.&quot;);
⋮----
///     Edits the interaction response.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The data to edit the response with.&lt;/param&gt;
/// &lt;param name=&quot;modifyMode&quot;&gt;The modify mode.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public Task&lt;DiscordMessage&gt; EditResponseAsync(DiscordWebhookBuilder builder, ModifyMode modifyMode = ModifyMode.Update)
=&gt; this.Interaction.EditOriginalResponseAsync(builder, modifyMode);
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content to edit the response with.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; EditResponseAsync(string content)
=&gt; this.Interaction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(content));
⋮----
///     Deletes the interaction response.
⋮----
public Task DeleteResponseAsync()
=&gt; this.Interaction.DeleteOriginalResponseAsync();
⋮----
///     Creates a follow up message to the interaction.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The message to be sent, in the form of a webhook.&lt;/param&gt;
/// &lt;returns&gt;The created message.&lt;/returns&gt;
public Task&lt;DiscordMessage&gt; FollowUpAsync(DiscordFollowupMessageBuilder builder)
=&gt; this.Interaction.CreateFollowupMessageAsync(builder);
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content of the message to be sent.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; FollowUpAsync(string content)
=&gt; this.FollowUpAsync(new DiscordFollowupMessageBuilder().WithContent(content));
⋮----
///     Edits a followup message.
⋮----
/// &lt;param name=&quot;followupMessageId&quot;&gt;The id of the followup message to edit.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The webhook builder.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; EditFollowupAsync(ulong followupMessageId, DiscordWebhookBuilder builder, ModifyMode modifyMode = ModifyMode.Update)
=&gt; this.Interaction.EditFollowupMessageAsync(followupMessageId, builder, modifyMode);
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content of the webhook.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; EditFollowupAsync(ulong followupMessageId, string content)
=&gt; this.EditFollowupAsync(followupMessageId, new DiscordWebhookBuilder().WithContent(content));
⋮----
///     Deletes a followup message.
⋮----
/// &lt;param name=&quot;followupMessageId&quot;&gt;The id of the followup message to delete.&lt;/param&gt;
⋮----
public Task DeleteFollowupAsync(ulong followupMessageId)
=&gt; this.Interaction.DeleteFollowupMessageAsync(followupMessageId);
⋮----
///     Gets the followup message.
⋮----
/// &lt;param name=&quot;followupMessageId&quot;&gt;The followup message id.&lt;/param&gt;
public Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong followupMessageId)
=&gt; this.Interaction.GetFollowupMessageAsync(followupMessageId);
⋮----
///     Gets the original interaction response.
⋮----
/// &lt;returns&gt;The original interaction response.&lt;/returns&gt;
public Task&lt;DiscordMessage&gt; GetOriginalResponseAsync()
=&gt; this.Interaction.GetOriginalResponseAsync();</file><file path="DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.ApplicationCommands&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.ApplicationCommands&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.ApplicationCommands&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Application Commands Extension

			Use it on top of your DisCatSharp powered bot and unleash the power of application commands in discord.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/application_commands/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Application Commands,Context Menu Commands&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.CommandsNext&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.CommandsNext&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.CommandsNext&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Commands Next Extension

			Allow your users to use text commands in your bot.

			Note: Requires the Message Content Intent enabled for your discord application.
			Documentation: https://docs.dcs.aitsys.dev/articles/modules/commandsnext/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Text Commands&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Common/DisCatSharp.Common.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Common&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Common&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;True&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Common&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Common Extension

			Common tools for DisCatSharp, like regexes and converters!
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Common Tools&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Maui.Graphics&quot; Version=&quot;9.0.90&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Maui.Graphics.Skia&quot; Version=&quot;9.0.90&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Collections.Immutable&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Runtime.CompilerServices.Unsafe&quot; Version=&quot;6.1.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.ValueTuple&quot; Version=&quot;4.6.1&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Configuration/DisCatSharp.Configuration.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;RootNamespace&gt;DisCatSharp.Configuration&lt;/RootNamespace&gt;
		&lt;AssemblyName&gt;DisCatSharp.Configuration&lt;/AssemblyName&gt;
		&lt;GenerateDocumentationFile&gt;True&lt;/GenerateDocumentationFile&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Configuration&lt;/PackageId&gt;
		&lt;Description&gt;Configuration for the DisCatSharp Hosting Extension.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Hosting,Web,Configuration&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Binder&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Docs/articles/modules/application_commands/paginated_modals.md">---
uid: modules_application_commands_paginated_modals
title: Paginated Modals
---

# Paginated Modals

**The package `DisCatSharp.Interactivity` is required for this to work.**

You may need multi-step modals to collect a variety of information from a user. We implemented an easy way of doing this with paginated modals.
You simply construct all your modals, call `DiscordInteraction.CreatePaginatedModalResponseAsync` and you&apos;re good to go. After the user submitted all modals, you&apos;ll get back a `PaginatedModalResponse` which has a `TimedOut` bool, the `DiscordInteraction` that was used to submit the last modal and a `IReadOnlyDictionary&lt;string, string&gt;` with the component custom ids as key.

The code below shows an example application command on how this could look.

```cs
using DisCatSharp.Interactivity;
using DisCatSharp.Interactivity.Enums;
using DisCatSharp.Interactivity.Extensions;
```

```cs
[SlashCommand(&quot;paginated-modals&quot;, &quot;Paginated modals!&quot;)]
public async Task PaginatedModals(InteractionContext ctx)
{
    _ = Task.Run(async () =&gt;
    {
        var responses = await ctx.Interaction.CreatePaginatedModalResponseAsync(
            new List&lt;ModalPage&gt;()
            {
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;First Modal&quot;)
                    .AddLabelComponent(new DiscordLabelComponent(&quot;First Label&quot;).WithTextComponent(new DiscordTextComponent(TextComponentStyle.Small, &quot;title&quot;, &quot;Placeholder&quot;, 0, 250, false)))),
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;Second Modal&quot;)
                    .AddLabelComponent(new DiscordLabelComponent(&quot;Second Title&quot;).WithTextComponent(new DiscordTextComponent(TextComponentStyle.Small, &quot;title_1&quot;, &quot;Placeholder 1&quot;, 0, 250, false))),
                    .AddLabelComponent(new DiscordLabelComponent(&quot;Second Description&quot;).WithTextComponent(new DiscordTextComponent(TextComponentStyle.Paragraph, &quot;description_1&quot;, &quot;Some bigger Placeholder here&quot;, required: false)))),
                new ModalPage(new DiscordInteractionModalBuilder().WithTitle(&quot;Third Modal&quot;)
                    .AddLabelComponent(new DiscordLabelComponent(&quot;Third Title&quot;).WithTextComponent(new DiscordTextComponent(TextComponentStyle.Small, &quot;title_2&quot;, &quot;Placeholder 2&quot;, 0, 250, false)))
                    .AddLabelComponent(new DiscordLabelComponent(&quot;Third Description&quot;).WithTextComponent(new DiscordTextComponent(TextComponentStyle.Paragraph, &quot;description_2&quot;, &quot;Some placeholder here&quot;, required: false)))),
            });

        // If the user didn&apos;t submit all modals, TimedOut will be true. We return the command as there is nothing to handle.
        if (responses.TimedOut)
            return;

        // We simply throw all response into the Console, you can do whatever with this.
        foreach (var b in responses.Responses.Values)
            Console.WriteLine(b.ToString());

        /*
        // You can also receive select values
        foreach (var b in responses.SelectResponses.Values)
            Console.WriteLine(string.Join(&quot;, &quot;, b.Select(x =&gt; x.ToString())));
        */

        // We use EditOriginalResponseAsync here because CreatePaginatedModalResponseAsync responds to the last modal with a thinking state.
        await responses.Interaction.EditOriginalResponseAsync(new DiscordWebhookBuilder().WithContent(&quot;Success&quot;));
    });
}
```</file><file path="DisCatSharp.Hosting.DependencyInjection/DisCatSharp.Hosting.DependencyInjection.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Hosting.DependencyInjection&lt;/PackageId&gt;
		&lt;Description&gt;Dependency Injection for the DisCatSharp Hosting Extension.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Hosting,Web,Dependency Injection&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Hosting/DisCatSharp.Hosting.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Hosting&lt;/PackageId&gt;
		&lt;Description&gt;Hosting Extension for DisCatSharp.&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Hosting,Web&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Interactivity&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Interactivity&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Interactivity&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Interactivity Extension

			Unleash the full power of discord commands.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/interactivity.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Pagination,Reactions,Buttons,Interactive Commands,Interactivity,Message Components&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
		&lt;PackageReference Include=&quot;ConcurrentHashSet&quot; Version=&quot;1.3.0&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Lavalink&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Lavalink&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.Lavalink&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Lavalink V4 Extension

			Extend your bot with the full power of lavalink.
			Play your favorite music in discord!

			Requires Lavalink Server v4

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/audio/lavalink_v4/intro.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Voice,Lavalink,Lavalink V4,Audio Player,Music,YouTube,Spotify,SoundCloud,Twitch,Vimeo,BandCamp,Apple Music,Yandex Music,Spotify,Spotify Recommendations,Deezer,Deezer ISRC,Local Music,Direct Url Music&lt;/PackageTags&gt;

	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.slnx">&lt;Solution&gt;
  &lt;Folder Name=&quot;/.github/&quot;&gt;
    &lt;File Path=&quot;.github/CODEOWNERS&quot; /&gt;
    &lt;File Path=&quot;.github/labeler.yml&quot; /&gt;
    &lt;File Path=&quot;.github/pull_request_template.md&quot; /&gt;
    &lt;File Path=&quot;.github/SECURITY.md&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Folder Name=&quot;/.github/workflows/&quot; Id=&quot;e7a3c856-6834-d657-f2f0-05592df2dde9&quot;&gt;
    &lt;File Path=&quot;.github/workflows/build.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/codeql-analysis.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/create_diagram.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/documentation.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/documentation_test.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/internal-release.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/labeler.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/public-dev-release.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/release.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/sentry.yml&quot; /&gt;
    &lt;File Path=&quot;.github/workflows/tweet.yml&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Folder Name=&quot;/Build Items/&quot; /&gt;
  &lt;Folder Name=&quot;/Build Items/Targets/&quot; Id=&quot;907a4610-bc9a-5508-808f-fa4105980a5f&quot;&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/Library.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/NuGet.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/Package.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/TestProject.targets&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Targets/Version.targets&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Folder Name=&quot;/Build Items/Tools/&quot; Id=&quot;e012d126-a562-2860-43ed-9b91994c4d92&quot;&gt;
    &lt;File Path=&quot;DisCatSharp.Tools/DisCatSharp.ruleset&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Tools/pack-docs.ps1&quot; /&gt;
    &lt;File Path=&quot;DisCatSharp.Tools/rebuild-lib.ps1&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Folder Name=&quot;/Solution Items/&quot;&gt;
    &lt;File Path=&quot;.editorconfig&quot; /&gt;
    &lt;File Path=&quot;.gitattributes&quot; /&gt;
    &lt;File Path=&quot;.gitignore&quot; /&gt;
    &lt;File Path=&quot;BUILDING.md&quot; /&gt;
    &lt;File Path=&quot;CONTRIBUTING.md&quot; /&gt;
    &lt;File Path=&quot;LICENSE.md&quot; /&gt;
    &lt;File Path=&quot;README.md&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Folder Name=&quot;/Tests/&quot;&gt;
    &lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/DisCatSharp.ApplicationCommands.Tests.csproj&quot; /&gt;
    &lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.Configuration.Tests/DisCatSharp.Configuration.Tests.csproj&quot; /&gt;
    &lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/DisCatSharp.EventHandlers.Tests.csproj&quot; /&gt;
    &lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.Hosting.Tests/DisCatSharp.Hosting.Tests.csproj&quot; /&gt;
    &lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.SafetyTests/DisCatSharp.SafetyTests.csproj&quot; /&gt;
	&lt;Project Path=&quot;DisCatSharp.Tests/DisCatSharp.CopilotTests/DisCatSharp.CopilotTests.csproj&quot; /&gt;
  &lt;/Folder&gt;
  &lt;Project Path=&quot;DisCatSharp.ApplicationCommands/DisCatSharp.ApplicationCommands.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.CommandsNext/DisCatSharp.CommandsNext.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Common/DisCatSharp.Common.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Configuration/DisCatSharp.Configuration.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Experimental/DisCatSharp.Experimental.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Hosting.DependencyInjection/DisCatSharp.Hosting.DependencyInjection.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Hosting/DisCatSharp.Hosting.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Interactivity/DisCatSharp.Interactivity.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.Lavalink/DisCatSharp.Lavalink.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.VoiceNext.Natives/DisCatSharp.VoiceNext.Natives.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj&quot; /&gt;
  &lt;Project Path=&quot;DisCatSharp/DisCatSharp.csproj&quot; /&gt;
&lt;/Solution&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.CopilotTests/DisCatSharp.CopilotTests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.SafetyTests/DisCatSharp.SafetyTests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;8.5.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.14.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Scripting&quot; Version=&quot;4.14.0&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.VoiceNext/DisCatSharp.VoiceNext.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.VoiceNext&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.VoiceNext&lt;/RootNamespace&gt;
		&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp.VoiceNext&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp Voice Next Extension

			Easy made audio player for discord bots.

			Documentation: https://docs.dcs.aitsys.dev/articles/modules/audio/voicenext/prerequisites.html
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10,Voice,Audio Player&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Threading.Channels&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp/Clients/DiscordClient.Dispatch.cs">/// &lt;summary&gt;
///     Represents the dispatch handler.
/// &lt;/summary&gt;
public sealed partial class DiscordClient
⋮----
///     Handles the dispatch payloads.
⋮----
/// &lt;param name=&quot;payload&quot;&gt;The payload.&lt;/param&gt;
internal async Task HandleDispatchAsync(GatewayPayload payload)
⋮----
this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Invalid payload body (this message is probably safe to ignore); opcode: {op} event: {event}; payload: {payload}&quot;, payload.OpCode, payload.EventName, payload.Data);
⋮----
await this._payloadReceived.InvokeAsync(this, new(this.ServiceProvider)
⋮----
}).ConfigureAwait(false);
⋮----
var payloadString = dat.ToString();
DiscordChannel chn;
⋮----
DiscordStageInstance stg = default;
DiscordIntegration itg = default;
DiscordThreadChannel trd = default;
DiscordThreadChannelMember trdm = default;
DiscordScheduledEvent gse = default;
TransportUser usr = default;
TransportMember mbr = default;
TransportUser refUsr = default;
TransportMember refMbr = default;
DiscordApplicationCommand ac = default;
DiscordEntitlement ent = default;
DiscordSubscription sub = default;
JToken rawMbr = default;
DiscordGuildJoinRequest joinRequest = default;
JoinRequestStatusType joinRequestStatusType = default;
var rawRefMsg = dat[&quot;referenced_message&quot;]; // TODO: Can we remove this?
⋮----
switch (payload.EventName.ToLowerInvariant())
⋮----
await this.OnReadyEventAsync(dat!.ToObject&lt;ReadyPayload&gt;()!, glds).ConfigureAwait(false);
⋮----
await this.OnResumedAsync().ConfigureAwait(false);
⋮----
await this.OnChannelCreateEventAsync(chn).ConfigureAwait(false);
⋮----
await this.OnChannelUpdateEventAsync(chn).ConfigureAwait(false);
⋮----
await this.OnChannelDeleteEventAsync(chn.IsPrivate ? chn as DiscordDmChannel : chn).ConfigureAwait(false);
⋮----
await this.OnChannelPinsUpdateAsync((ulong?)dat[&quot;guild_id&quot;], cid, ts != null ? DateTimeOffset.Parse(ts, CultureInfo.InvariantCulture) : default(DateTimeOffset?)).ConfigureAwait(false);
⋮----
await this.OnVoiceChannelStatusUpdateAsync((ulong)dat[&quot;guild_id&quot;], cid, voiceChannelStatus).ConfigureAwait(false);
⋮----
// It&apos;s fired incorrectly.
⋮----
await this.OnGuildCreateEventAsync(dat.ToDiscordObject&lt;DiscordGuild&gt;(), (JArray)dat[&quot;members&quot;]!, dat[&quot;presences&quot;]!.ToDiscordObject&lt;IEnumerable&lt;DiscordPresence&gt;&gt;()).ConfigureAwait(false);
⋮----
await this.OnGuildUpdateEventAsync(dat.ToDiscordObject&lt;DiscordGuild&gt;(), (JArray)dat[&quot;members&quot;]!).ConfigureAwait(false);
⋮----
await this.OnGuildDeleteEventAsync(DiscordJson.DeserializeObject&lt;DiscordGuild&gt;(payloadString, this)).ConfigureAwait(false);
⋮----
dat.Remove(&quot;guild_id&quot;);
await this.OnGuildAuditLogEntryCreateEventAsync(this.GuildsInternal[gid], dat).ConfigureAwait(false);
⋮----
await this.OnGuildSyncEventAsync(this.GuildsInternal[gid], (bool)dat[&quot;large&quot;]!, (JArray)dat[&quot;members&quot;]!, dat[&quot;presences&quot;]!.ToDiscordObject&lt;IEnumerable&lt;DiscordPresence&gt;&gt;()).ConfigureAwait(false);
⋮----
await this.OnGuildEmojisUpdateEventAsync(this.GuildsInternal[gid], ems).ConfigureAwait(false);
⋮----
await this.OnStickersUpdatedAsync(strs, gid).ConfigureAwait(false);
⋮----
// discord fires this event inconsistently if the current user leaves a guild.
if (!this.GuildsInternal.TryGetValue(gid, out var value))
⋮----
await this.OnGuildIntegrationsUpdateEventAsync(value).ConfigureAwait(false);
⋮----
await this.OnAutomodRuleCreated(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
⋮----
await this.OnAutomodRuleUpdated(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
⋮----
await this.OnAutomodRuleDeleted(dat.ToDiscordObject&lt;AutomodRule&gt;()).ConfigureAwait(false);
⋮----
await this.OnAutomodActionExecuted(this.GuildsInternal[gid], dat).ConfigureAwait(false);
⋮----
usr = DiscordJson.DeserializeObject&lt;TransportUser&gt;(dat[&quot;user&quot;]!.ToString(), this);
⋮----
await this.OnGuildBanAddEventAsync(usr, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildBanRemoveEventAsync(usr, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildScheduledEventCreateEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildScheduledEventUpdateEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildScheduledEventDeleteEventAsync(gse, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildScheduledEventUserAddedEventAsync((ulong)dat[&quot;guild_scheduled_event_id&quot;]!, uid, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildScheduledEventUserRemovedEventAsync((ulong)dat[&quot;guild_scheduled_event_id&quot;]!, uid, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
if (!this.GuildsInternal.TryGetValue(gid, out var icGuildVal))
⋮----
await this.OnGuildIntegrationCreateEventAsync(icGuildVal, itg).ConfigureAwait(false);
⋮----
if (!this.GuildsInternal.TryGetValue(gid, out var iuGuildVal))
⋮----
await this.OnGuildIntegrationUpdateEventAsync(iuGuildVal, itg).ConfigureAwait(false);
⋮----
if (!this.GuildsInternal.TryGetValue(gid, out var idGuildVal))
⋮----
await this.OnGuildIntegrationDeleteEventAsync(idGuildVal, (ulong)dat[&quot;id&quot;], (ulong?)dat[&quot;application_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnGuildMemberAddEventAsync(DiscordJson.DeserializeObject&lt;TransportMember&gt;(payloadString, this), this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
if (!this.GuildsInternal.TryGetValue(gid, out var gmrGuildVal))
⋮----
this.Logger.LogError(LoggerEvents.WebSocketReceive, &quot;Could not find {0} in guild cache&quot;, gid);
⋮----
await this.OnGuildMemberRemoveEventAsync(usr, gmrGuildVal).ConfigureAwait(false);
⋮----
await this.OnGuildMemberUpdateEventAsync(DiscordJson.DeserializeObject&lt;TransportMember&gt;(payloadString, this), this.GuildsInternal[gid], dat[&quot;roles&quot;]!.ToObject&lt;IEnumerable&lt;ulong&gt;&gt;()!, (string)dat[&quot;nick&quot;]!, (bool?)dat[&quot;pending&quot;]).ConfigureAwait(false);
⋮----
await this.OnGuildMembersChunkEventAsync(dat).ConfigureAwait(false);
⋮----
await this.OnGuildRoleCreateEventAsync(DiscordJson.DeserializeObject&lt;DiscordRole&gt;(dat[&quot;role&quot;]!.ToString(), this), this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildRoleUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordRole&gt;(dat[&quot;role&quot;]!.ToString(), this), this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildRoleDeleteEventAsync((ulong)dat[&quot;role_id&quot;]!, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnGuildSoundboardSoundCreateEventAsync(DiscordJson.DeserializeObject&lt;DiscordSoundboardSound&gt;(dat.ToString(), this), gid).ConfigureAwait(false);
⋮----
await this.OnGuildSoundboardSoundUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordSoundboardSound&gt;(dat.ToString(), this), gid).ConfigureAwait(false);
⋮----
await this.OnGuildSoundboardSoundDeleteEventAsync(Convert.ToUInt64(dat[&quot;sound_id&quot;]!.ToString()), gid).ConfigureAwait(false);
⋮----
await this.OnGuildSoundboardSoundsUpdateEventAsync(DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordSoundboardSound&gt;&gt;(dat[&quot;soundboard_sounds&quot;]!.ToString(), this), gid).ConfigureAwait(false);
⋮----
var sounds = DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordSoundboardSound&gt;&gt;(dat[&quot;soundboard_sounds&quot;].ToString(), this);
await this.OnSoundboardSoundsEventAsync(sounds, gid).ConfigureAwait(false);
⋮----
// TODO: This is so fucked..
⋮----
await this.OnGuildJoinRequestCreateAsync(this.Guilds[gid], joinRequestStatusType, joinRequest).ConfigureAwait(false);
⋮----
await this.OnGuildJoinRequestUpdateAsync(this.Guilds[gid], joinRequestStatusType, joinRequest).ConfigureAwait(false);
⋮----
await this.OnGuildJoinRequestDeleteAsync(requestId, uid, this.Guilds[gid]).ConfigureAwait(false);
⋮----
await this.OnInviteCreateEventAsync(cid, gid, DiscordJson.DeserializeObject&lt;DiscordInvite&gt;(payloadString, this)).ConfigureAwait(false);
⋮----
await this.OnInviteDeleteEventAsync(cid, gid, dat).ConfigureAwait(false);
⋮----
await this.OnMessageAckEventAsync(this.InternalGetCachedChannel(cid) ?? this.InternalGetCachedThread(cid), mid).ConfigureAwait(false);
⋮----
mbr = DiscordJson.DeserializeObject&lt;TransportMember&gt;(rawMbr.ToString(), this);
⋮----
if (rawRefMsg.SelectToken(&quot;author&quot;) != null)
refUsr = DiscordJson.DeserializeObject&lt;TransportUser&gt;(rawRefMsg.SelectToken(&quot;author&quot;)!.ToString(), this);
⋮----
if (rawRefMsg.SelectToken(&quot;member&quot;) != null)
refMbr = DiscordJson.DeserializeObject&lt;TransportMember&gt;(rawRefMsg.SelectToken(&quot;member&quot;)!.ToString(), this);
⋮----
await this.OnMessageCreateEventAsync(dat.ToDiscordObject&lt;DiscordMessage&gt;(), dat[&quot;author&quot;]!.ToObject&lt;TransportUser&gt;(), mbr!, refUsr!, refMbr!).ConfigureAwait(false);
⋮----
await this.OnMessageUpdateEventAsync(DiscordJson.DeserializeObject&lt;DiscordMessage&gt;(payloadString, this), dat[&quot;author&quot;] != null ? DiscordJson.DeserializeObject&lt;TransportUser&gt;(dat[&quot;author&quot;]!.ToString(), this) : null!, mbr!, refUsr!, refMbr!).ConfigureAwait(false);
⋮----
// delete event does *not* include message object
⋮----
await this.OnMessageDeleteEventAsync((ulong)dat[&quot;id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnMessageBulkDeleteEventAsync(dat[&quot;ids&quot;]!.ToObject&lt;ulong[]&gt;()!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnMessagePollVoteAddEventAsync(dat).ConfigureAwait(false);
⋮----
await this.OnMessagePollVoteRemoveEventAsync(dat).ConfigureAwait(false);
⋮----
// TODO: Add burst stuff
await this.OnMessageReactionAddAsync((ulong)dat[&quot;user_id&quot;]!, (ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;], mbr, DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this), (bool)dat[&quot;burst&quot;]!).ConfigureAwait(false);
⋮----
await this.OnMessageReactionRemoveAsync((ulong)dat[&quot;user_id&quot;]!, (ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;], DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this), (bool)dat[&quot;burst&quot;]!).ConfigureAwait(false);
⋮----
await this.OnMessageReactionRemoveAllAsync((ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnMessageReactionRemoveEmojiAsync((ulong)dat[&quot;message_id&quot;]!, (ulong)dat[&quot;channel_id&quot;]!, (ulong)dat[&quot;guild_id&quot;]!, DiscordJson.DeserializeObject&lt;DiscordEmoji&gt;(dat[&quot;emoji&quot;]!.ToString(), this)).ConfigureAwait(false);
⋮----
await this.OnStageInstanceCreateEventAsync(stg).ConfigureAwait(false);
⋮----
await this.OnStageInstanceUpdateEventAsync(stg).ConfigureAwait(false);
⋮----
await this.OnStageInstanceDeleteEventAsync(stg).ConfigureAwait(false);
⋮----
await this.OnThreadCreateEventAsync(trd).ConfigureAwait(false);
⋮----
await this.OnThreadUpdateEventAsync(trd).ConfigureAwait(false);
⋮----
await this.OnThreadDeleteEventAsync(trd).ConfigureAwait(false);
⋮----
var trds = DiscordJson.DeserializeIEnumerableObject&lt;IReadOnlyList&lt;DiscordThreadChannel&gt;&gt;(dat[&quot;threads&quot;]!.ToString(), this);
var trms = DiscordJson.DeserializeIEnumerableObject&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt;(dat[&quot;members&quot;]!.ToString(), this);
await this.OnThreadListSyncEventAsync(this.GuildsInternal[gid], dat[&quot;channel_ids&quot;]!.ToObject&lt;IReadOnlyList&lt;ulong?&gt;&gt;()!, trds, trms).ConfigureAwait(false);
⋮----
await this.OnThreadMemberUpdateEventAsync(trdm).ConfigureAwait(false);
⋮----
await this.OnThreadMembersUpdateEventAsync(this.GuildsInternal[gid], (ulong)dat[&quot;id&quot;]!, (JArray)dat[&quot;added_members&quot;]!, (JArray)dat[&quot;removed_member_ids&quot;]!, (int)dat[&quot;member_count&quot;]!).ConfigureAwait(false);
⋮----
await this.OnEmbeddedActivityUpdateAsync((JObject)dat[&quot;embedded_activity&quot;]!, this.GuildsInternal[gid], cid, (JArray)dat[&quot;users&quot;]!, (ulong)dat[&quot;embedded_activity&quot;][&quot;application_id&quot;]!).ConfigureAwait(false);
⋮----
await this.OnPresenceUpdateEventAsync(dat, (JObject)dat[&quot;user&quot;]!).ConfigureAwait(false);
⋮----
await this.OnUserSettingsUpdateEventAsync(usr).ConfigureAwait(false);
⋮----
await this.OnUserUpdateEventAsync(usr).ConfigureAwait(false);
⋮----
await this.OnVoiceStateUpdateEventAsync(dat).ConfigureAwait(false);
⋮----
await this.OnVoiceServerUpdateEventAsync((string)dat[&quot;endpoint&quot;]!, (string)dat[&quot;token&quot;]!, this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnVoiceChannelEffectSendEventAsync(gid, cid, uid, dat);
⋮----
// Console.WriteLine(dat.ToString()); // Get raw interaction payload.
await this.OnInteractionCreateAsync((ulong?)dat[&quot;guild_id&quot;], cid, usr, mbr, DiscordJson.DeserializeObject&lt;DiscordInteraction&gt;(payloadString, this), payloadString).ConfigureAwait(false);
⋮----
await this.OnApplicationCommandCreateAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnApplicationCommandUpdateAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnApplicationCommandDeleteAsync(ac, (ulong?)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
await this.OnGuildApplicationCommandCountsUpdateAsync((int)counts[&quot;1&quot;], (int)counts[&quot;2&quot;], (int)counts[&quot;3&quot;], (ulong)dat[&quot;guild_id&quot;]).ConfigureAwait(false);
⋮----
// TODO: Implement.
⋮----
var pms = DiscordJson.DeserializeIEnumerableObject&lt;IEnumerable&lt;DiscordApplicationCommandPermission&gt;&gt;(dat[&quot;permissions&quot;]!.ToString(), this);
⋮----
await this.OnApplicationCommandPermissionsUpdateAsync(pms, (ulong)dat[&quot;id&quot;]!, gid, aid).ConfigureAwait(false);
⋮----
case &quot;gift_code_update&quot;: //Not supposed to be dispatched to bots
⋮----
await this.OnTypingStartEventAsync((ulong)dat[&quot;user_id&quot;], cid, this.InternalGetCachedChannel(cid) ?? this.InternalGetCachedThread(cid), (ulong?)dat[&quot;guild_id&quot;], Utilities.GetDateTimeOffset((long)dat[&quot;timestamp&quot;]), mbr).ConfigureAwait(false);
⋮----
await this.OnWebhooksUpdateAsync(this.GuildsInternal[gid].GetChannel(cid), this.GuildsInternal[gid]).ConfigureAwait(false);
⋮----
await this.OnEntitlementCreateAsync(ent).ConfigureAwait(false);
⋮----
await this.OnEntitlementUpdateAsync(ent).ConfigureAwait(false);
⋮----
await this.OnEntitlementDeleteAsync(ent).ConfigureAwait(false);
⋮----
await this.OnSubscriptionCreateAsync(sub).ConfigureAwait(false);
⋮----
await this.OnSubscriptionUpdateAsync(sub).ConfigureAwait(false);
⋮----
await this.OnUnknownEventAsync(payload).ConfigureAwait(false);
this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Unknown event: {name}\npayload: {payload}&quot;, payload.EventName, dat.ToString(Formatting.Indented));
⋮----
///     /Gets the resume gateway url.
⋮----
///     Gets the session id.
⋮----
///     Gets whether the guild download has been completed.
⋮----
///     Gets the guild download completed lock.
⋮----
private readonly Lock _guildDownloadCompletedLock = new();
⋮----
///     Handles the ready event.
⋮----
/// &lt;param name=&quot;ready&quot;&gt;The ready payload.&lt;/param&gt;
/// &lt;param name=&quot;rawGuilds&quot;&gt;The raw guilds.&lt;/param&gt;
internal async Task OnReadyEventAsync(ReadyPayload ready, JArray rawGuilds)
⋮----
var rawGuildIndex = rawGuilds.Any() ? rawGuilds.ToDictionary(xt =&gt; (ulong)xt[&quot;id&quot;]!, xt =&gt; (JObject)xt) : null;
⋮----
this.ReadyGuildIds.Clear();
this.ReadyGuildIds.AddRange(rawGuildIndex.Select(x =&gt; x.Key));
⋮----
this.GuildsInternal.Clear();
⋮----
xc.Initialize(this);
⋮----
guild.MembersInternal.Clear();
⋮----
var usr = new DiscordUser(xtm.User)
⋮----
usr = this.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
⋮----
this._guildDownloadCompletedLock.Enter();
Volatile.Write(ref this._guildDownloadCompleted, true);
this._guildDownloadCompletedLock.Exit();
⋮----
await this.GuildDownloadCompletedEv.InvokeAsync(this, new(this.Guilds, true, this.ServiceProvider)).ConfigureAwait(false);
this.Logger.LogInformation(LoggerEvents.Startup, &quot;Application has no guilds. Firing GuildDownloadCompleted event for internal tools&quot;);
⋮----
await this.ReadyEv.InvokeAsync(this, new(this.ServiceProvider)).ConfigureAwait(false);
⋮----
///     Handles the resumed event.
⋮----
internal Task OnResumedAsync()
⋮----
this.Logger.LogInformation(LoggerEvents.SessionUpdate, &quot;Session resumed&quot;);
return this._resumed.InvokeAsync(this, new(this.ServiceProvider));
⋮----
///     Handles the channel create event.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
internal async Task OnChannelCreateEventAsync(DiscordChannel channel)
⋮----
channel.Initialize(this);
⋮----
/*if (this.Configuration.AutoRefreshChannelCache)
            {
                await this.RefreshChannelsAsync(channel.Guild.Id);
            }*/
⋮----
await this._channelCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the channel update event.
⋮----
internal async Task OnChannelUpdateEventAsync(DiscordChannel channel)
⋮----
var channelNew = this.InternalGetCachedChannel(channel.Id);
DiscordChannel channelOld = null;
⋮----
channelNew.PermissionOverwritesInternal.Clear();
⋮----
channelNew.PermissionOverwritesInternal.AddRange(channel.PermissionOverwritesInternal);
⋮----
channelNew.InternalAvailableTags.Clear();
⋮----
channelNew.InternalAvailableTags.AddRange(channel.InternalAvailableTags);
⋮----
channelOld.Initialize(this);
channelNew.Initialize(this);
⋮----
await this.RefreshChannelsAsync(channel.Guild.Id).ConfigureAwait(false);
⋮----
await this._channelUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the channel delete event.
⋮----
internal async Task OnChannelDeleteEventAsync(DiscordChannel channel)
⋮----
//if (channel.IsPrivate)
⋮----
await this._dmChannelDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
if (gld.ChannelsInternal.TryRemove(channel.Id, out var cachedChannel)) channel = cachedChannel;
⋮----
await this._channelDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Refreshes the channels.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id.&lt;/param&gt;
internal async Task RefreshChannelsAsync(ulong guildId)
⋮----
var guild = this.InternalGetCachedGuild(guildId);
var channels = await this.ApiClient.GetGuildChannelsAsync(guildId).ConfigureAwait(false);
guild.ChannelsInternal.Clear();
foreach (var channel in channels.ToList())
⋮----
///     Handles the channel pins update event.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The optional guild id.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;The channel id.&lt;/param&gt;
/// &lt;param name=&quot;lastPinTimestamp&quot;&gt;The optional last pin timestamp.&lt;/param&gt;
internal async Task OnChannelPinsUpdateAsync(ulong? guildId, ulong channelId, DateTimeOffset? lastPinTimestamp)
⋮----
var channel = this.InternalGetCachedChannel(channelId) ?? this.InternalGetCachedThread(channelId);
⋮----
var ea = new ChannelPinsUpdateEventArgs(this.ServiceProvider)
⋮----
await this._channelPinsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the voice channel status update event.
⋮----
/// &lt;param name=&quot;status&quot;&gt;The optional status.&lt;/param&gt;
internal async Task OnVoiceChannelStatusUpdateAsync(ulong guildId, ulong channelId, string? status)
⋮----
var channel = this.InternalGetCachedChannel(channelId);
⋮----
var ea = new VoiceChannelStatusUpdateEventArgs(this.ServiceProvider)
⋮----
await this._voiceChannelStatusUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild create event.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
/// &lt;param name=&quot;rawMembers&quot;&gt;The raw members.&lt;/param&gt;
/// &lt;param name=&quot;presences&quot;&gt;The presences.&lt;/param&gt;
internal async Task OnGuildCreateEventAsync(DiscordGuild guild, JArray rawMembers, IEnumerable&lt;DiscordPresence&gt;? presences)
⋮----
.Select(x =&gt; new DiscordActivity(x)).ToList();
⋮----
var exists = this.GuildsInternal.TryGetValue(guild.Id, out var foundGuild);
⋮----
this.UpdateCachedGuild(eventGuild, rawMembers);
⋮----
guild.MemberCount = Math.Max(eventGuild.MemberCount.Value, guild.MembersInternal.Count);
⋮----
this.GuildsInternal.TryAdd(guild.Id, guild);
⋮----
this.GuildsInternal.TryUpdate(guild.Id, guild, foundGuild);
⋮----
var old = Volatile.Read(ref this._guildDownloadCompleted);
var dcompl = this.GuildsInternal.Values.All(xg =&gt; xg.GuildReadyThrown);
Volatile.Write(ref this._guildDownloadCompleted, dcompl);
⋮----
await this._guildAvailable.InvokeAsync(this, new(this.ServiceProvider)
⋮----
await this._guildCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
await this.GuildDownloadCompletedEv.InvokeAsync(this, new(this.Guilds, false, this.ServiceProvider)).ConfigureAwait(false);
⋮----
///     Handles the guild update event.
⋮----
internal async Task OnGuildUpdateEventAsync(DiscordGuild guild, JArray rawMembers)
⋮----
DiscordGuild oldGuild;
⋮----
if (!this.GuildsInternal.TryGetValue(guild.Id, out var value))
⋮----
await this._guildUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild delete event.
⋮----
internal async Task OnGuildDeleteEventAsync(DiscordGuild guild)
⋮----
if (!this.GuildsInternal.TryGetValue(guild.Id, out var gld))
⋮----
await this._guildUnavailable.InvokeAsync(this, new(this.ServiceProvider)
⋮----
if (!this.GuildsInternal.TryRemove(guild.Id, out var gld))
⋮----
await this._guildDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild audit log entry create event.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild where the audit log entry was created.&lt;/param&gt;
/// &lt;param name=&quot;auditLogCreateEntry&quot;&gt;The auditlog event.&lt;/param&gt;
internal async Task OnGuildAuditLogEntryCreateEventAsync(DiscordGuild guild, JObject auditLogCreateEntry)
⋮----
var dataList = await guild.ProcessAuditLog(workaroundAuditLogEntryList).ConfigureAwait(false);
⋮----
await this._guildAuditLogEntryCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
AuditLogEntry = dataList.FirstOrDefault()
⋮----
///     Handles the guild sync event.
⋮----
/// &lt;param name=&quot;isLarge&quot;&gt;Whether the guild is a large guild.&lt;/param&gt;
⋮----
internal async Task OnGuildSyncEventAsync(DiscordGuild guild, bool isLarge, JArray rawMembers, IEnumerable&lt;DiscordPresence&gt; presences)
⋮----
presences = presences.Select(xp =&gt;
⋮----
this.UpdateCachedGuild(guild, rawMembers);
⋮----
///     Handles the guild emojis update event.
⋮----
/// &lt;param name=&quot;newEmojis&quot;&gt;The new emojis.&lt;/param&gt;
internal async Task OnGuildEmojisUpdateEventAsync(DiscordGuild guild, IEnumerable&lt;DiscordEmoji&gt; newEmojis)
⋮----
guild.EmojisInternal.Clear();
⋮----
var ea = new GuildEmojisUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildEmojisUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the stickers updated.
⋮----
/// &lt;param name=&quot;newStickers&quot;&gt;The new stickers.&lt;/param&gt;
⋮----
internal async Task OnStickersUpdatedAsync(IEnumerable&lt;DiscordSticker&gt; newStickers, ulong guildId)
⋮----
guild.StickersInternal.Clear();
⋮----
this.UserCache.AddOrUpdate(nst.User.Id, nst.User, (old, @new) =&gt; @new);
⋮----
var sea = new GuildStickersUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildStickersUpdated.InvokeAsync(this, sea).ConfigureAwait(false);
⋮----
///     Handles the created rule.
⋮----
/// &lt;param name=&quot;newRule&quot;&gt;The new added rule.&lt;/param&gt;
internal async Task OnAutomodRuleCreated(AutomodRule newRule)
⋮----
var sea = new AutomodRuleCreateEventArgs(this.ServiceProvider)
⋮----
await this._automodRuleCreated.InvokeAsync(this, sea).ConfigureAwait(false);
⋮----
///     Handles the updated rule.
⋮----
/// &lt;param name=&quot;updatedRule&quot;&gt;The updated rule.&lt;/param&gt;
internal async Task OnAutomodRuleUpdated(AutomodRule updatedRule)
⋮----
var sea = new AutomodRuleUpdateEventArgs(this.ServiceProvider)
⋮----
await this._automodRuleUpdated.InvokeAsync(this, sea).ConfigureAwait(false);
⋮----
///     Handles the deleted rule.
⋮----
/// &lt;param name=&quot;deletedRule&quot;&gt;The deleted rule.&lt;/param&gt;
internal async Task OnAutomodRuleDeleted(AutomodRule deletedRule)
⋮----
var sea = new AutomodRuleDeleteEventArgs(this.ServiceProvider)
⋮----
await this._automodRuleDeleted.InvokeAsync(this, sea).ConfigureAwait(false);
⋮----
///     Handles the rule action execution.
⋮----
/// &lt;param name=&quot;rawPayload&quot;&gt;The raw payload.&lt;/param&gt;
internal async Task OnAutomodActionExecuted(DiscordGuild guild, JObject rawPayload)
⋮----
var channelId = rawPayload.TryGetValue(&quot;channel_id&quot;, out var value) ? (ulong?)value : null;
var messageId = rawPayload.TryGetValue(&quot;message_id&quot;, out var value1) ? (ulong?)value1 : null;
var alertMessageId = rawPayload.TryGetValue(&quot;alert_system_message_id&quot;, out var value2) ? (ulong?)value2 : null;
var content = rawPayload.TryGetValue(&quot;content&quot;, out var value3) ? (string?)value3 : null;
var matchedKeyword = rawPayload.TryGetValue(&quot;matched_keyword&quot;, out var value4) ? (string?)value4 : null;
var matchedContent = rawPayload.TryGetValue(&quot;matched_content&quot;, out var value5) ? (string?)value5 : null;
⋮----
var ea = new AutomodActionExecutedEventArgs(this.ServiceProvider)
⋮----
await this._automodActionExecuted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild ban add event.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The transport user.&lt;/param&gt;
⋮----
internal async Task OnGuildBanAddEventAsync(TransportUser user, DiscordGuild guild)
⋮----
var usr = new DiscordUser(user)
⋮----
usr = this.UserCache.AddOrUpdate(user.Id, usr, (id, old) =&gt;
⋮----
if (!guild.Members.TryGetValue(user.Id, out var mbr))
⋮----
var ea = new GuildBanAddEventArgs(this.ServiceProvider)
⋮----
await this._guildBanAdded.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild ban remove event.
⋮----
internal async Task OnGuildBanRemoveEventAsync(TransportUser user, DiscordGuild guild)
⋮----
var ea = new GuildBanRemoveEventArgs(this.ServiceProvider)
⋮----
await this._guildBanRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the scheduled event create event.
⋮----
/// &lt;param name=&quot;scheduledEvent&quot;&gt;The created event.&lt;/param&gt;
⋮----
internal async Task OnGuildScheduledEventCreateEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
⋮----
guild.ScheduledEventsInternal.AddOrUpdate(scheduledEvent.Id, scheduledEvent, (old, newScheduledEvent) =&gt; newScheduledEvent);
⋮----
this.UserCache.AddOrUpdate(scheduledEvent.Creator.Id, scheduledEvent.Creator, (id, old) =&gt;
⋮----
await this._guildScheduledEventCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the scheduled event update event.
⋮----
/// &lt;param name=&quot;scheduledEvent&quot;&gt;The updated event.&lt;/param&gt;
⋮----
internal async Task OnGuildScheduledEventUpdateEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
⋮----
DiscordScheduledEvent oldEvent;
if (!guild.ScheduledEventsInternal.TryGetValue(scheduledEvent.Id, out var value))
⋮----
guild.ScheduledEventsInternal.TryRemove(scheduledEvent.Id, out var deletedEvent);
await this._guildScheduledEventDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
this.UpdateScheduledEvent(scheduledEvent, guild);
await this._guildScheduledEventUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the scheduled event delete event.
⋮----
/// &lt;param name=&quot;scheduledEvent&quot;&gt;The deleted event.&lt;/param&gt;
⋮----
internal async Task OnGuildScheduledEventDeleteEventAsync(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
⋮----
///     Handles the scheduled event user add event.
///     &lt;param name=&quot;guildScheduledEventId&quot;&gt;The event.&lt;/param&gt;
///     &lt;param name=&quot;userId&quot;&gt;The added user id.&lt;/param&gt;
///     &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
⋮----
internal async Task OnGuildScheduledEventUserAddedEventAsync(ulong guildScheduledEventId, ulong userId, DiscordGuild guild)
⋮----
var scheduledEvent = this.InternalGetCachedScheduledEvent(guildScheduledEventId) ?? this.UpdateScheduledEvent(new()
⋮----
var user = this.GetUserAsync(userId, true).Result;
⋮----
var member = guild.Members.TryGetValue(userId, out var mem) ? mem : guild.GetMemberAsync(userId).Result;
⋮----
await this._guildScheduledEventUserAdded.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the scheduled event user remove event.
⋮----
///     &lt;param name=&quot;userId&quot;&gt;The removed user id.&lt;/param&gt;
⋮----
internal async Task OnGuildScheduledEventUserRemovedEventAsync(ulong guildScheduledEventId, ulong userId, DiscordGuild guild)
⋮----
await this._guildScheduledEventUserRemoved.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild integration create event.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;The integration.&lt;/param&gt;
internal async Task OnGuildIntegrationCreateEventAsync(DiscordGuild guild, DiscordIntegration integration)
⋮----
await this._guildIntegrationCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild integration update event.
⋮----
internal async Task OnGuildIntegrationUpdateEventAsync(DiscordGuild guild, DiscordIntegration integration)
⋮----
await this._guildIntegrationUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild integrations update event.
⋮----
internal async Task OnGuildIntegrationsUpdateEventAsync(DiscordGuild guild)
⋮----
var ea = new GuildIntegrationsUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildIntegrationsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild integration delete event.
⋮----
/// &lt;param name=&quot;integrationId&quot;&gt;The integration id.&lt;/param&gt;
/// &lt;param name=&quot;applicationId&quot;&gt;The optional application id.&lt;/param&gt;
internal async Task OnGuildIntegrationDeleteEventAsync(DiscordGuild guild, ulong integrationId, ulong? applicationId)
=&gt; await this._guildIntegrationDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild member add event.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The transport member.&lt;/param&gt;
⋮----
internal async Task OnGuildMemberAddEventAsync(TransportMember member, DiscordGuild guild)
⋮----
var usr = new DiscordUser(member.User)
⋮----
usr = this.UserCache.AddOrUpdate(member.User.Id, usr, (id, old) =&gt;
⋮----
var mbr = new DiscordMember(member)
⋮----
var ea = new GuildMemberAddEventArgs(this.ServiceProvider)
⋮----
await this._guildMemberAdded.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild member remove event.
⋮----
internal async Task OnGuildMemberRemoveEventAsync(TransportUser user, DiscordGuild guild)
⋮----
var usr = new DiscordUser(user);
⋮----
if (!guild.MembersInternal.TryRemove(user.Id, out var mbr))
⋮----
_ = this.UserCache.AddOrUpdate(user.Id, usr, (old, @new) =&gt; @new);
⋮----
var ea = new GuildMemberRemoveEventArgs(this.ServiceProvider)
⋮----
await this._guildMemberRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild member update event.
⋮----
/// &lt;param name=&quot;roles&quot;&gt;The roles.&lt;/param&gt;
/// &lt;param name=&quot;nick&quot;&gt;The nick.&lt;/param&gt;
/// &lt;param name=&quot;pending&quot;&gt;Whether the member is pending.&lt;/param&gt;
internal async Task OnGuildMemberUpdateEventAsync(TransportMember member, DiscordGuild guild, IEnumerable&lt;ulong&gt; roles, string nick, bool? pending)
⋮----
usr = this.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
⋮----
if (!guild.Members.TryGetValue(member.User.Id, out var mbr))
⋮----
// TODO: fixme
⋮----
mbr.RoleIdsInternal.Clear();
mbr.RoleIdsInternal.AddRange(roles);
guild.MembersInternal.AddOrUpdate(member.User.Id, mbr, (id, oldMbr) =&gt; oldMbr);
⋮----
/*this.Logger.LogTrace($&quot;Timeout:\nBefore - {cduOld}\nAfter - {timeoutUntil}&quot;);
		if ((timeoutUntil.HasValue &amp;&amp; cduOld.HasValue) || (timeoutUntil == null &amp;&amp; cduOld.HasValue) || (timeoutUntil.HasValue &amp;&amp; cduOld == null))
		{
			// We are going to add a scheduled timer to assure that we get a auditlog entry.

			var id = $&quot;tt-{mbr.Id}-{guild.Id}-{DateTime.Now.ToLongTimeString()}&quot;;

			this._tempTimers.Add(
				id,
				new(
					new TimeoutHandler(
						mbr,
						guild,
						cduOld,
						timeoutUntil
					),
					new Timer(
						this.TimeoutTimer,
						id,
						2000,
						Timeout.Infinite
					)
				)
			);

			this.Logger.LogTrace(&quot;Scheduling timeout event.&quot;);

			return;
		}*/
⋮----
//this.Logger.LogTrace(&quot;No timeout detected. Continuing on normal operation.&quot;);
⋮----
var eargs = new GuildMemberUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildMemberUpdated.InvokeAsync(this, eargs).ConfigureAwait(false);
⋮----
var timeoutBefore = (eargs.TimeoutBefore ?? DateTimeOffset.UtcNow) &gt; DateTimeOffset.UtcNow ? eargs.TimeoutBefore : null; // safe guard in case timeout isnt null despite being in the past
var timeoutAfter = (eargs.TimeoutAfter ?? DateTimeOffset.MinValue) &gt; DateTimeOffset.UtcNow ? eargs.TimeoutAfter : null; // i remember that being an issue, idk if its fixed
⋮----
await this._guildMemberTimeoutAdded.InvokeAsync(this, new(this.ServiceProvider)
⋮----
await this._guildMemberTimeoutChanged.InvokeAsync(this, new(this.ServiceProvider)
⋮----
await this._guildMemberTimeoutRemoved.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the guild members chunk event.
⋮----
/// &lt;param name=&quot;dat&quot;&gt;The raw chunk data.&lt;/param&gt;
internal async Task OnGuildMembersChunkEventAsync(JObject dat)
⋮----
if (!this.UserCache.ContainsKey(mbr.Id))
⋮----
mbrs.Add(mbr);
⋮----
var ea = new GuildMembersChunkEventArgs(this.ServiceProvider)
⋮----
pres.Add(presence);
⋮----
await this._guildMembersChunked.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild role create event.
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role.&lt;/param&gt;
⋮----
internal async Task OnGuildRoleCreateEventAsync(DiscordRole role, DiscordGuild guild)
⋮----
var ea = new GuildRoleCreateEventArgs(this.ServiceProvider)
⋮----
await this._guildRoleCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild role update event.
⋮----
internal async Task OnGuildRoleUpdateEventAsync(DiscordRole role, DiscordGuild guild)
⋮----
var newRole = guild.GetRole(role.Id);
var oldRole = new DiscordRole
⋮----
var ea = new GuildRoleUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildRoleUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild role delete event.
⋮----
/// &lt;param name=&quot;roleId&quot;&gt;The role id.&lt;/param&gt;
⋮----
internal async Task OnGuildRoleDeleteEventAsync(ulong roleId, DiscordGuild guild)
⋮----
if (!guild.RolesInternal.TryRemove(roleId, out var role))
this.Logger.LogWarning($&quot;Attempted to delete a nonexistent role ({roleId}) from guild ({guild}).&quot;);
⋮----
var ea = new GuildRoleDeleteEventArgs(this.ServiceProvider)
⋮----
await this._guildRoleDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild soundboard sound create event.
⋮----
/// &lt;param name=&quot;sound&quot;&gt;The sound.&lt;/param&gt;
internal async Task OnGuildSoundboardSoundCreateEventAsync(DiscordSoundboardSound sound, ulong guildId)
⋮----
guild.SoundboardSoundsInternal.TryAdd(sound.Id, sound);
var args = new GuildSoundboardSoundCreateEventArgs(this.ServiceProvider)
⋮----
await this._guildSoundboardSoundCreated.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
///     Handles the guild soundboard sound update event.
⋮----
internal async Task OnGuildSoundboardSoundUpdateEventAsync(DiscordSoundboardSound sound, ulong guildId)
⋮----
guild.SoundboardSoundsInternal.TryRemove(sound.Id, out _);
⋮----
var args = new GuildSoundboardSoundUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildSoundboardSoundUpdated.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
///     Handles the guild soundboard sound delete event.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The sound id.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
internal async Task OnGuildSoundboardSoundDeleteEventAsync(ulong soundId, ulong guildId)
⋮----
guild.SoundboardSoundsInternal.TryRemove(soundId, out var sound);
var args = new GuildSoundboardSoundDeleteEventArgs(this.ServiceProvider)
⋮----
await this._guildSoundboardSoundDeleted.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
///     Handles the guild soundboard sounds update event.
⋮----
/// &lt;param name=&quot;sounds&quot;&gt;The sounds.&lt;/param&gt;
internal async Task OnGuildSoundboardSoundsUpdateEventAsync(List&lt;DiscordSoundboardSound&gt; sounds, ulong guildId)
⋮----
var args = new GuildSoundboardSoundsUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildSoundboardSoundsUpdated.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
///     Handles the soundboard sounds event.
⋮----
internal async Task OnSoundboardSoundsEventAsync(List&lt;DiscordSoundboardSound&gt; sounds, ulong guildId)
⋮----
var guild = this.Guilds.TryGetValue(guildId, out var cachedGuild)
⋮----
if (this.Guilds.ContainsKey(guildId))
⋮----
this.Guilds[guildId].SoundboardSoundsInternal.Clear();
⋮----
this.Guilds[guildId].SoundboardSoundsInternal.TryAdd(sound.Id, sound);
⋮----
await this._soundboardSounds.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the invite create event.
⋮----
/// &lt;param name=&quot;invite&quot;&gt;The invite.&lt;/param&gt;
internal async Task OnInviteCreateEventAsync(ulong channelId, ulong guildId, DiscordInvite invite)
⋮----
this.UserCache.AddOrUpdate(invite.Inviter.Id, invite.Inviter, (old, @new) =&gt; @new);
⋮----
var ea = new InviteCreateEventArgs(this.ServiceProvider)
⋮----
await this._inviteCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the invite delete event.
⋮----
/// &lt;param name=&quot;dat&quot;&gt;The raw invite.&lt;/param&gt;
internal async Task OnInviteDeleteEventAsync(ulong channelId, ulong guildId, JToken dat)
⋮----
var guild = this.InternalGetCachedGuild(guildId)!;
⋮----
if (!guild.Invites.TryRemove(dat[&quot;code&quot;]!.ToString(), out var invite))
⋮----
var ea = new InviteDeleteEventArgs(this.ServiceProvider)
⋮----
await this._inviteDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild join request create event.
⋮----
/// &lt;param name=&quot;statusType&quot;&gt;The join request status.&lt;/param&gt;
/// &lt;param name=&quot;request&quot;&gt;The join request.&lt;/param&gt;
internal async Task OnGuildJoinRequestCreateAsync(DiscordGuild guild, JoinRequestStatusType statusType, DiscordGuildJoinRequest request)
⋮----
var ea = new GuildJoinRequestCreateEventArgs(this.ServiceProvider)
⋮----
await this._guildJoinRequestCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild join request update event.
⋮----
internal async Task OnGuildJoinRequestUpdateAsync(DiscordGuild guild, JoinRequestStatusType statusType, DiscordGuildJoinRequest request)
⋮----
var ea = new GuildJoinRequestUpdateEventArgs(this.ServiceProvider)
⋮----
await this._guildJoinRequestUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild join request delete event.
⋮----
/// &lt;param name=&quot;requestId&quot;&gt;The request id.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user id.&lt;/param&gt;
⋮----
internal async Task OnGuildJoinRequestDeleteAsync(ulong requestId, ulong userId, DiscordGuild guild)
⋮----
var user = this.GetCachedOrEmptyUserInternal(userId);
var ea = new GuildJoinRequestDeleteEventArgs(this.ServiceProvider)
⋮----
await this._guildJoinRequestDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message acknowledge event.
⋮----
/// &lt;param name=&quot;chn&quot;&gt;The channel.&lt;/param&gt;
/// &lt;param name=&quot;messageId&quot;&gt;The message id.&lt;/param&gt;
internal async Task OnMessageAckEventAsync(DiscordChannel chn, ulong messageId)
⋮----
if (this.MessageCache == null || !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == chn.Id, out var msg))
⋮----
await this._messageAcknowledged.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the message create event.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;author&quot;&gt;The transport user (author).&lt;/param&gt;
⋮----
/// &lt;param name=&quot;referenceAuthor&quot;&gt;The reference transport user (author).&lt;/param&gt;
/// &lt;param name=&quot;referenceMember&quot;&gt;The reference transport member.&lt;/param&gt;
internal async Task OnMessageCreateEventAsync(DiscordMessage message, TransportUser author, TransportMember member, TransportUser referenceAuthor, TransportMember referenceMember)
⋮----
this.PopulateMessageReactionsAndCache(message, author, member);
message.PopulateMentions();
⋮----
this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Channel which the last message belongs to is not in cache - cache state might be invalid!&quot;);
⋮----
this.PopulateMessageReactionsAndCache(message.ReferencedMessage, referenceAuthor, referenceMember);
message.ReferencedMessage.PopulateMentions();
⋮----
x.Message.MentionedUsersInternal.ForEach(u =&gt; u.Discord = this);
⋮----
x.Message.AttachmentsInternal.ForEach(a =&gt; a.Discord = this);
⋮----
x.Message.EmbedsInternal.ForEach(a =&gt; a.Discord = this);
⋮----
x.Message.MentionedChannelsInternal.ForEach(u =&gt; u.Discord = this);
⋮----
x.Message.MentionedRolesInternal.ForEach(u =&gt; u.Discord = this);
x.Message.PopulateMentions();
⋮----
var ea = new MessageCreateEventArgs(this.ServiceProvider)
⋮----
await this._messageCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message update event.
⋮----
internal async Task OnMessageUpdateEventAsync(DiscordMessage message, TransportUser author, TransportMember member, TransportUser referenceAuthor, TransportMember referenceMember)
⋮----
DiscordGuild guild;
⋮----
DiscordMessage oldmsg = null;
⋮----
|| !this.MessageCache.TryGet(xm =&gt; xm.Id == eventMessage.Id &amp;&amp; xm.ChannelId == eventMessage.ChannelId, out message))
⋮----
message.EmbedsInternal.Clear();
message.EmbedsInternal.AddRange(eventMessage.EmbedsInternal);
⋮----
var ea = new MessageUpdateEventArgs(this.ServiceProvider)
⋮----
await this._messageUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message delete event.
⋮----
internal async Task OnMessageDeleteEventAsync(ulong messageId, ulong channelId, ulong? guildId)
⋮----
|| !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == channelId, out var msg))
⋮----
var ea = new MessageDeleteEventArgs(this.ServiceProvider)
⋮----
await this._messageDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message bulk delete event.
⋮----
/// &lt;param name=&quot;messageIds&quot;&gt;The message ids.&lt;/param&gt;
⋮----
internal async Task OnMessageBulkDeleteEventAsync(ulong[] messageIds, ulong channelId, ulong? guildId)
⋮----
msgs.Add(msg);
⋮----
var ea = new MessageBulkDeleteEventArgs(this.ServiceProvider)
⋮----
await this._messagesBulkDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message poll vote add event.
⋮----
/// &lt;param name=&quot;dat&quot;&gt;The raw jobject.&lt;/param&gt;
internal async Task OnMessagePollVoteAddEventAsync(JObject dat)
⋮----
if (!this.UserCache.TryGetValue(userId, out var user))
⋮----
|| !this.MessageCache.TryGet(xm =&gt; xm.Id == messageId &amp;&amp; xm.ChannelId == channelId, out var message))
⋮----
var ea = new MessagePollVoteAddEventArgs(this.ServiceProvider)
⋮----
await this._messagePollVoteAdded.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message poll vote remove event.
⋮----
internal async Task OnMessagePollVoteRemoveEventAsync(JObject dat)
⋮----
var ea = new MessagePollVoteRemoveEventArgs(this.ServiceProvider)
⋮----
await this._messagePollVoteRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
// BUG: Possible ratelimit bug in big guilds like Belugang due to message fetching and message cache
⋮----
///     Handles the message reaction add event.
⋮----
/// &lt;param name=&quot;mbr&quot;&gt;The transport member.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
/// &lt;param name=&quot;isBurst&quot;&gt;Whether a burst reaction was added.&lt;/param&gt;
internal async Task OnMessageReactionAddAsync(ulong userId, ulong messageId, ulong channelId, ulong? guildId, TransportMember mbr, DiscordEmoji emoji, bool isBurst)
⋮----
var channel = this.InternalGetCachedChannel(channelId) ?? this.InternalGetCachedThread(channelId) ?? new DiscordChannel
⋮----
var usr = this.UpdateUser(new()
⋮----
var react = msg.ReactionsInternal.FirstOrDefault(xr =&gt; xr.Emoji == emoji);
⋮----
msg.ReactionsInternal.Add(react = new()
⋮----
var ea = new MessageReactionAddEventArgs(this.ServiceProvider)
⋮----
await this._messageReactionAdded.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the message reaction remove event.
⋮----
internal async Task OnMessageReactionRemoveAsync(ulong userId, ulong messageId, ulong channelId, ulong? guildId, DiscordEmoji emoji, bool isBurst)
⋮----
if (!this.UserCache.TryGetValue(userId, out var usr))
⋮----
usr = channel.Guild.Members.TryGetValue(userId, out var member)
⋮----
if (msg.ReactionsInternal != null &amp;&amp; react.Count &lt;= 0) // shit happens
msg.ReactionsInternal.RemoveFirst(x =&gt; x.Emoji == emoji);
⋮----
var ea = new MessageReactionRemoveEventArgs(this.ServiceProvider)
⋮----
await this._messageReactionRemoved.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Fired when all message reactions were removed.
⋮----
internal async Task OnMessageReactionRemoveAllAsync(ulong messageId, ulong channelId, ulong? guildId)
⋮----
var ea = new MessageReactionsClearEventArgs(this.ServiceProvider)
⋮----
await this._messageReactionsCleared.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Fired when a emoji got removed.
⋮----
/// &lt;param name=&quot;partialEmoji&quot;&gt;The raw discord emoji.&lt;/param&gt;
internal async Task OnMessageReactionRemoveEmojiAsync(ulong messageId, ulong channelId, ulong guildId, DiscordEmoji partialEmoji)
⋮----
if (!guild.EmojisInternal.TryGetValue(partialEmoji.Id, out var emoji))
⋮----
msg.ReactionsInternal?.RemoveAll(r =&gt; r.Emoji.Equals(emoji));
⋮----
var ea = new MessageReactionRemoveEmojiEventArgs(this.ServiceProvider)
⋮----
await this._messageReactionRemovedEmoji.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the stage instance create event.
⋮----
/// &lt;param name=&quot;stage&quot;&gt;The created stage instance.&lt;/param&gt;
internal async Task OnStageInstanceCreateEventAsync(DiscordStageInstance stage)
⋮----
var guild = this.InternalGetCachedGuild(stage.GuildId);
⋮----
await this._stageInstanceCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the stage instance update event.
⋮----
/// &lt;param name=&quot;stage&quot;&gt;The updated stage instance.&lt;/param&gt;
internal async Task OnStageInstanceUpdateEventAsync(DiscordStageInstance stage)
⋮----
await this._stageInstanceUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the stage instance delete event.
⋮----
/// &lt;param name=&quot;stage&quot;&gt;The deleted stage instance.&lt;/param&gt;
internal async Task OnStageInstanceDeleteEventAsync(DiscordStageInstance stage)
⋮----
await this._stageInstanceDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the thread create event.
⋮----
/// &lt;param name=&quot;thread&quot;&gt;The created thread.&lt;/param&gt;
internal async Task OnThreadCreateEventAsync(DiscordThreadChannel thread)
⋮----
this.InternalGetCachedGuild(thread.GuildId).ThreadsInternal.AddOrUpdate(thread.Id, thread, (oldThread, newThread) =&gt; newThread);
⋮----
await this._threadCreated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the thread update event.
⋮----
/// &lt;param name=&quot;thread&quot;&gt;The updated thread.&lt;/param&gt;
internal async Task OnThreadUpdateEventAsync(DiscordThreadChannel thread)
⋮----
var threadNew = this.InternalGetCachedThread(thread.Id);
DiscordThreadChannel threadOld = null;
ThreadUpdateEventArgs updateEvent;
⋮----
if (thread.ParentId.HasValue &amp;&amp; this.InternalGetCachedChannel(thread.ParentId.Value).Type == ChannelType.Forum)
⋮----
await this._threadUpdated.InvokeAsync(this, updateEvent).ConfigureAwait(false);
⋮----
///     Handles the thread delete event.
⋮----
/// &lt;param name=&quot;thread&quot;&gt;The deleted thread.&lt;/param&gt;
internal async Task OnThreadDeleteEventAsync(DiscordThreadChannel thread)
⋮----
if (gld.ThreadsInternal.TryRemove(thread.Id, out var cachedThread))
⋮----
await this._threadDeleted.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the thread list sync event.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The synced guild.&lt;/param&gt;
/// &lt;param name=&quot;channelIds&quot;&gt;The synced channel ids.&lt;/param&gt;
/// &lt;param name=&quot;threads&quot;&gt;The synced threads.&lt;/param&gt;
/// &lt;param name=&quot;members&quot;&gt;The synced thread members.&lt;/param&gt;
internal async Task OnThreadListSyncEventAsync(DiscordGuild guild, IReadOnlyList&lt;ulong?&gt; channelIds, IReadOnlyList&lt;DiscordThreadChannel&gt; threads, IReadOnlyList&lt;DiscordThreadChannelMember&gt; members)
⋮----
var channels = channelIds.Select(x =&gt; guild.GetChannel(x.Value)); //getting channel objects
⋮----
_ = threads.Select(x =&gt; x.Discord = this);
⋮----
await this._threadListSynced.InvokeAsync(this, new(this.ServiceProvider)
⋮----
Channels = channels.ToList().AsReadOnly(),
⋮----
Members = members.ToList().AsReadOnly()
⋮----
///     Handles the thread member update event.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The updated member.&lt;/param&gt;
internal async Task OnThreadMemberUpdateEventAsync(DiscordThreadChannelMember member)
⋮----
var thread = this.InternalGetCachedThread(member.Id);
⋮----
var tempThread = await this.ApiClient.GetThreadAsync(member.Id).ConfigureAwait(false);
thread = this.GuildsInternal[member.GuildId].ThreadsInternal.AddOrUpdate(member.Id, tempThread, (old, newThread) =&gt; newThread);
⋮----
thread.Guild.ThreadsInternal.AddOrUpdate(member.Id, thread, (oldThread, newThread) =&gt; newThread);
⋮----
await this._threadMemberUpdated.InvokeAsync(this, new(this.ServiceProvider)
⋮----
///     Handles the thread members update event.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The target guild.&lt;/param&gt;
/// &lt;param name=&quot;threadId&quot;&gt;The thread id of the target thread this update belongs to.&lt;/param&gt;
/// &lt;param name=&quot;membersAdded&quot;&gt;The added members.&lt;/param&gt;
/// &lt;param name=&quot;membersRemoved&quot;&gt;The ids of the removed members.&lt;/param&gt;
/// &lt;param name=&quot;memberCount&quot;&gt;The new member count.&lt;/param&gt;
internal async Task OnThreadMembersUpdateEventAsync(DiscordGuild guild, ulong threadId, JArray membersAdded, JArray membersRemoved, int memberCount)
⋮----
var thread = this.InternalGetCachedThread(threadId);
⋮----
var tempThread = await this.ApiClient.GetThreadAsync(threadId).ConfigureAwait(false);
thread = guild.ThreadsInternal.AddOrUpdate(threadId, tempThread, (old, newThread) =&gt; newThread);
⋮----
addedMembers.Add(xtm);
⋮----
removedMembers.Add(guild.MembersInternal.TryGetValue((ulong)removedId, out var member)
⋮----
if (removedMemberIds.Contains(this.CurrentUser.Id)) //indicates the bot was removed from the thread
⋮----
var threadMembersUpdateArg = new ThreadMembersUpdateEventArgs(this.ServiceProvider)
⋮----
await this._threadMembersUpdated.InvokeAsync(this, threadMembersUpdateArg).ConfigureAwait(false);
⋮----
///     Dispatches the &lt;see cref=&quot;EmbeddedActivityUpdated&quot; /&gt; event.
⋮----
/// &lt;param name=&quot;trActivity&quot;&gt;The transport activity.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;jUsers&quot;&gt;The users in the activity.&lt;/param&gt;
/// &lt;param name=&quot;appId&quot;&gt;The application id.&lt;/param&gt;
internal async Task OnEmbeddedActivityUpdateAsync(JObject trActivity, DiscordGuild guild, ulong channelId, JArray jUsers, ulong appId)
=&gt; await Task.Delay(20).ConfigureAwait(false);
⋮----
/*{
            try
            {
                var users = j_users?.ToObject&lt;List&lt;ulong&gt;&gt;();

                DiscordActivity old = null;
                var uid = $&quot;{guild.Id}_{channel_id}_{app_id}&quot;;

                if (this._embeddedActivities.TryGetValue(uid, out var activity))
                {
                    old = new DiscordActivity(activity);
                    DiscordJson.PopulateObject(tr_activity, activity);
                }
                else
                {
                    activity = tr_activity.ToObject&lt;DiscordActivity&gt;();
                    this._embeddedActivities[uid] = activity;
                }

                var activity_users = new List&lt;DiscordMember&gt;();

                var channel = this.InternalGetCachedChannel(channel_id) ?? await this.ApiClient.GetChannelAsync(channel_id);

                if (users != null)
                {
                    foreach (var user in users)
                    {
                        var activity_user = guild._members.TryGetValue(user, out var member) ? member : new DiscordMember { Id = user, _guild_id = guild.Id, Discord = this };
                        activity_users.Add(activity_user);
                    }
                }
                else
                    activity_users = null;

                var ea = new EmbeddedActivityUpdateEventArgs(this.ServiceProvider)
                {
                    Guild = guild,
                    Users = activity_users,
                    Channel = channel

                };
                await this._embeddedActivityUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
            } catch (Exception ex)
            {
                this.Logger.LogError(ex, ex.Message);
            }
        }*/
⋮----
///     Handles the presence update event.
⋮----
/// &lt;param name=&quot;rawPresence&quot;&gt;The raw presence.&lt;/param&gt;
/// &lt;param name=&quot;rawUser&quot;&gt;The raw user.&lt;/param&gt;
internal async Task OnPresenceUpdateEventAsync(JObject rawPresence, JObject rawUser)
⋮----
if (this.PresencesInternal.TryGetValue(uid, out var presence))
⋮----
DiscordJson.PopulateObject(rawPresence, presence);
⋮----
presence = DiscordJson.DeserializeObject&lt;DiscordPresence&gt;(rawPresence.ToString(), this);
⋮----
// reuse arrays / avoid linq (this is a hot zone)
⋮----
presence.Activity.UpdateWith(presence.RawActivity);
⋮----
var ea = new PresenceUpdateEventArgs(this.ServiceProvider)
⋮----
await this._presenceUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the user settings update event.
⋮----
internal async Task OnUserSettingsUpdateEventAsync(TransportUser user)
⋮----
var ea = new UserSettingsUpdateEventArgs(this.ServiceProvider)
⋮----
await this._userSettingsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the user update event.
⋮----
internal async Task OnUserUpdateEventAsync(TransportUser user)
⋮----
var usrOld = new DiscordUser
⋮----
var ea = new UserUpdateEventArgs(this.ServiceProvider)
⋮----
await this._userUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the voice state update event.
⋮----
/// &lt;param name=&quot;raw&quot;&gt;The raw voice state update object.&lt;/param&gt;
internal async Task OnVoiceStateUpdateEventAsync(JObject raw)
⋮----
var vstateNew = DiscordJson.DeserializeObject&lt;DiscordVoiceState&gt;(raw.ToString(), this);
⋮----
gld.VoiceStatesInternal.TryRemove(uid, out var vstateOld);
⋮----
if (gld.MembersInternal.TryGetValue(uid, out var mbr))
⋮----
this.UpdateUser(new(transportMbr.User)
⋮----
var ea = new VoiceStateUpdateEventArgs(this.ServiceProvider)
⋮----
await this._voiceStateUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the voice server update event.
⋮----
/// &lt;param name=&quot;endpoint&quot;&gt;The new endpoint.&lt;/param&gt;
/// &lt;param name=&quot;token&quot;&gt;The new token.&lt;/param&gt;
⋮----
internal async Task OnVoiceServerUpdateEventAsync(string endpoint, string token, DiscordGuild guild)
⋮----
var ea = new VoiceServerUpdateEventArgs(this.ServiceProvider)
⋮----
await this._voiceServerUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
internal async Task OnVoiceChannelEffectSendEventAsync(ulong gid, ulong cid, ulong uid, JObject rawObject)
⋮----
var emoji = rawObject.TryGetValue(&quot;emoji&quot;, out var rawEmoji) ? rawEmoji.ToDiscordObject&lt;DiscordEmoji&gt;() : null;
⋮----
AnimationType? animationType = rawObject.TryGetValue(&quot;animation_type&quot;, out var rawAnimationType) &amp;&amp; Enum.TryParse&lt;AnimationType&gt;((string)rawAnimationType!, out var parsedType) ? parsedType : null;
int? animationId = rawObject.TryGetValue(&quot;animation_id&quot;, out var rawAnimationId) ? Convert.ToInt32(rawAnimationId.ToString()) : null;
ulong? soundId = rawObject.TryGetValue(&quot;sound_id&quot;, out var rawSoundId) ? Convert.ToUInt64(rawSoundId.ToString()) : null;
double? soundVolume = rawObject.TryGetValue(&quot;sound_volume&quot;, out var rawSoundVolume) ? Convert.ToDouble(rawSoundVolume.ToString()) : null;
⋮----
VoiceChannelEffectSendEventArgs ea = new(this.ServiceProvider)
⋮----
Channel = this.Guilds.TryGetValue(gid, out var cacheGuild)
? cacheGuild.Channels.TryGetValue(cid, out var channel)
⋮----
Guild = this.Guilds.TryGetValue(gid, out var guild)
⋮----
User = this.UserCache.TryGetValue(uid, out var user)
⋮----
await this._voiceChannelEffectSend.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the application command create event.
⋮----
/// &lt;param name=&quot;cmd&quot;&gt;The application command.&lt;/param&gt;
⋮----
internal async Task OnApplicationCommandCreateAsync(DiscordApplicationCommand cmd, ulong? guildId)
⋮----
var ea = new ApplicationCommandEventArgs(this.ServiceProvider)
⋮----
await this._applicationCommandCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the application command update event.
⋮----
internal async Task OnApplicationCommandUpdateAsync(DiscordApplicationCommand cmd, ulong? guildId)
⋮----
await this._applicationCommandUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the application command delete event.
⋮----
internal async Task OnApplicationCommandDeleteAsync(DiscordApplicationCommand cmd, ulong? guildId)
⋮----
await this._applicationCommandDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the guild application command counts update event.
⋮----
/// &lt;param name=&quot;chatInputCommandCount&quot;&gt;The &lt;see cref=&quot;ApplicationCommandType.ChatInput&quot; /&gt; count.&lt;/param&gt;
/// &lt;param name=&quot;userContextMenuCommandCount&quot;&gt;The &lt;see cref=&quot;ApplicationCommandType.User&quot; /&gt; count.&lt;/param&gt;
/// &lt;param name=&quot;messageContextMenuCount&quot;&gt;The &lt;see cref=&quot;ApplicationCommandType.Message&quot; /&gt; count.&lt;/param&gt;
⋮----
/// &lt;returns&gt;Count of application commands.&lt;/returns&gt;
internal async Task OnGuildApplicationCommandCountsUpdateAsync(int chatInputCommandCount, int userContextMenuCommandCount, int messageContextMenuCount, ulong guildId)
⋮----
var guild = this.InternalGetCachedGuild(guildId) ?? new DiscordGuild
⋮----
var ea = new GuildApplicationCommandCountEventArgs(this.ServiceProvider)
⋮----
await this._guildApplicationCommandCountUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the application command permissions update event.
⋮----
/// &lt;param name=&quot;perms&quot;&gt;The new permissions.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;The command id.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id.&lt;/param&gt;
internal async Task OnApplicationCommandPermissionsUpdateAsync(IEnumerable&lt;DiscordApplicationCommandPermission&gt; perms, ulong channelId, ulong guildId, ulong applicationId)
⋮----
DiscordApplicationCommand cmd;
⋮----
cmd = await this.GetGuildApplicationCommandAsync(guildId, channelId).ConfigureAwait(false);
⋮----
cmd = await this.GetGlobalApplicationCommandAsync(channelId).ConfigureAwait(false);
⋮----
var ea = new ApplicationCommandPermissionsUpdateEventArgs(this.ServiceProvider)
⋮----
Permissions = perms.ToList(),
⋮----
await this._applicationCommandPermissionsUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the interaction create event.
⋮----
/// &lt;param name=&quot;interaction&quot;&gt;The interaction.&lt;/param&gt;
/// &lt;param name=&quot;rawInteraction&quot;&gt;Debug.&lt;/param&gt;
⋮----
internal async Task OnInteractionCreateAsync(ulong? guildId, ulong channelId, TransportUser user, TransportMember member, DiscordInteraction interaction, string rawInteraction)
⋮----
//this.Logger.LogDebug(&quot;Interaction from {guild} on shard {shard}&quot;, guildId.HasValue ? guildId.Value : &quot;dm&quot;, this.ShardId);
//this.Logger.LogDebug(&quot;Interaction: {interaction}&quot;, rawInteraction);
⋮----
this.UserCache.AddOrUpdate(usr.Id, usr, (old, @new) =&gt; @new);
⋮----
usr = new DiscordMember(member)
⋮----
this.UpdateUser(usr, guildId, interaction.Guild, member);
⋮----
this.UserCache.AddOrUpdate(c.Value.Id, c.Value, (old, @new) =&gt; @new);
⋮----
this.UserCache.AddOrUpdate(c.Value.User.Id, c.Value.User, (old, @new) =&gt; @new);
⋮----
if (this.Guilds.TryGetValue(guildId.Value, out var guild))
if (guild.ChannelsInternal.TryGetValue(c.Key, out var channel) &amp;&amp; channel.PermissionOverwritesInternal != null &amp;&amp; channel.PermissionOverwritesInternal.Count != 0)
⋮----
var cea = new ComponentInteractionCreateEventArgs(this.ServiceProvider)
⋮----
await this._componentInteractionCreated.InvokeAsync(this, cea).ConfigureAwait(false);
⋮----
if (interaction.Data.Target.HasValue) // Context-Menu. //
⋮----
DiscordUser targetUser = null;
DiscordMember targetMember = null;
DiscordMessage targetMessage = null;
⋮----
var ea = new ContextMenuInteractionCreateEventArgs(this.ServiceProvider)
⋮----
await this._contextMenuInteractionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
var ea = new InteractionCreateEventArgs(this.ServiceProvider)
⋮----
await this._interactionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the entitlement create event.
⋮----
/// &lt;param name=&quot;entitlement&quot;&gt;The created entitlement&lt;/param&gt;
internal async Task OnEntitlementCreateAsync(DiscordEntitlement entitlement)
⋮----
var ea = new EntitlementCreateEventArgs(this.ServiceProvider)
⋮----
await this._entitlementCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the entitlement update event.
⋮----
/// &lt;param name=&quot;entitlement&quot;&gt;The updated entitlement&lt;/param&gt;
internal async Task OnEntitlementUpdateAsync(DiscordEntitlement entitlement)
⋮----
var ea = new EntitlementUpdateEventArgs(this.ServiceProvider)
⋮----
await this._entitlementUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the entitlement delete event.
⋮----
/// &lt;param name=&quot;entitlement&quot;&gt;The deleted entitlement&lt;/param&gt;
internal async Task OnEntitlementDeleteAsync(DiscordEntitlement entitlement)
⋮----
var ea = new EntitlementDeleteEventArgs(this.ServiceProvider)
⋮----
await this._entitlementDeleted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the subscription create event.
⋮----
/// &lt;param name=&quot;subscription&quot;&gt;The created subscription&lt;/param&gt;
internal async Task OnSubscriptionCreateAsync(DiscordSubscription subscription)
⋮----
var ea = new SubscriptionCreateEventArgs(this.ServiceProvider)
⋮----
await this._subscriptionCreated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the subscription update event.
⋮----
/// &lt;param name=&quot;subscription&quot;&gt;The updated subscription&lt;/param&gt;
internal async Task OnSubscriptionUpdateAsync(DiscordSubscription subscription)
⋮----
var ea = new SubscriptionUpdateEventArgs(this.ServiceProvider)
⋮----
await this._subscriptionUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the typing start event.
⋮----
/// &lt;param name=&quot;started&quot;&gt;The time when the user started typing.&lt;/param&gt;
⋮----
internal async Task OnTypingStartEventAsync(ulong userId, ulong channelId, DiscordChannel channel, ulong? guildId, DateTimeOffset started, TransportMember mbr)
⋮----
var ea = new TypingStartEventArgs(this.ServiceProvider)
⋮----
await this._typingStarted.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles the webhooks update.
⋮----
internal async Task OnWebhooksUpdateAsync(DiscordChannel channel, DiscordGuild guild)
⋮----
var ea = new WebhooksUpdateEventArgs(this.ServiceProvider)
⋮----
await this._webhooksUpdated.InvokeAsync(this, ea).ConfigureAwait(false);
⋮----
///     Handles all unknown events.
⋮----
internal async Task OnUnknownEventAsync(GatewayPayload payload)
⋮----
var ea = new UnknownEventArgs(this.ServiceProvider)
⋮----
await this._unknownEvent.InvokeAsync(this, ea).ConfigureAwait(false);</file><file path="DisCatSharp/Clients/DiscordClient.WebSocket.cs">/// &lt;summary&gt;
///     Represents a discord websocket client.
/// &lt;/summary&gt;
public sealed partial class DiscordClient
⋮----
///     Gets the socket lock.
⋮----
/// &lt;returns&gt;The added socket lock.&lt;/returns&gt;
private SocketLock GetSocketLock()
=&gt; s_socketLocks.GetOrAdd(this.CurrentApplication.Id, new SocketLock(this.CurrentApplication.Id, this.GatewayInfo!.SessionBucket.MaxConcurrency));
⋮----
///     Gets the heartbeat interval.
⋮----
///     Gets when the last heartbeat was sent.
⋮----
private DateTimeOffset _lastHeartbeat;
⋮----
///     Gets whether we already identified
⋮----
///     Gets the heartbeat task.
⋮----
private Task _heartbeatTask;
⋮----
///     Gets the default discord epoch.
⋮----
internal static DateTimeOffset DiscordEpoch = new(2015, 1, 1, 0, 0, 0, TimeSpan.Zero);
⋮----
///     Gets the count of skipped heartbeats.
⋮----
///     Gets the last sequence number.
⋮----
///     Gets the websocket client.
⋮----
internal IWebSocketClient WebSocketClient;
⋮----
///     Gets the payload decompressor.
⋮----
///     Gets the cancel token source.
⋮----
private CancellationTokenSource _cancelTokenSource;
⋮----
///     Gets the cancel token.
⋮----
private CancellationToken _cancelToken;
⋮----
///     Gets the socket locks.
⋮----
///     Gets the session lock.
⋮----
private readonly ManualResetEventSlim _sessionLock = new(true);
⋮----
///     Reconnects the websocket client.
⋮----
/// &lt;param name=&quot;startNewSession&quot;&gt;Whether to start a new session.&lt;/param&gt;
/// &lt;param name=&quot;code&quot;&gt;The reconnect code.&lt;/param&gt;
/// &lt;param name=&quot;message&quot;&gt;The reconnect message.&lt;/param&gt;
private Task InternalReconnectAsync(bool startNewSession = false, int code = 1000, string message = &quot;&quot;)
⋮----
_ = this.WebSocketClient.DisconnectAsync(code, message);
⋮----
///     Connects the websocket client.
⋮----
internal async Task InternalConnectAsync()
⋮----
await this.InternalUpdateGatewayAsync().ConfigureAwait(false);
await this.InitializeAsync().ConfigureAwait(false);
⋮----
socketLock = this.GetSocketLock();
await socketLock.LockAsync().ConfigureAwait(false);
⋮----
if (!this.Presences.ContainsKey(this.CurrentUser.Id))
⋮----
Volatile.Write(ref this._skippedHeartbeats, 0);
⋮----
this.WebSocketClient = this.Configuration.WebSocketClientFactory(this.Configuration.Proxy, this.ServiceProvider);
this.WebSocketClient.AddDefaultHeader(CommonHeaders.USER_AGENT, Utilities.GetUserAgent());
⋮----
? new PayloadDecompressor(this.Configuration.GatewayCompressionLevel)
⋮----
var gwuri = this.GatewayUri.AddParameter(&quot;v&quot;, this.Configuration.ApiVersion).AddParameter(&quot;encoding&quot;, &quot;json&quot;);
⋮----
gwuri = gwuri.AddParameter(&quot;compress&quot;, &quot;zlib-stream&quot;);
⋮----
this.Logger.LogDebug(LoggerEvents.Startup, &quot;Connecting to {gw}&quot;, this.GatewayUri.AbsoluteUri);
⋮----
await this.WebSocketClient.ConnectAsync(this.GatewayUri).ConfigureAwait(false);
⋮----
=&gt; this._socketOpened.InvokeAsync(this, e);
⋮----
using var ms = new MemoryStream();
⋮----
this.Logger.LogError(LoggerEvents.WebSocketReceiveFailure, &quot;Payload decompression failed&quot;);
⋮----
using var sr = new StreamReader(ms, Utilities.UTF8);
msg = await sr.ReadToEndAsync(this._cancelToken).ConfigureAwait(false);
⋮----
this.Logger.LogTrace(LoggerEvents.GatewayWsRx, &quot;{Message}&quot;, msg);
await this.HandleSocketMessageAsync(msg).ConfigureAwait(false);
⋮----
this.Logger.LogError(LoggerEvents.WebSocketReceiveFailure, ex, &quot;Socket handler suppressed an exception&quot;);
⋮----
this.Sentry.CaptureException(ex);
_ = Task.Run(this.Sentry.FlushAsync, this._cancelToken);
⋮----
=&gt; this._socketErrored.InvokeAsync(this, e);
⋮----
this._connectionLock.Set();
this._sessionLock.Set();
⋮----
await this._cancelTokenSource.CancelAsync();
⋮----
this.Logger.LogDebug(LoggerEvents.ConnectionClose, &quot;Connection closed ({CloseCode}, &apos;{Reason}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
await this._socketClosed.InvokeAsync(this, e).ConfigureAwait(false);
⋮----
this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Fatal close code received ({CloseCode}, &apos;{Reason}&apos;). No reconnection attempt.&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
⋮----
this.Logger.LogWarning(LoggerEvents.ConnectionClose, &quot;Session is invalid. Clearing session ID before reconnecting.&quot;);
⋮----
this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Connection terminated ({CloseCode}, &apos;{Reason}&apos;), reconnecting&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
⋮----
this.Logger.LogInformation(LoggerEvents.ConnectionClose, &quot;Attempting to resume session with ID {SessionId}.&quot;, this._sessionId);
⋮----
this.Logger.LogWarning(LoggerEvents.ConnectionClose, &quot;No valid session to resume, starting a new connection.&quot;);
⋮----
await this.ConnectAsync(this._status?.ActivitiesInternal?.FirstOrDefault(), this._status?.Status, this._status?.IdleSince is not null ? Utilities.GetDateTimeOffsetFromMilliseconds(this._status.IdleSince.Value) : null).ConfigureAwait(false);
⋮----
this.Logger.LogCritical(LoggerEvents.ConnectionClose, &quot;Connection terminated ({CloseCode}, &apos;{Reason}&apos;)&quot;, e.CloseCode, e.CloseMessage ?? &quot;No reason given&quot;);
⋮----
///     Handles the socket message.
⋮----
/// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
internal async Task HandleSocketMessageAsync(string data)
⋮----
_ = Task.Run(async () =&gt; await this.HandleDispatchAsync(payload).ConfigureAwait(false), this._cancelToken);
⋮----
await this.OnHeartbeatAsync((long)payload.Data).ConfigureAwait(false);
⋮----
await this.OnReconnectAsync().ConfigureAwait(false);
⋮----
await this.OnInvalidateSessionAsync((bool)payload.Data).ConfigureAwait(false);
⋮----
await this.OnHelloAsync((payload.Data as JObject).ToObject&lt;GatewayHello&gt;()).ConfigureAwait(false);
⋮----
await this.OnHeartbeatAckAsync().ConfigureAwait(false);
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received op code for non-bot event&quot;);
⋮----
this.Logger.LogWarning(LoggerEvents.WebSocketReceive, &quot;Unknown Discord opcode: {OpCode}\nPayload: {Payload}&quot;, payload.OpCode, payload.Data);
⋮----
///     Handles the heartbeat.
⋮----
/// &lt;param name=&quot;seq&quot;&gt;The sequence.&lt;/param&gt;
internal async Task OnHeartbeatAsync(long seq)
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HEARTBEAT (OP1)&quot;);
await this.SendHeartbeatAsync(seq).ConfigureAwait(false);
⋮----
///     Handles the reconnect event.
⋮----
internal async Task OnReconnectAsync()
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received RECONNECT (OP7)&quot;);
await this.InternalReconnectAsync(code: 4000, message: &quot;OP7 acknowledged&quot;).ConfigureAwait(false);
⋮----
///     Handles the invalidate session event
⋮----
/// &lt;param name=&quot;data&quot;&gt;Unknown. Please fill documentation.&lt;/param&gt;
internal async Task OnInvalidateSessionAsync(bool data)
⋮----
// begin a session if one is not open already
if (this._sessionLock.Wait(0))
this._sessionLock.Reset();
⋮----
// we are sending a fresh resume/identify, so lock the socket
var socketLock = this.GetSocketLock();
⋮----
socketLock.UnlockAfter(TimeSpan.FromSeconds(5));
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received INVALID_SESSION (OP9, true)&quot;);
await Task.Delay(6000, this._cancelToken).ConfigureAwait(false);
await this.SendResumeAsync().ConfigureAwait(false);
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received INVALID_SESSION (OP9, false)&quot;);
⋮----
await this.SendIdentifyAsync(this._status).ConfigureAwait(false);
⋮----
///     Handles the hello event.
⋮----
/// &lt;param name=&quot;hello&quot;&gt;The gateway hello payload.&lt;/param&gt;
internal async Task OnHelloAsync(GatewayHello hello)
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HELLO (OP10)&quot;);
⋮----
this.GetSocketLock().UnlockAfter(TimeSpan.FromSeconds(5));
⋮----
this.Logger.LogWarning(LoggerEvents.SessionUpdate, &quot;Attempt to start a session while another session is active&quot;);
⋮----
Interlocked.CompareExchange(ref this._skippedHeartbeats, 0, 0);
⋮----
this._heartbeatTask = Task.Run(this.HeartbeatLoopAsync, this._cancelToken);
⋮----
if (string.IsNullOrEmpty(this._sessionId))
⋮----
///     Handles the heartbeat acknowledge event.
⋮----
internal async Task OnHeartbeatAckAsync()
⋮----
Interlocked.Decrement(ref this._skippedHeartbeats);
⋮----
this.Logger.LogTrace(LoggerEvents.WebSocketReceive, &quot;Received HEARTBEAT_ACK (OP11, {0}ms)&quot;, ping);
⋮----
Volatile.Write(ref this._ping, ping);
⋮----
var args = new HeartbeatEventArgs(this.ServiceProvider)
⋮----
await this._heartbeated.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
///     Handles the heartbeat loop.
⋮----
internal async Task HeartbeatLoopAsync()
⋮----
this.Logger.LogDebug(LoggerEvents.Heartbeat, &quot;Heartbeat task started&quot;);
⋮----
await this.SendHeartbeatAsync(this._lastSequence).ConfigureAwait(false);
await Task.Delay(this._heartbeatInterval, token).ConfigureAwait(false);
token.ThrowIfCancellationRequested();
⋮----
///     Updates the status.
⋮----
/// &lt;param name=&quot;activities&quot;&gt;The activity.&lt;/param&gt;
/// &lt;param name=&quot;userStatus&quot;&gt;The optional user status.&lt;/param&gt;
/// &lt;param name=&quot;idleSince&quot;&gt;Since when is the client performing the specified activity.&lt;/param&gt;
internal async Task InternalUpdateStatusAsync(List&lt;DiscordActivity&gt;? activities, UserStatus? userStatus, DateTimeOffset? idleSince)
⋮----
var sinceUnix = idleSince != null ? (long?)Utilities.GetUnixTime(idleSince.Value) : null;
⋮----
var status = new StatusUpdate
⋮----
Activities = [..acts.Select(a =&gt; new TransportActivity(a))],
⋮----
// Solution to have status persist between sessions
⋮----
var statusUpdate = new GatewayPayload
⋮----
var statusstr = JsonConvert.SerializeObject(statusUpdate);
⋮----
await this.WsSendAsync(statusstr).ConfigureAwait(false);
⋮----
if (!this.PresencesInternal.TryGetValue(this.CurrentUser.Id, out var value))
⋮----
Activity = acts.First(),
⋮----
value.Activity = acts.First();
⋮----
///     Sends the heartbeat.
⋮----
/// &lt;param name=&quot;seq&quot;&gt;The sequenze.&lt;/param&gt;
internal async Task SendHeartbeatAsync(long seq)
⋮----
var moreThan5 = Volatile.Read(ref this._skippedHeartbeats) &gt; 5;
var guildsComp = Volatile.Read(ref this._guildDownloadCompleted);
⋮----
this.Logger.LogCritical(LoggerEvents.HeartbeatFailure, &quot;Server failed to acknowledge more than 5 heartbeats - connection is zombie&quot;);
⋮----
var args = new ZombiedEventArgs(this.ServiceProvider)
⋮----
Failures = Volatile.Read(ref this._skippedHeartbeats),
⋮----
await this._zombied.InvokeAsync(this, args).ConfigureAwait(false);
⋮----
await this.InternalReconnectAsync(code: 4001, message: &quot;Too many heartbeats missed&quot;).ConfigureAwait(false);
⋮----
this.Logger.LogWarning(LoggerEvents.HeartbeatFailure, &quot;Server failed to acknowledge more than 5 heartbeats, but the guild download is still running - check your connection speed&quot;);
⋮----
Volatile.Write(ref this._lastSequence, seq);
this.Logger.LogTrace(LoggerEvents.Heartbeat, &quot;Sending heartbeat&quot;);
var heartbeat = new GatewayPayload
⋮----
var heartbeatStr = JsonConvert.SerializeObject(heartbeat);
await this.WsSendAsync(heartbeatStr).ConfigureAwait(false);
⋮----
Interlocked.Increment(ref this._skippedHeartbeats);
⋮----
///     Sends the identify payload.
⋮----
/// &lt;param name=&quot;status&quot;&gt;The status update payload.&lt;/param&gt;
internal async Task SendIdentifyAsync(StatusUpdate? status)
⋮----
var identify = new GatewayIdentify
⋮----
Token = Utilities.GetFormattedToken(this),
⋮----
var payload = new GatewayPayload
⋮----
var payloadstr = JsonConvert.SerializeObject(payload);
await this.WsSendAsync(payloadstr).ConfigureAwait(false);
⋮----
this.Logger.LogDebug(LoggerEvents.Intents, &quot;Registered gateway intents ({Intents})&quot;, this.Configuration.Intents);
⋮----
///     Sends the resume payload.
⋮----
internal async Task SendResumeAsync()
⋮----
ArgumentNullException.ThrowIfNull(this._sessionId);
ArgumentNullException.ThrowIfNull(this._resumeGatewayUrl);
⋮----
var resume = new GatewayResume
⋮----
SequenceNumber = Volatile.Read(ref this._lastSequence)
⋮----
var resumePayload = new GatewayPayload
⋮----
var resumestr = JsonConvert.SerializeObject(resumePayload);
⋮----
this.Logger.LogDebug(LoggerEvents.ConnectionClose, &quot;Request to resume via {gw}&quot;, this.GatewayUri.AbsoluteUri);
await this.WsSendAsync(resumestr).ConfigureAwait(false);
⋮----
///     Internals the update gateway async.
⋮----
/// &lt;returns&gt;A Task.&lt;/returns&gt;
internal async Task InternalUpdateGatewayAsync()
⋮----
var info = await this.GetGatewayInfoAsync().ConfigureAwait(false);
⋮----
///     Sends a websocket message.
⋮----
/// &lt;param name=&quot;payload&quot;&gt;The payload to send.&lt;/param&gt;
internal async Task WsSendAsync(string payload)
⋮----
this.Logger.LogTrace(LoggerEvents.GatewayWsTx, &quot;{Payload}&quot;, payload);
await this.WebSocketClient.SendMessageAsync(payload).ConfigureAwait(false);</file><file path="DisCatSharp/Entities/Channel/DiscordChannel.cs">/// &lt;summary&gt;
///     Represents a discord channel.
/// &lt;/summary&gt;
public class DiscordChannel : SnowflakeObject, IEquatable&lt;DiscordChannel&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordChannel&quot; /&gt; class.
⋮----
///     Gets ID of the guild to which this channel belongs.
⋮----
///     Gets the version number for this channel.
⋮----
///     Gets ID of the category that contains this channel.
⋮----
///     Gets the category that contains this channel.
⋮----
=&gt; this.ParentId.HasValue ? this.Guild.GetChannel(this.ParentId.Value) : null;
⋮----
///     Gets the name of this channel.
⋮----
///     Gets the type of this channel.
⋮----
///     Gets the template for new posts in this channel.
///     Applicable if forum channel.
⋮----
///     Gets the position of this channel.
⋮----
///     Gets the flags of this channel.
⋮----
///     Gets the icon emoji for this channel.
///     Only visible and configurable on mobile with the new layout.
⋮----
///     Gets the theme color for this channel.
⋮----
=&gt; this.ThemeColorInt.HasValue ? new DiscordColor(this.ThemeColorInt.Value) : null;
⋮----
///     Gets whether this channel is a DM channel.
⋮----
///     Gets whether this channel is a channel category.
⋮----
///     Gets whether this channel is a stage channel.
⋮----
///     Gets the guild to which this channel belongs.
⋮----
=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
⋮----
///     Gets a collection of permission overwrites for this channel.
⋮----
///     Gets the channel&apos;s topic. This is applicable to text channels only.
⋮----
///     Gets the ID of the last message sent in this channel. This is applicable to text channels only.
⋮----
///     Gets this channel&apos;s bitrate. This is applicable to voice channels only.
⋮----
///     Gets this channel&apos;s user limit. This is applicable to voice channels only.
⋮----
///     &lt;para&gt;Gets the slow mode delay configured for this channel.&lt;/para&gt;
///     &lt;para&gt;
///         All bots, as well as users with &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt; or
///         &lt;see cref=&quot;Permissions.ManageMessages&quot; /&gt; permissions in the channel are exempt from slow mode.
///     &lt;/para&gt;
⋮----
///     &lt;para&gt;Gets the slow mode delay configured for this channel for post creations.&lt;/para&gt;
⋮----
///     Gets this channel&apos;s video quality mode. This is applicable to voice channels only.
⋮----
///     List of available tags for forum posts.
⋮----
///     Gets the default forum layout for this channel
⋮----
///     Gets the tag matching mode for this forum channel.
⋮----
///     Gets when the last pinned message was pinned.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.LastPinTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.LastPinTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets when the last pinned message was pinned as raw string.
⋮----
///     Gets this channel&apos;s default duration for newly created threads, in minutes, to automatically archive the thread
///     after recent activity.
⋮----
///     Gets this channel&apos;s mention string.
⋮----
=&gt; this.Mention();
⋮----
///     Gets this channel&apos;s children. This applies only to channel categories.
⋮----
? throw new ArgumentException(&quot;Only channel categories contain children.&quot;)
: this.Guild.ChannelsInternal.Values.Where(e =&gt; e.ParentId == this.Id).ToList();
⋮----
///     Gets the list of members currently in the channel (if voice channel), or members who can see the channel
///     (otherwise).
⋮----
? throw new InvalidOperationException(&quot;Cannot query users outside of guild channels.&quot;)
: this.IsVoiceJoinable()
? this.Guild.Members.Values.Where(x =&gt; x.VoiceState?.ChannelId == this.Id).ToList()
: this.Guild.Members.Values.Where(x =&gt; (this.PermissionsFor(x) &amp; Permissions.AccessChannels) == Permissions.AccessChannels).ToList();
⋮----
///     Gets whether this channel is an NSFW channel.
⋮----
///     Gets this channel&apos;s region id (if voice channel).
⋮----
///     Gets this channel&apos;s region override (if voice channel).
⋮----
///     Only sent on the resolved channels of interaction responses for application commands.
///     Gets the permissions of the user in this channel who invoked the command.
⋮----
/// Gets the voice channel status.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordChannel&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordChannel&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordChannel&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordChannel&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordChannel&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordChannel e)
⋮----
///     Gets the maximum available position to move the channel to.
///     This can contain outdated information.
⋮----
public int GetMaxPosition()
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News)).OrderBy(xc =&gt; xc.Position).Last().Position
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage)).OrderBy(xc =&gt; xc.Position).Last().Position
: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).Last().Position
: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).Last().Position;
⋮----
///     Gets the minimum available position to move the channel to.
⋮----
public int GetMinPosition()
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News)).OrderBy(xc =&gt; xc.Position).First().Position
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage)).OrderBy(xc =&gt; xc.Position).First().Position
: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).First().Position
: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position).First().Position;
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordChannel&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordChannel&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordChannel);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordChannel&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordChannel&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordChannel&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First channel to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second channel to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two channels are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordChannel&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two channels are not equal.&lt;/returns&gt;
⋮----
///     Sends a message to this channel.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Content of the message to send.&lt;/param&gt;
/// &lt;returns&gt;The sent message.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission if TTS is true and &lt;see cref=&quot;Permissions.SendTtsMessages&quot; /&gt; if
///     TTS is true.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the channel does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;DiscordMessage&gt; SendMessageAsync(string content) =&gt;
!this.IsWritable()
? throw new ArgumentException(&quot;Cannot send a text message to a non-text channel.&quot;)
: this.Discord.ApiClient.CreateMessageAsync(this.Id, content, null, null, null, false, false);
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to attach to the message.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission and &lt;see cref=&quot;Permissions.SendTtsMessages&quot; /&gt; if TTS is true.
⋮----
public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordEmbed embed) =&gt;
⋮----
: this.Discord.ApiClient.CreateMessageAsync(this.Id, null, embed != null
⋮----
Task&lt;DiscordMessage&gt; SendMessageAsync(string content, DiscordEmbed embed) =&gt;
⋮----
: this.Discord.ApiClient.CreateMessageAsync(this.Id, content, embed != null
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The builder with all the items to send.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission TTS is true and &lt;see cref=&quot;Permissions.SendTtsMessages&quot; /&gt; if
⋮----
Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordMessageBuilder builder)
=&gt; this.Discord.ApiClient.CreateMessageAsync(this.Id, builder);
⋮----
/// &lt;param name=&quot;action&quot;&gt;The builder with all the items to send.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendMessageAsync(Action&lt;DiscordMessageBuilder&gt; action)
⋮----
var builder = new DiscordMessageBuilder();
⋮----
return !this.IsWritable()
⋮----
: this.Discord.ApiClient.CreateMessageAsync(this.Id, builder);
⋮----
///     Sends a soundboard sound to a voice channel the user is connected to.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The ID of the soundboard sound to play.&lt;/param&gt;
/// &lt;param name=&quot;sourceGuildId&quot;&gt;
///     The ID of the guild the soundboard sound is from, required to play sounds from different
///     servers. Optional.
/// &lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.Speak&quot; /&gt;, &lt;see cref=&quot;Permissions.UseSoundboard&quot; /&gt;
///     ,
///     or &lt;see cref=&quot;Permissions.UseExternalSounds&quot; /&gt; permissions, or if the user&apos;s voice state is invalid.
⋮----
public Task SendSoundboardSoundAsync(ulong soundId, ulong? sourceGuildId = null)
⋮----
? throw new ArgumentException(&quot;Cannot send a soundboard sound to a non-voice channel.&quot;)
: this.Discord.ApiClient.SendSoundboardSoundAsync(this.Id, soundId, sourceGuildId);
⋮----
///     Deletes a guild channel
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt; permission.
⋮----
public Task DeleteAsync(string reason = null)
=&gt; this.Discord.ApiClient.DeleteChannelAsync(this.Id, reason);
⋮----
///     Clones this channel. This operation will create a channel with identical settings to this one. Note that this will
///     not copy messages or tags.
⋮----
/// &lt;returns&gt;Newly-created channel.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordChannel&gt; CloneAsync(string reason = null)
⋮----
throw new InvalidOperationException(&quot;Non-guild channels cannot be cloned.&quot;);
⋮----
ovrs.Add(new(ovr));
⋮----
if (!this.IsVoiceJoinable())
⋮----
if (!this.IsWritable())
⋮----
return await this.Guild.CreateChannelAsync(this.Name, this.Type, this.Parent, this.Topic, bitrate, userLimit, ovrs, this.IsNsfw, perUserRateLimit, this.QualityMode, this.DefaultAutoArchiveDuration, this.Flags, reason).ConfigureAwait(false);
⋮----
///     Gets a specific message.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the message&lt;/param&gt;
/// &lt;param name=&quot;fetch&quot;&gt;Whether to bypass the cache. Defaults to false.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ReadMessageHistory&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordMessage&gt; GetMessageAsync(ulong id, bool fetch = false) =&gt;
⋮----
&amp;&amp; dc.MessageCache.TryGet(xm =&gt; xm.Id == id &amp;&amp; xm.ChannelId == this.Id, out var msg)
⋮----
: await this.Discord.ApiClient.GetMessageAsync(this.Id, id).ConfigureAwait(false);
⋮----
///     Tries to get a specific message.
⋮----
/// &lt;param name=&quot;fetch&quot;&gt;Whether to bypass the cache. Defaults to true.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMessage?&gt; TryGetMessageAsync(ulong id, bool fetch = true)
⋮----
return await this.GetMessageAsync(id, fetch).ConfigureAwait(false);
⋮----
///     Modifies the current channel.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this channel&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt;.
⋮----
/// &lt;exception cref=&quot;NotSupportedException&quot;&gt;
///     Thrown when the client does not have the correct &lt;see cref=&quot;PremiumTier&quot; /&gt; for
///     modifying the &lt;see cref=&quot;ThreadAutoArchiveDuration&quot; /&gt;.
⋮----
public Task ModifyAsync(Action&lt;ChannelEditModel&gt; action)
⋮----
throw new NotSupportedException(&quot;Cannot execute this request on a forum channel.&quot;);
⋮----
var mdl = new ChannelEditModel();
⋮----
return this.Discord.ApiClient.ModifyChannelAsync(this.Id, mdl.Name, mdl.Position, mdl.Topic, mdl.Nsfw,
mdl.Parent.Map(p =&gt; p?.Id), mdl.Bitrate, mdl.UserLimit, mdl.PerUserRateLimit, mdl.RtcRegion.Map(r =&gt; r?.Id),
⋮----
///     Modifies the current forum channel.
⋮----
public Task ModifyForumAsync(Action&lt;ForumChannelEditModel&gt; action)
⋮----
throw new NotSupportedException(&quot;Cannot execute this request on a non-forum channel.&quot;);
⋮----
var mdl = new ForumChannelEditModel();
⋮----
? throw new NotSupportedException(&quot;Cannot have more than 20 tags in a forum channel.&quot;)
: (Task)this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, mdl.Name, mdl.Position, mdl.Topic, mdl.Template, mdl.Nsfw,
mdl.Parent.Map(p =&gt; p?.Id), mdl.AvailableTags, mdl.DefaultReactionEmoji, mdl.PerUserRateLimit, mdl.PostCreateUserRateLimit,
⋮----
///     Updates the channel position when it doesn&apos;t have a category.
///     Use &lt;see cref=&quot;ModifyParentAsync&quot; /&gt; for moving to other categories.
///     Use &lt;see cref=&quot;RemoveParentAsync&quot; /&gt; to move out of a category.
///     Use &lt;see cref=&quot;ModifyPositionInCategoryAsync&quot; /&gt; for moving within a category.
⋮----
/// &lt;param name=&quot;position&quot;&gt;Position the channel should be moved to.&lt;/param&gt;
⋮----
public Task ModifyPositionAsync(int position, string reason = null)
⋮----
throw new ArgumentException(&quot;Cannot modify order of non-guild channels.&quot;);
if (!this.IsMovable())
throw new NotSupportedException(&quot;You can&apos;t move this type of channel in categories.&quot;);
⋮----
throw new ArgumentException(&quot;Cannot modify order of channels within a category. Use ModifyPositionInCategoryAsync instead.&quot;);
⋮----
var pmds = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type).OrderBy(xc =&gt; xc.Position)
.Select(x =&gt; new RestGuildChannelReorderPayload
⋮----
return this.Discord.ApiClient.ModifyGuildChannelPositionAsync(this.Guild.Id, pmds, reason);
⋮----
///     Updates the channel position within it&apos;s own category.
⋮----
///     Use &lt;see cref=&quot;ModifyPositionAsync&quot; /&gt; to move channels outside a category.
⋮----
/// &lt;param name=&quot;position&quot;&gt;The position.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;IndexOutOfRangeException&quot;&gt;Thrown when &lt;paramref name=&quot;position&quot; /&gt; is out of range.&lt;/exception&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when function is called on a channel without a parent channel.&lt;/exception&gt;
public async Task ModifyPositionInCategoryAsync(int position, string reason = null)
⋮----
if (!this.IsMovableInParent())
⋮----
var channels = await this.InternalRefreshChannelsAsync().ConfigureAwait(false);
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News))
⋮----
? channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage))
: channels.Where(xc =&gt; xc.ParentId == this.ParentId &amp;&amp; xc.Type == this.Type)
⋮----
? channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; (xc.Type == ChannelType.Text || xc.Type == ChannelType.News))
⋮----
? channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; (xc.Type == ChannelType.Voice || xc.Type == ChannelType.Stage))
: channels.Where(xc =&gt; xc.ParentId == null &amp;&amp; xc.Type == this.Type);
⋮----
var ochns = chns.OrderBy(xc =&gt; xc.Position).ToArray();
var min = ochns.First().Position;
var max = ochns.Last().Position;
⋮----
throw new IndexOutOfRangeException($&quot;Position is not in range. {position} is {(position &gt; max ? &quot;greater then the maximal&quot; : &quot;lower then the minimal&quot;)} position.&quot;);
⋮----
var pmds = ochns.Select(x =&gt;
new RestGuildChannelReorderPayload
⋮----
await this.Discord.ApiClient.ModifyGuildChannelPositionAsync(this.Guild.Id, pmds, reason).ConfigureAwait(false);
⋮----
///     Internally refreshes the channel list.
⋮----
private async Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; InternalRefreshChannelsAsync()
⋮----
await this.RefreshPositionsAsync().ConfigureAwait(false);
return this.Guild.Channels.Values.ToList().AsReadOnly();
⋮----
internal void Initialize(BaseDiscordClient client)
⋮----
///     Refreshes the positions.
⋮----
public async Task RefreshPositionsAsync()
⋮----
var channels = await this.Discord.ApiClient.GetGuildChannelsAsync(this.Guild.Id).ConfigureAwait(false);
this.Guild.ChannelsInternal.Clear();
foreach (var channel in channels.ToList())
⋮----
channel.Initialize(this.Discord);
⋮----
///     Valid modes: &apos;+&apos; or &apos;down&apos; to move a channel down | &apos;-&apos; or &apos;up&apos; to move a channel up.
⋮----
/// &lt;param name=&quot;mode&quot;&gt;The mode. Valid: &apos;+&apos; or &apos;down&apos; to move a channel down | &apos;-&apos; or &apos;up&apos; to move a channel up&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Thrown when function is called on a channel without a parent channel, a wrong mode
///     is given or given position is zero.
⋮----
public Task ModifyPositionInCategorySmartAsync(string mode, int position, string reason = null)
⋮----
throw new ArgumentException(&quot;Error with the selected mode: Valid is &apos;+&apos; or &apos;down&apos; to move a channel down and &apos;-&apos; or &apos;up&apos; to move a channel up&quot;);
⋮----
? position &lt; this.GetMaxPosition()
? this.ModifyPositionInCategoryAsync(this.Position + position, reason)
: throw new IndexOutOfRangeException(&quot;Position is not in range of category.&quot;)
⋮----
? position &gt; this.GetMinPosition()
? this.ModifyPositionInCategoryAsync(this.Position - position, reason)
⋮----
: throw new ArgumentException(&quot;You can only modify with +X or -X. 0 is not valid.&quot;);
⋮----
///     Updates the channel parent, moving the channel to the bottom of the new category.
⋮----
/// &lt;param name=&quot;newParent&quot;&gt;New parent for channel. Use &lt;see cref=&quot;RemoveParentAsync(string)&quot; /&gt; to remove from parent.&lt;/param&gt;
/// &lt;param name=&quot;lockPermissions&quot;&gt;Sync permissions with parent. Defaults to null.&lt;/param&gt;
⋮----
public Task ModifyParentAsync(DiscordChannel newParent, bool? lockPermissions = null, string reason = null)
⋮----
throw new ArgumentException(&quot;Cannot modify parent of non-guild channels.&quot;);
⋮----
throw new ArgumentException(&quot;Only category type channels can be parents.&quot;);
⋮----
var position = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type &amp;&amp; xc.ParentId == newParent.Id) // gets list same type channels in parent
.Select(xc =&gt; xc.Position).DefaultIfEmpty(-1).Max() + 1; // returns highest position of list +1, default val: 0
⋮----
var pmds = this.Guild.ChannelsInternal.Values.Where(xc =&gt; xc.Type == this.Type)
.OrderBy(xc =&gt; xc.Position)
.Select(x =&gt;
⋮----
var pmd = new RestGuildChannelNewParentPayload
⋮----
return this.Discord.ApiClient.ModifyGuildChannelParentAsync(this.Guild.Id, pmds, reason);
⋮----
///     Moves the channel out of a category.
⋮----
public Task RemoveParentAsync(string reason = null)
⋮----
var pmd = new RestGuildChannelNoParentPayload
⋮----
return this.Discord.ApiClient.DetachGuildChannelParentAsync(this.Guild.Id, pmds, reason);
⋮----
///     Returns a list of messages before a certain message.
///     &lt;param name=&quot;limit&quot;&gt;The amount of messages to fetch.&lt;/param&gt;
///     &lt;param name=&quot;before&quot;&gt;Message to fetch before from.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.AccessChannels&quot; /&gt; permission.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesBeforeAsync(ulong before, int limit = 100)
=&gt; this.GetMessagesInternalAsync(limit, before);
⋮----
///     Returns a list of messages after a certain message.
⋮----
///     &lt;param name=&quot;after&quot;&gt;Message to fetch after from.&lt;/param&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAfterAsync(ulong after, int limit = 100)
=&gt; this.GetMessagesInternalAsync(limit, null, after);
⋮----
///     Returns a list of messages around a certain message.
⋮----
///     &lt;param name=&quot;around&quot;&gt;Message to fetch around from.&lt;/param&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAroundAsync(ulong around, int limit = 100)
=&gt; this.GetMessagesInternalAsync(limit, null, null, around);
⋮----
///     Returns a list of messages from the last message in the channel.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesAsync(int limit = 100) =&gt;
this.GetMessagesInternalAsync(limit);
⋮----
///     Returns a list of messages
⋮----
/// &lt;param name=&quot;limit&quot;&gt;How many messages should be returned.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Get messages before snowflake.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get messages after snowflake.&lt;/param&gt;
/// &lt;param name=&quot;around&quot;&gt;Get messages around snowflake.&lt;/param&gt;
private async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetMessagesInternalAsync(int limit = 100, ulong? before = null, ulong? after = null, ulong? around = null)
⋮----
throw new ArgumentException(&quot;Cannot get the messages of a non-text channel.&quot;);
⋮----
throw new ArgumentException(&quot;Cannot get a negative number of messages.&quot;);
⋮----
//return this.Discord.ApiClient.GetChannelMessagesAsync(this.Id, limit, before, after, around);
⋮----
throw new InvalidOperationException(&quot;Cannot get more than 100 messages around the specified ID.&quot;);
⋮----
var fetch = await this.Discord.ApiClient.GetChannelMessagesAsync(this.Id, fetchSize, !isAfter ? last ?? before : null, isAfter ? last ?? after : null, around).ConfigureAwait(false);
⋮----
msgs.AddRange(fetch);
last = fetch.LastOrDefault()?.Id;
⋮----
msgs.InsertRange(0, fetch);
last = fetch.FirstOrDefault()?.Id;
⋮----
///     Deletes multiple messages if they are less than 14 days old.  If they are older, none of the messages will be
///     deleted and you will receive a &lt;see cref=&quot;BadRequestException&quot; /&gt; error.
⋮----
/// &lt;param name=&quot;messages&quot;&gt;A collection of messages to delete.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageMessages&quot; /&gt; permission.
⋮----
public async Task DeleteMessagesAsync(IEnumerable&lt;DiscordMessage&gt; messages, string reason = null)
⋮----
// don&apos;t enumerate more than once
var msgs = messages.Where(x =&gt; x.Channel.Id == this.Id).Select(x =&gt; x.Id).ToArray();
if (messages == null || !msgs.Any())
throw new ArgumentException(&quot;You need to specify at least one message to delete.&quot;);
⋮----
await this.Discord.ApiClient.DeleteMessageAsync(this.Id, msgs.Single(), reason).ConfigureAwait(false);
⋮----
await this.Discord.ApiClient.DeleteMessagesAsync(this.Id, msgs.Skip(i).Take(100), reason).ConfigureAwait(false);
⋮----
///     Deletes a message
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to be deleted.&lt;/param&gt;
⋮----
public Task DeleteMessageAsync(DiscordMessage message, string reason = null)
=&gt; this.Discord.ApiClient.DeleteMessageAsync(this.Id, message.Id, reason);
⋮----
///     Returns a list of invite objects
⋮----
///     &lt;see cref=&quot;Permissions.CreateInstantInvite&quot; /&gt; permission.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetInvitesAsync() =&gt;
⋮----
? throw new ArgumentException(&quot;Cannot get the invites of a channel that does not belong to a guild.&quot;)
: this.Discord.ApiClient.GetChannelInvitesAsync(this.Id);
⋮----
///     Create a new invite object
⋮----
/// &lt;param name=&quot;maxAge&quot;&gt;Duration of invite in seconds before expiry, or 0 for never.  Defaults to 86400.&lt;/param&gt;
/// &lt;param name=&quot;maxUses&quot;&gt;Max number of uses or 0 for unlimited. Defaults to 0&lt;/param&gt;
/// &lt;param name=&quot;temporary&quot;&gt;Whether this invite should be temporary. Defaults to false.&lt;/param&gt;
/// &lt;param name=&quot;unique&quot;&gt;Whether this invite should be unique. Defaults to false.&lt;/param&gt;
/// &lt;param name=&quot;targetType&quot;&gt;The target type. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;targetApplicationId&quot;&gt;The target activity ID. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;targetUser&quot;&gt;The target user id. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The audit log reason.&lt;/param&gt;
⋮----
public Task&lt;DiscordInvite&gt; CreateInviteAsync(int maxAge = 86400, int maxUses = 0, bool temporary = false, bool unique = false, TargetType? targetType = null, ulong? targetApplicationId = null, ulong? targetUser = null, string reason = null)
=&gt; this.Discord.ApiClient.CreateChannelInviteAsync(this.Id, maxAge, maxUses, targetType, targetApplicationId, targetUser, temporary, unique, reason);
⋮----
///     Sets a voice channels status.
⋮----
/// &lt;param name=&quot;status&quot;&gt;Status of the voice channel.&lt;/param&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the voice channel does not exist.&lt;/exception&gt;
⋮----
public Task SetVoiceChannelStatusAsync(string status)
=&gt; this.Type != ChannelType.Voice ? throw new NotSupportedException(&quot;Cannot execute this request on a non-voice channel.&quot;) : this.Discord.ApiClient.ModifyVoiceChannelStatusAsync(this.Id, status);
⋮----
///     Removes a voice channels status.
⋮----
public Task RemoveVoiceChannelStatusAsync(string reason = null)
=&gt; this.Type != ChannelType.Voice ? throw new NotSupportedException(&quot;Cannot execute this request on a non-voice channel.&quot;) : this.Discord.ApiClient.ModifyVoiceChannelStatusAsync(this.Id, null);
⋮----
///     Opens a stage.
⋮----
/// &lt;param name=&quot;topic&quot;&gt;Topic of the stage.&lt;/param&gt;
/// &lt;param name=&quot;sendStartNotification&quot;&gt;Whether @everyone should be notified.&lt;/param&gt;
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The associated scheduled event id.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Audit log reason.&lt;/param&gt;
/// &lt;returns&gt;Stage instance&lt;/returns&gt;
⋮----
public async Task&lt;DiscordStageInstance&gt; OpenStageAsync(string topic, bool sendStartNotification = false, ulong? scheduledEventId = null, string reason = null)
=&gt; await this.Discord.ApiClient.CreateStageInstanceAsync(this.Id, topic, sendStartNotification, scheduledEventId, reason).ConfigureAwait(false);
⋮----
///     Modifies a stage topic.
⋮----
/// &lt;param name=&quot;topic&quot;&gt;New topic of the stage.&lt;/param&gt;
⋮----
public async Task ModifyStageAsync(Optional&lt;string&gt; topic, string reason = null)
=&gt; await this.Discord.ApiClient.ModifyStageInstanceAsync(this.Id, topic, reason).ConfigureAwait(false);
⋮----
///     Closes a stage.
⋮----
public async Task CloseStageAsync(string reason = null)
=&gt; await this.Discord.ApiClient.DeleteStageInstanceAsync(this.Id, reason).ConfigureAwait(false);
⋮----
///     Gets a stage.
⋮----
/// &lt;returns&gt;The requested stage.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.AccessChannels&quot; /&gt; or &lt;see cref=&quot;Permissions.UseVoice&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordStageInstance&gt; GetStageAsync()
=&gt; await this.Discord.ApiClient.GetStageInstanceAsync(this.Id).ConfigureAwait(false);
⋮----
///     Creates a scheduled event based on the channel type.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
/// &lt;param name=&quot;scheduledStartTime&quot;&gt;The scheduled start time.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;coverImage&quot;&gt;The cover image.&lt;/param&gt;
/// &lt;param name=&quot;recurrenceRule&quot;&gt;The recurrence rule.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A scheduled event.&lt;/returns&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the resource does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; CreateScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, string description = null, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
⋮----
throw new NotSupportedException(&quot;Cannot create a scheduled event for this type of channel. Channel type must be either voice or stage.&quot;);
⋮----
return await this.Guild.CreateScheduledEventAsync(name, scheduledStartTime, null, this, null, description, type, coverImage, recurrenceRule, reason).ConfigureAwait(false);
⋮----
///     Creates a thread.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the thread.&lt;/param&gt;
/// &lt;param name=&quot;autoArchiveDuration&quot;&gt;
///     &lt;see cref=&quot;ThreadAutoArchiveDuration&quot; /&gt; till it gets archived. Defaults to
///     &lt;see cref=&quot;ThreadAutoArchiveDuration.OneHour&quot; /&gt;.
⋮----
/// &lt;param name=&quot;type&quot;&gt;
///     Can be either an &lt;see cref=&quot;ChannelType.PrivateThread&quot; /&gt;, &lt;see cref=&quot;ChannelType.NewsThread&quot; /&gt; or
///     an &lt;see cref=&quot;ChannelType.PublicThread&quot; /&gt;.
⋮----
/// &lt;param name=&quot;rateLimitPerUser&quot;&gt;The per user ratelimit, aka slowdown.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The created thread.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.CreatePublicThreads&quot; /&gt; or &lt;see cref=&quot;Permissions.SendMessagesInThreads&quot; /&gt; or if creating a
///     private thread the &lt;see cref=&quot;Permissions.CreatePrivateThreads&quot; /&gt; permission.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the guild hasn&apos;t enabled threads atm.&lt;/exception&gt;
⋮----
/// &lt;exception cref=&quot;NotSupportedException&quot;&gt;Thrown when a wrong &lt;paramref name=&quot;type&quot; /&gt; was given.&lt;/exception&gt;
public async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(string name, ThreadAutoArchiveDuration autoArchiveDuration = ThreadAutoArchiveDuration.OneHour, ChannelType type = ChannelType.PublicThread, int? rateLimitPerUser = null, string reason = null) =&gt;
⋮----
? throw new NotSupportedException(&quot;Wrong thread type given.&quot;)
: !this.IsThreadHolder()
? throw new NotSupportedException(&quot;Parent channel can&apos;t have threads.&quot;)
: await this.Discord.ApiClient.CreateThreadAsync(this.Id, null, name, autoArchiveDuration, this.Type == ChannelType.News
⋮----
: ChannelType.PublicThread, rateLimitPerUser, isForum: false, reason: reason).ConfigureAwait(false);
⋮----
///     Creates a forum post.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the post.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The message of the post.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;tags&quot;&gt;The tags to add on creation.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordThreadChannel&gt; CreatePostAsync(string name, DiscordMessageBuilder builder, int? rateLimitPerUser = null, IEnumerable&lt;ForumPostTag&gt;? tags = null, string reason = null)
=&gt; this.Type != ChannelType.Forum ? throw new NotSupportedException(&quot;Parent channel must be forum.&quot;) : await this.Discord.ApiClient.CreateThreadAsync(this.Id, null, name, null, null, rateLimitPerUser, tags, builder, true, reason).ConfigureAwait(false);
⋮----
///     Gets joined archived private threads. Can contain more threads.
///     If the result&apos;s value &apos;HasMore&apos; is true, you need to recall this function to get older threads.
⋮----
/// &lt;param name=&quot;before&quot;&gt;Get threads created before this thread id.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Defines the limit of returned &lt;see cref=&quot;DiscordThreadResult&quot; /&gt;.&lt;/param&gt;
⋮----
public async Task&lt;DiscordThreadResult&gt; GetJoinedPrivateArchivedThreadsAsync(ulong? before, int? limit)
=&gt; await this.Discord.ApiClient.GetJoinedPrivateArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
⋮----
///     Gets archived public threads. Can contain more threads.
⋮----
public async Task&lt;DiscordThreadResult&gt; GetPublicArchivedThreadsAsync(ulong? before, int? limit)
=&gt; await this.Discord.ApiClient.GetPublicArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
⋮----
///     Gets archived private threads. Can contain more threads.
⋮----
///     &lt;see cref=&quot;Permissions.ManageThreads&quot; /&gt; or &lt;see cref=&quot;Permissions.ReadMessageHistory&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordThreadResult&gt; GetPrivateArchivedThreadsAsync(ulong? before, int? limit)
=&gt; await this.Discord.ApiClient.GetPrivateArchivedThreadsAsync(this.Id, before, limit).ConfigureAwait(false);
⋮----
///     Gets a forum channel tag.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the tag to get.&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when the tag does not exist.&lt;/exception&gt;
public ForumPostTag GetForumPostTag(ulong id)
⋮----
var tag = this.InternalAvailableTags.First(x =&gt; x.Id == id);
⋮----
///     Tries to get a forum channel tag.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the tag to get or null if not found.&lt;/param&gt;
public ForumPostTag? TryGetForumPostTag(ulong id)
⋮----
var tag = this.InternalAvailableTags.FirstOrDefault(x =&gt; x.Id == id);
⋮----
///     Creates a forum channel tag.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the tag.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;
///     The emoji of the tag. Has to be either a &lt;see cref=&quot;DiscordGuildEmoji&quot; /&gt; of the current guild or a
///     &lt;see cref=&quot;DiscordUnicodeEmoji&quot; /&gt;.
⋮----
/// &lt;param name=&quot;moderated&quot;&gt;Whether only moderators should be able to apply this tag.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the tag does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordChannel&gt; CreateForumPostTagAsync(string name, DiscordEmoji emoji = null, bool moderated = false, string reason = null)
⋮----
? throw new NotSupportedException(&quot;Channel needs to be type of Forum&quot;)
⋮----
: await this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, null, null, Optional.None, Optional.None, null, Optional.None, this.InternalAvailableTags.Append(new()
⋮----
}).ToList(), Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, null, Optional.None, reason).ConfigureAwait(false);
⋮----
///     Deletes a forum channel tag.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the tag to delete.&lt;/param&gt;
⋮----
public async Task&lt;DiscordChannel&gt; DeleteForumPostTag(ulong id, string reason = null)
=&gt; this.Type != ChannelType.Forum ? throw new NotSupportedException(&quot;Channel needs to be type of Forum&quot;) : await this.Discord.ApiClient.ModifyForumChannelAsync(this.Id, null, null, Optional.None, Optional.None, null, Optional.None, this.InternalAvailableTags?.Where(x =&gt; x.Id != id)?.ToList(), Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, Optional.None, null, Optional.None, reason).ConfigureAwait(false);
⋮----
///     Adds a channel permission overwrite for specified role.
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role to have the permission added.&lt;/param&gt;
/// &lt;param name=&quot;allow&quot;&gt;The permissions to allow.&lt;/param&gt;
/// &lt;param name=&quot;deny&quot;&gt;The permissions to deny.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt;
///     permission.
⋮----
public Task AddOverwriteAsync(DiscordRole role, Permissions allow = Permissions.None, Permissions deny = Permissions.None, string reason = null)
=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.Id, role.Id, allow, deny, &quot;role&quot;, reason);
⋮----
///     Adds a channel permission overwrite for specified member.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to have the permission added.&lt;/param&gt;
⋮----
public Task AddOverwriteAsync(DiscordMember member, Permissions allow = Permissions.None, Permissions deny = Permissions.None, string reason = null)
=&gt; this.Discord.ApiClient.EditChannelPermissionsAsync(this.Id, member.Id, allow, deny, &quot;member&quot;, reason);
⋮----
///     Deletes a channel permission overwrite for specified member.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to have the permission deleted.&lt;/param&gt;
⋮----
public Task DeleteOverwriteAsync(DiscordMember member, string reason = null)
=&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.Id, member.Id, reason);
⋮----
///     Deletes a channel permission overwrite for specified role.
⋮----
/// &lt;param name=&quot;role&quot;&gt;The role to have the permission deleted.&lt;/param&gt;
⋮----
public Task DeleteOverwriteAsync(DiscordRole role, string reason = null)
=&gt; this.Discord.ApiClient.DeleteChannelPermissionAsync(this.Id, role.Id, reason);
⋮----
///     Post a typing indicator.
⋮----
public Task TriggerTypingAsync() =&gt;
⋮----
? throw new ArgumentException(&quot;Cannot start typing in a non-text channel.&quot;)
: this.Discord.ApiClient.TriggerTypingAsync(this.Id);
⋮----
///     Returns the pinned messages.
⋮----
/// &lt;param name=&quot;before&quot;&gt;Get messages pinned before this timestamp.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Max number of pins to return (1-50).&lt;/param&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetPinnedMessagesAsync(ulong? before = null, int limit = 50)
=&gt; !this.IsWritable()
? throw new ArgumentException(&quot;A non-text channel does not have pinned messages.&quot;)
: this.Discord.ApiClient.GetPinnedMessagesAsync(this.Id, before, limit);
⋮----
///     Create a new webhook.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the webhook.&lt;/param&gt;
/// &lt;param name=&quot;avatar&quot;&gt;The image for the default webhook avatar.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageWebhooks&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordWebhook&gt; CreateWebhookAsync(string name, Optional&lt;Stream&gt; avatar = default, string reason = null)
=&gt; await this.Discord.ApiClient.CreateWebhookAsync(this.IsThread() ? this.ParentId!.Value : this.Id, name,
MediaTool.Base64FromStream(avatar), reason).ConfigureAwait(false);
⋮----
///     Returns a list of webhooks.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetWebhooksAsync()
=&gt; this.Discord.ApiClient.GetChannelWebhooksAsync(this.IsThread() ? this.ParentId!.Value : this.Id);
⋮----
///     Moves a member to this voice channel.
⋮----
/// &lt;param name=&quot;member&quot;&gt;The member to be moved.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.MoveMembers&quot; /&gt;
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the channel does not exists or if the Member does not exists.&lt;/exception&gt;
⋮----
public async Task PlaceMemberAsync(DiscordMember member)
⋮----
throw new ArgumentException(&quot;Cannot place a member in a non-voice channel.&quot;);
⋮----
await this.Discord.ApiClient.ModifyGuildMemberAsync(this.Guild.Id, member.Id, default, default, default,
default, this.Id, default, member.MemberFlags, null).ConfigureAwait(false);
⋮----
///     Follows a news channel.
⋮----
/// &lt;param name=&quot;targetChannel&quot;&gt;Channel to crosspost messages to.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when trying to follow a non-news channel.&lt;/exception&gt;
⋮----
///     Thrown when the current user doesn&apos;t have
///     &lt;see cref=&quot;Permissions.ManageWebhooks&quot; /&gt; on the target channel.
⋮----
public Task&lt;DiscordFollowedChannel&gt; FollowAsync(DiscordChannel targetChannel) =&gt;
⋮----
? throw new ArgumentException(&quot;Cannot follow a non-news channel.&quot;)
: this.Discord.ApiClient.FollowChannelAsync(this.Id, targetChannel.Id);
⋮----
///     Publishes a message in a news channel to following channels.
⋮----
/// &lt;param name=&quot;message&quot;&gt;Message to publish.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the message has already been crossposted.&lt;/exception&gt;
⋮----
///     Thrown when the current user doesn&apos;t have &lt;see cref=&quot;Permissions.ManageWebhooks&quot; /&gt; and/or
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt;
⋮----
public Task&lt;DiscordMessage&gt; CrosspostMessageAsync(DiscordMessage message) =&gt;
⋮----
? throw new ArgumentException(&quot;Message is already crossposted.&quot;)
: this.Discord.ApiClient.CrosspostMessageAsync(this.Id, message.Id);
⋮----
///     Updates the current user&apos;s suppress state in this channel, if stage channel.
⋮----
/// &lt;param name=&quot;suppress&quot;&gt;Toggles the suppress state.&lt;/param&gt;
/// &lt;param name=&quot;requestToSpeakTimestamp&quot;&gt;Sets the time the user requested to speak.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the channel is not a stage channel.&lt;/exception&gt;
public async Task UpdateCurrentUserVoiceStateAsync(bool? suppress, DateTimeOffset? requestToSpeakTimestamp = null)
⋮----
throw new ArgumentException(&quot;Voice state can only be updated in a stage channel.&quot;);
⋮----
await this.Discord.ApiClient.UpdateCurrentUserVoiceStateAsync(this.GuildId.Value, this.Id, suppress, requestToSpeakTimestamp).ConfigureAwait(false);
⋮----
///     Calculates permissions for a given member.
⋮----
/// &lt;param name=&quot;mbr&quot;&gt;Member to calculate permissions for.&lt;/param&gt;
/// &lt;returns&gt;Calculated permissions for a given member.&lt;/returns&gt;
public Permissions PermissionsFor(DiscordMember mbr)
⋮----
// user &gt; role &gt; everyone
// allow &gt; deny &gt; undefined
// =&gt;
// user allow &gt; user deny &gt; role allow &gt; role deny &gt; everyone allow &gt; everyone deny
⋮----
Permissions perms;
⋮----
// assign @everyone permissions
⋮----
// roles that member is in
var mbRoles = mbr.Roles.Where(xr =&gt; xr.Id != everyoneRole.Id);
⋮----
// assign permissions from member&apos;s roles (in order)
perms |= mbRoles.Aggregate(Permissions.None, (c, role) =&gt; c | role.Permissions);
⋮----
// Administrator grants all permissions and cannot be overridden
⋮----
// channel overrides for roles that member is in
⋮----
.Select(xr =&gt; this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == xr.Id))
.Where(xo =&gt; xo != null)
.ToList();
⋮----
// assign channel permission overwrites for @everyone pseudo-role
var everyoneOverwrites = this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == everyoneRole.Id);
⋮----
// assign channel permission overwrites for member&apos;s roles (explicit deny)
perms &amp;= ~mbRoleOverrides.Aggregate(Permissions.None, (c, overs) =&gt; c | overs.Denied);
// assign channel permission overwrites for member&apos;s roles (explicit allow)
perms |= mbRoleOverrides.Aggregate(Permissions.None, (c, overs) =&gt; c | overs.Allowed);
⋮----
// channel overrides for just this member
var mbOverrides = this.PermissionOverwritesInternal.FirstOrDefault(xo =&gt; xo.Id == mbr.Id);
⋮----
// assign channel permission overwrites for just this member
⋮----
///     Returns a string representation of this channel.
⋮----
/// &lt;returns&gt;String representation of this channel.&lt;/returns&gt;
public override string ToString() =&gt;
⋮----
: this.Type == ChannelType.Text || this.Type == ChannelType.News || this.IsThread()
⋮----
: !string.IsNullOrWhiteSpace(this.Name)</file><file path="DisCatSharp/Entities/Emoji/DiscordEmoji.cs">/// &lt;summary&gt;
///     Represents a Discord emoji.
/// &lt;/summary&gt;
public partial class DiscordEmoji : SnowflakeObject, IEquatable&lt;DiscordEmoji&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordEmoji&quot; /&gt; class.
⋮----
///     Gets the name of this emoji.
⋮----
///     Gets IDs the roles this emoji is enabled for.
⋮----
///     Gets whether this emoji requires colons to use.
⋮----
///     Gets whether this emoji is managed by an integration.
⋮----
///     Gets whether this emoji is animated.
⋮----
///     Gets whether the emoji is available for use.
///     An emoji may not be available due to loss of server boost.
⋮----
///     Gets the image URL of this emoji.
⋮----
? throw new InvalidOperationException(&quot;Cannot get URL of unicode emojis.&quot;)
⋮----
? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMOJIS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.gif&quot;
: $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMOJIS}/{this.Id.ToString(CultureInfo.InvariantCulture)}.png&quot;;
⋮----
///     Gets the unicode version of this emoji.
⋮----
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if emoji is not a unicode emoji.&lt;/exception&gt;
⋮----
? throw new InvalidOperationException(&quot;Emoji is not a unicode emoji&quot;)
: s_aliasNameToCanonical.TryGetValue(this.Name, out var canonicalName)
⋮----
: s_unicodeEmojis.TryGetValue(this.Name, out var value)
⋮----
: s_discordNameLookup.ContainsKey(this.Name)
⋮----
: throw new InvalidOperationException(&quot;Emoji is not a unicode emoji&quot;);
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordEmoji&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordEmoji&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordEmoji&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordEmoji e)
⋮----
///     Gets emoji&apos;s name in non-Unicode format (eg. :thinking: instead of the Unicode representation of the emoji).
⋮----
public string GetDiscordName()
⋮----
s_discordNameLookup.TryGetValue(this.Name, out var name);
⋮----
///     Returns a string representation of this emoji.
⋮----
/// &lt;returns&gt;String representation of this emoji.&lt;/returns&gt;
public override string ToString()
⋮----
? $&quot;&lt;a:{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
: $&quot;&lt;:{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&gt;&quot;
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordEmoji&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordEmoji);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordEmoji&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
⋮----
hash = (hash * 7) + this.Id.GetHashCode();
hash = (hash * 7) + this.Name.GetHashCode();
⋮----
///     Gets the reactions string.
⋮----
internal string ToReactionString()
=&gt; this.Id != 0 ? $&quot;{this.Name}:{this.Id.ToString(CultureInfo.InvariantCulture)}&quot; : this.Name;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordEmoji&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First emoji to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second emoji to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two emoji are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordEmoji&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two emoji are not equal.&lt;/returns&gt;
⋮----
///     Implicitly converts this emoji to its string representation.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;Emoji to convert.&lt;/param&gt;
⋮----
///     Checks whether specified unicode entity is a valid unicode emoji.
⋮----
/// &lt;param name=&quot;unicodeEntity&quot;&gt;Entity to check.&lt;/param&gt;
/// &lt;returns&gt;Whether it&apos;s a valid emoji.&lt;/returns&gt;
public static bool IsValidUnicode(string unicodeEntity)
=&gt; s_discordNameLookup.ContainsKey(unicodeEntity);
⋮----
///     Creates an emoji object from a unicode entity.
⋮----
/// &lt;param name=&quot;client&quot;&gt;&lt;see cref=&quot;BaseDiscordClient&quot; /&gt; to attach to the object.&lt;/param&gt;
/// &lt;param name=&quot;unicodeEntity&quot;&gt;Unicode entity to create the object from.&lt;/param&gt;
/// &lt;returns&gt;Create &lt;see cref=&quot;DiscordEmoji&quot; /&gt; object.&lt;/returns&gt;
public static DiscordEmoji FromUnicode(BaseDiscordClient client, string unicodeEntity)
⋮----
? throw new ArgumentException(&quot;Specified unicode entity is not a valid unicode emoji.&quot;, nameof(unicodeEntity))
: new DiscordEmoji
⋮----
public static DiscordEmoji FromUnicode(string unicodeEntity)
⋮----
///     Attempts to create an emoji object from a unicode entity.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Resulting &lt;see cref=&quot;DiscordEmoji&quot; /&gt; object.&lt;/param&gt;
/// &lt;returns&gt;Whether the operation was successful.&lt;/returns&gt;
public static bool TryFromUnicode(BaseDiscordClient client, string unicodeEntity, out DiscordEmoji emoji)
⋮----
if (!s_discordNameLookup.TryGetValue(unicodeEntity, out var discordName))
⋮----
if (!s_unicodeEmojis.TryGetValue(discordName, out unicodeEntity))
⋮----
public static bool TryFromUnicode(string unicodeEntity, out DiscordEmoji emoji)
⋮----
///     Gets an emoji object from an guild emote.
⋮----
/// &lt;param name=&quot;id&quot;&gt;Id of the emote.&lt;/param&gt;
⋮----
public static DiscordEmoji FromGuildEmote(BaseDiscordClient client, ulong id)
⋮----
throw new ArgumentNullException(nameof(client), &quot;Client cannot be null.&quot;);
⋮----
if (guild.Emojis.TryGetValue(id, out var found))
⋮----
throw new KeyNotFoundException(&quot;Given emote was not found.&quot;);
⋮----
///     Gets an emoji object from an application emote.
⋮----
public static DiscordEmoji FromApplicationEmote(BaseDiscordClient client, ulong id)
⋮----
? throw new ArgumentNullException(nameof(client), &quot;Client cannot be null.&quot;)
: client.Emojis.TryGetValue(id, out var found)
⋮----
: throw new KeyNotFoundException(&quot;Given emote was not found.&quot;);
⋮----
///     Attempts to get an emoji object from an guild emote.
⋮----
public static bool TryFromGuildEmote(BaseDiscordClient client, ulong id, out DiscordEmoji emoji)
⋮----
if (guild.Emojis.TryGetValue(id, out emoji))
⋮----
///     Gets an emoji object from emote name that includes colons (eg. :thinking:). This method also supports
///     skin tone variations (eg. :ok_hand::skin-tone-2:), standard emoticons (eg. :D), guild emoji, as well as application
///     emoji
///     (still specified by :name:).
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the emote to find, including colons (eg. :thinking:).&lt;/param&gt;
/// &lt;param name=&quot;includeGuilds&quot;&gt;Should guild emojis be included in the search.&lt;/param&gt;
/// &lt;param name=&quot;includeApplication&quot;&gt;Should application emojis be included in the search.&lt;/param&gt;
⋮----
public static DiscordEmoji FromName(BaseDiscordClient client, string name, bool includeGuilds = true, bool includeApplication = true)
⋮----
if (string.IsNullOrWhiteSpace(name))
throw new ArgumentNullException(nameof(name), &quot;Name cannot be empty or null.&quot;);
⋮----
if (s_aliasNameToCanonical.TryGetValue(name, out var canonicalName))
⋮----
if (s_unicodeEmojis.TryGetValue(name, out var unicodeEntity))
⋮----
.SelectMany(xg =&gt; xg.Emojis.Values); // save cycles - don&apos;t order
⋮----
var ek = name.AsSpan().Slice(1, name.Length - 2);
⋮----
if (emoji.Name.AsSpan().SequenceEqual(ek))
⋮----
throw new ArgumentException(&quot;Invalid emoji name specified.&quot;, nameof(name));
⋮----
///     Attempts to create an emoji object from emote name that includes colons (eg. :thinking:). This method also
///     supports skin tone variations (eg. :ok_hand::skin-tone-2:), standard emoticons (eg. :D), as well as guild
///     emoji (still specified by :name:).
⋮----
public static bool TryFromName(BaseDiscordClient client, string name, out DiscordEmoji emoji)
⋮----
///     Attempts to get an emoji object from emote name that includes colons (eg. :thinking:). This method also
⋮----
public static bool TryFromName(BaseDiscordClient client, string name, bool includeGuilds, bool includeApplication, out DiscordEmoji emoji)
⋮----
if (xemoji.Name.AsSpan().SequenceEqual(ek))</file><file path="DisCatSharp/Entities/Guild/DiscordGuild.cs">/// &lt;summary&gt;
///     Represents a Discord guild.
/// &lt;/summary&gt;
public partial class DiscordGuild : SnowflakeObject, IEquatable&lt;DiscordGuild&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordGuild&quot; /&gt; class.
⋮----
this._currentMemberLazy = new(() =&gt; this.MembersInternal.GetValueOrDefault(this.Discord.CurrentUser.Id));
⋮----
///     Gets the guild&apos;s name.
⋮----
///     Gets the guild icon&apos;s hash.
⋮----
///     Gets the guild icon&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.IconHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.ICONS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.IconHash}.{(this.IconHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot; : null;
⋮----
///     Gets the guild splash&apos;s hash.
⋮----
///     Gets the guild splash&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.SplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.SplashHash}.png?size=1024&quot; : null;
⋮----
///     Gets the guild discovery splash&apos;s hash.
⋮----
///     Gets the guild discovery splash&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.DiscoverySplashHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_DISCOVERY_SPLASHES}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.DiscoverySplashHash}.png?size=1024&quot; : null;
⋮----
///     Gets the guild home header&apos;s hash.
⋮----
///     Gets the guild home header&apos;s url.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.HomeHeaderHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.GUILD_HOME_HEADERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.HomeHeaderHash}.jpg?size=1280&quot; : null;
⋮----
///     Gets the preferred locale of this guild.
///     &lt;para&gt;This is used for server discovery, interactions and notices from Discord. Defaults to en-US.&lt;/para&gt;
⋮----
///     Gets the ID of the guild&apos;s owner.
⋮----
///     Gets the guild&apos;s owner.
⋮----
? this.Members.TryGetValue(this.OwnerId.Value, out var owner)
⋮----
: this.Discord.ApiClient.GetGuildMemberAsync(this.Id, this.OwnerId.Value).ConfigureAwait(false).GetAwaiter().GetResult()
⋮----
///     Gets permissions for the user in the guild (does not include channel overrides)
⋮----
///     Gets the guild&apos;s voice region ID.
⋮----
///     Gets the guild&apos;s voice region.
⋮----
///     Gets the guild&apos;s AFK voice channel ID.
⋮----
///     Gets the guild&apos;s AFK voice channel.
⋮----
? this.GetChannel(this.AfkChannelId.Value)
⋮----
///     List of &lt;see cref=&quot;DisCatSharp.Entities.DiscordApplicationCommand&quot; /&gt;.
///     Null if DisCatSharp.ApplicationCommands is not used or no guild commands are registered.
⋮----
///     Gets the guild&apos;s AFK timeout.
⋮----
///     Gets the guild&apos;s verification level.
⋮----
///     Gets the guild&apos;s default notification settings.
⋮----
///     Gets the guild&apos;s explicit content filter settings.
⋮----
///     Gets the guild&apos;s nsfw level.
⋮----
///     Gets the system channel id.
⋮----
///     Gets the channel where system messages (such as boost and welcome messages) are sent.
⋮----
? this.GetChannel(this.SystemChannelId.Value)
⋮----
///     Gets the settings for this guild&apos;s system channel.
⋮----
///     Gets whether this guild&apos;s widget is enabled.
⋮----
///     Gets the widget channel id.
⋮----
///     Gets the widget channel for this guild.
⋮----
? this.GetChannel(this.WidgetChannelId.Value)
⋮----
///     Gets the safety alerts channel id.
⋮----
///     Gets the safety alert channel for this guild.
⋮----
? this.GetChannel(this.SafetyAlertsChannelId.Value)
⋮----
///     Gets the rules channel id.
⋮----
///     Gets the rules channel for this guild.
///     &lt;para&gt;This is only available if the guild is considered &quot;discoverable&quot;.&lt;/para&gt;
⋮----
? this.GetChannel(this.RulesChannelId.Value)
⋮----
///     Gets the public updates channel id.
⋮----
///     Gets the public updates channel (where admins and moderators receive messages from Discord) for this guild.
⋮----
? this.GetChannel(this.PublicUpdatesChannelId.Value)
⋮----
///     Gets the application id of this guild if it is bot created.
⋮----
///     Gets a collection of this guild&apos;s roles.
⋮----
///     Gets a collection of this guild&apos;s stickers.
⋮----
///     Gets a collection of this guild&apos;s emojis.
⋮----
///     Gets a collection of this guild&apos;s features.
⋮----
///     Gets the guild&apos;s features.
⋮----
///     Gets the required multi-factor authentication level for this guild.
⋮----
///     Gets this guild&apos;s join date.
⋮----
///     Gets whether this guild is considered to be a large guild.
⋮----
///     Gets whether this guild is unavailable.
⋮----
///     Gets whether the guild ready event has been thrown.
⋮----
///     Gets the total number of members in this guild.
⋮----
///     Gets the maximum amount of members allowed for this guild.
⋮----
///     Gets the maximum amount of presences allowed for this guild.
⋮----
///     Gets the approximate number of members in this guild, when using
///     &lt;see cref=&quot;DiscordClient.GetGuildAsync(ulong, bool?, bool)&quot; /&gt; and having withCounts set to true.
⋮----
///     Gets the approximate number of presences in this guild, when using
⋮----
///     Gets the maximum amount of users allowed per video channel.
⋮----
///     Gets the maximum amount of users allowed per video stage channel.
⋮----
///     Gets a dictionary of all the voice states for this guilds. The key for this dictionary is the ID of the user
///     the voice state corresponds to.
⋮----
///     Gets a dictionary of all the members that belong to this guild. The dictionary&apos;s key is the member ID.
⋮----
///     Gets a dictionary of all the channels associated with this guild. The dictionary&apos;s key is the channel ID.
⋮----
///     Gets a dictionary of all the active threads associated with this guild the user has permission to view. The
///     dictionary&apos;s key is the channel ID.
⋮----
///     Gets a dictionary of all active stage instances. The dictionary&apos;s key is the stage ID.
⋮----
///     Gets a dictionary of all scheduled events.
⋮----
///     Gets a dictionary of all soundboard sounds.
⋮----
///     Gets the guild member for current user.
⋮----
///     Gets the @everyone role for this guild.
⋮----
=&gt; this.GetRole(this.Id);
⋮----
///     Gets whether the current user is the guild&apos;s owner.
⋮----
///     Gets the vanity URL code for this guild, when applicable.
⋮----
///     Gets the guild description, when applicable.
⋮----
///     Gets this guild&apos;s banner hash, when applicable.
⋮----
///     Gets this guild&apos;s banner in url form.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.BannerHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Uri}{Endpoints.BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}&quot; : null;
⋮----
///     Whether this guild has the community feature enabled.
⋮----
=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled);
⋮----
///     Whether this guild has enabled the welcome screen.
⋮----
=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasWelcomeScreenEnabled);
⋮----
///     Whether this guild has enabled membership screening.
⋮----
=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasMembershipScreeningEnabled);
⋮----
///     Gets this guild&apos;s premium tier (Nitro boosting).
⋮----
///     Gets the amount of members that boosted this guild.
⋮----
///     Whether the premium progress bar is enabled.
⋮----
///     Gets whether this guild is designated as NSFW.
⋮----
///     Gets this guild&apos;s hub type, if applicable.
⋮----
///     Gets the latest onboarding question id.
⋮----
///     Gets the guild incidents data.
⋮----
///     Gets the guild inventory settings.
⋮----
? this.GetChannel(this.EmbedChannelId.Value)
⋮----
///     Gets a dictionary of all by position ordered channels associated with this guild. The dictionary&apos;s key is the
///     channel ID.
⋮----
=&gt; new ReadOnlyDictionary&lt;ulong, DiscordChannel&gt;(this.InternalSortChannels());
⋮----
///     Whether it is synced.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuild&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordGuild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordGuild&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordGuild&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordGuild&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordGuild e)
⋮----
///     Gets the current guild member&apos;s voice state.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
public async Task&lt;DiscordVoiceState?&gt; GetCurrentMemberVoiceStateAsync()
=&gt; await this.Discord.ApiClient.GetCurrentUserVoiceStateAsync(this.Id);
⋮----
///     Gets the current voice state for a member.
⋮----
public async Task&lt;DiscordVoiceState?&gt; GetMemberVoiceStateAsync(ulong memberId)
=&gt; await this.Discord.ApiClient.GetMemberVoiceStateAsync(this.Id, memberId);
⋮----
///     Sorts the channels.
⋮----
private Dictionary&lt;ulong, DiscordChannel&gt; InternalSortChannels()
⋮----
var orderedChannels = this.GetOrderedChannels();
⋮----
keyValuePairs.Add(orderedChannel.Key, this.GetChannel(orderedChannel.Key));
⋮----
keyValuePairs.Add(chan.Id, chan);
⋮----
///     Gets an ordered &lt;see cref=&quot;DiscordChannel&quot; /&gt; list out of the channel cache.
///     Returns a Dictionary where the key is an ulong and can be mapped to &lt;see cref=&quot;ChannelType.Category&quot; /&gt;
///     &lt;see cref=&quot;DiscordChannel&quot; /&gt;s.
///     Ignore the 0 key here, because that indicates that this is the &quot;has no category&quot; list.
///     Each value contains a ordered list of text/news and voice/stage channels as &lt;see cref=&quot;DiscordChannel&quot; /&gt;.
⋮----
/// &lt;returns&gt;A ordered list of categories with its channels&lt;/returns&gt;
public Dictionary&lt;ulong, List&lt;DiscordChannel&gt;&gt; GetOrderedChannels()
⋮----
foreach (var channel in rawChannels.Where(c =&gt; c.Type == ChannelType.Category).OrderBy(c =&gt; c.Position))
orderedChannels.Add(channel.Id, []);
⋮----
foreach (var channel in rawChannels.Where(c =&gt; c is { ParentId: not null, Type: ChannelType.Text or ChannelType.News or ChannelType.Forum }).OrderBy(c =&gt; c.Position))
orderedChannels[channel.ParentId.Value!].Add(channel);
foreach (var channel in rawChannels.Where(c =&gt; c is { ParentId: not null, Type: ChannelType.Voice or ChannelType.Stage }).OrderBy(c =&gt; c.Position))
⋮----
foreach (var channel in rawChannels.Where(c =&gt; !c.ParentId.HasValue &amp;&amp; c.Type != ChannelType.Category &amp;&amp; c.Type is ChannelType.Text or ChannelType.News or ChannelType.Forum).OrderBy(c =&gt; c.Position))
orderedChannels[0].Add(channel);
foreach (var channel in rawChannels.Where(c =&gt; !c.ParentId.HasValue &amp;&amp; c.Type != ChannelType.Category &amp;&amp; c.Type is ChannelType.Voice or ChannelType.Stage).OrderBy(c =&gt; c.Position))
⋮----
///     Gets an ordered &lt;see cref=&quot;DiscordChannel&quot; /&gt; list.
⋮----
public async Task&lt;Dictionary&lt;ulong, List&lt;DiscordChannel&gt;&gt;&gt; GetOrderedChannelsAsync()
⋮----
var rawChannels = await this.Discord.ApiClient.GetGuildChannelsAsync(this.Id).ConfigureAwait(false);
⋮----
///     Returns a string representation of this guild.
⋮----
/// &lt;returns&gt;String representation of this guild.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordGuild&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordGuild&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordGuild);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordGuild&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordGuild&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuild&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First guild to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second guild to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two guilds are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordGuild&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two guilds are not equal.&lt;/returns&gt;
⋮----
///     Gets this guilds onboarding configuration.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when onboarding does not exist for a reason.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
⋮----
public Task&lt;DiscordOnboarding&gt; GetOnboardingAsync()
=&gt; this.Discord.ApiClient.GetGuildOnboardingAsync(this.Id);
⋮----
///     Modifies this guilds onboarding configuration.
⋮----
/// &lt;param name=&quot;prompts&quot;&gt;The onboarding prompts&lt;/param&gt;
/// &lt;param name=&quot;defaultChannelIds&quot;&gt;The default channel ids.&lt;/param&gt;
/// &lt;param name=&quot;enabled&quot;&gt;Whether onboarding is enabled.&lt;/param&gt;
/// &lt;param name=&quot;mode&quot;&gt;The onboarding mode.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
⋮----
public Task&lt;DiscordOnboarding&gt; ModifyOnboardingAsync(
⋮----
=&gt; this.Discord.ApiClient.ModifyGuildOnboardingAsync(this.Id, prompts, defaultChannelIds, enabled, mode,
⋮----
///     Gets this guilds server guide configuration.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when server guide does not exist for a reason.&lt;/exception&gt;
⋮----
public Task&lt;DiscordServerGuide&gt; GetServerGuideAsync()
=&gt; this.Discord.ApiClient.GetGuildServerGuideAsync(this.Id);
⋮----
///     Modifies this guilds server guide configuration.
⋮----
/// &lt;param name=&quot;enabled&quot;&gt;Whether the server guide is enabled.&lt;/param&gt;
/// &lt;param name=&quot;welcomeMessage&quot;&gt;The server guide welcome message.&lt;/param&gt;
/// &lt;param name=&quot;newMemberActions&quot;&gt;The new member actions.&lt;/param&gt;
/// &lt;param name=&quot;resourceChannels&quot;&gt;The resource channels.&lt;/param&gt;
⋮----
public Task&lt;DiscordServerGuide&gt; ModifyServerGuideAsync(Optional&lt;bool&gt; enabled = default, Optional&lt;WelcomeMessage&gt; welcomeMessage = default, Optional&lt;List&lt;NewMemberAction&gt;&gt; newMemberActions = default, Optional&lt;List&lt;ResourceChannel&gt;&gt; resourceChannels = default, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildServerGuideAsync(this.Id, enabled, welcomeMessage, newMemberActions, resourceChannels, reason);
⋮----
///     Searches the current guild for members who&apos;s display name start with the specified name.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name to search for.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The maximum amount of members to return. Max 1000. Defaults to 1.&lt;/param&gt;
/// &lt;returns&gt;The members found, if any.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordMember&gt;&gt; SearchMembersAsync(string name, int? limit = 1)
=&gt; this.Discord.ApiClient.SearchGuildMembersAsync(this.Id, name, limit);
⋮----
///     Adds a new member to this guild
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to add.&lt;/param&gt;
/// &lt;param name=&quot;accessToken&quot;&gt;The user&apos;s access token (OAuth2).&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;The new nickname.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;The new roles.&lt;/param&gt;
/// &lt;param name=&quot;muted&quot;&gt;Whether this user has to be muted.&lt;/param&gt;
/// &lt;param name=&quot;deaf&quot;&gt;Whether this user has to be deafened.&lt;/param&gt;
⋮----
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.CreateInstantInvite&quot; /&gt; permission.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;
///     Thrown when the &lt;paramref name=&quot;user&quot; /&gt; or &lt;paramref name=&quot;accessToken&quot; /&gt; is not
///     found.
⋮----
public Task AddMemberAsync(
⋮----
=&gt; this.Discord.ApiClient.AddGuildMemberAsync(this.Id, user.Id, accessToken, nickname, roles, muted, deaf);
⋮----
///     Enables the mfa requirement for this guild.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The audit log reason.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the current user is not the guilds owner.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the guild does not exist.&lt;/exception&gt;
⋮----
public Task EnableMfaAsync(string? reason = null)
=&gt; this.IsOwner ? this.Discord.ApiClient.EnableGuildMfaAsync(this.Id, reason) : throw new(&quot;The current user does not own the guild.&quot;);
⋮----
///     Disables the mfa requirement for this guild.
⋮----
public Task DisableMfaAsync(string? reason = null)
=&gt; this.IsOwner ? this.Discord.ApiClient.DisableGuildMfaAsync(this.Id, reason) : throw new(&quot;The current user does not own the guild.&quot;);
⋮----
///     Modifies this guild.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform on this guild.&lt;/param&gt;
/// &lt;returns&gt;The modified guild object.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordGuild&gt; ModifyAsync(Action&lt;GuildEditModel&gt; action)
⋮----
var mdl = new GuildEditModel();
⋮----
? throw new ArgumentException(&quot;AFK channel needs to be a text channel.&quot;)
⋮----
? throw new ArgumentException($&quot;{name} channel needs to be a text channel.&quot;)
⋮----
var iconb64 = MediaTool.Base64FromStream(mdl.Icon);
var splashb64 = MediaTool.Base64FromStream(mdl.Splash);
var bannerb64 = MediaTool.Base64FromStream(mdl.Banner);
var discoverySplashb64 = MediaTool.Base64FromStream(mdl.DiscoverySplash);
var homeHeaderb64 = MediaTool.Base64FromStream(mdl.HomeHeader);
⋮----
return await this.Discord.ApiClient.ModifyGuildAsync(this.Id, mdl.Name,
⋮----
mdl.Description, bannerb64, discoverySplashb64, homeHeaderb64, mdl.PreferredLocale, mdl.PremiumProgressBarEnabled, mdl.AuditLogReason).ConfigureAwait(false);
⋮----
///     Modifies the community settings async.
///     This sets &lt;see cref=&quot;VerificationLevel.High&quot; /&gt; if not highest and &lt;see cref=&quot;ExplicitContentFilter.AllMembers&quot; /&gt;.
⋮----
/// &lt;param name=&quot;enabled&quot;&gt;If true, enables &lt;see cref=&quot;GuildFeaturesEnum.HasCommunityEnabled&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;rulesChannel&quot;&gt;The rules channel.&lt;/param&gt;
/// &lt;param name=&quot;publicUpdatesChannel&quot;&gt;The public updates channel.&lt;/param&gt;
/// &lt;param name=&quot;preferredLocale&quot;&gt;The preferred locale. Defaults to en-US.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;defaultMessageNotifications&quot;&gt;
///     The default message notifications. Defaults to
///     &lt;see cref=&quot;DefaultMessageNotifications.MentionsOnly&quot; /&gt;
/// &lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.Administrator&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordGuild&gt; ModifyCommunitySettingsAsync(bool enabled, DiscordChannel rulesChannel, DiscordChannel publicUpdatesChannel, string preferredLocale = &quot;en-US&quot;, string description = null, DefaultMessageNotifications defaultMessageNotifications = Enums.DefaultMessageNotifications.MentionsOnly, string? reason = null)
⋮----
if (!rfeatures.Contains(&quot;COMMUNITY&quot;) &amp;&amp; enabled)
rfeatures.Add(&quot;COMMUNITY&quot;);
else if (rfeatures.Contains(&quot;COMMUNITY&quot;) &amp;&amp; !enabled)
rfeatures.Remove(&quot;COMMUNITY&quot;);
⋮----
return await this.Discord.ApiClient.ModifyGuildCommunitySettingsAsync(this.Id, rfeatures, rulesChannelId, publicUpdatesChannelId, preferredLocale, description, defaultMessageNotifications, explicitContentFilter, verificationLevel ?? Optional&lt;VerificationLevel&gt;.None, reason).ConfigureAwait(false);
⋮----
///     Modifies the guild&apos;s inventory settings.
⋮----
/// &lt;param name=&quot;enabled&quot;&gt;Whether to allow emoji packs to be collected.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The audit log reason, currently not supported.&lt;/param&gt;
⋮----
public Task&lt;DiscordGuild&gt; ModifyInventorySettingsAsync(bool enabled, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildInventorySettingsAsync(this.Id, enabled, reason);
⋮----
///     Modifies the safety alerts settings async.
⋮----
/// &lt;param name=&quot;safetyAlertsChannel&quot;&gt;The safety alerts channel.&lt;/param&gt;
⋮----
public async Task&lt;DiscordGuild&gt; ModifySafetyAlertsSettingsAsync(bool enabled, DiscordChannel safetyAlertsChannel, string? reason = null)
⋮----
if (!rfeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;) &amp;&amp; enabled)
rfeatures.Add(&quot;RAID_ALERTS_ENABLED&quot;);
else if (rfeatures.Contains(&quot;RAID_ALERTS_ENABLED&quot;) &amp;&amp; !enabled)
rfeatures.Remove(&quot;RAID_ALERTS_ENABLED&quot;);
⋮----
return await this.Discord.ApiClient.ModifyGuildSafetyAlertsSettingsAsync(this.Id, rfeatures, safetyAlertsChannelId, reason).ConfigureAwait(false);
⋮----
///     Enables invites for the guild.
⋮----
public async Task&lt;DiscordGuild&gt; EnableInvitesAsync(string? reason = null)
⋮----
if (this.Features.HasFeature(GuildFeaturesEnum.InvitesDisabled))
rfeatures.Remove(&quot;INVITES_DISABLED&quot;);
⋮----
return await this.Discord.ApiClient.ModifyGuildFeaturesAsync(this.Id, rfeatures, reason).ConfigureAwait(false);
⋮----
///     Disables invites for the guild.
⋮----
public async Task&lt;DiscordGuild&gt; DisableInvitesAsync(string? reason = null)
⋮----
if (!this.Features.HasFeature(GuildFeaturesEnum.InvitesDisabled))
rfeatures.Add(&quot;INVITES_DISABLED&quot;);
⋮----
/// &lt;param name=&quot;invitesDisabledUntil&quot;&gt;Until when invites are disabled. Set &lt;see langword=&quot;null&quot; /&gt; to disable.&lt;/param&gt;
/// &lt;param name=&quot;dmsDisabledUntil&quot;&gt;Until when direct messages are disabled. Set &lt;see langword=&quot;null&quot; /&gt; to disable.&lt;/param&gt;
⋮----
public async Task&lt;IncidentsData&gt; ModifyIncidentActionsAsync(DateTimeOffset? invitesDisabledUntil = null, DateTimeOffset? dmsDisabledUntil = null)
⋮----
invitesDisabledUntil.Value.UtcDateTime &gt; DateTimeOffset.UtcNow.UtcDateTime.AddHours(24)
? throw new InvalidOperationException(&quot;Cannot disable invites for more than 24 hours.&quot;)
⋮----
dmsDisabledUntil.Value.UtcDateTime &gt; DateTimeOffset.UtcNow.UtcDateTime.AddHours(24)
? throw new InvalidOperationException(&quot;Cannot disable direct messages for more than 24 hours.&quot;)
: await this.Discord.ApiClient.ModifyGuildIncidentActionsAsync(this.Id, invitesDisabledUntil, dmsDisabledUntil).ConfigureAwait(false);
⋮----
///     Timeout a specified member in this guild.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;Member to timeout.&lt;/param&gt;
/// &lt;param name=&quot;until&quot;&gt;The datetime offset to time out the user. Up to 28 days.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ModerateMembers&quot; /&gt; permission.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the member does not exist.&lt;/exception&gt;
⋮----
public Task TimeoutAsync(ulong memberId, DateTimeOffset until, string? reason = null)
=&gt; until.Subtract(DateTimeOffset.UtcNow).Days &gt; 28
? throw new ArgumentException(&quot;Timeout can not be longer than 28 days&quot;)
: this.Discord.ApiClient.ModifyTimeoutAsync(this.Id, memberId, until, reason);
⋮----
/// &lt;param name=&quot;until&quot;&gt;The timespan to time out the user. Up to 28 days.&lt;/param&gt;
⋮----
public Task TimeoutAsync(ulong memberId, TimeSpan until, string? reason = null)
=&gt; this.TimeoutAsync(memberId, DateTimeOffset.UtcNow + until, reason);
⋮----
/// &lt;param name=&quot;until&quot;&gt;The datetime to time out the user. Up to 28 days.&lt;/param&gt;
⋮----
public Task TimeoutAsync(ulong memberId, DateTime until, string? reason = null)
=&gt; this.TimeoutAsync(memberId, until.ToUniversalTime() - DateTime.UtcNow, reason);
⋮----
///     Removes the timeout from a specified member in this guild.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;Member to remove the timeout from.&lt;/param&gt;
⋮----
public Task RemoveTimeoutAsync(ulong memberId, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyTimeoutAsync(this.Id, memberId, null, reason);
⋮----
///     Bans a specified &lt;see cref=&quot;DiscordMember&quot; /&gt; from this guild.
⋮----
/// &lt;param name=&quot;member&quot;&gt;Member to ban.&lt;/param&gt;
/// &lt;param name=&quot;deleteMessageSeconds&quot;&gt;
///     How many seconds to remove messages from the users. Minimum &lt;c&gt;0&lt;/c&gt; seconds and
///     maximum &lt;c&gt;604800 &lt;/c&gt; seconds (7 days).
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.BanMembers&quot; /&gt;
⋮----
public Task BanMemberAsync(DiscordMember member, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string? reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, member.Id, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
⋮----
///     Bans a specified &lt;see cref=&quot;DiscordUser&quot; /&gt;. This doesn&apos;t require the user to be in this guild.
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to ban.&lt;/param&gt;
⋮----
public Task BanMemberAsync(DiscordUser user, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string? reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, user.Id, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
⋮----
///     Bans a specified user ID from this guild. This doesn&apos;t require the user to be in this guild.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;ID of the user to ban.&lt;/param&gt;
⋮----
public Task BanMemberAsync(ulong userId, [DiscordDeprecated(&quot;This is now in seconds, we convert it until the next minor release.&quot;)] int deleteMessageSeconds = 0, string reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBanAsync(this.Id, userId, deleteMessageSeconds is &lt; 8 and &gt; 0 ? this.DaysToSeconds(deleteMessageSeconds) : deleteMessageSeconds, reason);
⋮----
///     Converts days to seconds to help users transition from &lt;c&gt;deleteMessageDays&lt;/c&gt; to &lt;c&gt;deleteMessageSeconds&lt;/c&gt;.
⋮----
/// &lt;param name=&quot;days&quot;&gt;The days to convert to seconds.&lt;/param&gt;
/// &lt;returns&gt;The days in seconds.&lt;/returns&gt;
private int DaysToSeconds(int days)
⋮----
///     Bulk bans a list of &lt;see cref=&quot;DiscordMember&quot; /&gt;s from this guild.
⋮----
/// &lt;param name=&quot;members&quot;&gt;The members to ban.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Thrown when &lt;paramref name=&quot;deleteMessageSeconds&quot; /&gt; was too low or too high, or
///     when &lt;paramref name=&quot;members&quot; /&gt; contains more than &lt;c&gt;200&lt;/c&gt; members.
⋮----
///     or &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt; permission.
⋮----
public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;DiscordMember&gt; members, int deleteMessageSeconds = 0, string? reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, members.Select(x =&gt; x.Id).ToList(), deleteMessageSeconds, reason);
⋮----
///     Bulk bans a list of &lt;see cref=&quot;DiscordUser&quot; /&gt;s from this guild. This doesn&apos;t require the users to be in this
///     guild.
⋮----
/// &lt;param name=&quot;users&quot;&gt;The users to ban.&lt;/param&gt;
⋮----
///     when &lt;paramref name=&quot;users&quot; /&gt; contains more than &lt;c&gt;200&lt;/c&gt; users.
⋮----
public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;DiscordUser&gt; users, int deleteMessageSeconds = 0, string? reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, users.Select(x =&gt; x.Id).ToList(), deleteMessageSeconds, reason);
⋮----
///     Bans a list of user IDs from this guild. This doesn&apos;t require the users to be in this guild.
⋮----
/// &lt;param name=&quot;userIds&quot;&gt;The user IDs to ban.&lt;/param&gt;
⋮----
///     when &lt;paramref name=&quot;userIds&quot; /&gt; contains more than &lt;c&gt;200&lt;/c&gt; user ids.
⋮----
public Task&lt;DiscordBulkBanResponse&gt; BulkBanMembersAsync(List&lt;ulong&gt; userIds, int deleteMessageSeconds = 0, string reason = null)
=&gt; this.Discord.ApiClient.CreateGuildBulkBanAsync(this.Id, userIds, deleteMessageSeconds, reason);
⋮----
///     Unbans a user from this guild.
⋮----
/// &lt;param name=&quot;user&quot;&gt;User to unban.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the user does not exist.&lt;/exception&gt;
⋮----
public Task UnbanMemberAsync(DiscordUser user, string? reason = null)
=&gt; this.Discord.ApiClient.RemoveGuildBanAsync(this.Id, user.Id, reason);
⋮----
///     Unbans a user by ID.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;ID of the user to unban.&lt;/param&gt;
⋮----
public Task UnbanMemberAsync(ulong userId, string? reason = null)
=&gt; this.Discord.ApiClient.RemoveGuildBanAsync(this.Id, userId, reason);
⋮----
///     Leaves this guild.
⋮----
public Task LeaveAsync()
=&gt; this.Discord.ApiClient.LeaveGuildAsync(this.Id);
⋮----
///     Gets the bans for this guild, allowing for pagination.
⋮----
/// &lt;param name=&quot;limit&quot;&gt;Maximum number of bans to fetch. Max 1000. Defaults to 1000.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;
///     The Id of the user before which to fetch the bans. Overrides &lt;paramref name=&quot;after&quot; /&gt; if both are
///     present.
⋮----
/// &lt;param name=&quot;after&quot;&gt;The Id of the user after which to fetch the bans.&lt;/param&gt;
/// &lt;returns&gt;Collection of bans in this guild in ascending order by user id.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordBan&gt;&gt; GetBansAsync(int? limit = null, ulong? before = null, ulong? after = null)
=&gt; this.Discord.ApiClient.GetGuildBansAsync(this.Id, limit, before, after);
⋮----
///     Gets a ban for a specific user.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The Id of the user to get the ban for.&lt;/param&gt;
/// &lt;returns&gt;The requested ban object.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the specified user is not banned.&lt;/exception&gt;
public Task&lt;DiscordBan&gt; GetBanAsync(ulong userId)
=&gt; this.Discord.ApiClient.GetGuildBanAsync(this.Id, userId);
⋮----
///     Tries to get a ban for a specific user.
⋮----
/// &lt;returns&gt;The requested ban object or null if not found.&lt;/returns&gt;
public async Task&lt;DiscordBan?&gt; TryGetBanAsync(ulong userId)
⋮----
return await this.GetBanAsync(userId).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;user&quot;&gt;The user to get the ban for.&lt;/param&gt;
⋮----
public Task&lt;DiscordBan&gt; GetBanAsync(DiscordUser user)
=&gt; this.GetBanAsync(user.Id);
⋮----
public async Task&lt;DiscordBan?&gt; TryGetBanAsync(DiscordUser user)
⋮----
return await this.GetBanAsync(user).ConfigureAwait(false);
⋮----
///     Gets all auto mod rules for a guild.
⋮----
/// &lt;returns&gt;A collection of all rules in the guild.&lt;/returns&gt;
⋮----
public Task&lt;ReadOnlyCollection&lt;AutomodRule&gt;&gt; GetAutomodRulesAsync()
=&gt; this.Discord.ApiClient.GetAutomodRulesAsync(this.Id);
⋮----
///     Gets a specific auto mod rule.
⋮----
/// &lt;param name=&quot;ruleId&quot;&gt;The rule id to get.&lt;/param&gt;
/// &lt;returns&gt;The auto mod rule.&lt;/returns&gt;
⋮----
public Task&lt;AutomodRule&gt; GetAutomodRuleAsync(ulong ruleId)
=&gt; this.Discord.ApiClient.GetAutomodRuleAsync(this.Id, ruleId);
⋮----
///     Creates a new auto mod rule in a guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the rule.&lt;/param&gt;
/// &lt;param name=&quot;eventType&quot;&gt;The event type of the rule.&lt;/param&gt;
/// &lt;param name=&quot;triggerType&quot;&gt;The trigger type of the rule.&lt;/param&gt;
/// &lt;param name=&quot;actions&quot;&gt;The actions of the rule.&lt;/param&gt;
/// &lt;param name=&quot;triggerMetadata&quot;&gt;The meta data of the rule.&lt;/param&gt;
/// &lt;param name=&quot;enabled&quot;&gt;Whether this rule is enabled.&lt;/param&gt;
/// &lt;param name=&quot;exemptRoles&quot;&gt;The exempt roles of the rule.&lt;/param&gt;
/// &lt;param name=&quot;exemptChannels&quot;&gt;The exempt channels of the rule.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for this addition&lt;/param&gt;
/// &lt;returns&gt;The created rule.&lt;/returns&gt;
⋮----
public async Task&lt;AutomodRule&gt; CreateAutomodRuleAsync(
⋮----
=&gt; await this.Discord.ApiClient.CreateAutomodRuleAsync(this.Id, name, eventType, triggerType, actions, triggerMetadata, enabled, exemptRoles, exemptChannels, reason).ConfigureAwait(false);
⋮----
///     Creates a scheduled event.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
/// &lt;param name=&quot;scheduledStartTime&quot;&gt;The scheduled start time.&lt;/param&gt;
/// &lt;param name=&quot;scheduledEndTime&quot;&gt;The scheduled end time.&lt;/param&gt;
/// &lt;param name=&quot;channel&quot;&gt;The channel.&lt;/param&gt;
/// &lt;param name=&quot;metadata&quot;&gt;The metadata.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;coverImage&quot;&gt;The cover image.&lt;/param&gt;
/// &lt;param name=&quot;recurrenceRule&quot;&gt;The recurrence rule.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A scheduled event.&lt;/returns&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; CreateScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, DateTimeOffset? scheduledEndTime = null, DiscordChannel channel = null, DiscordScheduledEventEntityMetadata metadata = null, string description = null, ScheduledEventEntityType type = ScheduledEventEntityType.StageInstance, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
⋮----
var coverb64 = MediaTool.Base64FromStream(coverImage);
return await this.Discord.ApiClient.CreateGuildScheduledEventAsync(this.Id, type is ScheduledEventEntityType.External ? null : channel?.Id, type is ScheduledEventEntityType.External ? metadata : null, name, scheduledStartTime, scheduledEndTime.HasValue &amp;&amp; type is ScheduledEventEntityType.External ? scheduledEndTime.Value : null, description, type, coverb64, recurrenceRule, reason).ConfigureAwait(false);
⋮----
///     Creates a scheduled event with type &lt;see cref=&quot;ScheduledEventEntityType.External&quot; /&gt;.
⋮----
/// &lt;param name=&quot;location&quot;&gt;The location of the external event.&lt;/param&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; CreateExternalScheduledEventAsync(string name, DateTimeOffset scheduledStartTime, DateTimeOffset scheduledEndTime, string location, string description = null, Optional&lt;Stream&gt; coverImage = default, DiscordScheduledEventRecurrenceRule? recurrenceRule = null, string reason = null)
⋮----
return await this.Discord.ApiClient.CreateGuildScheduledEventAsync(this.Id, null, new(location), name, scheduledStartTime, scheduledEndTime, description, ScheduledEventEntityType.External, coverb64, recurrenceRule, reason).ConfigureAwait(false);
⋮----
///     Gets a specific scheduled events.
⋮----
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The Id of the event to get.&lt;/param&gt;
/// &lt;param name=&quot;withUserCount&quot;&gt;Whether to include user count.&lt;/param&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; GetScheduledEventAsync(ulong scheduledEventId, bool? withUserCount = null)
=&gt; this.ScheduledEventsInternal.TryGetValue(scheduledEventId, out var ev) ? ev : await this.Discord.ApiClient.GetGuildScheduledEventAsync(this.Id, scheduledEventId, withUserCount).ConfigureAwait(false);
⋮----
///     Tries to get a specific scheduled events.
⋮----
/// &lt;returns&gt;A scheduled event or null if not found.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordScheduledEvent?&gt; TryGetScheduledEventAsync(ulong scheduledEventId, bool? withUserCount = null)
⋮----
return await this.GetScheduledEventAsync(scheduledEventId, withUserCount).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;scheduledEvent&quot;&gt;The event to get.&lt;/param&gt;
⋮----
public async Task&lt;DiscordScheduledEvent&gt; GetScheduledEventAsync(DiscordScheduledEvent scheduledEvent, bool? withUserCount = null)
=&gt; await this.GetScheduledEventAsync(scheduledEvent.Id, withUserCount).ConfigureAwait(false);
⋮----
public async Task&lt;DiscordScheduledEvent?&gt; TryGetScheduledEventAsync(DiscordScheduledEvent scheduledEvent, bool? withUserCount = null)
⋮----
return await this.GetScheduledEventAsync(scheduledEvent, withUserCount).ConfigureAwait(false);
⋮----
///     Gets the guilds scheduled events.
⋮----
/// &lt;returns&gt;A list of the guilds scheduled events.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEvent&gt;&gt; GetScheduledEventsAsync(bool? withUserCount = null)
=&gt; await this.Discord.ApiClient.ListGuildScheduledEventsAsync(this.Id, withUserCount).ConfigureAwait(false);
⋮----
///     Creates a new text channel in this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the new channel.&lt;/param&gt;
/// &lt;param name=&quot;parent&quot;&gt;Category to put this channel in.&lt;/param&gt;
/// &lt;param name=&quot;topic&quot;&gt;Topic of the channel.&lt;/param&gt;
/// &lt;param name=&quot;overwrites&quot;&gt;Permission overwrites for this channel.&lt;/param&gt;
/// &lt;param name=&quot;nsfw&quot;&gt;Whether the channel is to be flagged as not safe for work.&lt;/param&gt;
/// &lt;param name=&quot;perUserRateLimit&quot;&gt;Slow mode timeout for users.&lt;/param&gt;
/// &lt;param name=&quot;defaultAutoArchiveDuration&quot;&gt;The default auto archive duration for new threads.&lt;/param&gt;
/// &lt;param name=&quot;flags&quot;&gt;The flags of the new channel.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The newly-created channel.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt; permission.
⋮----
public Task&lt;DiscordChannel&gt; CreateTextChannelAsync(string name, DiscordChannel? parent = null, Optional&lt;string&gt; topic = default, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, bool? nsfw = null, Optional&lt;int?&gt; perUserRateLimit = default, ThreadAutoArchiveDuration defaultAutoArchiveDuration = ThreadAutoArchiveDuration.OneDay, Optional&lt;ChannelFlags?&gt; flags = default, string? reason = null)
=&gt; this.CreateChannelAsync(name, ChannelType.Text, parent, topic, null, null, overwrites, nsfw, perUserRateLimit, null, defaultAutoArchiveDuration, flags, reason);
⋮----
///     Creates a new forum channel in this guild.
///     &lt;note type=&quot;note&quot;&gt;The field template is not yet released, so it won&apos;t applied.&lt;/note&gt;
⋮----
/// &lt;param name=&quot;defaultReactionEmoji&quot;&gt;The default reaction emoji for posts.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;postCreateUserRateLimit&quot;&gt;Slow mode timeout for user post creations.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;defaultSortOrder&quot;&gt;The default sort order for posts in the new channel.&lt;/param&gt;
/// &lt;param name=&quot;defaultLayout&quot;&gt;The default forum layout for this channel&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt; permission or the guild does not have the forum channel feature.
⋮----
public Task&lt;DiscordChannel&gt; CreateForumChannelAsync(
⋮----
=&gt; this.Discord.ApiClient.CreateGuildForumChannelAsync(this.Id, name, parent?.Id, topic, null, nsfw, defaultReactionEmoji, perUserRateLimit, postCreateUserRateLimit, defaultSortOrder, defaultLayout, defaultAutoArchiveDuration, overwrites, flags, reason);
⋮----
///     Creates a new channel category in this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the new category.&lt;/param&gt;
/// &lt;param name=&quot;overwrites&quot;&gt;Permission overwrites for this category.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The newly-created channel category.&lt;/returns&gt;
⋮----
public Task&lt;DiscordChannel&gt; CreateChannelCategoryAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt; overwrites = null, string reason = null)
=&gt; this.CreateChannelAsync(name, ChannelType.Category, null, Optional.None, null, null, overwrites, null, Optional.None, null, null, Optional.None, reason);
⋮----
///     Creates a new stage channel in this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the new stage channel.&lt;/param&gt;
/// &lt;param name=&quot;overwrites&quot;&gt;Permission overwrites for this stage channel.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The newly-created stage channel.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageChannels&quot; /&gt;.
⋮----
/// &lt;exception cref=&quot;NotSupportedException&quot;&gt;Thrown when the guilds has not enabled community.&lt;/exception&gt;
⋮----
public Task&lt;DiscordChannel&gt; CreateStageChannelAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt; overwrites = null, string reason = null)
=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled) ? this.CreateChannelAsync(name, ChannelType.Stage, null, Optional.None, null, null, overwrites, null, Optional.None, null, null, Optional.None, reason) : throw new NotSupportedException(&quot;Guild has not enabled community. Can not create a stage channel.&quot;);
⋮----
///     Creates a new news channel in this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the new news channel.&lt;/param&gt;
/// &lt;param name=&quot;overwrites&quot;&gt;Permission overwrites for this news channel.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The newly-created news channel.&lt;/returns&gt;
⋮----
public Task&lt;DiscordChannel&gt; CreateNewsChannelAsync(string name, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, string? reason = null, ThreadAutoArchiveDuration defaultAutoArchiveDuration = ThreadAutoArchiveDuration.OneDay, Optional&lt;ChannelFlags?&gt; flags = default)
=&gt; this.Features.HasFeature(GuildFeaturesEnum.HasCommunityEnabled) ? this.CreateChannelAsync(name, ChannelType.News, null, Optional.None, null, null, overwrites, null, Optional.None, null, defaultAutoArchiveDuration, flags, reason) : throw new NotSupportedException(&quot;Guild has not enabled community. Can not create a news channel.&quot;);
⋮----
///     Creates a new voice channel in this guild.
⋮----
/// &lt;param name=&quot;bitrate&quot;&gt;Bitrate of the channel.&lt;/param&gt;
/// &lt;param name=&quot;userLimit&quot;&gt;Maximum number of users in the channel.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;qualityMode&quot;&gt;Video quality mode of the channel.&lt;/param&gt;
⋮----
public Task&lt;DiscordChannel&gt; CreateVoiceChannelAsync(string name, DiscordChannel? parent = null, int? bitrate = null, int? userLimit = null, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites = null, VideoQualityMode? qualityMode = null, Optional&lt;ChannelFlags?&gt; flags = default, string? reason = null)
=&gt; this.CreateChannelAsync(name, ChannelType.Voice, parent, Optional.None, bitrate, userLimit, overwrites, null, Optional.None, qualityMode, null, flags, reason);
⋮----
///     Creates a new channel in this guild.
⋮----
/// &lt;param name=&quot;type&quot;&gt;Type of the new channel.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;bitrate&quot;&gt;Bitrate of the channel. Applies to voice only.&lt;/param&gt;
/// &lt;param name=&quot;userLimit&quot;&gt;Maximum number of users in the channel. Applies to voice only.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;nsfw&quot;&gt;Whether the channel is to be flagged as not safe for work. Applies to text only.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;qualityMode&quot;&gt;Video quality mode of the channel. Applies to voice only.&lt;/param&gt;
⋮----
public Task&lt;DiscordChannel&gt; CreateChannelAsync(
⋮----
// technically you can create news/store channels but not always
⋮----
? throw new ArgumentException(&quot;Channel type must be text, voice, stage, or category.&quot;, nameof(type))
⋮----
? throw new ArgumentException(&quot;Cannot specify parent of a channel category.&quot;, nameof(parent))
: this.Discord.ApiClient.CreateGuildChannelAsync(this.Id, name, type, parent?.Id, topic, bitrate, userLimit, overwrites, nsfw, perUserRateLimit, qualityMode, defaultAutoArchiveDuration, flags, reason);
⋮----
///     Gets active threads. Can contain more threads.
///     If the result&apos;s value &apos;HasMore&apos; is true, you need to recall this function to get older threads.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the thread does not exist.&lt;/exception&gt;
⋮----
public Task&lt;DiscordThreadResult&gt; GetActiveThreadsAsync()
=&gt; this.Discord.ApiClient.GetActiveThreadsAsync(this.Id);
⋮----
///     &lt;para&gt;Deletes all channels in this guild.&lt;/para&gt;
///     &lt;para&gt;Note that this is irreversible. Use carefully!&lt;/para&gt;
⋮----
public Task DeleteAllChannelsAsync()
⋮----
var tasks = this.Channels.Values.Select(xc =&gt; xc.DeleteAsync());
return Task.WhenAll(tasks);
⋮----
///     Estimates the number of users to be pruned.
⋮----
/// &lt;param name=&quot;days&quot;&gt;Minimum number of inactivity days required for users to be pruned. Defaults to 7.&lt;/param&gt;
/// &lt;param name=&quot;includedRoles&quot;&gt;The roles to be included in the prune.&lt;/param&gt;
/// &lt;returns&gt;Number of users that will be pruned.&lt;/returns&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.KickMembers&quot; /&gt;
⋮----
public Task&lt;int&gt; GetPruneCountAsync(int days = 7, IEnumerable&lt;DiscordRole&gt;? includedRoles = null)
⋮----
includedRoles = includedRoles.Where(r =&gt; r != null);
⋮----
.Where(x =&gt; this.RolesInternal.ContainsKey(x.Id))
.Select(x =&gt; x.Id);
⋮----
return this.Discord.ApiClient.GetGuildPruneCountAsync(this.Id, days, rawRoleIds);
⋮----
return this.Discord.ApiClient.GetGuildPruneCountAsync(this.Id, days, null);
⋮----
///     Prunes inactive users from this guild.
⋮----
/// &lt;param name=&quot;computePruneCount&quot;&gt;
///     Whether to return the prune count after this method completes. This is discouraged for
///     larger guilds.
⋮----
/// &lt;returns&gt;Number of users pruned.&lt;/returns&gt;
⋮----
public Task&lt;int?&gt; PruneAsync(int days = 7, bool computePruneCount = true, IEnumerable&lt;DiscordRole&gt;? includedRoles = null, string? reason = null)
⋮----
return this.Discord.ApiClient.BeginGuildPruneAsync(this.Id, days, computePruneCount, rawRoleIds, reason);
⋮----
return this.Discord.ApiClient.BeginGuildPruneAsync(this.Id, days, computePruneCount, null, reason);
⋮----
///     Gets integrations attached to this guild.
⋮----
/// &lt;returns&gt;Collection of integrations attached to this guild.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordIntegration&gt;&gt; GetIntegrationsAsync()
=&gt; this.Discord.ApiClient.GetGuildIntegrationsAsync(this.Id);
⋮----
///     Attaches an integration from current user to this guild.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;Integration to attach.&lt;/param&gt;
/// &lt;returns&gt;The integration after being attached to the guild.&lt;/returns&gt;
⋮----
public Task&lt;DiscordIntegration&gt; AttachUserIntegrationAsync(DiscordIntegration integration)
=&gt; this.Discord.ApiClient.CreateGuildIntegrationAsync(this.Id, integration.Type, integration.Id);
⋮----
///     Modifies an integration in this guild.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;Integration to modify.&lt;/param&gt;
/// &lt;param name=&quot;expireBehaviour&quot;&gt;Number of days after which the integration expires.&lt;/param&gt;
/// &lt;param name=&quot;expireGracePeriod&quot;&gt;Length of grace period which allows for renewing the integration.&lt;/param&gt;
/// &lt;param name=&quot;enableEmoticons&quot;&gt;Whether emotes should be synced from this integration.&lt;/param&gt;
/// &lt;returns&gt;The modified integration.&lt;/returns&gt;
⋮----
public Task&lt;DiscordIntegration&gt; ModifyIntegrationAsync(DiscordIntegration integration, int expireBehaviour, int expireGracePeriod, bool enableEmoticons)
=&gt; this.Discord.ApiClient.ModifyGuildIntegrationAsync(this.Id, integration.Id, expireBehaviour, expireGracePeriod, enableEmoticons);
⋮----
///     Removes an integration from this guild.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;Integration to remove.&lt;/param&gt;
⋮----
public Task DeleteIntegrationAsync(DiscordIntegration integration)
=&gt; this.Discord.ApiClient.DeleteGuildIntegrationAsync(this.Id, integration);
⋮----
///     Forces re-synchronization of an integration for this guild.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;Integration to synchronize.&lt;/param&gt;
⋮----
public Task SyncIntegrationAsync(DiscordIntegration integration)
=&gt; this.Discord.ApiClient.SyncGuildIntegrationAsync(this.Id, integration.Id);
⋮----
///     Gets the voice regions for this guild.
⋮----
/// &lt;returns&gt;Voice regions available for this guild.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
⋮----
var vrs = await this.Discord.ApiClient.GetGuildVoiceRegionsAsync(this.Id).ConfigureAwait(false);
⋮----
this.Discord.InternalVoiceRegions.TryAdd(xvr.Id, xvr);
⋮----
///     Gets an invite from this guild from an invite code.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The invite code&lt;/param&gt;
/// &lt;returns&gt;An invite, or null if not in cache.&lt;/returns&gt;
public DiscordInvite? GetInvite(string code)
=&gt; this.Invites.GetValueOrDefault(code);
⋮----
///     Gets all the invites created for all the channels in this guild.
⋮----
/// &lt;returns&gt;A collection of invites.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetInvitesAsync()
⋮----
var res = await this.Discord.ApiClient.GetGuildInvitesAsync(this.Id).ConfigureAwait(false);
⋮----
if (!intents.HasIntent(DiscordIntents.GuildInvites))
⋮----
///     Gets the vanity invite for this guild.
⋮----
/// &lt;returns&gt;A partial vanity invite.&lt;/returns&gt;
⋮----
public Task&lt;DiscordInvite&gt; GetVanityInviteAsync()
=&gt; this.Discord.ApiClient.GetGuildVanityUrlAsync(this.Id);
⋮----
///     Gets all the webhooks created for all the channels in this guild.
⋮----
/// &lt;returns&gt;A collection of webhooks this guild has.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageWebhooks&quot; /&gt; permission.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetWebhooksAsync()
=&gt; this.Discord.ApiClient.GetGuildWebhooksAsync(this.Id);
⋮----
///     Gets this guild&apos;s widget image.
⋮----
/// &lt;param name=&quot;bannerType&quot;&gt;The format of the widget.&lt;/param&gt;
/// &lt;returns&gt;The URL of the widget image.&lt;/returns&gt;
public string GetWidgetImage(WidgetType bannerType = WidgetType.Shield)
⋮----
return $&quot;{Utilities.GetApiBaseUri(this.Discord.Configuration)}{Endpoints.GUILDS}/{this.Id}{Endpoints.WIDGET_PNG}?style={param}&quot;;
⋮----
///     Gets a member of this guild by their user ID.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;ID of the member to get.&lt;/param&gt;
/// &lt;param name=&quot;fetch&quot;&gt;Whether to fetch the member from the api prior to cache.&lt;/param&gt;
/// &lt;returns&gt;The requested member.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the member does not exist in this guild.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordMember&gt; GetMemberAsync(ulong userId, bool fetch = false)
⋮----
if (!fetch &amp;&amp; this.MembersInternal.TryGetValue(userId, out var mbr))
⋮----
mbr = await this.Discord.ApiClient.GetGuildMemberAsync(this.Id, userId).ConfigureAwait(false);
⋮----
if (intents.HasIntent(DiscordIntents.GuildMembers))
⋮----
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordMember&quot; /&gt; if the member was found, otherwise &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordMember?&gt; TryGetMemberAsync(ulong userId, bool fetch = false)
⋮----
/// &lt;param name=&quot;member&quot;&gt;The requested member if found, otherwise &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
⋮----
/// &lt;returns&gt;Whether the member was found.&lt;/returns&gt;
public bool TryGetMember(ulong userId, [NotNullWhen(true)] out DiscordMember? member)
⋮----
member = this.TryGetMemberAsync(userId).Result;
⋮----
///     Retrieves a full list of members from Discord. This method will bypass cache.
⋮----
/// &lt;returns&gt;A collection of all members in this guild.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyCollection&lt;DiscordMember&gt;&gt; GetAllMembersAsync()
⋮----
var hasIntent = intents.HasIntent(DiscordIntents.GuildMembers);
⋮----
var tms = await this.Discord.ApiClient.ListGuildMembersAsync(this.Id, 1000, last == 0 ? null : last).ConfigureAwait(false);
⋮----
var usr = new DiscordUser(xtm.User)
⋮----
usr = this.Discord.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
⋮----
var mbr = new DiscordMember(xtm)
⋮----
recmbr.Add(mbr);
⋮----
var tm = tms.LastOrDefault();
⋮----
///     Requests that Discord send a list of guild members based on the specified arguments. This method will fire the
///     &lt;see cref=&quot;DiscordClient.GuildMembersChunked&quot; /&gt; event.
///     &lt;para&gt;
///         If no arguments aside from &lt;paramref name=&quot;presences&quot; /&gt; and &lt;paramref name=&quot;nonce&quot; /&gt; are specified, this
///         will request all guild members.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;query&quot;&gt;
///     Filters the returned members based on what the username starts with. Either this or &lt;paramref name=&quot;userIds&quot; /&gt;
///     must not be null.
///     The &lt;paramref name=&quot;limit&quot; /&gt; must also be greater than 0 if this is specified.
⋮----
/// &lt;param name=&quot;limit&quot;&gt;
///     Total number of members to request. This must be greater than 0 if &lt;paramref name=&quot;query&quot; /&gt; is
///     specified.
⋮----
/// &lt;param name=&quot;presences&quot;&gt;
///     Whether to include the
///     &lt;see cref=&quot;DisCatSharp.EventArgs.GuildMembersChunkEventArgs.Presences&quot; /&gt; associated with the fetched members.
⋮----
/// &lt;param name=&quot;userIds&quot;&gt;
///     Whether to limit the request to the specified user ids. Either this or &lt;paramref name=&quot;query&quot; /&gt;
⋮----
/// &lt;param name=&quot;nonce&quot;&gt;The unique string to identify the response.&lt;/param&gt;
public async Task RequestMembersAsync(string? query = null, int limit = 0, bool? presences = null, IEnumerable&lt;ulong&gt;? userIds = null, string? nonce = null)
⋮----
throw new InvalidOperationException(&quot;This operation is only valid for regular Discord clients.&quot;);
⋮----
throw new ArgumentException(&quot;The query and user IDs cannot both be null.&quot;);
⋮----
var grgm = new GatewayRequestGuildMembers(this)
⋮----
var payload = new GatewayPayload
⋮----
var payloadStr = JsonConvert.SerializeObject(payload, Formatting.None);
await client.WsSendAsync(payloadStr).ConfigureAwait(false);
⋮----
///     Gets all the channels this guild has.
⋮----
/// &lt;returns&gt;A collection of this guild&apos;s channels.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; GetChannelsAsync()
=&gt; this.Discord.ApiClient.GetGuildChannelsAsync(this.Id);
⋮----
///     Creates a new role in this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the role.&lt;/param&gt;
/// &lt;param name=&quot;permissions&quot;&gt;Permissions for the role.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;Color for the role.&lt;/param&gt;
/// &lt;param name=&quot;hoist&quot;&gt;Whether the role is to be hoisted.&lt;/param&gt;
/// &lt;param name=&quot;mentionable&quot;&gt;Whether the role is to be mentionable.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The newly-created role.&lt;/returns&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageRoles&quot; /&gt;
⋮----
public Task&lt;DiscordRole&gt; CreateRoleAsync(string name = null, Permissions? permissions = null, DiscordColor? color = null, bool? hoist = null, bool? mentionable = null, string reason = null)
=&gt; this.Discord.ApiClient.CreateGuildRoleAsync(this.Id, name, permissions, color?.Value, hoist, mentionable, reason);
⋮----
///     Gets a role from this guild&apos;s cache by its ID.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the role to get.&lt;/param&gt;
/// &lt;returns&gt;Requested role.&lt;/returns&gt;
public DiscordRole? GetRole(ulong id)
=&gt; this.RolesInternal.GetValueOrDefault(id);
⋮----
///     Gets a role from this guild from the api by its ID.
⋮----
public async Task&lt;DiscordRole&gt; GetRoleAsync(ulong id)
=&gt; await this.Discord.ApiClient.GetGuildRoleAsync(this.Id, id);
⋮----
///     Gets a channel from this guild by its ID.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the channel to get.&lt;/param&gt;
/// &lt;returns&gt;Requested channel.&lt;/returns&gt;
⋮----
public DiscordChannel? GetChannel(ulong id)
=&gt; this.ChannelsInternal.GetValueOrDefault(id);
⋮----
///     Gets a thread from this guild by its ID.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the thread to get.&lt;/param&gt;
/// &lt;returns&gt;Requested thread.&lt;/returns&gt;
⋮----
public DiscordThreadChannel? GetThread(ulong id)
=&gt; this.ThreadsInternal.GetValueOrDefault(id);
⋮----
///     Gets all of this guild&apos;s custom emojis.
⋮----
/// &lt;returns&gt;All of this guild&apos;s custom emojis.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordGuildEmoji&gt;&gt; GetEmojisAsync()
=&gt; this.Discord.ApiClient.GetGuildEmojisAsync(this.Id);
⋮----
///     Gets this guild&apos;s specified custom emoji.
⋮----
/// &lt;param name=&quot;id&quot;&gt;ID of the emoji to get.&lt;/param&gt;
/// &lt;returns&gt;The requested custom emoji.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildEmoji&gt; GetEmojiAsync(ulong id)
=&gt; this.Discord.ApiClient.GetGuildEmojiAsync(this.Id, id);
⋮----
///     Creates a new custom emoji for this guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the new emoji.&lt;/param&gt;
/// &lt;param name=&quot;image&quot;&gt;Image to use as the emoji.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;
///     Roles for which the emoji will be available. This works only if your application is whitelisted as
///     integration.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit log.&lt;/param&gt;
/// &lt;returns&gt;The newly-created emoji.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.ManageGuildExpressions&quot; /&gt; permission.
⋮----
public Task&lt;DiscordGuildEmoji&gt; CreateEmojiAsync(string name, Stream image, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
⋮----
if (string.IsNullOrWhiteSpace(name))
throw new ArgumentNullException(nameof(name));
⋮----
name = name.Trim();
⋮----
throw new ArgumentException(&quot;Emoji name needs to be between 2 and 50 characters long.&quot;);
⋮----
ArgumentNullException.ThrowIfNull(image);
⋮----
var image64 = MediaTool.Base64FromStream(image);
⋮----
return this.Discord.ApiClient.CreateGuildEmojiAsync(this.Id, name, image64, roles?.Select(xr =&gt; xr.Id), reason);
⋮----
///     Modifies a this guild&apos;s custom emoji.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji to modify.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;New name for the emoji.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The modified emoji.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildEmoji&gt; ModifyEmojiAsync(DiscordGuildEmoji emoji, string name, IEnumerable&lt;DiscordRole&gt; roles = null, string reason = null)
⋮----
ArgumentNullException.ThrowIfNull(emoji);
⋮----
throw new ArgumentException(&quot;This emoji does not belong to this guild.&quot;);
⋮----
? throw new ArgumentException(&quot;Emoji name needs to be between 2 and 50 characters long.&quot;)
: this.Discord.ApiClient.ModifyGuildEmojiAsync(this.Id, emoji.Id, name, roles?.Select(xr =&gt; xr.Id), reason);
⋮----
///     Deletes this guild&apos;s custom emoji.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji to delete.&lt;/param&gt;
⋮----
public Task DeleteEmojiAsync(DiscordGuildEmoji emoji, string? reason = null)
⋮----
? throw new ArgumentNullException(nameof(emoji))
⋮----
? throw new ArgumentException(&quot;This emoji does not belong to this guild.&quot;)
: this.Discord.ApiClient.DeleteGuildEmojiAsync(this.Id, emoji.Id, reason);
⋮----
///     Gets all of this guild&apos;s custom stickers.
⋮----
/// &lt;returns&gt;All of this guild&apos;s custom stickers.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordSticker&gt;&gt; GetStickersAsync()
⋮----
var stickers = await this.Discord.ApiClient.GetGuildStickersAsync(this.Id).ConfigureAwait(false);
⋮----
this.StickersInternal.AddOrUpdate(xstr.Id, xstr, (id, old) =&gt;
⋮----
///     Gets a sticker
⋮----
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the sticker could not be found.&lt;/exception&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Sticker does not belong to a guild.&lt;/exception&gt;
public Task&lt;DiscordSticker&gt; GetStickerAsync(ulong stickerId)
=&gt; this.Discord.ApiClient.GetGuildStickerAsync(this.Id, stickerId);
⋮----
///     Creates a sticker
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the sticker.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The optional description of the sticker.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to associate the sticker with.&lt;/param&gt;
/// &lt;param name=&quot;format&quot;&gt;The file format the sticker is written in.&lt;/param&gt;
/// &lt;param name=&quot;file&quot;&gt;The sticker.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Audit log reason&lt;/param&gt;
⋮----
public Task&lt;DiscordSticker&gt; CreateStickerAsync(string name, string description, DiscordEmoji emoji, Stream file, StickerFormat format, string? reason = null)
⋮----
_ =&gt; throw new InvalidOperationException(&quot;This format is not supported.&quot;)
⋮----
? throw new InvalidOperationException(&quot;Only unicode emoji can be used for stickers.&quot;)
⋮----
? throw new ArgumentOutOfRangeException(nameof(name), &quot;Sticker name needs to be between 2 and 30 characters long.&quot;)
⋮----
? throw new ArgumentOutOfRangeException(nameof(description), &quot;Sticker description needs to be between 1 and 100 characters long.&quot;)
: this.Discord.ApiClient.CreateGuildStickerAsync(this.Id, name, description, emoji.GetDiscordName().Replace(&quot;:&quot;, &quot;&quot;), new(&quot;sticker&quot;, file, null, fileExt, contentType), reason);
⋮----
///     Modifies a sticker
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;The id of the sticker to modify&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the sticker&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description of the sticker&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to associate with this sticker.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A sticker object&lt;/returns&gt;
⋮----
public async Task&lt;DiscordSticker&gt; ModifyStickerAsync(ulong sticker, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;DiscordEmoji&gt; emoji, string? reason = null)
⋮----
if (!this.StickersInternal.TryGetValue(sticker, out var stickerobj) || stickerobj.Guild.Id != this.Id)
throw new ArgumentException(&quot;This sticker does not belong to this guild.&quot;);
⋮----
throw new ArgumentException(&quot;Sticker name needs to be between 2 and 30 characters long.&quot;);
⋮----
throw new ArgumentException(&quot;Sticker description needs to be between 1 and 100 characters long.&quot;);
⋮----
throw new ArgumentException(&quot;Only unicode emojis can be used with stickers.&quot;);
⋮----
uemoji = emoji.Value.GetDiscordName().Replace(&quot;:&quot;, &quot;&quot;);
⋮----
var usticker = await this.Discord.ApiClient.ModifyGuildStickerAsync(this.Id, sticker, name, description, uemoji, reason).ConfigureAwait(false);
⋮----
if (this.StickersInternal.TryGetValue(usticker.Id, out var old))
this.StickersInternal.TryUpdate(usticker.Id, usticker, old);
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;The sticker to modify&lt;/param&gt;
⋮----
public Task&lt;DiscordSticker&gt; ModifyStickerAsync(DiscordSticker sticker, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;DiscordEmoji&gt; emoji, string? reason = null)
=&gt; this.ModifyStickerAsync(sticker.Id, name, description, emoji, reason);
⋮----
///     Deletes a sticker
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;Id of sticker to delete&lt;/param&gt;
⋮----
public Task DeleteStickerAsync(ulong sticker, string? reason = null) =&gt;
!this.StickersInternal.TryGetValue(sticker, out var stickerobj)
? throw new ArgumentNullException(nameof(sticker))
⋮----
? throw new ArgumentException(&quot;This sticker does not belong to this guild.&quot;)
: this.Discord.ApiClient.DeleteGuildStickerAsync(this.Id, sticker, reason);
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;Sticker to delete&lt;/param&gt;
⋮----
public Task DeleteStickerAsync(DiscordSticker sticker, string? reason = null)
=&gt; this.DeleteStickerAsync(sticker.Id, reason);
⋮----
///     &lt;para&gt;Gets the default channel for this guild.&lt;/para&gt;
///     &lt;para&gt;Default channel is the first channel current member can see.&lt;/para&gt;
⋮----
/// &lt;returns&gt;This member&apos;s default guild.&lt;/returns&gt;
⋮----
public DiscordChannel? GetDefaultChannel() =&gt;
this.ChannelsInternal.Values.Where(xc =&gt; xc.Type == ChannelType.Text)
.OrderBy(xc =&gt; xc.Position)
.FirstOrDefault(xc =&gt; (xc.PermissionsFor(this.CurrentMember) &amp; Enums.Permissions.AccessChannels) == Enums.Permissions.AccessChannels);
⋮----
///     Gets the guild&apos;s widget
⋮----
/// &lt;returns&gt;The guild&apos;s widget&lt;/returns&gt;
public Task&lt;DiscordWidget&gt; GetWidgetAsync()
=&gt; this.Discord.ApiClient.GetGuildWidgetAsync(this.Id);
⋮----
///     Gets the guild&apos;s widget settings
⋮----
/// &lt;returns&gt;The guild&apos;s widget settings&lt;/returns&gt;
public Task&lt;DiscordWidgetSettings&gt; GetWidgetSettingsAsync()
=&gt; this.Discord.ApiClient.GetGuildWidgetSettingsAsync(this.Id);
⋮----
///     Modifies the guild&apos;s widget settings
⋮----
/// &lt;param name=&quot;isEnabled&quot;&gt;If the widget is enabled or not&lt;/param&gt;
/// &lt;param name=&quot;channel&quot;&gt;Widget channel&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason the widget settings were modified&lt;/param&gt;
/// &lt;returns&gt;The newly modified widget settings&lt;/returns&gt;
public Task&lt;DiscordWidgetSettings&gt; ModifyWidgetSettingsAsync(bool? isEnabled = null, DiscordChannel? channel = null, string? reason = null)
=&gt; this.Discord.ApiClient.ModifyGuildWidgetSettingsAsync(this.Id, isEnabled, channel?.Id, reason);
⋮----
///     Gets all of this guild&apos;s templates.
⋮----
/// &lt;returns&gt;All of the guild&apos;s templates.&lt;/returns&gt;
⋮----
///     Throws when the client does not have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordGuildTemplate&gt;&gt; GetTemplatesAsync()
=&gt; this.Discord.ApiClient.GetGuildTemplatesAsync(this.Id);
⋮----
///     Creates a guild template.
⋮----
/// &lt;param name=&quot;name&quot;&gt;Name of the template.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the template.&lt;/param&gt;
/// &lt;returns&gt;The template created.&lt;/returns&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;
///     Throws when a template already exists for the guild or a null parameter is
///     provided for the name.
⋮----
public Task&lt;DiscordGuildTemplate&gt; CreateTemplateAsync(string name, string? description = null)
=&gt; this.Discord.ApiClient.CreateGuildTemplateAsync(this.Id, name, description);
⋮----
///     Syncs the template to the current guild&apos;s state.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code of the template to sync.&lt;/param&gt;
/// &lt;returns&gt;The template synced.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Throws when the template for the code cannot be found&lt;/exception&gt;
⋮----
public Task&lt;DiscordGuildTemplate&gt; SyncTemplateAsync(string code)
=&gt; this.Discord.ApiClient.SyncGuildTemplateAsync(this.Id, code);
⋮----
///     Modifies the template&apos;s metadata.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The template&apos;s code.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The template modified.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildTemplate&gt; ModifyTemplateAsync(string code, string? name = null, string? description = null)
=&gt; this.Discord.ApiClient.ModifyGuildTemplateAsync(this.Id, code, name, description);
⋮----
///     Deletes the template.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code of the template to delete.&lt;/param&gt;
/// &lt;returns&gt;The deleted template.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildTemplate&gt; DeleteTemplateAsync(string code)
=&gt; this.Discord.ApiClient.DeleteGuildTemplateAsync(this.Id, code);
⋮----
///     Gets this guild&apos;s membership screening form.
⋮----
/// &lt;returns&gt;This guild&apos;s membership screening form.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildMembershipScreening&gt; GetMembershipScreeningFormAsync()
=&gt; this.Discord.ApiClient.GetGuildMembershipScreeningFormAsync(this.Id);
⋮----
///     Modifies this guild&apos;s membership screening form.
⋮----
/// &lt;param name=&quot;action&quot;&gt;Action to perform&lt;/param&gt;
/// &lt;returns&gt;The modified screening form.&lt;/returns&gt;
⋮----
///     Thrown when the client doesn&apos;t have the &lt;see cref=&quot;Permissions.ManageGuild&quot; /&gt;
///     permission, or community is not enabled on this guild.
⋮----
public async Task&lt;DiscordGuildMembershipScreening&gt; ModifyMembershipScreeningFormAsync(Action&lt;MembershipScreeningEditModel&gt; action)
⋮----
var mdl = new MembershipScreeningEditModel();
⋮----
return await this.Discord.ApiClient.ModifyGuildMembershipScreeningFormAsync(this.Id, mdl.Enabled, mdl.Fields, mdl.Description).ConfigureAwait(false);
⋮----
///     Gets all the application commands in this guild.
⋮----
/// &lt;returns&gt;A list of application commands in this guild.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetApplicationCommandsAsync() =&gt;
this.Discord.ApiClient.GetGuildApplicationCommandsAsync(this.Discord.CurrentApplication.Id, this.Id);
⋮----
///     Overwrites the existing application commands in this guild. New commands are automatically created and missing
///     commands are automatically delete
⋮----
/// &lt;param name=&quot;commands&quot;&gt;The list of commands to overwrite with.&lt;/param&gt;
/// &lt;returns&gt;The list of guild commands&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteApplicationCommandsAsync(IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
this.Discord.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.Discord.CurrentApplication.Id, this.Id, commands);
⋮----
///     Creates or overwrites a application command in this guild.
⋮----
/// &lt;param name=&quot;command&quot;&gt;The command to create.&lt;/param&gt;
/// &lt;returns&gt;The created command.&lt;/returns&gt;
public Task&lt;DiscordApplicationCommand&gt; CreateApplicationCommandAsync(DiscordApplicationCommand command) =&gt;
this.Discord.ApiClient.CreateGuildApplicationCommandAsync(this.Discord.CurrentApplication.Id, this.Id, command);
⋮----
///     Edits a application command in this guild.
⋮----
/// &lt;param name=&quot;commandId&quot;&gt;The id of the command to edit.&lt;/param&gt;
/// &lt;param name=&quot;action&quot;&gt;Action to perform.&lt;/param&gt;
/// &lt;returns&gt;The edit command.&lt;/returns&gt;
public async Task&lt;DiscordApplicationCommand&gt; EditApplicationCommandAsync(ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
⋮----
var mdl = new ApplicationCommandEditModel();
⋮----
return await this.Discord.ApiClient.EditGuildApplicationCommandAsync(this.Discord.CurrentApplication.Id, this.Id, commandId, mdl.Name, mdl.Description!, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
⋮----
///     Gets this guild&apos;s welcome screen.
⋮----
/// &lt;returns&gt;This guild&apos;s welcome screen object.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildWelcomeScreen&gt; GetWelcomeScreenAsync() =&gt;
this.Discord.ApiClient.GetGuildWelcomeScreenAsync(this.Id);
⋮----
///     Modifies this guild&apos;s welcome screen.
⋮----
/// &lt;returns&gt;The modified welcome screen.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordGuildWelcomeScreen&gt; ModifyWelcomeScreenAsync(Action&lt;WelcomeScreenEditModel&gt; action)
⋮----
var mdl = new WelcomeScreenEditModel();
⋮----
return await this.Discord.ApiClient.ModifyGuildWelcomeScreenAsync(this.Id, mdl.Enabled, mdl.WelcomeChannels, mdl.Description).ConfigureAwait(false);
⋮----
///     Creates a new soundboard sound in the guild.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the sound.&lt;/param&gt;
/// &lt;param name=&quot;sound&quot;&gt;The sound file stream. Can be MP3 or OGG, and must be base64 encoded.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume of the sound. Optional.&lt;/param&gt;
/// &lt;param name=&quot;emojiId&quot;&gt;The ID of the emoji associated with the sound. Optional.&lt;/param&gt;
/// &lt;param name=&quot;emojiName&quot;&gt;The name of the emoji associated with the sound. Optional.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for creating the sound, to be logged in the audit log. Optional.&lt;/param&gt;
/// &lt;returns&gt;The created &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt;.&lt;/returns&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.CreateGuildExpressions&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordSoundboardSound&gt; CreateSoundboardSoundAsync(string name, Stream sound, double? volume = null, ulong? emojiId = null, string? emojiName = null, string? reason = null)
⋮----
var sound64 = MediaTool.Base64FromStream(sound);
return await this.Discord.ApiClient.CreateGuildSoundboardSoundAsync(this.Id, name, sound64, volume, emojiId, emojiName, reason);
⋮----
///     Modifies an existing soundboard sound.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The ID of the sound to modify.&lt;/param&gt;
/// &lt;param name=&quot;action&quot;&gt;The action to configure the soundboard sound edit model.&lt;/param&gt;
/// &lt;returns&gt;The updated &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt;.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the soundboard sound cannot be found.&lt;/exception&gt;
⋮----
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.ManageGuildExpressions&quot; /&gt; permission.
⋮----
public async Task&lt;DiscordSoundboardSound&gt; ModifySoundboardSoundAsync(ulong soundId, Action&lt;SoundboardSoundEditModel&gt; action)
⋮----
var mdl = new SoundboardSoundEditModel();
⋮----
return await this.Discord.ApiClient.ModifyGuildSoundboardSoundAsync(
⋮----
).ConfigureAwait(false);
⋮----
///     Deletes a soundboard sound from the guild.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The ID of the sound to delete.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for deleting the sound, to be logged in the audit log. Optional.&lt;/param&gt;
/// &lt;returns&gt;A task representing the deletion operation.&lt;/returns&gt;
⋮----
public Task DeleteSoundboardSoundAsync(ulong soundId, string? reason = null)
=&gt; this.Discord.ApiClient.DeleteGuildSoundboardSoundAsync(this.Id, soundId, reason);
⋮----
///     Gets a soundboard sound by its ID.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The ID of the sound to retrieve.&lt;/param&gt;
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt;.&lt;/returns&gt;
⋮----
public Task&lt;DiscordSoundboardSound&gt; GetSoundboardSoundAsync(ulong soundId)
=&gt; this.Discord.ApiClient.GetGuildSoundboardSoundAsync(this.Id, soundId);
⋮----
///     Lists all soundboard sounds in the guild.
⋮----
/// &lt;returns&gt;A collection of &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt; objects representing all soundboard sounds in the guild.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListSoundboardSoundsAsync()
=&gt; this.Discord.ApiClient.ListGuildSoundboardSoundsAsync(this.Id);
⋮----
///     Gets the join requests.
⋮----
/// &lt;param name=&quot;limit&quot;&gt;The maximum number of join requests to return. Defaults to 100.&lt;/param&gt;
/// &lt;param name=&quot;statusType&quot;&gt;The status type to filter join requests by. Can be Submitted, Approved, or Rejected.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Retrieve join requests before this ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Retrieve join requests after this ID.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;Thrown when the status type is not supported.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordGuildJoinRequestSearchResult&gt; GetJoinRequestsAsync(int limit = 100, JoinRequestStatusType? statusType = null, ulong? before = null, ulong? after = null)
=&gt; await this.Discord.ApiClient.GetGuildJoinRequestsAsync(this.Id, limit, statusType, before, after);
⋮----
///     Gets a specific join request.
⋮----
/// &lt;param name=&quot;joinRequestId&quot;&gt;The ID of the join request.&lt;/param&gt;
⋮----
public async Task&lt;DiscordGuildJoinRequest&gt; GetJoinRequestAsync(ulong joinRequestId)
=&gt; await this.Discord.ApiClient.GetGuildJoinRequestAsync(this.Id, joinRequestId);
⋮----
///     Modifies a join request.
⋮----
/// &lt;param name=&quot;approve&quot;&gt;Whether to approve or deny the request.&lt;/param&gt;
/// &lt;param name=&quot;rejectionReason&quot;&gt;The optional rejection reason.&lt;/param&gt;
⋮----
public async Task&lt;DiscordGuildJoinRequest&gt; ModifyJoinRequestsAsync(ulong joinRequestId, bool approve, string? rejectionReason)
=&gt; await this.Discord.ApiClient.ModifyGuildJoinRequestsAsync(this.Id, joinRequestId, approve ? JoinRequestStatusType.Approved : JoinRequestStatusType.Rejected, rejectionReason);</file><file path="DisCatSharp/Entities/Guild/Onboarding/DiscordOnboardingPromptOption.cs">/// &lt;summary&gt;
///     Represents an onboarding prompt option.
/// &lt;/summary&gt;
public sealed class DiscordOnboardingPromptOption : NullableSnowflakeObject
⋮----
///     Constructs a new onboarding prompt option.
///     &lt;para&gt;You need to either specify &lt;paramref name=&quot;roleIds&quot; /&gt; and/or &lt;paramref name=&quot;channelIds&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;title&quot;&gt;The title.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The emoji. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;roleIds&quot;&gt;The role ids. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;channelIds&quot;&gt;The channel ids. Defaults to &lt;see langword=&quot;null&quot; /&gt;.&lt;/param&gt;
⋮----
///     Gets the option&apos;s title.
⋮----
///     Gets the option&apos;s description.
⋮----
///     Gets the option&apos;s emoji.
⋮----
///     Gets the option&apos;s role ids.
⋮----
///     Gets the option&apos;s channel ids.
⋮----
/// 	Sets the emoji name for create and modify payloads.
⋮----
///     Sets the emoji id for create and modify payloads.
⋮----
///     Sets the emoji animated state for create and modify payloads.</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordBaseSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public class DiscordBaseSelectComponent : DiscordComponent, ILabelComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordBaseSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type of select.&lt;/param&gt;
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;defaultValues&quot;&gt;
///     The default values of this select menu. Not valid for
///     &lt;see cref=&quot;ComponentType.StringSelect&quot; /&gt;.
⋮----
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
this.CustomId = customId ?? Guid.NewGuid().ToString();
⋮----
if (defaultValues.Count() &gt; maxOptions)
throw new OverflowException(&quot;The amount of default values cannot exceed the maximum amount of selectable options.&quot;);
if (type == ComponentType.MentionableSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type == &quot;channel&quot;))
throw new ArgumentException(&quot;The default values for a mentionable select must be of type user or role.&quot;, nameof(defaultValues));
if (type == ComponentType.ChannelSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;channel&quot;))
throw new ArgumentException(&quot;The default values for a channel select menus must be of type channel.&quot;, nameof(defaultValues));
if (type == ComponentType.UserSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;user&quot;))
throw new ArgumentException(&quot;The default values for a user select menus must be of type user.&quot;, nameof(defaultValues));
if (type == ComponentType.RoleSelect &amp;&amp; defaultValues.Any(x =&gt; x.Type != &quot;role&quot;))
throw new ArgumentException(&quot;The default values for a role select menus must be of type role.&quot;, nameof(defaultValues));
⋮----
///     The text to show when no option is selected.
⋮----
///     The minimum amount of options that can be selected. Must be less than or equal to
///     &lt;see cref=&quot;MaximumSelectedValues&quot; /&gt;. Defaults to one.
⋮----
///     The maximum amount of options that can be selected. Must be greater than or equal to zero or
///     &lt;see cref=&quot;MinimumSelectedValues&quot; /&gt;. Defaults to one.
⋮----
///     Whether this select can be used.
⋮----
///     The default values of this select menu.
⋮----
///     Whether this select component is required. For modals.
⋮----
///     The selected values of this select menu.</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordChannelSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public sealed class DiscordChannelSelectComponent : DiscordBaseSelectComponent
⋮----
// TODO: Can we set required
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordChannelSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;channelTypes&quot;&gt;The channel types to filter by.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;defaultValues&quot;&gt;The default values of this select menu.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
///     The channel types to filter by.
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordChannelSelectComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordChannelSelectComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordChannelSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordMentionableSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public sealed class DiscordMentionableSelectComponent : DiscordBaseSelectComponent
⋮----
// TODO: Can we set required
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordMentionableSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;defaultValues&quot;&gt;The default values of this select menu.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordMentionableSelectComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordMentionableSelectComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordMentionableSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordRoleSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public sealed class DiscordRoleSelectComponent : DiscordBaseSelectComponent
⋮----
// TODO: Can we set required
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordRoleSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;defaultValues&quot;&gt;The default values of this select menu.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordRoleSelectComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordRoleSelectComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordRoleSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordStringSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public sealed class DiscordStringSelectComponent : DiscordBaseSelectComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordStringSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;options&quot;&gt;Array of options&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
this.Options = options.ToArray();
⋮----
///     The options to pick from on this component.
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordStringSelectComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordStringSelectComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordStringSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/Select/DiscordUserSelectComponent.cs">/// &lt;summary&gt;
///     A select menu with multiple options to choose from.
/// &lt;/summary&gt;
public sealed class DiscordUserSelectComponent : DiscordBaseSelectComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordUserSelectComponent&quot; /&gt;.
⋮----
/// &lt;param name=&quot;placeholder&quot;&gt;Text to show if no option is selected.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the select component.&lt;/param&gt;
/// &lt;param name=&quot;minOptions&quot;&gt;Minimum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;maxOptions&quot;&gt;Maximum count of selectable options.&lt;/param&gt;
/// &lt;param name=&quot;disabled&quot;&gt;
///     Whether this select component should be initialized as being disabled. User sees a greyed out
///     select component that cannot be interacted with.
/// &lt;/param&gt;
/// &lt;param name=&quot;defaultValues&quot;&gt;The default values of this select menu.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this select component is required. Applicable for Modals.&lt;/param&gt;
⋮----
///     Enables this component if it was disabled before.
⋮----
/// &lt;returns&gt;The current component.&lt;/returns&gt;
public DiscordUserSelectComponent Enable()
⋮----
///     Disables this component.
⋮----
public DiscordUserSelectComponent Disable()
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordUserSelectComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/Components/V2Components/DiscordLabelComponent.cs">/// &lt;summary&gt;
///     Represents a label component.
/// &lt;/summary&gt;
public sealed class DiscordLabelComponent : DiscordComponent
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordLabelComponent&quot; /&gt;.
⋮----
///     Constructs a new label component based on another label component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The label component to copy.&lt;/param&gt;
⋮----
///     Constructs a new label component field with the specified options.
⋮----
/// &lt;param name=&quot;label&quot;&gt;The label for the modal field.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description for the modal field.&lt;/param&gt;
/// &lt;param name=&quot;component&quot;&gt;The component to attach to the label. This parameter is added for future-proof support. Please use either &lt;see cref=&quot;WithTextComponent(DiscordTextInputComponent)&quot;/&gt; or &lt;see cref=&quot;WithStringSelectComponent(DiscordStringSelectComponent)&quot;/&gt;.&lt;/param&gt;
⋮----
///     Sets the text component for the label.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The text component to attach to the label.&lt;/param&gt;
public DiscordLabelComponent WithTextComponent(DiscordTextInputComponent component)
⋮----
/// 	Sets the string select component for the label.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The string select component to attach to the label.&lt;/param&gt;
public DiscordLabelComponent WithSelectComponent(DiscordBaseSelectComponent component)
⋮----
///     The label.
⋮----
///     The description.
⋮----
/// 	The attached component.
⋮----
/// 	Helper to determine whether a &lt;see cref=&quot;DiscordTextInputComponent&quot;/&gt; or &lt;see cref=&quot;DiscordBaseSelectComponent&quot;/&gt; is attached to the label.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordLabelComponent WithId(int id)</file><file path="DisCatSharp/Entities/Interaction/DiscordFollowupMessageBuilder.cs">/// &lt;summary&gt;
///     Constructs a followup message to an interaction.
/// &lt;/summary&gt;
public sealed class DiscordFollowupMessageBuilder : DisCatSharpBuilder
⋮----
///     Whether this followup message is text-to-speech.
⋮----
///     Whether this followup message should be ephemeral.
⋮----
///     Gets or sets a value indicating whether the followup message is ephemeral.
⋮----
/// &lt;remarks&gt;
///     An ephemeral message is only visible to the user who triggered the interaction.
/// &lt;/remarks&gt;
⋮----
///     Gets the poll for this message.
⋮----
///     Sets that this builder should be using UI Kit.
⋮----
/// &lt;returns&gt;The current builder to chain calls with.&lt;/returns&gt;
public DiscordFollowupMessageBuilder WithV2Components()
⋮----
///     &lt;para&gt;
///         Adds a row of components to the builder, up to &lt;c&gt;5&lt;/c&gt; components per row, and up to &lt;c&gt;5&lt;/c&gt; rows per
///         message.
///     &lt;/para&gt;
⋮----
///         If &lt;see cref=&quot;WithV2Components&quot; /&gt; was called, the limit changes to &lt;c&gt;10&lt;/c&gt; top-level components and max
///         &lt;c&gt;30&lt;/c&gt; components in total.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The collection of components to add.&lt;/param&gt;
/// &lt;returns&gt;The builder to chain calls with.&lt;/returns&gt;
public DiscordFollowupMessageBuilder AddComponents(params DiscordComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
⋮----
///     Appends several rows of components to the message
⋮----
/// &lt;param name=&quot;components&quot;&gt;The rows of components to add, holding up to five each.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;No components were passed.&lt;/exception&gt;
public DiscordFollowupMessageBuilder AddComponents(params DiscordActionRowComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
⋮----
public DiscordFollowupMessageBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
⋮----
var ara = components.ToArray();
⋮----
throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
⋮----
this.ComponentsInternal.Add(ar);
⋮----
///     Appends a collection of components to the message.
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;paramref name=&quot;components&quot; /&gt; contained more than 5 components.&lt;/exception&gt;
public DiscordFollowupMessageBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
⋮----
var cmpArr = components.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
⋮----
throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
⋮----
this.ComponentsInternal.AddRange(cmpArr);
⋮----
throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
⋮----
var comp = new DiscordActionRowComponent(cmpArr);
this.ComponentsInternal.Add(comp);
⋮----
///     Adds a poll to this builder.
⋮----
/// &lt;param name=&quot;pollBuilder&quot;&gt;The poll builder to add.&lt;/param&gt;
/// &lt;returns&gt;The current builder to be chained.&lt;/returns&gt;
public DiscordFollowupMessageBuilder WithPoll(DiscordPollBuilder pollBuilder)
⋮----
///     Indicates if the followup message must use text-to-speech.
⋮----
/// &lt;param name=&quot;tts&quot;&gt;Text-to-speech&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder WithTts(bool tts)
⋮----
///     Sets the message to send with the followup message.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Message to send.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder WithContent(string content)
⋮----
///     Adds an embed to the followup message.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to add.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder AddEmbed(DiscordEmbed embed)
⋮----
ArgumentNullException.ThrowIfNull(embed, nameof(embed));
⋮----
this.EmbedsInternal.Add(embed);
⋮----
///     Adds the given embeds to the followup message.
⋮----
/// &lt;param name=&quot;embeds&quot;&gt;Embeds to add.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
⋮----
this.EmbedsInternal.AddRange(embeds);
⋮----
///     Adds a file to the followup message.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;Name of the file.&lt;/param&gt;
/// &lt;param name=&quot;data&quot;&gt;File data.&lt;/param&gt;
/// &lt;param name=&quot;resetStreamPosition&quot;&gt;
///     Tells the API Client to reset the stream position to what it was after the file is
///     sent.
/// &lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the file.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string? description = null)
⋮----
throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
throw new ArgumentException(&quot;A File with that filename already exists&quot;);
⋮----
this.FilesInternal.Add(new(filename, data, data.Position, description: description));
⋮----
this.FilesInternal.Add(new(filename, data, null, description: description));
⋮----
///     Sets if the message has files to be sent.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The Stream to the file.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string? description = null)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
⋮----
this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
⋮----
this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
⋮----
///     Adds the given files to the followup message.
⋮----
/// &lt;param name=&quot;files&quot;&gt;Dictionary of file name and file data.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, null));
⋮----
///     Adds the mention to the mentions to parse, etc. with the followup message.
⋮----
/// &lt;param name=&quot;mention&quot;&gt;Mention to add.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder WithAllowedMention(IMention mention)
⋮----
this.MentionsInternal.Add(mention);
⋮----
///     Adds the mentions to the mentions to parse, etc. with the followup message.
⋮----
/// &lt;param name=&quot;mentions&quot;&gt;Mentions to add.&lt;/param&gt;
⋮----
public DiscordFollowupMessageBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
⋮----
this.MentionsInternal.AddRange(mentions);
⋮----
///     Sets the followup message to be ephemeral.
⋮----
public DiscordFollowupMessageBuilder AsEphemeral()
⋮----
///     Sets the followup message to suppress embeds.
⋮----
public DiscordFollowupMessageBuilder SuppressEmbeds()
⋮----
///     Sets the followup message to be sent as voice message.
⋮----
internal DiscordFollowupMessageBuilder AsVoiceMessage(bool asVoiceMessage = true)
⋮----
///     Sets the followup message to be sent as silent message.
⋮----
public DiscordFollowupMessageBuilder AsSilentMessage()
⋮----
/// &lt;inheritdoc /&gt;
public override void Clear()
⋮----
base.Clear();
⋮----
internal override void Validate()
⋮----
if (this.Files?.Count is 0 or null &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; this.EmbedsInternal?.Count is 0 or null &amp;&amp; this.ComponentsInternal?.Count is 0 or null &amp;&amp; this.Poll is null &amp;&amp; this.AttachmentsInternal?.Count is 0 or null)
throw new ArgumentException(&quot;You must specify content, an embed, a component, a poll, or at least one file.&quot;);
⋮----
base.Validate();</file><file path="DisCatSharp/Entities/Webhook/DiscordWebhook.cs">/// &lt;summary&gt;
///     Represents information about a Discord webhook.
/// &lt;/summary&gt;
public class DiscordWebhook : SnowflakeObject, IEquatable&lt;DiscordWebhook&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordWebhook&quot; /&gt; class.
⋮----
///     Gets the api client.
⋮----
///     Gets the id of the guild this webhook belongs to.
⋮----
///     Gets the ID of the channel this webhook belongs to.
⋮----
///     Gets the ID of the application this webhook belongs to, if applicable.
⋮----
///     Gets the user this webhook was created by.
⋮----
///     Gets the default name of this webhook.
⋮----
///     Gets hash of the default avatar for this webhook.
⋮----
///     Gets the partial source guild for this webhook (For Channel Follower Webhooks).
⋮----
///     Gets the partial source channel for this webhook (For Channel Follower Webhooks).
⋮----
///     Gets the url used for executing the webhook.
⋮----
///     Gets the default avatar url for this webhook.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.AvatarHash) ? $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id}/{this.AvatarHash}.png?size=1024&quot; : null;
⋮----
///     Gets the secure token of this webhook.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordWebhook&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordWebhook&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordWebhook&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordWebhook&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordWebhook&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordWebhook e) =&gt; e is not null &amp;&amp; (ReferenceEquals(this, e) || this.Id == e.Id);
⋮----
///     Modifies this webhook.
⋮----
/// &lt;param name=&quot;name&quot;&gt;New default name for this webhook.&lt;/param&gt;
/// &lt;param name=&quot;avatar&quot;&gt;New avatar for this webhook.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;The new channel id to move the webhook to.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
/// &lt;returns&gt;The modified webhook.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageWebhooks&quot; /&gt; permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the webhook does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public Task&lt;DiscordWebhook&gt; ModifyAsync(string name = null, Optional&lt;Stream&gt; avatar = default, ulong? channelId = null, string reason = null)
⋮----
var avatarb64 = MediaTool.Base64FromStream(avatar);
⋮----
return this.Discord.ApiClient.ModifyWebhookAsync(this.Id, newChannelId, name, avatarb64, reason);
⋮----
///     Gets a previously-sent webhook message.
⋮----
public Task&lt;DiscordMessage&gt; GetMessageAsync(ulong messageId)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).GetWebhookMessageAsync(this.Id, this.Token, messageId);
⋮----
///     Tries to get a previously-sent webhook message.
⋮----
public async Task&lt;DiscordMessage?&gt; TryGetMessageAsync(ulong messageId)
⋮----
return await this.GetMessageAsync(messageId).ConfigureAwait(false);
⋮----
public Task&lt;DiscordMessage&gt; GetMessageAsync(ulong messageId, ulong threadId)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).GetWebhookMessageAsync(this.Id, this.Token, messageId, threadId);
⋮----
public async Task&lt;DiscordMessage&gt; TryGetMessageAsync(ulong messageId, ulong threadId)
⋮----
return await this.GetMessageAsync(messageId, threadId).ConfigureAwait(false);
⋮----
///     Permanently deletes this webhook.
⋮----
public Task DeleteAsync()
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookAsync(this.Id, this.Token);
⋮----
///     Executes this webhook with the given &lt;see cref=&quot;DiscordWebhookBuilder&quot; /&gt;.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;Webhook builder filled with data to send.&lt;/param&gt;
/// &lt;param name=&quot;threadId&quot;&gt;Target thread id (Optional). Defaults to null.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; ExecuteAsync(DiscordWebhookBuilder builder, ulong? threadId = null)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookAsync(this.Id, this.Token, builder, threadId?.ToString());
⋮----
///     Executes this webhook in Slack compatibility mode.
⋮----
/// &lt;param name=&quot;json&quot;&gt;JSON containing Slack-compatible payload for this webhook.&lt;/param&gt;
⋮----
public Task ExecuteSlackAsync(string json, ulong? threadId = null)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookSlackAsync(this.Id, this.Token, json, threadId?.ToString());
⋮----
///     Executes this webhook in GitHub compatibility mode.
⋮----
/// &lt;param name=&quot;json&quot;&gt;JSON containing GitHub-compatible payload for this webhook.&lt;/param&gt;
⋮----
public Task ExecuteGithubAsync(string json, ulong? threadId = null)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).ExecuteWebhookGithubAsync(this.Id, this.Token, json, threadId?.ToString());
⋮----
///     Edits a previously-sent webhook message.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The id of the message to edit.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The builder of the message to edit.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;modifyMode&quot;&gt;The mode of modification.&lt;/param&gt;
/// &lt;returns&gt;The modified &lt;see cref=&quot;DiscordMessage&quot; /&gt;&lt;/returns&gt;
⋮----
public async Task&lt;DiscordMessage&gt; EditMessageAsync(ulong messageId, DiscordWebhookBuilder builder, ulong? threadId = null, ModifyMode modifyMode = ModifyMode.Update)
⋮----
builder.DoConditionalReplace();
⋮----
builder.AttachmentsInternal.AddRange(this.ApiClient.GetWebhookMessageAsync(this.Id, this.Token, messageId.ToString(), threadId?.ToString()).Result.Attachments);
⋮----
builder.AttachmentsInternal.Clear();
return await (this.Discord?.ApiClient ?? this.ApiClient).EditWebhookMessageAsync(this.Id, this.Token, messageId.ToString(), builder, threadId?.ToString()).ConfigureAwait(false);
⋮----
///     Deletes a message that was created by the webhook.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The id of the message to delete&lt;/param&gt;
⋮----
public Task DeleteMessageAsync(ulong messageId)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookMessageAsync(this.Id, this.Token, messageId);
⋮----
public Task DeleteMessageAsync(ulong messageId, ulong? threadId = null)
=&gt; (this.Discord?.ApiClient ?? this.ApiClient).DeleteWebhookMessageAsync(this.Id, this.Token, messageId.ToString(), threadId?.ToString());
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordWebhook&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordWebhook&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj) =&gt; this.Equals(obj as DiscordWebhook);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordWebhook&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordWebhook&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode() =&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordWebhook&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First webhook to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second webhook to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two webhooks are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordWebhook&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two webhooks are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Enums/User/DisplayNameFont.cs">/// &lt;summary&gt;
/// Represents the display name font for a user.
/// &lt;/summary&gt;
⋮----
/// Bangers font.
⋮----
/// BioRhyme font.
⋮----
/// CherryBomb font.
⋮----
/// Chicle font.
⋮----
/// Compagnon font.
⋮----
/// MuseoModerno font.
⋮----
/// NeoCastel font.
⋮----
/// Pixelify font.
⋮----
/// Ribes font.
⋮----
/// Sinistre font.
⋮----
/// Default font.
⋮----
/// ZillaSlab font.</file><file path="DisCatSharp/Net/Serialization/DisCatSharpContractResolver.cs">/// &lt;summary&gt;
///    Contract resolver that combines Optional and ShouldSerializeXy() support.
/// &lt;/summary&gt;
public sealed class DisCatSharpContractResolver : DefaultContractResolver
⋮----
protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
⋮----
var property = base.CreateProperty(member, memberSerialization);
⋮----
// ShouldSerializeXy() support
⋮----
var shouldSerializeMethod = declaringType.GetMethod($&quot;ShouldSerialize{property.PropertyName}&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
if (shouldSerializeMethod != null &amp;&amp; shouldSerializeMethod.ReturnType == typeof(bool) &amp;&amp; shouldSerializeMethod.GetParameters().Length == 0)
⋮----
var result = shouldSerializeMethod.Invoke(instance, null);
⋮----
// Optional&lt;T&gt; support
if (type.GetTypeInfo().ImplementedInterfaces.Contains(typeof(DisCatSharp.Entities.IOptional)))
⋮----
var declaringMember = property.DeclaringType.GetTypeInfo().DeclaredMembers
.FirstOrDefault(e =&gt; e.Name == property.UnderlyingName);
⋮----
var optionalValue = declaringProp.GetValue(instance);
⋮----
var optionalValue = declaringField.GetValue(instance);
⋮----
throw new InvalidOperationException(&quot;Can only serialize Optional&lt;T&gt; members that are fields or properties&quot;);</file><file path="DisCatSharp/Net/Serialization/ILabelComponentJsonConverter.cs">/// &lt;summary&gt;
///     Represents a label component json converter.
/// &lt;/summary&gt;
internal sealed class ILabelComponentJsonConverter : JsonConverter
⋮----
/// &lt;inheritdoc /&gt;
⋮----
public override bool CanConvert(Type objectType)
=&gt; typeof(ILabelComponent).IsAssignableFrom(objectType);
⋮----
public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
⋮----
var job = JObject.Load(reader);
// You may need a more robust way to determine the type
var type = job[&quot;type&quot;]?.ToObject&lt;ComponentType&gt;() ?? throw new JsonSerializationException(&quot;Missing type discriminator for ILabelComponent.&quot;);
⋮----
ILabelComponent cmp = type switch
⋮----
_ =&gt; throw new JsonSerializationException($&quot;Unknown ILabelComponent type: {type}&quot;)
⋮----
public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
=&gt; throw new NotImplementedException();</file><file path="DisCatSharp.Docs/articles/modules/application_commands/modals.md">---
uid: modules_application_commands_modals
title: Modals
---

# Modals

**The package `DisCatSharp.Interactivity` is required for this to work.**

You probably heard about the modal feature in Discord.
It&apos;s a feature that allows you to create a popup window that can be used to ask for information from the user.
This is a great way to create a more interactive user experience.

The code below shows an example application command on how this could look.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using DisCatSharp;
using DisCatSharp.Entities;
using DisCatSharp.Enums;
using DisCatSharp.Interactivity;
using DisCatSharp.Interactivity.Enums;
using DisCatSharp.Interactivity.Extensions;
```

```cs
[SlashCommand(&quot;cats_modal&quot;, &quot;A modal with questions about cats!&quot;)]
public async Task SendCatsModalAsync(InteractionContext ctx)
{
	var builder = new DiscordInteractionModalBuilder();
	builder.WithCustomId(&quot;cats_modal&quot;);
	builder.WithTitle(&quot;Cats&quot;);

	List&lt;DiscordStringSelectComponentOption&gt; cats = [new(&quot;Yes&quot;, &quot;I love cats&quot;, isDefault: true), new(&quot;No&quot;, &quot;I hate cats&quot;)];
    builder.AddModalComponents(new DiscordTextDisplayComponent(&quot;Cats are the best things&quot;));
	builder.AddLabelComponent(new DiscordLabelComponent(&quot;Cats&quot;, &quot;Do you like cats?&quot;).WithSelectComponent(new DiscordStringSelectComponent(&quot;Choose carefully..&quot;, cats, customId: &quot;cat_select&quot;)));
	builder.AddLabelComponent(new DiscordLabelComponent(&quot;Like&quot;, &quot;What do you like about cats?&quot;).WithTextComponent(new(TextComponentStyle.Paragraph, customId: &quot;cat_like&quot;)));
	builder.AddLabelComponent(new DiscordLabelComponent(&quot;Dislike&quot;, &quot;What do you dislike about cats?&quot;).WithTextComponent(new(TextComponentStyle.Small, customId: &quot;cat_dislike&quot;)));

	await ctx.CreateModalResponseAsync(builder);

	var res = await ctx.Client.GetInteractivity().WaitForModalAsync(builder.CustomId, TimeSpan.FromMinutes(1));

	if (res.TimedOut)
		return;

	await res.Result.Interaction.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource);

	var catSelectChoice = (res.Result.Interaction.Data.ModalComponents
		.OfType&lt;DiscordLabelComponent&gt;()
		.Where(x =&gt; x.Component is DiscordStringSelectComponent)
		.FirstOrDefault()?.Component as DiscordStringSelectComponent)?.SelectedValues?.FirstOrDefault();

	var catLikeText = (res.Result.Interaction.Data.ModalComponents
		.OfType&lt;DiscordLabelComponent&gt;()
		.Where(x =&gt; x.Component is DiscordTextInputComponent y &amp;&amp; y.CustomId is &quot;cat_like&quot;)
		.FirstOrDefault()?.Component as DiscordTextInputComponent)?.Value;

	var catDislikeText = (res.Result.Interaction.Data.ModalComponents
		.OfType&lt;DiscordLabelComponent&gt;()
		.Where(x =&gt; x.Component is DiscordTextInputComponent y &amp;&amp; y.CustomId is &quot;cat_dislike&quot;)
		.FirstOrDefault()?.Component as DiscordTextInputComponent)?.Value;

	var webhookBuilder = new DiscordWebhookBuilder().WithV2Components();
	var container = new DiscordContainerComponent([
		new DiscordTextDisplayComponent(builder.Title.Header2()),
		new DiscordTextDisplayComponent(&quot;Do you like cats?&quot;.Header3() + $&quot;\n{(catSelectChoice ?? &quot;No selection&quot;).Italic()}&quot;),
		new DiscordTextDisplayComponent(&quot;What do you like about cats?&quot;.Header3() + $&quot;\n{(catLikeText ?? &quot;No input&quot;).BlockCode()}&quot;),
		new DiscordTextDisplayComponent(&quot;What do you dislike about cats?&quot;.Header3() + $&quot;\n{(catDislikeText ?? &quot;No input&quot;).Italic()}&quot;),
	]);
	webhookBuilder.AddComponents(container);
	await res.Result.Interaction.EditOriginalResponseAsync(webhookBuilder);
}
```</file><file path="DisCatSharp.Experimental/DisCatSharp.Experimental.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp.Experimental&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp.Experimental&lt;/RootNamespace&gt;
		&lt;PackageId&gt;DisCatSharp.Experimental&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp.Experimental

			Experimental changes for DisCatSharp.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Experimental,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10&lt;/PackageTags&gt;
		&lt;NoWarn&gt;IDE0130;DV2001;CS8602;CS8618;CS8602&lt;/NoWarn&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Concentus&quot; Version=&quot;2.2.2&quot; /&gt;
		&lt;PackageReference Include=&quot;Concentus.Oggfile&quot; Version=&quot;1.0.6&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;NAudio&quot; Version=&quot;2.2.1&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
	  &lt;Folder Include=&quot;Entities\Message\&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.ApplicationCommands.Tests/DisCatSharp.ApplicationCommands.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.ApplicationCommands\DisCatSharp.ApplicationCommands.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Folder Include=&quot;SplitTest\&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Configuration.Tests/DisCatSharp.Configuration.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Json&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Configuration\DisCatSharp.Configuration.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;enumerable-test.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;section-with-suffix.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;section-no-suffix.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;default-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;intents-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;haphazard-discord.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.CopilotTests/NullValueHandlingTests.cs">public class NullValueHandlingTests
⋮----
private readonly ITestOutputHelper _output;
⋮----
public class TestClass
⋮----
public class ShouldSerializeTestClass
⋮----
public bool ShouldSerializeValue() =&gt; this.ShouldSerializeValueFlag;
⋮----
public class ComponentTestClass
⋮----
public bool ShouldSerializeComponents() =&gt; this.HasComponents;
⋮----
public void Test_NullValueHandling_Respected()
⋮----
var obj = new TestClass
⋮----
var json = DiscordJson.SerializeObject(obj);
⋮----
Assert.DoesNotContain(&quot;should_serialize&quot;, json);
Assert.Contains(&quot;should_always_serialize&quot;, json);
⋮----
public void Test_ShouldSerialize_Method_Respected()
⋮----
var obj = new ShouldSerializeTestClass
⋮----
this._output.WriteLine($&quot;ShouldSerializeValueFlag = false: {json}&quot;);
Assert.DoesNotContain(&quot;value&quot;, json);
⋮----
json = DiscordJson.SerializeObject(obj);
this._output.WriteLine($&quot;ShouldSerializeValueFlag = true: {json}&quot;);
Assert.Contains(&quot;value&quot;, json);
⋮----
public void Test_Components_Serialization_Cases()
⋮----
var settings = new JsonSerializerSettings
⋮----
ContractResolver = new DisCatSharpContractResolver()
⋮----
// Case 1: Components = null, HasComponents = false
// TLDR: If you use ShouldSerializeXy(), set NullValueHandling.Include for that property (or globally) to ensure it is serialized even when null.
var obj = new ComponentTestClass { Components = null, HasComponents = false };
⋮----
Assert.DoesNotContain(&quot;components&quot;, JsonConvert.SerializeObject(obj, settings));
⋮----
// Case 2: Components = null, HasComponents = true
obj = new ComponentTestClass { Components = null, HasComponents = true };
⋮----
var json = JsonConvert.SerializeObject(obj, settings);
Assert.Contains(&quot;components&quot;, json); // Should be present as null
Assert.Contains(&quot;\&quot;components\&quot;:null&quot;, json);
⋮----
// Case 3: Components = [], HasComponents = true
obj = new ComponentTestClass { Components = new List&lt;string&gt;(), HasComponents = true };
⋮----
json = JsonConvert.SerializeObject(obj, settings);
Assert.Contains(&quot;components&quot;, json);
Assert.Contains(&quot;[]&quot;, json);
⋮----
// Case 4: Components = [&quot;foo&quot;], HasComponents = true
obj = new ComponentTestClass { Components = new List&lt;string&gt; { &quot;foo&quot; }, HasComponents = true };
⋮----
Assert.Contains(&quot;foo&quot;, json);
⋮----
this._output.WriteLine($&quot;{label}:\n  HasComponents: {((ComponentTestClass)obj).HasComponents}\n  Components: {((ComponentTestClass)obj).Components?.Count.ToString() ?? &quot;null&quot;}\n  JSON: {json}\n&quot;);</file><file path="DisCatSharp.Tests/DisCatSharp.EventHandlers.Tests/DisCatSharp.EventHandlers.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp.Tests/DisCatSharp.Hosting.Tests/DisCatSharp.Hosting.Tests.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../../DisCatSharp.Targets/TestProject.targets&quot; /&gt;
	&lt;Import Project=&quot;../../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Json&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.14.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.1.3&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.4&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Hosting\DisCatSharp.Hosting.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Interactivity\DisCatSharp.Interactivity.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp.Lavalink\DisCatSharp.Lavalink.csproj&quot; /&gt;
		&lt;ProjectReference Include=&quot;..\..\DisCatSharp\DisCatSharp.csproj&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;None Update=&quot;interactivity-lavalink.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;interactivity-different-section.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;lavalink-different-section.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
		&lt;None Update=&quot;BotTwo.json&quot;&gt;
			&lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
		&lt;/None&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp/DisCatSharp.csproj">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;Import Project=&quot;../DisCatSharp.Targets/Version.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/DisCatSharp.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Package.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/NuGet.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/Library.targets&quot; /&gt;
	&lt;Import Project=&quot;../DisCatSharp.Targets/InternalsVisibleTo.targets&quot; /&gt;

	&lt;PropertyGroup&gt;
		&lt;AssemblyName&gt;DisCatSharp&lt;/AssemblyName&gt;
		&lt;RootNamespace&gt;DisCatSharp&lt;/RootNamespace&gt;
	&lt;/PropertyGroup&gt;

	&lt;PropertyGroup&gt;
		&lt;PackageId&gt;DisCatSharp&lt;/PackageId&gt;
		&lt;Description&gt;
			DisCatSharp

			Your library to write discord bots in C# with a focus on always providing access to the latest discord features.
			Written with love and for everyone.
		&lt;/Description&gt;
		&lt;PackageTags&gt;DisCatSharp,Discord API Wrapper,Discord,Bots,Discord Bots,AITSYS,Net8,Net9,Net10&lt;/PackageTags&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup Condition=&quot;!$([MSBuild]::IsTargetFrameworkCompatible(&apos;$(TargetFramework)&apos;, &apos;net9.0&apos;))&quot;&gt;
		&lt;PackageReference Include=&quot;Backport.System.Threading.Lock&quot; Version=&quot;3.1.4&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Analyzer&quot; Version=&quot;1.0.0&quot;&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.Bcl.HashCode&quot; Version=&quot;6.0.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.DependencyValidation.Analyzers&quot; Version=&quot;0.11.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Console&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;13.0.3&quot; /&gt;
		&lt;PackageReference Include=&quot;NuGet.Protocol&quot; Version=&quot;6.14.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Octokit&quot; Version=&quot;14.0.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Sentry&quot; Version=&quot;5.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Sentry.Extensions.Logging&quot; Version=&quot;5.13.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Diagnostics.DiagnosticSource&quot; Version=&quot;9.0.7&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Memory&quot; Version=&quot;4.6.3&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.Http&quot; Version=&quot;4.3.4&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.WebSockets&quot; Version=&quot;4.3.0&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Net.WebSockets.Client&quot; Version=&quot;4.3.2&quot; /&gt;
		&lt;PackageReference Include=&quot;System.Runtime.InteropServices.RuntimeInformation&quot; Version=&quot;4.3.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\DisCatSharp.Common\DisCatSharp.Common.csproj&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;</file><file path="DisCatSharp/Entities/Interaction/Components/Text/DiscordTextInputComponent.cs">/// &lt;summary&gt;
///     Represents a text input component that can be submitted. Fires
///     &lt;see cref=&quot;DisCatSharp.DiscordClient.ComponentInteractionCreated&quot; /&gt; event when submitted.
/// &lt;/summary&gt;
public sealed class DiscordTextInputComponent : DiscordComponent, ILabelComponent
⋮----
/*
	/// &lt;summary&gt;
	/// Enables this component if it was disabled before.
	/// &lt;/summary&gt;
	/// &lt;returns&gt;The current component.&lt;/returns&gt;
	public DiscordTextInputComponent Enable()
	{
		this.Disabled = false;
		return this;
	}

	/// &lt;summary&gt;
	/// Disables this component.
	/// &lt;/summary&gt;
	/// &lt;returns&gt;The current component.&lt;/returns&gt;
	public DiscordTextInputComponent Disable()
	{
		this.Disabled = true;
		return this;
	}
	*/
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordTextInputComponent&quot; /&gt;.
⋮----
///     Constructs a new text component based on another text component.
⋮----
/// &lt;param name=&quot;other&quot;&gt;The button to copy.&lt;/param&gt;
⋮----
//this.Disabled = other.Disabled;
⋮----
///     Constructs a new text component field with the specified options.
⋮----
/// &lt;param name=&quot;style&quot;&gt;The style of the text component.&lt;/param&gt;
/// &lt;param name=&quot;label&quot;&gt;The text to display before the text component, up to 80 characters.&lt;/param&gt;
/// &lt;param name=&quot;customId&quot;&gt;The Id to assign to the text component.&lt;/param&gt;
/// &lt;param name=&quot;placeholder&quot;&gt;The placeholder for the text input.&lt;/param&gt;
/// &lt;param name=&quot;minLength&quot;&gt;The minimal length of text input.&lt;/param&gt;
/// &lt;param name=&quot;maxLength&quot;&gt;The maximal length of text input.&lt;/param&gt;
/// &lt;param name=&quot;required&quot;&gt;Whether this text component should be required.&lt;/param&gt;
/// &lt;param name=&quot;defaultValue&quot;&gt;Pre-filled value for text field.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Is thrown when no label is set.&lt;/exception&gt;
⋮----
this.CustomId = customId ?? Guid.NewGuid().ToString();
⋮----
//this.Disabled = disabled;
⋮----
///     The style of the text component.
⋮----
///     The text description to apply to the text component.
⋮----
///     The placeholder for the text component.
⋮----
///     The pre-filled value for the text component.
⋮----
///     The minimal length of text input.
///     Defaults to 0.
⋮----
///     The maximal length of text input.
⋮----
// NOTE: Probably will be introduced in future
/*
	/// &lt;summary&gt;
	/// Whether this text component can be used.
	/// &lt;/summary&gt;
	[JsonProperty(&quot;disabled&quot;, NullValueHandling = NullValueHandling.Ignore)]
	public bool Disabled { get; internal set; }
	*/
⋮----
///     Whether this text component is required.
///     Defaults to true.
⋮----
///     Assigns a unique id to the components.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id to assign.&lt;/param&gt;
public DiscordTextInputComponent WithId(int id)</file><file path="DisCatSharp/Net/Abstractions/Rest/RestWebhookPayloads.cs">/// &lt;summary&gt;
///     Represents a webhook payload.
/// &lt;/summary&gt;
internal sealed class RestWebhookPayload : ObservableApiObject
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the avatar base64.
⋮----
///     Gets or sets the channel id.
⋮----
///     Gets whether an avatar is set.
⋮----
///     Gets whether the avatar should be serialized.
⋮----
public bool ShouldSerializeAvatarBase64()
⋮----
///     Represents a webhook execute payload.
⋮----
internal sealed class RestWebhookExecutePayload : ObservableApiObject
⋮----
///     Gets or sets the content.
⋮----
///     Gets or sets the username.
⋮----
///     Gets or sets the avatar url.
⋮----
///     Whether this message is tts.
⋮----
///     Gets or sets the embeds.
⋮----
///     Gets or sets the mentions.
⋮----
///     Gets or sets the components.
⋮----
///     Gets or sets the attachments.
⋮----
///     Gets or sets the thread name.
⋮----
///     Gets or sets the poll request.
⋮----
///     Represents a webhook message edit payload.
⋮----
internal sealed class RestWebhookMessageEditPayload : ObservableApiObject
⋮----
///     Tracks if content was explicitly set (even to null).
///     Used to control conditional serialization of the content field.
⋮----
///     Tracks if embeds were explicitly set (including empty).
///     Used to control conditional serialization of the embeds field.
⋮----
///     Tracks if components were explicitly set (including empty).
///     Used to control conditional serialization of the components field.
⋮----
///     Determines whether the content field should be serialized.
⋮----
public bool ShouldSerializeContent() =&gt; this.HasContent;
⋮----
///     Determines whether the embeds field should be serialized.
⋮----
public bool ShouldSerializeEmbeds() =&gt; this.HasEmbeds;
⋮----
///     Determines whether the components field should be serialized.
⋮----
public bool ShouldSerializeComponents() =&gt; this.HasComponents;
⋮----
///     Gets or sets the flags.</file><file path="DisCatSharp.Tools/DisCatSharp.Analyzer/DisCatSharp.Analyzer/DisCatSharp.Analyzer.csproj">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
		&lt;PackageId&gt;*$(MSBuildProjectFile)*&lt;/PackageId&gt;
		&lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;
		&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
		&lt;GenerateAssemblyDescriptionAttribute&gt;false&lt;/GenerateAssemblyDescriptionAttribute&gt;
		&lt;GenerateAssemblyFileVersionAttribute&gt;false&lt;/GenerateAssemblyFileVersionAttribute&gt;
		&lt;GenerateAssemblyCompanyAttribute&gt;false&lt;/GenerateAssemblyCompanyAttribute&gt;
		&lt;GenerateAssemblyCopyrightAttribute&gt;false&lt;/GenerateAssemblyCopyrightAttribute&gt;
		&lt;GenerateAssemblyInformationalVersionAttribute&gt;false&lt;/GenerateAssemblyInformationalVersionAttribute&gt;
		&lt;GenerateAssemblyProductAttribute&gt;false&lt;/GenerateAssemblyProductAttribute&gt;
		&lt;GenerateAssemblyTitleAttribute&gt;false&lt;/GenerateAssemblyTitleAttribute&gt;
		&lt;GenerateAssemblyVersionAttribute&gt;false&lt;/GenerateAssemblyVersionAttribute&gt;
		&lt;NuGetAuditSuppress&gt;true&lt;/NuGetAuditSuppress&gt;
		&lt;NuGetAudit&gt;false&lt;/NuGetAudit&gt;
		&lt;DebugType&gt;embedded&lt;/DebugType&gt;
		&lt;NoWarn&gt;1701;1702;NU1701&lt;/NoWarn&gt;
		&lt;IncludeSymbols&gt;True&lt;/IncludeSymbols&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;4.14.0&quot;&gt;
		  &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		  &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
		&lt;/PackageReference&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.14.0&quot; /&gt;
		&lt;PackageReference Include=&quot;DisCatSharp.Attributes&quot; Version=&quot;2025.3.27&quot; PrivateAssets=&quot;All&quot; IncludeInPackage=&quot;true&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Compile Update=&quot;Resources.Designer.cs&quot; DesignTime=&quot;True&quot; AutoGen=&quot;True&quot; DependentUpon=&quot;Resources.resx&quot; /&gt;
		&lt;EmbeddedResource Update=&quot;Resources.resx&quot; Generator=&quot;ResXFileCodeGenerator&quot; LastGenOutput=&quot;Resources.Designer.cs&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;</file><file path="DisCatSharp/Clients/DiscordClient.cs">/// &lt;summary&gt;
///     A Discord API wrapper.
/// &lt;/summary&gt;
public sealed partial class DiscordClient : BaseDiscordClient
⋮----
///     Gets whether this client is running as a shard.
⋮----
///     Gets the message cache.
⋮----
internal RingBuffer&lt;DiscordMessage&gt;? MessageCache { get; } // TODO: Check usage
⋮----
///     Gets the list of extensions.
⋮----
///     Gets the status update.
⋮----
///     Gets the connection lock.
⋮----
private readonly ManualResetEventSlim _connectionLock = new(true);
⋮----
///     Gets the gateway protocol version.
⋮----
///     Gets the gateway session information for this client.
⋮----
///     Gets the gateway URL.
⋮----
///     Gets the total number of shards the bot is connected to.
⋮----
///     Gets the currently connected shard ID.
⋮----
///     Gets the intents configured for this client.
⋮----
///     Gets a dictionary of guilds that this client is in. The dictionary&apos;s key is the guild ID. Note that the
///     guild objects in this dictionary will not be filled in if the specific guilds aren&apos;t available (the
///     &lt;see cref=&quot;GuildAvailable&quot; /&gt; or &lt;see cref=&quot;GuildDownloadCompleted&quot; /&gt; events haven&apos;t been fired yet)
⋮----
///     Gets the guilds.
⋮----
///     Gets a dictionary of application emojis that this client has. The dictionary&apos;s key is the emoji ID.
⋮----
///     Gets the application emojis.
⋮----
///     Gets the websocket latency for this client.
⋮----
=&gt; Volatile.Read(ref this._ping);
⋮----
///     Gets the ping.
⋮----
///     Gets the collection of presences held by this client.
⋮----
///     Gets the internal collection of presences.
⋮----
///     Lazily gets the collection of presences held by this client.
⋮----
///     Gets the internal collection of embedded activities.
⋮----
///     Lazily gets the collection of embedded activities held by this client.
⋮----
///     Gets the cooldown buckets for commands.
⋮----
///     Initializes a new instance of &lt;see cref=&quot;DiscordClient&quot; /&gt;.
⋮----
/// &lt;param name=&quot;config&quot;&gt;Specifies configuration parameters.&lt;/param&gt;
⋮----
this.MessageCache = intents.HasIntent(DiscordIntents.GuildMessages) || intents.HasIntent(DiscordIntents.DirectMessages)
⋮----
this.InternalSetup();
⋮----
///     Internal setup of the Client.
⋮----
internal void InternalSetup()
⋮----
this.GuildsInternal.Clear();
this.EmojisInternal.Clear();
⋮----
///     Registers an extension with this client.
⋮----
/// &lt;param name=&quot;ext&quot;&gt;Extension to register.&lt;/param&gt;
public void AddExtension(BaseExtension ext)
⋮----
ext.Setup(this);
this._extensions.Add(ext);
⋮----
///     Retrieves a previously registered extension from this client.
⋮----
/// &lt;typeparam name=&quot;T&quot;&gt;The type of extension to retrieve.&lt;/typeparam&gt;
/// &lt;returns&gt;The requested extension.&lt;/returns&gt;
public T? GetExtension&lt;T&gt;() where T : BaseExtension
=&gt; this._extensions.FirstOrDefault(x =&gt; x.GetType() == typeof(T)) as T;
⋮----
///     Connects to the gateway.
⋮----
/// &lt;param name=&quot;activity&quot;&gt;The activity to set. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;status&quot;&gt;The optional status to set. Defaults to null.&lt;/param&gt;
/// &lt;param name=&quot;idlesince&quot;&gt;Since when is the client performing the specified activity. Defaults to null.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when an invalid token was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task ConnectAsync(DiscordActivity? activity = null, UserStatus? status = null, DateTimeOffset? idlesince = null)
⋮----
// Check if connection lock is already set, and set it if it isn&apos;t
if (!this._connectionLock.Wait(0))
throw new InvalidOperationException(&quot;This client is already connected.&quot;);
⋮----
this._connectionLock.Set();
⋮----
var sinceUnix = idlesince != null ? (long?)Utilities.GetUnixTime(idlesince.Value) : null;
⋮----
this.Logger.LogWarning(LoggerEvents.Misc, &quot;You are logging in with a token that is not a bot token. This is not officially supported by Discord, and can result in your account being terminated if you aren&apos;t careful&quot;);
this.Logger.LogInformation(LoggerEvents.Startup, &quot;Lib {LibraryName}, version {LibraryVersion}&quot;, this.BotLibrary, this.VersionString);
⋮----
this.Logger.LogInformation(&quot;Checking versions..&quot;);
await Utilities.CheckVersionAsync(this, true, this.IsShard, githubToken: this.Configuration.UpdateCheckGitHubToken, includePrerelease: this.Configuration.IncludePrereleaseInUpdateCheck, checkMode: this.Configuration.UpdateCheckMode);
foreach (var extension in this._extensions.Where(extension =&gt; extension.HasVersionCheckSupport))
await Utilities.CheckVersionAsync(this, true, this.IsShard, extension.RepositoryOwner, extension.Repository, extension.PackageId, extension.VersionString, this.Configuration.UpdateCheckGitHubToken, this.Configuration.IncludePrereleaseInUpdateCheck, this.Configuration.UpdateCheckMode);
this.Logger.LogInformation(&quot;Done&quot;);
⋮----
this.Logger.LogInformation(&quot;Skipped version check&quot;);
⋮----
await this.InternalConnectAsync().ConfigureAwait(false);
⋮----
this.Logger.LogError(LoggerEvents.ConnectionFailure, ex, &quot;Connection attempt failed, retrying in {Seconds}s&quot;, w / 1000);
await Task.Delay(w, this._cancelToken).ConfigureAwait(false);
⋮----
var skus = await this.ApiClient.GetSkusAsync(this.CurrentApplication.Id).ConfigureAwait(false);
if (!skus.Any())
⋮----
this.Configuration.SkuId = skus.FirstOrDefault(x =&gt; x.Type is SkuType.Subscription)?.Id;
⋮----
this.Logger.LogError(LoggerEvents.Startup, ex, &quot;Failed to fetch SKU IDs&quot;);
⋮----
await this.ApiClient.GetApplicationEmojisAsync(this.CurrentApplication.Id);
⋮----
this.Logger.LogError(LoggerEvents.Startup, ex, &quot;Failed to fetch application emojis&quot;);
⋮----
// non-closure, hence args
⋮----
// unlock this (if applicable) so we can let others attempt to connect
⋮----
///     Reconnects to the gateway.
⋮----
/// &lt;param name=&quot;startNewSession&quot;&gt;Whether to start a new session.&lt;/param&gt;
public Task ReconnectAsync(bool startNewSession = true)
=&gt; this.InternalReconnectAsync(startNewSession, startNewSession ? 1000 : 4002);
⋮----
///     Disconnects from the gateway.
⋮----
public async Task DisconnectAsync()
⋮----
await this.WebSocketClient.DisconnectAsync().ConfigureAwait(false);
⋮----
///     Requests soundboard sounds over the gateway.
⋮----
/// &lt;param name=&quot;guildIds&quot;&gt;The guild ids to request sounds from.&lt;/param&gt;
public async Task RequestSoundboardSoundsAsync(IEnumerable&lt;ulong&gt; guildIds)
⋮----
var payload = new DiscordDispatchPayload
⋮----
Payload = new RequestSoundboardSoundsPayload
⋮----
await this.WsSendAsync(DiscordJson.SerializeObject(payload)).ConfigureAwait(false);
⋮----
///     Requests and waits for guild soundboard sounds.
⋮----
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt;&apos;s as key-value-pair, where the key is a guild id.&lt;/returns&gt;
public async Task&lt;IReadOnlyDictionary&lt;ulong, IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt;&gt; RequestAndWaitForSoundboardSoundsAsync(IEnumerable&lt;ulong&gt; guildIds)
⋮----
var targetGuildIds = guildIds.ToList();
⋮----
if (targetGuildIds.Contains(e.GuildId))
guildSoundsKvp.TryAdd(e.GuildId, e.Sounds);
⋮----
await this.RequestSoundboardSoundsAsync(targetGuildIds);
⋮----
await Task.Delay(TimeSpan.FromSeconds(1), this._cancelToken);
⋮----
return guildSoundsKvp.AsReadOnly();
⋮----
///     Gets a user.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;Id of the user&lt;/param&gt;
/// &lt;param name=&quot;fetch&quot;&gt;Whether to ignore the cache. Defaults to false.&lt;/param&gt;
/// &lt;returns&gt;The requested user.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the user does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordUser&gt; GetUserAsync(ulong userId, bool fetch = false)
⋮----
if (!fetch &amp;&amp; this.TryGetCachedUserInternal(userId, out var cachedUsr))
⋮----
var usr = await this.ApiClient.GetUserAsync(userId).ConfigureAwait(false);
usr = this.UserCache.AddOrUpdate(userId, usr, (id, old) =&gt;
⋮----
///     Gets a applications rpc information.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;Id of the application&lt;/param&gt;
/// &lt;returns&gt;The requested application.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the application does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordRpcApplication&gt; GetRpcApplicationAsync(ulong applicationId)
=&gt; await this.ApiClient.GetApplicationRpcInfoAsync(applicationId).ConfigureAwait(false);
⋮----
///     Gets the current applications information.
⋮----
public async Task&lt;DiscordApplication&gt; GetCurrentApplicationInfoAsync()
⋮----
var tapp = await this.ApiClient.GetCurrentApplicationInfoAsync().ConfigureAwait(false);
⋮----
///     Tries to get a user.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;Id of the user.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;The user, if found.&lt;/param&gt;
/// &lt;param name=&quot;fetch&quot;&gt;Whether to ignore the cache. Defaults to true.&lt;/param&gt;
/// &lt;returns&gt;True if found, otherwise false.&lt;/returns&gt;
public bool TryGetUser(ulong userId, [NotNullWhen(true)] out DiscordUser? user, bool fetch = true)
⋮----
user = this.GetUserAsync(userId, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets the published store sku listings (premium application subscription).
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to fetch the listings for.&lt;/param&gt;
/// &lt;returns&gt;A list of published listings with &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;s.&lt;/returns&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordStoreSku&gt;&gt; GetPublishedListingsAsync(ulong applicationId)
=&gt; await this.ApiClient.GetPublishedListingsAsync(applicationId).ConfigureAwait(false);
⋮----
///     Gets the applications skus.
⋮----
/// &lt;returns&gt;A list of published listings with &lt;see cref=&quot;DiscordSku&quot; /&gt;s.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the skus do not exist.&lt;/exception&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordSku&gt;&gt; GetSkusAsync()
=&gt; await this.ApiClient.GetSkusAsync(this.CurrentApplication.Id).ConfigureAwait(false);
⋮----
///     Gets the application&apos;s entitlements.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;Filter returned entitlements to a specific guild id.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;Filter returned entitlements to a specific user id.&lt;/param&gt;
/// &lt;param name=&quot;skuIds&quot;&gt;Optional list of SKU IDs to check entitlements for.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Retrieve entitlements before this entitlement ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Retrieve entitlements after this entitlement ID.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Number of entitlements to return, 1-100, default 100.&lt;/param&gt;
/// &lt;param name=&quot;excludeEnded&quot;&gt;
///     Whether or not ended entitlements should be omitted. Defaults to false, ended entitlements
///     are included by default.
/// &lt;/param&gt;
/// &lt;param name=&quot;excludeDeleted&quot;&gt;
///     Whether or not deleted entitlements should be omitted. Defaults to true, deleted
///     entitlements are not included by default.
⋮----
/// &lt;returns&gt;A list of &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the entitlements do not exist.&lt;/exception&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordEntitlement&gt;&gt; GetEntitlementsAsync(ulong? guildId = null, ulong? userId = null, List&lt;ulong&gt;? skuIds = null, ulong? before = null, ulong? after = null, int limit = 100, bool? excludeEnded = null, bool? excludeDeleted = null)
=&gt; await this.ApiClient.GetEntitlementsAsync(this.CurrentApplication.Id, guildId, userId, skuIds, before, after, limit, excludeEnded, excludeDeleted).ConfigureAwait(false);
⋮----
///     Gets an entitlement.
⋮----
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to fetch.&lt;/param&gt;
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordEntitlement?&gt; GetEntitlementAsync(ulong entitlementId)
=&gt; await this.ApiClient.GetEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
⋮----
///    Consumes an entitlement.
⋮----
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to consume.&lt;/param&gt;
/// &lt;returns&gt;Whether the entitlement was consumed.&lt;/returns&gt;
⋮----
public async Task&lt;bool&gt; ConsumeEntitlementAsync(ulong entitlementId)
=&gt; await this.ApiClient.ConsumeEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
⋮----
///     Gets the subscriptions of an sku.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to fetch the subscriptions for.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user ID for which to return subscriptions. Required except for OAuth queries.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;List subscriptions before this ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;List subscriptions after this ID.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Number of results to return (1-100).&lt;/param&gt;
/// &lt;returns&gt;A list of &lt;see cref=&quot;DiscordSubscription&quot; /&gt;.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the subscriptions do not exist.&lt;/exception&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSkuSubscriptionsAsync(ulong skuId, ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
=&gt; await this.ApiClient.GetSkuSubscriptionsAsync(skuId, userId, before, after, limit).ConfigureAwait(false);
⋮----
///     Gets a subscription of an sku.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to fetch the subscription for.&lt;/param&gt;
/// &lt;param name=&quot;subscriptionId&quot;&gt;The subscription id to fetch.&lt;/param&gt;
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordSubscription&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;DiscordSubscription?&gt; GetSkuSubscriptionAsync(ulong skuId, ulong subscriptionId)
=&gt; await this.ApiClient.GetSkuSubscriptionAsync(skuId, subscriptionId).ConfigureAwait(false);
⋮----
///     Creates a test entitlement.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;ownerId&quot;&gt;The owner id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;ownerType&quot;&gt;The owner type to create the entitlement for.&lt;/param&gt;
/// &lt;returns&gt;A partial &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong skuId, ulong ownerId, EntitlementOwnerType ownerType)
=&gt; await this.ApiClient.CreateTestEntitlementAsync(this.CurrentApplication.Id, skuId, ownerId, ownerType).ConfigureAwait(false);
⋮----
///     Deletes a test entitlement.
⋮----
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to delete.&lt;/param&gt;
⋮----
public async Task DeleteTestEntitlementAsync(ulong entitlementId)
=&gt; await this.ApiClient.DeleteTestEntitlementAsync(this.CurrentApplication.Id, entitlementId).ConfigureAwait(false);
⋮----
///     Gets the applications role connection metadata.
⋮----
/// &lt;returns&gt;A list of metadata records or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
public async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; GetRoleConnectionMetadata()
=&gt; await this.ApiClient.GetRoleConnectionMetadataRecords(this.CurrentApplication.Id).ConfigureAwait(false);
⋮----
///     Updates the applications role connection metadata.
⋮----
/// &lt;param name=&quot;metadata&quot;&gt;A list of metadata objects. Max 5.&lt;/param&gt;
public async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; UpdateRoleConnectionMetadata(IEnumerable&lt;DiscordApplicationRoleConnectionMetadata&gt; metadata)
=&gt; await this.ApiClient.UpdateRoleConnectionMetadataRecords(this.CurrentApplication.Id, metadata).ConfigureAwait(false);
⋮----
///     Removes all global application commands.
⋮----
public async Task RemoveGlobalApplicationCommandsAsync()
=&gt; await this.ApiClient.BulkOverwriteGlobalApplicationCommandsAsync(this.CurrentApplication.Id, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
⋮----
///     Removes all global application commands for a specific guild id.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The target guild id.&lt;/param&gt;
public async Task RemoveGuildApplicationCommandsAsync(ulong guildId)
=&gt; await this.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, Array.Empty&lt;DiscordApplicationCommand&gt;()).ConfigureAwait(false);
⋮----
///     Removes all global application commands for a specific guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The target guild.&lt;/param&gt;
public async Task RemoveGuildApplicationCommandsAsync(DiscordGuild guild)
=&gt; await this.RemoveGuildApplicationCommandsAsync(guild.Id).ConfigureAwait(false);
⋮----
///     &lt;param name=&quot;fetch&quot;&gt;Whether to ignore the cache. Defaults to false.&lt;/param&gt;
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordApplicationEmoji&gt;&gt; GetApplicationEmojisAsync(bool fetch = false)
=&gt; (fetch ? null : this.InternalGetCachedApplicationEmojis()) ?? await this.ApiClient.GetApplicationEmojisAsync(this.CurrentApplication.Id).ConfigureAwait(false);
⋮----
///     Gets an application emoji.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The emoji id.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the emoji does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordApplicationEmoji?&gt; GetApplicationEmojiAsync(ulong id, bool fetch = false)
=&gt; (fetch ? null : this.InternalGetCachedApplicationEmoji(id)) ?? await this.ApiClient.GetApplicationEmojiAsync(this.CurrentApplication.Id, id).ConfigureAwait(false);
⋮----
///     Creates an application emoji.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
/// &lt;param name=&quot;image&quot;&gt;The image.&lt;/param&gt;
⋮----
public async Task&lt;DiscordApplicationEmoji&gt; CreateApplicationEmojiAsync(string name, Stream image)
⋮----
var imageb64 = MediaTool.Base64FromStream(image);
return await this.ApiClient.CreateApplicationEmojiAsync(this.CurrentApplication.Id, name, imageb64);
⋮----
///     Modifies an application emoji.
⋮----
public Task&lt;DiscordApplicationEmoji&gt; ModifyApplicationEmojiAsync(ulong id, string name)
=&gt; this.ApiClient.ModifyApplicationEmojiAsync(this.CurrentApplication.Id, id, name);
⋮----
///     Deletes an application emoji.
⋮----
public Task DeleteApplicationEmojiAsync(ulong id)
=&gt; this.ApiClient.DeleteApplicationEmojiAsync(this.CurrentApplication.Id, id);
⋮----
///     Gets a channel.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the channel to get.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The requested channel.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the channel does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordChannel&gt; GetChannelAsync(ulong id, bool fetch = false)
=&gt; (fetch ? null : this.InternalGetCachedChannel(id)) ?? await this.ApiClient.GetChannelAsync(id).ConfigureAwait(false);
⋮----
///     Tries to get a channel.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The queried channel, if found.&lt;/param&gt;
⋮----
/// &lt;returns&gt;True if channel found, otherwise false.&lt;/returns&gt;
public bool TryGetChannel(ulong id, [NotNullWhen(true)] out DiscordChannel? channel, bool fetch = true)
⋮----
channel = this.GetChannelAsync(id, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a thread.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id of the thread to get.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The requested thread.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the thread does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordThreadChannel&gt; GetThreadAsync(ulong id, bool fetch = false)
=&gt; (fetch ? null : this.InternalGetCachedThread(id)) ?? await this.ApiClient.GetThreadAsync(id).ConfigureAwait(false);
⋮----
///     Tries to get a thread.
⋮----
/// &lt;param name=&quot;thread&quot;&gt;The thread, if found.&lt;/param&gt;
⋮----
public bool TryGetThread(ulong id, [NotNullWhen(true)] out DiscordThreadChannel? thread, bool fetch = true)
⋮----
thread = this.GetThreadAsync(id, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Sends a normal message.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to send to.&lt;/param&gt;
/// &lt;param name=&quot;content&quot;&gt;The message content to send.&lt;/param&gt;
/// &lt;returns&gt;The message that was sent.&lt;/returns&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission.
/// &lt;/exception&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, string content)
=&gt; this.ApiClient.CreateMessageAsync(channel.Id, content, null, null, null, false, false);
⋮----
///     Sends a message with an embed.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;The embed to attach to the message.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, DiscordEmbed embed)
=&gt; this.ApiClient.CreateMessageAsync(channel.Id, null, embed != null
⋮----
///     Sends a message with content and an embed.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;Channel to send to.&lt;/param&gt;
⋮----
Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, string content, DiscordEmbed embed)
=&gt; this.ApiClient.CreateMessageAsync(channel.Id, content, embed != null
⋮----
///     Sends a message with the &lt;see cref=&quot;DisCatSharp.Entities.DiscordMessageBuilder&quot; /&gt;.
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel to send the message to.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The message builder.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission if TTS is false and &lt;see cref=&quot;Permissions.SendTtsMessages&quot; /&gt;
///     if TTS is true.
⋮----
Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, DiscordMessageBuilder builder)
=&gt; this.ApiClient.CreateMessageAsync(channel.Id, builder);
⋮----
///     Sends a message with an &lt;see cref=&quot;Action{DiscordMessageBuilder}&quot; /&gt;.
⋮----
/// &lt;param name=&quot;action&quot;&gt;The message builder.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordChannel channel, Action&lt;DiscordMessageBuilder&gt; action)
⋮----
var builder = new DiscordMessageBuilder();
⋮----
return this.ApiClient.CreateMessageAsync(channel.Id, builder);
⋮----
///     Gets a guild.
///     &lt;para&gt;Setting &lt;paramref name=&quot;withCounts&quot; /&gt; to true will make a REST request.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;id&quot;&gt;The guild ID to search for.&lt;/param&gt;
/// &lt;param name=&quot;withCounts&quot;&gt;Whether to include approximate presence and member counts in the returned guild.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The requested Guild.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the guild does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordGuild&gt; GetGuildAsync(ulong id, bool? withCounts = null, bool fetch = false)
⋮----
if (!fetch &amp;&amp; this.GuildsInternal.TryGetValue(id, out var guild) &amp;&amp; (!withCounts.HasValue || !withCounts.Value))
⋮----
guild = await this.ApiClient.GetGuildAsync(id, withCounts).ConfigureAwait(false);
var channels = await this.ApiClient.GetGuildChannelsAsync(guild.Id).ConfigureAwait(false);
⋮----
///     Tries to get a guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild, if found.&lt;/param&gt;
⋮----
/// &lt;returns&gt;True if the guild was found, otherwise false.&lt;/returns&gt;
public bool TryGetGuild(ulong id, [NotNullWhen(true)] out DiscordGuild? guild, bool? withCounts = null, bool fetch = true)
⋮----
guild = this.GetGuildAsync(id, withCounts, fetch).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a guild preview.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The guild ID.&lt;/param&gt;
/// &lt;returns&gt;A preview of the requested guild.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildPreview&gt; GetGuildPreviewAsync(ulong id)
=&gt; this.ApiClient.GetGuildPreviewAsync(id);
⋮----
///     Tries to get a guild preview.
⋮----
/// &lt;param name=&quot;preview&quot;&gt;The preview, if found.&lt;/param&gt;
/// &lt;returns&gt;True if the preview was found, otherwise false.&lt;/returns&gt;
public bool TryGetGuildPreview(ulong id, [NotNullWhen(true)] out DiscordGuildPreview? preview)
⋮----
preview = this.ApiClient.GetGuildPreviewAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a guild widget.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The Guild Id.&lt;/param&gt;
/// &lt;returns&gt;A guild widget.&lt;/returns&gt;
⋮----
public Task&lt;DiscordWidget&gt; GetGuildWidgetAsync(ulong id)
=&gt; this.ApiClient.GetGuildWidgetAsync(id);
⋮----
///     Tries to get a guild widget.
⋮----
/// &lt;param name=&quot;widget&quot;&gt;The widget, if found.&lt;/param&gt;
/// &lt;returns&gt;True if the widget was found, otherwise false.&lt;/returns&gt;
public bool TryGetGuildWidget(ulong id, [NotNullWhen(true)] out DiscordWidget? widget)
⋮----
widget = this.ApiClient.GetGuildWidgetAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets an invite.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The invite code.&lt;/param&gt;
/// &lt;param name=&quot;withCounts&quot;&gt;Whether to include presence and total member counts in the returned invite.&lt;/param&gt;
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The scheduled event id.&lt;/param&gt;
/// &lt;param name=&quot;withPermissions&quot;&gt;Whether to include the invite&apos;s permissions.&lt;/param&gt;
/// &lt;returns&gt;The requested invite.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the invite does not exist.&lt;/exception&gt;
⋮----
public Task&lt;DiscordInvite&gt; GetInviteByCodeAsync(string code, bool? withCounts = null, ulong? scheduledEventId = null, bool? withPermissions = null)
=&gt; this.ApiClient.GetInviteAsync(code, withCounts, scheduledEventId, withPermissions);
⋮----
///     Tries to get an invite.
⋮----
/// &lt;param name=&quot;invite&quot;&gt;The invite, if found.&lt;/param&gt;
⋮----
/// &lt;returns&gt;True if the invite was found, otherwise false.&lt;/returns&gt;
public bool TryGetInviteByCode(string code, [NotNullWhen(true)] out DiscordInvite? invite, bool? withCounts = null, ulong? scheduledEventId = null, bool? withPermissions = null)
⋮----
invite = this.GetInviteByCodeAsync(code, withCounts, scheduledEventId, withPermissions).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a list of user connections.
⋮----
public Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetConnectionsAsync()
=&gt; this.ApiClient.GetUserConnectionsAsync();
⋮----
///     Gets a sticker.
⋮----
/// &lt;returns&gt;The requested sticker.&lt;/returns&gt;
/// &lt;param name=&quot;id&quot;&gt;The id of the sticker.&lt;/param&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the sticker does not exist.&lt;/exception&gt;
⋮----
public Task&lt;DiscordSticker&gt; GetStickerAsync(ulong id)
=&gt; this.ApiClient.GetStickerAsync(id);
⋮----
///     Tries to get a sticker.
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;The sticker, if found.&lt;/param&gt;
public bool TryGetSticker(ulong id, [NotNullWhen(true)] out DiscordSticker? sticker)
⋮----
sticker = this.GetStickerAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a sticker pack.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The sticker pack&apos;s id.&lt;/param&gt;
/// &lt;returns&gt;The sticker pack.&lt;/returns&gt;
⋮----
public Task&lt;DiscordStickerPack&gt; GetStickerPackAsync(ulong id)
=&gt; this.ApiClient.GetStickerPackAsync(id);
⋮----
///     Gets all nitro sticker packs.
⋮----
/// &lt;returns&gt;List of sticker packs.&lt;/returns&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordStickerPack&gt;&gt; GetStickerPacksAsync()
=&gt; this.ApiClient.GetStickerPacksAsync();
⋮----
///     Gets the In-App OAuth Url for the current application.
⋮----
/// &lt;param name=&quot;scopes&quot;&gt;
///     The scopes to send with the request. Defaults to
///     &lt;see cref=&quot;DisCatSharp.Enums.OAuthScopes.BOT_DEFAULT&quot; /&gt;. Mutually exclusive to &lt;paramref name=&quot;manual_scopes&quot; /&gt;.
⋮----
/// &lt;param name=&quot;redir&quot;&gt;Redirect Uri.&lt;/param&gt;
/// &lt;param name=&quot;permissions&quot;&gt;Defaults to &lt;see cref=&quot;Permissions.None&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;user_install&quot;&gt;Whether to install as user app.&lt;/param&gt;
/// &lt;param name=&quot;guild_id&quot;&gt;The guild id to pre-select.&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;The state to send with the request.&lt;/param&gt;
/// &lt;param name=&quot;access_type&quot;&gt;The access type to send with the request (offline|online).&lt;/param&gt;
/// &lt;param name=&quot;response_type&quot;&gt;The response type to send with the request (code|token).&lt;/param&gt;
/// &lt;param name=&quot;prompt&quot;&gt;Whether to prompt the user for authorization.&lt;/param&gt;
/// &lt;param name=&quot;manual_scopes&quot;&gt;The scopes to send with the request. Mutually exclusive to &lt;paramref name=&quot;scopes&quot; /&gt;.&lt;/param&gt;
/// &lt;returns&gt;The OAuth Url&lt;/returns&gt;
public Uri GetInAppOAuth(Permissions permissions = Permissions.None, OAuthScopes scopes = OAuthScopes.BOT_DEFAULT, string? redir = null, bool user_install = false, ulong? guild_id = null, string? state = null, string? access_type = null, string? response_type = null, bool prompt = true, string? manual_scopes = null)
⋮----
return new(new QueryUriBuilder($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.OAUTH2}{Endpoints.AUTHORIZE}&quot;)
.AddParameter(&quot;client_id&quot;, this.CurrentApplication.Id.ToString(CultureInfo.InvariantCulture))
.AddParameter(&quot;scope&quot;, manual_scopes ?? OAuth.ResolveScopes(scopes))
.AddParameter(&quot;permissions&quot;, ((long)permissions).ToString(CultureInfo.InvariantCulture))
.AddParameter(&quot;state&quot;, state ?? string.Empty)
.AddParameter(&quot;redirect_uri&quot;, redir ?? string.Empty)
.AddParameter(&quot;integration_type&quot;, user_install ? &quot;1&quot; : &quot;0&quot;)
.AddParameter(&quot;guild_id&quot;, guild_id.HasValue ? guild_id.Value.ToString(CultureInfo.InvariantCulture) : string.Empty)
.AddParameter(&quot;access_type&quot;, access_type ?? string.Empty)
.AddParameter(&quot;response_type&quot;, response_type ?? string.Empty)
.AddParameter(&quot;prompt&quot;, prompt ? &quot;consent&quot; : &quot;none&quot;)
.ToString());
⋮----
///     Generates an In-App OAuth Url for a specific &lt;paramref name=&quot;bot&quot; /&gt;.
⋮----
/// &lt;param name=&quot;bot&quot;&gt;The bot to generate the url for.&lt;/param&gt;
⋮----
public Uri GenerateInAppOauthFor(DiscordUser bot, Permissions permissions = Permissions.None, OAuthScopes scopes = OAuthScopes.BOT_DEFAULT, string? redir = null, bool user_install = false, ulong? guild_id = null, string? state = null, string? access_type = null, string? response_type = null, bool prompt = true, string? manual_scopes = null)
⋮----
throw new ArgumentException(&quot;The user must be a bot.&quot;, nameof(bot));
⋮----
.AddParameter(&quot;client_id&quot;, bot.Id.ToString(CultureInfo.InvariantCulture))
⋮----
///     Gets a webhook.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The target webhook id.&lt;/param&gt;
/// &lt;returns&gt;The requested webhook.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the webhook does not exist.&lt;/exception&gt;
⋮----
public Task&lt;DiscordWebhook&gt; GetWebhookAsync(ulong id)
=&gt; this.ApiClient.GetWebhookAsync(id);
⋮----
///     Tries to get a webhook.
⋮----
/// &lt;param name=&quot;webhook&quot;&gt;The webhook, if found.&lt;/param&gt;
⋮----
public bool TryGetWebhook(ulong id, [NotNullWhen(true)] out DiscordWebhook? webhook)
⋮----
webhook = this.GetWebhookAsync(id).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Gets a webhook with a token.
⋮----
/// &lt;param name=&quot;token&quot;&gt;The target webhook token.&lt;/param&gt;
⋮----
public Task&lt;DiscordWebhook&gt; GetWebhookWithTokenAsync(ulong id, string token)
=&gt; this.ApiClient.GetWebhookWithTokenAsync(id, token);
⋮----
///     Tries to get a webhook with a token.
⋮----
public bool TryGetWebhookWithToken(ulong id, string token, [NotNullWhen(true)] out DiscordWebhook? webhook)
⋮----
webhook = this.GetWebhookWithTokenAsync(id, token).ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
///     Updates current user&apos;s activity and status.
⋮----
/// &lt;param name=&quot;activity&quot;&gt;Activity to set.&lt;/param&gt;
/// &lt;param name=&quot;userStatus&quot;&gt;Status of the user.&lt;/param&gt;
/// &lt;param name=&quot;idleSince&quot;&gt;Since when is the client performing the specified activity.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public Task UpdateStatusAsync(DiscordActivity? activity = null, UserStatus? userStatus = null, DateTimeOffset? idleSince = null)
=&gt; this.InternalUpdateStatusAsync(activity is not null ? [activity] : null, userStatus, idleSince);
⋮----
///     Edits current user.
⋮----
/// &lt;param name=&quot;username&quot;&gt;New username.&lt;/param&gt;
/// &lt;param name=&quot;avatar&quot;&gt;New avatar.&lt;/param&gt;
/// &lt;param name=&quot;banner&quot;&gt;New banner.&lt;/param&gt;
/// &lt;returns&gt;The modified user.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordUser&gt; UpdateCurrentUserAsync(string? username = null, Optional&lt;Stream?&gt; avatar = default, Optional&lt;Stream?&gt; banner = default)
⋮----
var av64 = MediaTool.Base64FromStream(avatar);
var ba64 = MediaTool.Base64FromStream(banner);
⋮----
var usr = await this.ApiClient.ModifyCurrentUserAsync(username ?? this.CurrentUser.Username, av64, ba64).ConfigureAwait(false);
⋮----
///     Gets a guild template by the code.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code of the template.&lt;/param&gt;
/// &lt;returns&gt;The guild template for the code.&lt;/returns&gt;
⋮----
public Task&lt;DiscordGuildTemplate&gt; GetTemplateAsync(string code)
=&gt; this.ApiClient.GetTemplateAsync(code);
⋮----
///     Gets all the global application commands for this application.
⋮----
/// &lt;param name=&quot;withLocalizations&quot;&gt;Whether to get the full localization dict.&lt;/param&gt;
/// &lt;returns&gt;A list of global application commands.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGlobalApplicationCommandsAsync(bool withLocalizations = false) =&gt;
this.ApiClient.GetGlobalApplicationCommandsAsync(this.CurrentApplication.Id, withLocalizations);
⋮----
///     Overwrites the existing global application commands. New commands are automatically created and missing commands
///     are automatically deleted.
⋮----
/// &lt;param name=&quot;commands&quot;&gt;The list of commands to overwrite with.&lt;/param&gt;
/// &lt;returns&gt;The list of global commands.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGlobalApplicationCommandsAsync(IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
this.ApiClient.BulkOverwriteGlobalApplicationCommandsAsync(this.CurrentApplication.Id, commands);
⋮----
///     Creates or overwrites a global application command.
⋮----
/// &lt;param name=&quot;command&quot;&gt;The command to create.&lt;/param&gt;
/// &lt;returns&gt;The created command.&lt;/returns&gt;
public Task&lt;DiscordApplicationCommand&gt; CreateGlobalApplicationCommandAsync(DiscordApplicationCommand command) =&gt;
this.ApiClient.CreateGlobalApplicationCommandAsync(this.CurrentApplication.Id, command);
⋮----
///     Gets a global application command by its id.
⋮----
/// &lt;param name=&quot;commandId&quot;&gt;The id of the command to get.&lt;/param&gt;
/// &lt;returns&gt;The command with the id.&lt;/returns&gt;
public Task&lt;DiscordApplicationCommand&gt; GetGlobalApplicationCommandAsync(ulong commandId) =&gt;
this.ApiClient.GetGlobalApplicationCommandAsync(this.CurrentApplication.Id, commandId);
⋮----
///     Edits a global application command.
⋮----
/// &lt;param name=&quot;commandId&quot;&gt;The id of the command to edit.&lt;/param&gt;
/// &lt;param name=&quot;action&quot;&gt;Action to perform.&lt;/param&gt;
/// &lt;returns&gt;The edited command.&lt;/returns&gt;
public async Task&lt;DiscordApplicationCommand&gt; EditGlobalApplicationCommandAsync(ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
⋮----
var mdl = new ApplicationCommandEditModel();
⋮----
var applicationId = this.CurrentApplication?.Id ?? (await this.GetCurrentApplicationAsync().ConfigureAwait(false)).Id;
return await this.ApiClient.EditGlobalApplicationCommandAsync(applicationId, commandId, mdl.Name, mdl.Description, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
⋮----
///     Deletes a global application command.
⋮----
/// &lt;param name=&quot;commandId&quot;&gt;The id of the command to delete.&lt;/param&gt;
public Task DeleteGlobalApplicationCommandAsync(ulong commandId) =&gt;
this.ApiClient.DeleteGlobalApplicationCommandAsync(this.CurrentApplication.Id, commandId);
⋮----
///     Gets all the application commands for a guild.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The id of the guild to get application commands for.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A list of application commands in the guild.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGuildApplicationCommandsAsync(ulong guildId, bool withLocalizations = false) =&gt;
this.ApiClient.GetGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, withLocalizations);
⋮----
///     Overwrites the existing application commands in a guild. New commands are automatically created and missing
///     commands are automatically deleted.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The id of the guild.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The list of guild commands.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGuildApplicationCommandsAsync(ulong guildId, IEnumerable&lt;DiscordApplicationCommand&gt; commands) =&gt;
this.ApiClient.BulkOverwriteGuildApplicationCommandsAsync(this.CurrentApplication.Id, guildId, commands);
⋮----
///     Creates or overwrites a guild application command.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The id of the guild to create the application command in.&lt;/param&gt;
⋮----
public Task&lt;DiscordApplicationCommand&gt; CreateGuildApplicationCommandAsync(ulong guildId, DiscordApplicationCommand command) =&gt;
this.ApiClient.CreateGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, command);
⋮----
///     Gets a application command in a guild by its id.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The id of the guild the application command is in.&lt;/param&gt;
⋮----
public Task&lt;DiscordApplicationCommand&gt; GetGuildApplicationCommandAsync(ulong guildId, ulong commandId) =&gt;
this.ApiClient.GetGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, commandId);
⋮----
///     Edits a application command in a guild.
⋮----
public async Task&lt;DiscordApplicationCommand&gt; EditGuildApplicationCommandAsync(ulong guildId, ulong commandId, Action&lt;ApplicationCommandEditModel&gt; action)
⋮----
return await this.ApiClient.EditGuildApplicationCommandAsync(applicationId, guildId, commandId, mdl.Name, mdl.Description, mdl.Options, mdl.NameLocalizations, mdl.DescriptionLocalizations, mdl.DefaultMemberPermissions, mdl.IsNsfw, mdl.AllowedContexts, mdl.IntegrationTypes).ConfigureAwait(false);
⋮----
///     Deletes a application command in a guild.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The id of the guild to delete the application command in.&lt;/param&gt;
/// &lt;param name=&quot;commandId&quot;&gt;The id of the command.&lt;/param&gt;
public Task DeleteGuildApplicationCommandAsync(ulong guildId, ulong commandId) =&gt;
this.ApiClient.DeleteGuildApplicationCommandAsync(this.CurrentApplication.Id, guildId, commandId);
⋮----
///     Gets all default soundboard sounds available for all users.
⋮----
/// &lt;returns&gt;A list of &lt;see cref=&quot;DiscordSoundboardSound&quot; /&gt; objects that are available by default.&lt;/returns&gt;
public Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListDefaultSoundboardSoundsAsync()
=&gt; this.ApiClient.ListDefaultSoundboardSoundsAsync();
⋮----
///     Gets the internal cached threads.
⋮----
/// &lt;param name=&quot;threadId&quot;&gt;The target thread id.&lt;/param&gt;
⋮----
internal DiscordThreadChannel? InternalGetCachedThread(ulong threadId)
⋮----
if (guild.Threads.TryGetValue(threadId, out var foundThread))
⋮----
///     Gets an internal cached emoji.
⋮----
/// &lt;param name=&quot;emojiId&quot;&gt;The target emoji id.&lt;/param&gt;
/// &lt;returns&gt;The requested emoji.&lt;/returns&gt;
internal DiscordApplicationEmoji? InternalGetCachedApplicationEmoji(ulong emojiId)
=&gt; this.EmojisInternal is null || this.EmojisInternal.Count is 0 ? null : this.EmojisInternal.GetValueOrDefault(emojiId);
⋮----
///     Gets the internal cached emojis.
⋮----
internal IReadOnlyList&lt;DiscordApplicationEmoji&gt;? InternalGetCachedApplicationEmojis()
=&gt; this.EmojisInternal is null || this.EmojisInternal.Count is 0 ? null : this.EmojisInternal.Values.ToList();
⋮----
///     Gets the internal cached scheduled event.
⋮----
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The target scheduled event id.&lt;/param&gt;
/// &lt;returns&gt;The requested scheduled event.&lt;/returns&gt;
internal DiscordScheduledEvent? InternalGetCachedScheduledEvent(ulong scheduledEventId)
⋮----
if (guild.ScheduledEvents.TryGetValue(scheduledEventId, out var foundScheduledEvent))
⋮----
///     Gets the internal cached channel.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The target channel id.&lt;/param&gt;
⋮----
internal DiscordChannel? InternalGetCachedChannel(ulong channelId, ulong? guildId = null)
⋮----
if (guild.Channels.TryGetValue(channelId, out var foundChannel))
⋮----
///     Gets the internal cached guild.
⋮----
/// &lt;returns&gt;The requested guild.&lt;/returns&gt;
internal DiscordGuild? InternalGetCachedGuild(ulong? guildId)
⋮----
if (this.GuildsInternal.TryGetValue(guildId.Value, out var guild))
⋮----
///     Updates a message.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to update.&lt;/param&gt;
/// &lt;param name=&quot;author&quot;&gt;The author to update.&lt;/param&gt;
/// &lt;param name=&quot;guild&quot;&gt;The guild to update.&lt;/param&gt;
/// &lt;param name=&quot;member&quot;&gt;The member to update.&lt;/param&gt;
private void UpdateMessage(DiscordMessage message, TransportUser? author, DiscordGuild? guild, TransportMember? member)
⋮----
var usr = new DiscordUser(author)
⋮----
message.Author = this.UpdateUser(usr, guild?.Id, guild, member);
⋮----
var channel = this.InternalGetCachedChannel(message.ChannelId);
⋮----
? new DiscordDmChannel
⋮----
: new DiscordChannel
⋮----
///     Updates a scheduled event.
⋮----
/// &lt;param name=&quot;scheduledEvent&quot;&gt;The scheduled event to update.&lt;/param&gt;
⋮----
/// &lt;returns&gt;The updated scheduled event.&lt;/returns&gt;
private DiscordScheduledEvent UpdateScheduledEvent(DiscordScheduledEvent scheduledEvent, DiscordGuild guild)
⋮----
ObjectDisposedException.ThrowIf(this._disposed, this);
⋮----
_ = guild.ScheduledEventsInternal.AddOrUpdate(scheduledEvent.Id, scheduledEvent, (id, old) =&gt;
⋮----
///     Updates a user.
⋮----
/// &lt;param name=&quot;usr&quot;&gt;The user to update.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to update.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;mbr&quot;&gt;The member to update.&lt;/param&gt;
/// &lt;returns&gt;The updated user.&lt;/returns&gt;
private DiscordUser UpdateUser(DiscordUser usr, ulong? guildId, DiscordGuild? guild, TransportMember? mbr)
⋮----
_ = this.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
⋮----
usr = new DiscordMember(mbr)
⋮----
if (intents.HasAllPrivilegedIntents() &amp;&amp; !guild.IsLarge) // we have the necessary privileged intents, no need to worry about caching here unless guild is large.
⋮----
if (!guild.MembersInternal.TryGetValue(usr.Id, out var member))
⋮----
if (intents.HasIntent(DiscordIntents.GuildMembers) || this.Configuration.AlwaysCacheMembers) // member can be updated by events, so cache it
guild.MembersInternal.TryAdd(usr.Id, (DiscordMember)usr);
⋮----
else if (intents.HasIntent(DiscordIntents.GuildPresences) || this.Configuration.AlwaysCacheMembers) // we can attempt to update it if it&apos;s already in cache.
if (!intents.HasIntent(DiscordIntents.GuildMembers)) // no need to update if we already have the member events
_ = guild.MembersInternal.TryUpdate(usr.Id, (DiscordMember)usr, member);
⋮----
else if (usr.Username is not null) // check if not a skeleton user
⋮----
///     Updates the cached scheduled events in a guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild.&lt;/param&gt;
/// &lt;param name=&quot;rawEvents&quot;&gt;The raw events.&lt;/param&gt;
private void UpdateCachedScheduledEvents(DiscordGuild guild, JArray? rawEvents)
⋮----
guild.ScheduledEventsInternal.Clear();
⋮----
///     Updates the cached application emojis.
⋮----
/// &lt;param name=&quot;rawEmojis&quot;&gt;The raw emojis.&lt;/param&gt;
internal override IReadOnlyDictionary&lt;ulong, DiscordApplicationEmoji&gt; UpdateCachedApplicationEmojis(JArray? rawEmojis)
⋮----
this.UpdateUser(xtm.User, null, null, null);
⋮----
///     Updates a cached application emoji.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
internal override DiscordApplicationEmoji UpdateCachedApplicationEmoji(DiscordApplicationEmoji emoji)
⋮----
_ = this.EmojisInternal.AddOrUpdate(emoji.Id, emoji, (id, old) =&gt;
⋮----
this.UpdateUser(emoji.User, null, null, null);
⋮----
///     Updates the cached guild.
⋮----
/// &lt;param name=&quot;newGuild&quot;&gt;The new guild.&lt;/param&gt;
/// &lt;param name=&quot;rawMembers&quot;&gt;The raw members.&lt;/param&gt;
private void UpdateCachedGuild(DiscordGuild newGuild, JArray? rawMembers)
⋮----
this.GuildsInternal.TryAdd(newGuild.Id, newGuild);
⋮----
if (guild.ChannelsInternal.TryGetValue(channel.Id, out _))
⋮----
channel.Initialize(this);
⋮----
if (guild.ThreadsInternal.TryGetValue(thread.Id, out _))
⋮----
if (guild.ScheduledEventsInternal.TryGetValue(@event.Id, out _))
⋮----
if (guild.SoundboardSoundsInternal.TryGetValue(sound.Id, out _))
⋮----
_ = guild.EmojisInternal.GetOrAdd(newEmoji.Id, newEmoji);
⋮----
_ = guild.StickersInternal.GetOrAdd(newSticker.Id, newSticker);
⋮----
_ = guild.StageInstancesInternal.GetOrAdd(newStageInstance.Id, newStageInstance);
⋮----
guild.MembersInternal.Clear();
⋮----
ArgumentNullException.ThrowIfNull(xtm.User);
var usr = new DiscordUser(xtm.User)
⋮----
_ = this.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
⋮----
if (guild.RolesInternal.TryGetValue(role.Id, out _))
⋮----
// fields not sent for update:
// - guild.Channels
// - voice states
// - guild.JoinedAt = new_guild.JoinedAt;
// - guild.Large = new_guild.Large;
// - guild.MemberCount = Math.Max(new_guild.MemberCount, guild._members.Count);
// - guild.Unavailable = new_guild.Unavailable;
⋮----
///     Populates the message reactions and cache.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
/// &lt;param name=&quot;author&quot;&gt;The author.&lt;/param&gt;
/// &lt;param name=&quot;member&quot;&gt;The member.&lt;/param&gt;
private void PopulateMessageReactionsAndCache(DiscordMessage message, TransportUser author, TransportMember? member)
⋮----
var guild = message.Channel?.Guild ?? this.InternalGetCachedGuild(message.GuildId);
⋮----
this.UpdateMessage(message, author, guild, member);
⋮----
///     Disposes the client.
⋮----
this.Dispose();
⋮----
///     Whether the client is disposed.
⋮----
public override void Dispose()
⋮----
this.DisconnectAsync().ConfigureAwait(false).GetAwaiter().GetResult();
⋮----
this.ApiClient.Rest.Dispose();
⋮----
this.CommandCooldownBuckets.Clear();
⋮----
var extensions = this._extensions; // prevent _extensions being modified during dispose
this._extensions.Clear();
⋮----
disposable.Dispose();
⋮----
SentrySdk.EndSession();
⋮----
GC.SuppressFinalize(this);</file><file path="DisCatSharp/Entities/Core/DisCatSharpBuilder.cs">/// &lt;summary&gt;
///     Represents the common base for most builders.
/// &lt;/summary&gt;
public class DisCatSharpBuilder
⋮----
///     The attachments of this builder.
⋮----
///     The components of this builder.
⋮----
///     The embeds of this builder.
⋮----
///     The files of this builder.
⋮----
///     The allowed mentions of this builder.
⋮----
///     The content of this builder.
⋮----
///     Tracks if content was explicitly set (even to null).
⋮----
///     Tracks if embeds were explicitly set (including empty).
⋮----
///     Tracks if components were explicitly set (including empty).
⋮----
///     Whether flags were changed in this builder.
⋮----
///     Sets the content of this builder.
⋮----
throw new InvalidOperationException(&quot;You cannot set the content for UI Kit / Voice messages&quot;);
⋮----
throw new ArgumentException(&quot;Content length cannot exceed 2000 characters.&quot;, nameof(value));
⋮----
///     Gets the components of this builder.
⋮----
///     Gets the embeds of this builder.
⋮----
///     Gets the attachments of this builder.
⋮----
///     Gets the files of this builder.
⋮----
///     Gets the allowed mentions of this builder.
⋮----
///     Sets whether this builder sends a voice message.
///     You can&apos;t use that on your own, it needs DisCatSharp.Experimental.
⋮----
///     Whether this builder sends a voice message.
⋮----
///     Sets whether this builder should send a silent message.
⋮----
///     Whether this builder sends a silent message.
⋮----
///     Sets whether this builder should be using UI Kit.
⋮----
///     Whether this builder is using UI Kit.
⋮----
///     Sets whether this builder suppresses its embeds.
⋮----
throw new InvalidOperationException(&quot;You cannot set embeds suppressed for UI Kit messages since they cannot have embeds&quot;);
⋮----
///     Whether this builder has its embeds suppressed.
⋮----
///     Clears the components on this builder.
⋮----
public virtual void ClearComponents()
⋮----
///     Allows for clearing the builder so that it can be used again.
⋮----
public virtual void Clear()
⋮----
///     Modifies the builder to replace all fields.
///     &lt;para&gt;Used when &lt;see cref=&quot;Enums.Core.ModifyMode&quot;/&gt; is &lt;see cref=&quot;Enums.Core.ModifyMode.Replace&quot;/&gt;.&lt;/para&gt;
///     &lt;para&gt;Used when &lt;see cref=&quot;Action{T}&quot;/&gt; is called on this builder.&lt;/para&gt;
⋮----
internal virtual void DoReplace()
⋮----
this.ClearComponents();
⋮----
/// 	Modifies the builder to replace all fields that are not null or empty.
/// 	&lt;para&gt;Used when &lt;see cref=&quot;Enums.Core.ModifyMode&quot;/&gt; is &lt;see cref=&quot;Enums.Core.ModifyMode.Replace&quot;/&gt;.&lt;/para&gt;
⋮----
internal virtual void DoConditionalReplace()
⋮----
///     Validates the builder.
⋮----
internal virtual void Validate()
⋮----
this.CheckComponentIds(component, ids, duplicateIds);
⋮----
var duplicateDetails = string.Join(&quot;, &quot;, duplicateIds.Select(kvp =&gt; $&quot;ID: {kvp.Key}, Types: {string.Join(&quot;, &quot;, kvp.Value)}&quot;));
throw new AggregateException($&quot;You provided one or more components with the same id. They have to be unique. Duplicates: {duplicateDetails}&quot;);
⋮----
///     Validates the uniqueness of component IDs within a given &lt;see cref=&quot;DiscordComponent&quot; /&gt; hierarchy.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The root component to validate.&lt;/param&gt;
/// &lt;param name=&quot;ids&quot;&gt;A set of IDs already encountered, used to track uniqueness.&lt;/param&gt;
/// &lt;param name=&quot;duplicateIds&quot;&gt;
///     A dictionary to store duplicate IDs and their associated component types,
///     for reporting purposes if duplicates are found.
/// &lt;/param&gt;
/// &lt;exception cref=&quot;AggregateException&quot;&gt;
///     Thrown when duplicate component IDs are detected, providing details about the duplicates.
/// &lt;/exception&gt;
private void CheckComponentIds(DiscordComponent component, HashSet&lt;int&gt; ids, Dictionary&lt;int, List&lt;string&gt;&gt; duplicateIds)
⋮----
this.AddId(actionRowComponentChild, ref ids, ref duplicateIds);
⋮----
this.AddId(sectionComponentChild, ref ids, ref duplicateIds);
this.AddId(subSectionComponent.Accessory, ref ids, ref duplicateIds);
⋮----
this.AddId(containerComponentChild, ref ids, ref duplicateIds);
⋮----
this.AddId(sectionComponent.Accessory, ref ids, ref duplicateIds);
⋮----
this.AddId(component, ref ids, ref duplicateIds);
⋮----
///     Adds the identifier of the specified &lt;see cref=&quot;DiscordComponent&quot; /&gt; to the provided collection of identifiers.
⋮----
/// &lt;param name=&quot;component&quot;&gt;
///     The &lt;see cref=&quot;DiscordComponent&quot; /&gt; whose identifier is to be added.
⋮----
/// &lt;param name=&quot;ids&quot;&gt;
///     A collection of unique identifiers to which the component&apos;s identifier will be added.
⋮----
///     A dictionary that tracks duplicate identifiers and their associated component types.
⋮----
/// &lt;remarks&gt;
///     If the identifier of the specified component already exists in the &lt;paramref name=&quot;ids&quot; /&gt; collection,
///     it will be added to the &lt;paramref name=&quot;duplicateIds&quot; /&gt; dictionary along with its type.
/// &lt;/remarks&gt;
private void AddId(DiscordComponent component, ref HashSet&lt;int&gt; ids, ref Dictionary&lt;int, List&lt;string&gt;&gt; duplicateIds)
⋮----
if (!ids.Add(id))
⋮----
if (!duplicateIds.ContainsKey(id))
⋮----
duplicateIds[id].Add(component.Type.ToString());</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionModalBuilder.cs">/// &lt;summary&gt;
///     Constructs an interaction modal response.
/// &lt;/summary&gt;
public sealed class DiscordInteractionModalBuilder
⋮----
///     Represents the title associated with the current instance.
⋮----
/// &lt;remarks&gt;This field is private and is used internally to store the title value.&lt;/remarks&gt;
⋮----
///     Constructs a new empty interaction modal builder.
⋮----
this.CustomId = customId ?? Guid.NewGuid().ToString();
⋮----
///     The components.
⋮----
///     Components to send on this interaction response.
⋮----
///     Title of modal.
⋮----
throw new ArgumentException(&quot;Title length cannot exceed 128 characters.&quot;, nameof(value));
⋮----
///     Custom id of modal.
⋮----
=&gt; this.Components?.Select(c =&gt; c as DiscordActionRowComponent).ToList()!;
⋮----
///     Sets the title of the modal.
⋮----
/// &lt;param name=&quot;title&quot;&gt;The title to set.&lt;/param&gt;
/// &lt;returns&gt;The current builder to chain calls with.&lt;/returns&gt;
public DiscordInteractionModalBuilder WithTitle(string title)
⋮----
///     Sets the custom id of the modal.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id to set.&lt;/param&gt;
⋮----
public DiscordInteractionModalBuilder WithCustomId(string customId)
⋮----
///     Appends a collection of text components to the builder. Each call will append to a new row.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to append. Up to five.&lt;/param&gt;
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when passing more than 5 components.&lt;/exception&gt;&apos;
⋮----
public DiscordInteractionModalBuilder AddTextComponents(params DiscordTextInputComponent[] components)
=&gt; this.AddModalComponents(components);
⋮----
///     Appends a text component to the builder.
⋮----
/// &lt;param name=&quot;component&quot;&gt;The component to append.&lt;/param&gt;
⋮----
public DiscordInteractionModalBuilder AddTextComponent(DiscordTextInputComponent component)
=&gt; this.AddModalComponents(component);
⋮----
///     Appends a collection of label components to the builder.
⋮----
public DiscordInteractionModalBuilder AddLabelComponents(params DiscordLabelComponent[] components)
⋮----
///     Appends a label component to the builder.
⋮----
public DiscordInteractionModalBuilder AddLabelComponent(DiscordLabelComponent component)
⋮----
///     Appends a collection of components to the builder.
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when passing more than 5 components.&lt;/exception&gt;
public DiscordInteractionModalBuilder AddModalComponents(params DiscordComponent[] components)
⋮----
var ara = components.ToArray();
⋮----
throw new ArgumentException(&quot;You can only add 5 components to modals.&quot;);
⋮----
throw new ArgumentException($&quot;You try to add too many components. We already have {this.ComponentsInternal.Count}.&quot;);
⋮----
if (components.All(x =&gt; x.Type is ComponentType.TextInput))
⋮----
this.ComponentsInternal.Add(new DiscordActionRowComponent(
⋮----
if (components.OfType&lt;DiscordLabelComponent&gt;().Any(x =&gt; x.Component is null))
throw new ArgumentException(&quot;You can only add DiscordLabelComponents with a component attached to them.&quot;);
this.ComponentsInternal.AddRange(ara);
⋮----
///     Appends several rows of components to the message
⋮----
/// &lt;param name=&quot;components&quot;&gt;The rows of components to add, holding up to five each.&lt;/param&gt;
⋮----
public DiscordInteractionModalBuilder AddModalComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
⋮----
throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
⋮----
this.ComponentsInternal.Add(ar);
⋮----
///     Allows for clearing the Interaction Response Builder so that it can be used again to send a new response.
⋮----
public void Clear()</file><file path="DisCatSharp/Entities/User/DiscordUser.cs">/// &lt;summary&gt;
///     Represents a Discord user.
/// &lt;/summary&gt;
public class DiscordUser : SnowflakeObject, IEquatable&lt;DiscordUser&gt;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordUser&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;transport&quot;&gt;The transport user.&lt;/param&gt;
⋮----
///     Gets the user&apos;s banner color integer.
⋮----
///     Gets the user&apos;s theme color integers.
⋮----
///     Gets this user&apos;s username.
⋮----
///     Gets this user&apos;s username with the discriminator.
///     Example: Discord#0000
⋮----
///     Gets the username with the global name.
///     Example: @lulalaby (Lala Sabathil)
⋮----
///     Gets this user&apos;s global name.
///     Only applicable if &lt;see cref=&quot;IsMigrated&quot; /&gt; is &lt;see langword=&quot;true&quot; /&gt;.
⋮----
///     &lt;para&gt;Whether this user account is migrated to the new username system.&lt;/para&gt;
///     &lt;para&gt;Learn more at &lt;see href=&quot;https://dis.gd/usernames&quot;&gt;dis.gd/usernames&lt;/see&gt;.&lt;/para&gt;
⋮----
///     Gets the user&apos;s 4-digit discriminator.
⋮----
///     Gets the discriminator integer.
⋮----
=&gt; int.Parse(this.Discriminator, NumberStyles.Integer, CultureInfo.InvariantCulture);
⋮----
///     Gets the user&apos;s banner color, if set. Mutually exclusive with &lt;see cref=&quot;BannerHash&quot; /&gt;.
⋮----
=&gt; !this.BannerColorInternal.HasValue ? null : new DiscordColor(this.BannerColorInternal.Value);
⋮----
///     Gets the user&apos;s theme colors, if set.
⋮----
public virtual IReadOnlyList&lt;DiscordColor&gt;? ThemeColors =&gt; !(this.ThemeColorsInternal is not null &amp;&amp; this.ThemeColorsInternal.Count != 0) ? null : this.ThemeColorsInternal.Select(x =&gt; new DiscordColor(x)).ToList();
⋮----
///     Gets the user&apos;s banner url
⋮----
=&gt; string.IsNullOrWhiteSpace(this.BannerHash) ? null : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.BANNERS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.BannerHash}.{(this.BannerHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=4096&quot;;
⋮----
///     Gets the user&apos;s banner hash. Mutually exclusive with &lt;see cref=&quot;BannerColor&quot; /&gt;.
⋮----
///     Gets the users bio.
///     This is not available to bots tho.
⋮----
///     Gets the users primary guild.
⋮----
///     Gets the user&apos;s avatar hash.
⋮----
///     Gets the user&apos;s avatar decoration data.
⋮----
///     Gets the user&apos;s collectibles.
⋮----
///     Returns a uri to this users profile.
⋮----
=&gt; new($&quot;{DiscordDomain.GetDomain(CoreDomain.Discord).Url}{Endpoints.USERS}/{this.Id}&quot;);
⋮----
///     Returns a string representing the direct URL to this users profile.
⋮----
/// &lt;returns&gt;The URL of this users profile.&lt;/returns&gt;
⋮----
///     Gets the user&apos;s avatar url.
⋮----
=&gt; string.IsNullOrWhiteSpace(this.AvatarHash) ? this.DefaultAvatarUrl : $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{this.Id.ToString(CultureInfo.InvariantCulture)}/{this.AvatarHash}.{(this.AvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot;)}?size=1024&quot;;
⋮----
///     Gets the user&apos;s avatar decoration url.
⋮----
///     Gets the URL of default avatar for this user.
⋮----
=&gt; $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMBED}{Endpoints.AVATARS}/{(this.IsMigrated ? (this.Id &gt;&gt; 22) % 6 : Convert.ToUInt64(this.DiscriminatorInt) % 5).ToString(CultureInfo.InvariantCulture)}.png?size=1024&quot;;
⋮----
///     Gets whether the user is a bot.
⋮----
///     Gets whether the user has multifactor authentication enabled.
⋮----
///     Gets whether the user is an official Discord system user.
⋮----
///     Gets whether the user is verified.
///     &lt;para&gt;This is only present in OAuth.&lt;/para&gt;
⋮----
///     Gets the user&apos;s email address.
⋮----
///     Gets the user&apos;s premium type.
⋮----
///     Gets the user&apos;s chosen language
⋮----
///     Gets the user&apos;s flags for OAuth.
⋮----
///     Gets the user&apos;s flags.
⋮----
///     Gets the user&apos;s pronouns.
⋮----
///		Gets the user&apos;s display name styles.
⋮----
///     Gets the user&apos;s mention string.
⋮----
=&gt; this.Mention(this is DiscordMember);
⋮----
///     Gets whether this user is the Client which created this object.
⋮----
///     Gets the user&apos;s access token.
///     &lt;para&gt;Can be used in combination with &lt;see cref=&quot;DiscordOAuth2Client&quot; /&gt;.&lt;/para&gt;
///     &lt;para&gt;You can generate a token object from json with &lt;see cref=&quot;DiscordAccessToken.FromJson&quot; /&gt;, if needed.&lt;/para&gt;
///     &lt;para&gt;
///         As alternative you can construct the object via
///         &lt;code&gt;new DiscordAccessToken(string accessToken, string tokenType, int expiresIn, string refreshToken, string scope)&lt;/code&gt;
///         .
///     &lt;/para&gt;
⋮----
///     Gets this user&apos;s presence.
⋮----
=&gt; this.Discord is DiscordClient dc &amp;&amp; dc.Presences.TryGetValue(this.Id, out var presence) ? presence : null;
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordUser&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordUser&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordUser&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordUser&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordUser&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordUser e)
⋮----
///     Fetches the user from the API.
⋮----
/// &lt;returns&gt;The user with fresh data from the API.&lt;/returns&gt;
public async Task&lt;DiscordUser&gt; GetFromApiAsync()
=&gt; await this.Discord.ApiClient.GetUserAsync(this.Id).ConfigureAwait(false);
⋮----
///     Gets additional information about an application if the user is an bot.
⋮----
/// &lt;returns&gt;The rpc info or &lt;see langword=&quot;null&quot; /&gt;&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the application does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task&lt;DiscordRpcApplication?&gt; GetRpcInfoAsync()
=&gt; this.IsBot ? await this.Discord.ApiClient.GetApplicationRpcInfoAsync(this.Id).ConfigureAwait(false) : await Task.FromResult&lt;DiscordRpcApplication?&gt;(null).ConfigureAwait(false);
⋮----
///     Whether this user is in a &lt;see cref=&quot;DiscordGuild&quot; /&gt;
⋮----
/// &lt;example&gt;
///     &lt;code&gt;
/// DiscordGuild guild = await Client.GetGuildAsync(806675511555915806);
/// DiscordUser user = await Client.GetUserAsync(469957180968271873);
/// Console.WriteLine($&quot;{user.Username} {(user.IsInGuild(guild) ? &quot;is a&quot; : &quot;is not a&quot;)} member of {guild.Name}&quot;);
/// &lt;/code&gt;
///     results to &lt;c&gt;J_M_Lutra is a member of Project Nyaw~&lt;/c&gt;.
/// &lt;/example&gt;
/// &lt;param name=&quot;guild&quot;&gt;
///     &lt;see cref=&quot;DiscordGuild&quot; /&gt;
/// &lt;/param&gt;
/// &lt;returns&gt;
///     &lt;see cref=&quot;bool&quot; /&gt;
/// &lt;/returns&gt;
public async Task&lt;bool&gt; IsInGuild(DiscordGuild guild)
⋮----
var member = await guild.GetMemberAsync(this.Id).ConfigureAwait(false);
⋮----
///     Whether this user is not in a &lt;see cref=&quot;DiscordGuild&quot; /&gt;
⋮----
public async Task&lt;bool&gt; IsNotInGuild(DiscordGuild guild)
=&gt; !await this.IsInGuild(guild).ConfigureAwait(false);
⋮----
///     Returns the DiscordMember in the specified &lt;see cref=&quot;DiscordGuild&quot; /&gt;
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The &lt;see cref=&quot;DiscordGuild&quot; /&gt; to get this user on.&lt;/param&gt;
/// &lt;returns&gt;The &lt;see cref=&quot;DiscordMember&quot; /&gt;.&lt;/returns&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the user is not part of the guild.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordMember&gt; ConvertToMember(DiscordGuild guild)
=&gt; await guild.GetMemberAsync(this.Id).ConfigureAwait(false);
⋮----
///     Unbans this user from a guild.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;Guild to unban this user from.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the client does not have the &lt;see cref=&quot;Permissions.BanMembers&quot; /&gt;
///     permission.
/// &lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the user does not exist.&lt;/exception&gt;
⋮----
public Task UnbanAsync(DiscordGuild guild, string? reason = null)
=&gt; guild.UnbanMemberAsync(this, reason);
⋮----
///     Gets the user&apos;s avatar URL, in requested format and size.
⋮----
/// &lt;param name=&quot;fmt&quot;&gt;Format of the avatar to get.&lt;/param&gt;
/// &lt;param name=&quot;size&quot;&gt;Maximum size of the avatar. Must be a power of two, minimum 16, maximum 2048.&lt;/param&gt;
/// &lt;returns&gt;URL of the user&apos;s avatar.&lt;/returns&gt;
public string GetAvatarUrl(MediaFormat fmt, ushort size = 1024)
⋮----
throw new ArgumentException(&quot;You must specify valid image format.&quot;, nameof(fmt));
⋮----
throw new ArgumentOutOfRangeException(nameof(size));
⋮----
var log = Math.Log(size, 2);
⋮----
MediaFormat.Auto =&gt; !string.IsNullOrWhiteSpace(this.AvatarHash) ? this.AvatarHash.StartsWith(&quot;a_&quot;, StringComparison.Ordinal) ? &quot;gif&quot; : &quot;png&quot; : &quot;png&quot;,
_ =&gt; throw new ArgumentOutOfRangeException(nameof(fmt))
⋮----
var ssize = size.ToString(CultureInfo.InvariantCulture);
if (!string.IsNullOrWhiteSpace(this.AvatarHash))
⋮----
var id = this.Id.ToString(CultureInfo.InvariantCulture);
return $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.AVATARS}/{id}/{this.AvatarHash}.{sfmt}?size={ssize}&quot;;
⋮----
var type = (this.DiscriminatorInt % 5).ToString(CultureInfo.InvariantCulture);
return $&quot;{DiscordDomain.GetDomain(CoreDomain.DiscordCdn).Url}{Endpoints.EMBED}{Endpoints.AVATARS}/{type}.{sfmt}?size={ssize}&quot;;
⋮----
///     Creates a direct message channel to this user.
⋮----
/// &lt;returns&gt;Direct message channel to this user.&lt;/returns&gt;
⋮----
///     Thrown when the user has the bot blocked, the member shares no guild with the
///     bot, or if the member has Allow DM from server members off.
⋮----
public Task&lt;DiscordDmChannel&gt; CreateDmChannelAsync()
=&gt; this.Discord.ApiClient.CreateDmAsync(this.Id);
⋮----
///     Sends a direct message to this user. Creates a direct message channel if one does not exist already.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Content of the message to send.&lt;/param&gt;
/// &lt;returns&gt;The sent message.&lt;/returns&gt;
⋮----
public async Task&lt;DiscordMessage&gt; SendMessageAsync(string content)
⋮----
throw new ArgumentException(&quot;Bots cannot DM each other.&quot;);
⋮----
var chn = await this.CreateDmChannelAsync().ConfigureAwait(false);
return await chn.SendMessageAsync(content).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to attach to the message.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordEmbed embed)
⋮----
return await chn.SendMessageAsync(embed).ConfigureAwait(false);
⋮----
public async Task&lt;DiscordMessage&gt; SendMessageAsync(string content, DiscordEmbed embed)
⋮----
return await chn.SendMessageAsync(content, embed).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;message&quot;&gt;Builder to with the message.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMessage&gt; SendMessageAsync(DiscordMessageBuilder message)
⋮----
return await chn.SendMessageAsync(message).ConfigureAwait(false);
⋮----
///     Returns a string representation of this user.
⋮----
/// &lt;returns&gt;String representation of this user.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordUser&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordUser&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordUser);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordUser&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordUser&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
=&gt; this.Id.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordUser&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First user to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second user to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two users are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordUser&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two users are not equal.&lt;/returns&gt;
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.CertifiedModerator&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.CertifiedModerator);
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.Partner&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.Partner);
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.VerifiedBot&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.VerifiedBot);
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.VerifiedDeveloper&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.VerifiedDeveloper);
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.ActiveDeveloper&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.ActiveDeveloper);
⋮----
///     Whether this member is a &lt;see cref=&quot;UserFlags.Staff&quot; /&gt;
⋮----
=&gt; this.Flags.HasValue &amp;&amp; this.Flags.Value.HasFlag(UserFlags.Staff);
⋮----
///     Gets the current user&apos;s connections.
///     &lt;para&gt;Requires a &lt;see cref=&quot;DiscordAccessToken&quot; /&gt; set in &lt;see cref=&quot;AccessToken&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;oauth2Client&quot;&gt;The oauth2 client.&lt;/param&gt;
/// &lt;exception cref=&quot;NullReferenceException&quot;&gt;Thrown when &lt;see cref=&quot;AccessToken&quot; /&gt; is not present.&lt;/exception&gt;
public async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; OAuth2GetConnectionsAsync(DiscordOAuth2Client oauth2Client)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserConnectionsAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s guilds.
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; OAuth2GetGuildAsync(DiscordOAuth2Client oauth2Client)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildsAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s member object for given &lt;paramref name=&quot;guild&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild to get the member object for.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMember&gt; OAuth2GetGuildMemberAsync(DiscordOAuth2Client oauth2Client, DiscordGuild guild)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildMemberAsync(this.AccessToken, guild.Id) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s member object for given &lt;paramref name=&quot;guildId&quot; /&gt;.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to get the member object for.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMember&gt; OAuth2GetGuildMemberAsync(DiscordOAuth2Client oauth2Client, ulong guildId)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserGuildMemberAsync(this.AccessToken, guildId) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     &lt;para&gt;Adds the user to the given &lt;paramref name=&quot;guildId&quot; /&gt;.&lt;/para&gt;
⋮----
///         Some parameters might need additional permissions for the bot on the target guild. See
///         https://discord.com/developers/docs/resources/guild#add-guild-member for details.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to add the member to.&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;The new nickname.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;The new roles.&lt;/param&gt;
/// &lt;param name=&quot;muted&quot;&gt;Whether this user has to be muted.&lt;/param&gt;
/// &lt;param name=&quot;deafened&quot;&gt;Whether this user has to be deafened.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMember&gt; OAuth2AddToGuildAsync(DiscordOAuth2Client oauth2Client, ulong guildId, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
=&gt; this.AccessToken is not null ? await oauth2Client.AddCurrentUserToGuildAsync(this.AccessToken, this.Id, guildId, nickname, roles, muted, deafened) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     &lt;para&gt;Adds the user to the given &lt;paramref name=&quot;guild&quot; /&gt;.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;guild&quot;&gt;The guild to add the member to.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMember&gt; OAuth2AddToGuildAsync(DiscordOAuth2Client oauth2Client, DiscordGuild guild, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
=&gt; this.AccessToken is not null ? await oauth2Client.AddCurrentUserToGuildAsync(this.AccessToken, this.Id, guild.Id, nickname, roles, muted, deafened) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s oauth2 object.
⋮----
public async Task&lt;DiscordUser&gt; OAuth2GetAsync(DiscordOAuth2Client oauth2Client)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s authorization info.
⋮----
public async Task&lt;DiscordAuthorizationInformation&gt; OAuth2GetAuthorizationInfoAsync(DiscordOAuth2Client oauth2Client)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentAuthorizationInformationAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Gets the current user&apos;s application role connection.
⋮----
public async Task&lt;DiscordApplicationRoleConnection&gt; OAuth2GetApplicationRoleConnectionAsync(DiscordOAuth2Client oauth2Client)
=&gt; this.AccessToken is not null ? await oauth2Client.GetCurrentUserApplicationRoleConnectionAsync(this.AccessToken) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Updates the current user&apos;s application role connection.
⋮----
/// &lt;param name=&quot;platformName&quot;&gt;The platform name.&lt;/param&gt;
/// &lt;param name=&quot;platformUsername&quot;&gt;The platform username.&lt;/param&gt;
/// &lt;param name=&quot;metadata&quot;&gt;The metadata.&lt;/param&gt;
⋮----
public async Task&lt;DiscordApplicationRoleConnection&gt; OAuth2UpdateApplicationRoleConnectionAsync(DiscordOAuth2Client oauth2Client, string platformName, string platformUsername, ApplicationRoleConnectionMetadata metadata)
=&gt; this.AccessToken is not null ? await oauth2Client.UpdateCurrentUserApplicationRoleConnectionAsync(this.AccessToken, platformName, platformUsername, metadata) : throw new NullReferenceException(&quot;You need to specify the AccessToken on this DiscordUser entity.&quot;);
⋮----
///     Represents a user comparer.
⋮----
internal sealed class DiscordUserComparer : IEqualityComparer&lt;DiscordUser&gt;
⋮----
///     Whether the users are equal.
⋮----
/// &lt;param name=&quot;x&quot;&gt;The first user&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The second user.&lt;/param&gt;
public bool Equals(DiscordUser x, DiscordUser y)
=&gt; x.Equals(y);
⋮----
///     Gets the hash code.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;The user.&lt;/param&gt;
public int GetHashCode(DiscordUser obj)
=&gt; obj.Id.GetHashCode();</file><file path="DisCatSharp/Net/Abstractions/Rest/RestChannelPayloads.cs">/// &lt;summary&gt;
///     Represents a channel create payload.
/// &lt;/summary&gt;
internal sealed class RestChannelCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the name.
⋮----
///     Gets or sets the type.
⋮----
///     Gets or sets the parent.
⋮----
///     Gets or sets the topic.
⋮----
///     Gets or sets the template.
⋮----
///     Gets or sets the bitrate.
⋮----
///     Gets or sets the user limit.
⋮----
///     Gets or sets the permission overwrites.
⋮----
///     Gets or sets a value indicating whether nsfw.
⋮----
///     Gets or sets the per user rate limit.
⋮----
///     Gets or sets the quality mode.
⋮----
///     Gets or sets the default auto archive duration.
⋮----
///     Gets the default reaction emoji for forum posts.
⋮----
///     Gets the default forum post sort order
⋮----
///     Gets the default forum layout for this channel
⋮----
///     Gets or sets the channel flags.
⋮----
///     Represents a channel modify payload.
⋮----
internal sealed class RestChannelModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the position.
⋮----
///     Gets or sets the rtc region.
⋮----
///     Gets the default tag matching setting for this forum channel.
⋮----
///     Gets or sets the available tags.
⋮----
///     Represents a channel message edit payload.
⋮----
internal class RestChannelMessageEditPayload : ObservableApiObject
⋮----
///     Gets or sets the content.
⋮----
///     Tracks if content was explicitly set (even to null).
///     Used to control conditional serialization of the content field.
⋮----
///     Tracks if embeds were explicitly set (including empty).
///     Used to control conditional serialization of the embeds field.
⋮----
///     Tracks if components were explicitly set (including empty).
///     Used to control conditional serialization of the components field.
⋮----
///     Gets or sets the embeds.
⋮----
///     Gets or sets the mentions.
⋮----
///     Gets or sets the attachments.
⋮----
///     Gets or sets the flags.
⋮----
///     Gets or sets the components.
⋮----
///     Determines whether the content field should be serialized.
⋮----
public bool ShouldSerializeContent() =&gt; this.HasContent;
⋮----
///     Determines whether the embeds field should be serialized.
⋮----
public bool ShouldSerializeEmbeds() =&gt; this.HasEmbeds;
⋮----
///     Determines whether the components field should be serialized.
⋮----
public bool ShouldSerializeComponents() =&gt; this.HasComponents;
⋮----
///     Represents a channel message create payload.
⋮----
internal sealed class RestChannelMessageCreatePayload : RestChannelMessageEditPayload
⋮----
///     Gets or sets a value indicating whether t t is s.
⋮----
///     Gets or sets the stickers ids.
⋮----
///     Gets or sets the message reference.
⋮----
///     Gets or sets the nonce sent with the message.
⋮----
///     Gets or sets whether to enforce the &lt;see cref=&quot;Nonce&quot; /&gt; to be validated.
⋮----
///     Gets or sets the poll request.
⋮----
///     Represents a channel message bulk delete payload.
⋮----
internal sealed class RestChannelMessageBulkDeletePayload : ObservableApiObject
⋮----
///     Gets or sets the messages.
⋮----
///     Represents a channel invite create payload.
⋮----
internal sealed class RestChannelInviteCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the max age.
⋮----
///     Gets or sets the max uses.
⋮----
///     Gets or sets the target type.
⋮----
///     Gets or sets the target application.
⋮----
///     Gets or sets the target user id.
⋮----
///     Gets or sets a value indicating whether temporary.
⋮----
///     Gets or sets a value indicating whether unique.
⋮----
///     Represents a channel permission edit payload.
⋮----
internal sealed class RestChannelPermissionEditPayload : ObservableApiObject
⋮----
///     Gets or sets the allow.
⋮----
///     Gets or sets the deny.
⋮----
///     Represents a channel group dm recipient add payload.
⋮----
internal sealed class RestChannelGroupDmRecipientAddPayload : IOAuth2Payload
⋮----
///     Gets or sets the nickname.
⋮----
///     Gets or sets the access token.
⋮----
///     The acknowledge payload.
⋮----
internal sealed class AcknowledgePayload : ObservableApiObject
⋮----
///     Gets or sets the token.
⋮----
///     Represents a thread channel create payload.
⋮----
internal sealed class RestThreadChannelCreatePayload : ObservableApiObject
⋮----
///     Gets or sets the auto archive duration.
⋮----
///     Gets or sets the rate limit per user.
⋮----
///     Gets or sets the thread type.
⋮----
///     Gets or sets the applied tags.
⋮----
///     Represents a thread channel modify payload.
⋮----
internal sealed class RestThreadChannelModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the archived.
⋮----
///     Gets or sets the locked.
⋮----
///     Gets or sets the thread&apos;s invitable state.
⋮----
///     Represents a voice channel status modify payload.
⋮----
internal sealed class RestVoiceChannelStatusModifyPayload : ObservableApiObject
⋮----
///     Gets or sets the status.</file><file path="DisCatSharp/Entities/Interaction/DiscordInteractionResponseBuilder.cs">/// &lt;summary&gt;
///     Constructs an interaction response.
/// &lt;/summary&gt;
public sealed class DiscordInteractionResponseBuilder : DisCatSharpBuilder
⋮----
///     Constructs a new empty interaction response builder.
⋮----
///     Constructs a new &lt;see cref=&quot;DiscordInteractionResponseBuilder&quot; /&gt; based on an existing
///     &lt;see cref=&quot;DisCatSharpBuilder&quot; /&gt;.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The builder to copy.&lt;/param&gt;
⋮----
///     Gets the choices.
⋮----
///     Whether this interaction response is text-to-speech.
⋮----
///     Whether this interaction response should be ephemeral.
⋮----
///     Gets or sets a value indicating whether the followup message is ephemeral.
⋮----
/// &lt;remarks&gt;
///     An ephemeral message is only visible to the user who triggered the interaction.
/// &lt;/remarks&gt;
⋮----
///     The choices to sent on this interaction response.
///     Mutually exclusive with content, embed, and components.
⋮----
///     Gets the poll for this message.
⋮----
///     &lt;para&gt;
///         Adds a row of components to the builder, up to &lt;c&gt;5&lt;/c&gt; components per row, and up to &lt;c&gt;5&lt;/c&gt; rows per
///         message.
///     &lt;/para&gt;
⋮----
///         If &lt;see cref=&quot;WithV2Components&quot; /&gt; was called, the limit changes to &lt;c&gt;10&lt;/c&gt; top-level components and max
///         &lt;c&gt;30&lt;/c&gt; components in total.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to append. Up to five.&lt;/param&gt;
/// &lt;returns&gt;The current builder to chain calls with.&lt;/returns&gt;
public DiscordInteractionResponseBuilder AddComponents(params DiscordComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
⋮----
///     Appends several rows of components to the message
⋮----
/// &lt;param name=&quot;components&quot;&gt;The rows of components to add, holding up to five each.&lt;/param&gt;
/// &lt;returns&gt;The builder to chain calls with.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;No components were passed.&lt;/exception&gt;
public DiscordInteractionResponseBuilder AddComponents(params DiscordActionRowComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
⋮----
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when passing more than 5 components.&lt;/exception&gt;
public DiscordInteractionResponseBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
⋮----
var ara = components.ToArray();
⋮----
throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
⋮----
this.ComponentsInternal.Add(ar);
⋮----
///     Appends a collection of components to the builder. Each call will append to a new row.
⋮----
public DiscordInteractionResponseBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
⋮----
var cmpArr = components.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
⋮----
throw new ArgumentException(&quot;Cannot add more than 10 components!&quot;);
⋮----
this.ComponentsInternal.AddRange(cmpArr);
⋮----
throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
⋮----
var comp = new DiscordActionRowComponent(cmpArr);
this.ComponentsInternal.Add(comp);
⋮----
///     Adds a poll to this builder.
⋮----
/// &lt;param name=&quot;pollBuilder&quot;&gt;The poll builder to add.&lt;/param&gt;
/// &lt;returns&gt;The current builder to be chained.&lt;/returns&gt;
public DiscordInteractionResponseBuilder WithPoll(DiscordPollBuilder pollBuilder)
⋮----
///     Indicates if the interaction response will be text-to-speech.
⋮----
/// &lt;param name=&quot;tts&quot;&gt;Text-to-speech&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder WithTts(bool tts)
⋮----
///     Sets the interaction response to be ephemeral.
⋮----
public DiscordInteractionResponseBuilder AsEphemeral()
⋮----
///     Sets that this builder should be using UI Kit.
⋮----
public DiscordInteractionResponseBuilder WithV2Components()
⋮----
///     Sets the interaction response to suppress embeds.
⋮----
public DiscordInteractionResponseBuilder SuppressEmbeds()
⋮----
///     Sets the interaction response to be sent as silent message.
⋮----
public DiscordInteractionResponseBuilder AsSilentMessage()
⋮----
///     Sets the followup message to be sent as voice message.
⋮----
internal DiscordInteractionResponseBuilder AsVoiceMessage(bool asVoiceMessage = true)
⋮----
///     Sets the content of the message to send.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Content to send.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder WithContent(string content)
⋮----
///     Adds an embed to sent with the interaction response.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddEmbed(DiscordEmbed embed)
⋮----
ArgumentNullException.ThrowIfNull(embed, nameof(embed));
⋮----
this.EmbedsInternal.Add(embed);
⋮----
///     Adds the given embeds to sent with the interaction response.
⋮----
/// &lt;param name=&quot;embeds&quot;&gt;Embeds to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
⋮----
this.EmbedsInternal.AddRange(embeds);
⋮----
///     Adds a file to the interaction response.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;Name of the file.&lt;/param&gt;
/// &lt;param name=&quot;data&quot;&gt;File data.&lt;/param&gt;
/// &lt;param name=&quot;resetStreamPosition&quot;&gt;
///     Tells the API Client to reset the stream position to what it was after the file is
///     sent.
/// &lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the file.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string? description = null)
⋮----
throw new ArgumentException(&quot;Cannot sent more than 10 files with a single message.&quot;);
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
throw new ArgumentException(&quot;A File with that filename already exists&quot;);
⋮----
this.FilesInternal.Add(new(filename, data, data.Position, description: description));
⋮----
this.FilesInternal.Add(new(filename, data, null, description: description));
⋮----
///     Sets if the message has files to be sent.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The Stream to the file.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string? description = null)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
⋮----
this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
⋮----
this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
⋮----
///     Adds the given files to the interaction response builder.
⋮----
/// &lt;param name=&quot;files&quot;&gt;Dictionary of file name and file data.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, null));
⋮----
///     Adds the mention to the mentions to parse, etc. with the interaction response.
⋮----
/// &lt;param name=&quot;mention&quot;&gt;Mention to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder WithAllowedMention(IMention mention)
⋮----
this.MentionsInternal.Add(mention);
⋮----
///     Adds the mentions to the mentions to parse, etc. with the interaction response.
⋮----
/// &lt;param name=&quot;mentions&quot;&gt;Mentions to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
⋮----
this.MentionsInternal.AddRange(mentions);
⋮----
///     Adds a single auto-complete choice to the builder.
⋮----
/// &lt;param name=&quot;choice&quot;&gt;The choice to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddAutoCompleteChoice(DiscordApplicationCommandAutocompleteChoice choice)
⋮----
this.ChoicesInternal.Add(choice);
⋮----
///     Adds auto-complete choices to the builder.
⋮----
/// &lt;param name=&quot;choices&quot;&gt;The choices to add.&lt;/param&gt;
⋮----
public DiscordInteractionResponseBuilder AddAutoCompleteChoices(IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt; choices)
⋮----
this.ChoicesInternal.AddRange(choices);
⋮----
public DiscordInteractionResponseBuilder AddAutoCompleteChoices(params DiscordApplicationCommandAutocompleteChoice[] choices)
=&gt; this.AddAutoCompleteChoices((IEnumerable&lt;DiscordApplicationCommandAutocompleteChoice&gt;)choices);
⋮----
/// &lt;inheritdoc cref=&quot;DisCatSharpBuilder.ClearComponents&quot;/&gt;
public new DiscordInteractionResponseBuilder ClearComponents()
⋮----
base.ClearComponents();
⋮----
/// &lt;inheritdoc /&gt;
public override void Clear()
⋮----
base.Clear();
⋮----
internal override void DoReplace()
⋮----
base.DoReplace();
⋮----
internal override void DoConditionalReplace()
⋮----
base.DoConditionalReplace();</file><file path="DisCatSharp/Entities/Message/DiscordMessageBuilder.cs">/// &lt;summary&gt;
///     Constructs a message to be sent.
/// &lt;/summary&gt;
public sealed class DiscordMessageBuilder : DisCatSharpBuilder
⋮----
///     Whether to keep previous attachments.
⋮----
///     Gets the Sticker to be sent.
⋮----
///     Gets or Sets if the message should be TTS.
⋮----
///     Gets or Ssts if the message should be sent silent.
⋮----
///     Gets the Reply Message ID.
⋮----
///     Gets if the Reply should mention the user.
⋮----
///     Gets if the Reply will error if the Reply Message ID does not reference a valid message.
///     &lt;para&gt;If set to false, invalid replies are send as a regular message.&lt;/para&gt;
///     &lt;para&gt;Defaults to false.&lt;/para&gt;
⋮----
///     Gets the nonce for the message.
⋮----
///     Gets whether to enforce the nonce.
⋮----
///     Gets the poll for this message.
⋮----
///     Sets the nonce for the message.
⋮----
/// &lt;param name=&quot;nonce&quot;&gt;The nonce for the message. Max 25 chars.&lt;/param&gt;
/// &lt;returns&gt;The current builder to be chained.&lt;/returns&gt;
public DiscordMessageBuilder WithNonce(string nonce)
⋮----
///     Whether to enforce the nonce.
⋮----
/// &lt;param name=&quot;enforceNonce&quot;&gt;Controls the nonce enforcement.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithEnforceNonce(bool enforceNonce)
⋮----
///     Sets the Content of the Message.
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content to be set.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithContent(string content)
⋮----
///     Adds a sticker to the message. Sticker must be from current guild.
⋮----
/// &lt;param name=&quot;sticker&quot;&gt;The sticker to add.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithSticker(DiscordSticker sticker)
⋮----
throw new ArgumentException(&quot;Cannot send more than 4 stickers in a message&quot;);
⋮----
this.StickerIds.Add(sticker.Id);
⋮----
///     Adds stickers to the message. Sticker must be from current guild.
⋮----
/// &lt;param name=&quot;stickerIds&quot;&gt;The sticker to add.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithStickerIds(params ulong[] stickerIds)
⋮----
this.StickerIds.AddRange(stickerIds);
⋮----
public DiscordMessageBuilder WithStickerIds(IEnumerable&lt;ulong&gt; stickerIds)
⋮----
if (this.StickerIds.Count &gt;= 4 || stickerIds.Count() &gt; 4 || (this.StickerIds.Count + stickerIds.Count() &gt; 4))
⋮----
///     Adds a poll to the message.
⋮----
/// &lt;param name=&quot;pollBuilder&quot;&gt;The poll builder to add.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithPoll(DiscordPollBuilder pollBuilder)
⋮----
///     &lt;para&gt;Adds components to the message. &lt;/para&gt;
///     &lt;para&gt;If &lt;see cref=&quot;WithV2Components&quot; /&gt; was called, the limit changes to max &lt;c&gt;40&lt;/c&gt; components in total.&lt;/para&gt;
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to add to the message.&lt;/param&gt;
⋮----
public DiscordMessageBuilder AddComponents(params DiscordComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
⋮----
///     Appends several rows of components to the message
⋮----
/// &lt;param name=&quot;components&quot;&gt;The rows of components to add, holding up to five each.&lt;/param&gt;
/// &lt;returns&gt;The builder to chain calls with.&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;No components were passed.&lt;/exception&gt;
public DiscordMessageBuilder AddComponents(params DiscordActionRowComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
⋮----
public DiscordMessageBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
⋮----
var ara = components.ToArray();
⋮----
throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
⋮----
this.ComponentsInternal.Add(ar);
⋮----
public DiscordMessageBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
⋮----
var cmpArr = components.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
⋮----
throw new ArgumentException(&quot;Cannot add more than 40 components!&quot;);
⋮----
this.ComponentsInternal.AddRange(cmpArr);
⋮----
throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
⋮----
var comp = new DiscordActionRowComponent(cmpArr);
this.ComponentsInternal.Add(comp);
⋮----
///     Sets if the message should be TTS.
⋮----
/// &lt;param name=&quot;isTts&quot;&gt;If TTS should be set.&lt;/param&gt;
⋮----
public DiscordMessageBuilder HasTts(bool isTts)
⋮----
///     Sets the message response to suppress embeds.
/// 	This also clears the embeds of the message.
⋮----
public DiscordMessageBuilder SuppressEmbeds()
⋮----
///     Sets that this builder should be using UI Kit.
⋮----
/// &lt;returns&gt;The current builder to chain calls with.&lt;/returns&gt;
public DiscordMessageBuilder WithV2Components()
⋮----
///     Sets the message to be sent as voice message.
⋮----
public DiscordMessageBuilder AsVoiceMessage()
⋮----
///     Sets the followup message to be sent as silent message.
⋮----
public DiscordMessageBuilder AsSilentMessage()
⋮----
///     Appends an embed to the current builder.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;The embed that should be appended.&lt;/param&gt;
⋮----
public DiscordMessageBuilder AddEmbed(DiscordEmbed embed)
⋮----
ArgumentNullException.ThrowIfNull(embed, nameof(embed));
⋮----
this.EmbedsInternal.Add(embed);
⋮----
///     Appends several embeds to the current builder.
⋮----
/// &lt;param name=&quot;embeds&quot;&gt;The embeds that should be appended.&lt;/param&gt;
⋮----
public DiscordMessageBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
⋮----
this.EmbedsInternal.AddRange(embeds);
⋮----
///     Sets if the message has allowed mentions.
⋮----
/// &lt;param name=&quot;mention&quot;&gt;The allowed Mention that should be sent.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithAllowedMention(IMention mention)
⋮----
this.MentionsInternal.Add(mention);
⋮----
/// &lt;param name=&quot;mentions&quot;&gt;The allowed Mentions that should be sent.&lt;/param&gt;
⋮----
public DiscordMessageBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
⋮----
this.MentionsInternal.AddRange(mentions);
⋮----
///     Adds a file to the message.
⋮----
/// &lt;param name=&quot;fileName&quot;&gt;The fileName that the file should be sent as.&lt;/param&gt;
/// &lt;param name=&quot;stream&quot;&gt;The Stream to the file.&lt;/param&gt;
/// &lt;param name=&quot;resetStreamPosition&quot;&gt;
///     Tells the API Client to reset the stream position to what it was after the file is
///     sent.
/// &lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the file.&lt;/param&gt;
⋮----
public DiscordMessageBuilder AddFile(string fileName, Stream stream, bool resetStreamPosition = false, string? description = null)
⋮----
throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == fileName))
throw new ArgumentException(&quot;A File with that filename already exists&quot;);
⋮----
this.FilesInternal.Add(new(fileName, stream, stream.Position, description: description));
⋮----
this.FilesInternal.Add(new(fileName, stream, null, description: description));
⋮----
public DiscordMessageBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string? description = null)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
⋮----
this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
⋮----
this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
⋮----
///     Adds file to the message.
⋮----
/// &lt;param name=&quot;files&quot;&gt;The Files that should be sent.&lt;/param&gt;
⋮----
public DiscordMessageBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, null));
⋮----
///     Modifies the given attachments on edit.
⋮----
/// &lt;param name=&quot;attachments&quot;&gt;Attachments to edit.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public DiscordMessageBuilder ModifyAttachments(IEnumerable&lt;DiscordAttachment&gt; attachments)
⋮----
this.AttachmentsInternal.AddRange(attachments);
⋮----
///     Whether to keep the message attachments, if new ones are added.
⋮----
public DiscordMessageBuilder KeepAttachments(bool keep)
⋮----
///     Sets if the message is a reply
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The ID of the message to reply to.&lt;/param&gt;
/// &lt;param name=&quot;mention&quot;&gt;If we should mention the user in the reply.&lt;/param&gt;
/// &lt;param name=&quot;failOnInvalidReply&quot;&gt;Whether sending a reply that references an invalid message should be &lt;/param&gt;
⋮----
public DiscordMessageBuilder WithReply(ulong messageId, bool mention = false, bool failOnInvalidReply = false)
⋮----
this.MentionsInternal.Add(new RepliedUserMention());
⋮----
///     Sends the Message to a specific channel
⋮----
/// &lt;param name=&quot;channel&quot;&gt;The channel the message should be sent to.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; SendAsync(DiscordChannel channel)
=&gt; channel.SendMessageAsync(this);
⋮----
///     Sends the modified message.
///     &lt;para&gt;
///         Note: Message replies cannot be modified. To clear the reply, simply pass &lt;see langword=&quot;null&quot; /&gt; to
///         &lt;see cref=&quot;WithReply&quot; /&gt;.
///     &lt;/para&gt;
⋮----
/// &lt;param name=&quot;msg&quot;&gt;The original Message to modify.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(DiscordMessage msg)
=&gt; msg.ModifyAsync(this);
⋮----
/// &lt;inheritdoc cref=&quot;DisCatSharpBuilder.ClearComponents&quot;/&gt;
public new DiscordMessageBuilder ClearComponents()
⋮----
base.ClearComponents();
⋮----
/// &lt;inheritdoc /&gt;
public override void Clear()
⋮----
base.Clear();
⋮----
internal override void DoReplace()
⋮----
base.DoReplace();
⋮----
internal override void DoConditionalReplace()
⋮----
base.DoConditionalReplace();
⋮----
///     Does the validation before we send the Create/Modify request.
⋮----
/// &lt;param name=&quot;isModify&quot;&gt;Tells the method to perform the Modify Validation or Create Validation.&lt;/param&gt;
internal void Validate(bool isModify = false)
⋮----
throw new ArgumentException(&quot;A message can only have up to 10 embeds.&quot;);
⋮----
if (this.Files?.Count == 0 &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; (!this.Embeds?.Any() ?? true) &amp;&amp; (!this.StickerIds?.Any() ?? true) &amp;&amp; (!this.Components?.Any() ?? true) &amp;&amp; this.Poll is null &amp;&amp; this?.Attachments.Count is 0)
throw new ArgumentException(&quot;You must specify content, an embed, a sticker, a component, a poll or at least one file.&quot;);
⋮----
if (this.IsComponentsV2 &amp;&amp; (!string.IsNullOrEmpty(this.Content) || (this.Embeds?.Any() ?? false)))
throw new ArgumentException(&quot;Using UI Kit mode. You cannot specify content or embeds.&quot;);
⋮----
throw new InvalidOperationException(&quot;You can only have 10 components per message.&quot;);
⋮----
throw new InvalidOperationException(&quot;You can only have 5 action rows per message.&quot;);
⋮----
if (this.EnforceNonce &amp;&amp; string.IsNullOrEmpty(this.Nonce))
throw new InvalidOperationException(&quot;Nonce enforcement is enabled, but no nonce is set.&quot;);
⋮----
throw new InvalidOperationException(&quot;Messages with polls can&apos;t be edited.&quot;);
⋮----
base.Validate();</file><file path="DisCatSharp/Entities/Webhook/DiscordWebhookBuilder.cs">/// &lt;summary&gt;
///     Constructs ready-to-send webhook requests.
/// &lt;/summary&gt;
public sealed class DiscordWebhookBuilder : DisCatSharpBuilder
⋮----
///     Gets the applied tags.
⋮----
///     Whether to keep previous attachments.
⋮----
///     Constructs a new empty webhook request builder.
⋮----
///     Username to use for this webhook request.
⋮----
///     Avatar url to use for this webhook request.
⋮----
///     Whether this webhook request is text-to-speech.
⋮----
///     Name of the new thread.
///     Only works if the webhook is sent in a &lt;see cref=&quot;ChannelType.Forum&quot; /&gt;.
⋮----
///     Forum post tags to send on this webhook request.
⋮----
///     Gets the poll for this message.
⋮----
///     Whether to send components with this webhook requests.
///     Set to &lt;see langword=&quot;true&quot; /&gt; if you want to send components with non-application-owned webhooks.
⋮----
///     Sets the webhook response to suppress embeds.
⋮----
public DiscordWebhookBuilder SuppressEmbeds()
⋮----
///     Sets the webhook to be sent as silent message.
⋮----
public DiscordWebhookBuilder AsSilentMessage()
⋮----
///     Sets if you want to send components with non-application-owned webhooks.
⋮----
public DiscordWebhookBuilder SendWithComponents()
⋮----
///     Sets the webhook to be sent as voice message.
⋮----
public DiscordWebhookBuilder AsVoiceMessage()
⋮----
///     &lt;para&gt;
///         Adds a row of components to the builder, up to &lt;c&gt;5&lt;/c&gt; components per row, and up to &lt;c&gt;5&lt;/c&gt; rows per
///         message.
///     &lt;/para&gt;
⋮----
///         If &lt;see cref=&quot;WithV2Components&quot; /&gt; was called, the limit changes to &lt;c&gt;10&lt;/c&gt; top-level components and max
///         &lt;c&gt;30&lt;/c&gt; components in total.
⋮----
/// &lt;param name=&quot;components&quot;&gt;The components to add to the builder.&lt;/param&gt;
/// &lt;returns&gt;The current builder to be chained.&lt;/returns&gt;
public DiscordWebhookBuilder AddComponents(params DiscordComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordComponent&gt;)components);
⋮----
///     Appends several rows of components to the message
⋮----
/// &lt;param name=&quot;components&quot;&gt;The rows of components to add, holding up to five each.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;No components were passed.&lt;/exception&gt;
public DiscordWebhookBuilder AddComponents(params DiscordActionRowComponent[] components)
=&gt; this.AddComponents((IEnumerable&lt;DiscordActionRowComponent&gt;)components);
⋮----
///     Appends several rows of components to the builder
⋮----
/// &lt;returns&gt;The builder to chain calls with.&lt;/returns&gt;
public DiscordWebhookBuilder AddComponents(IEnumerable&lt;DiscordActionRowComponent&gt; components)
⋮----
var ara = components.ToArray();
⋮----
throw new ArgumentException(&quot;ActionRow count exceeds maximum of five.&quot;);
⋮----
this.ComponentsInternal.Add(ar);
⋮----
///     Adds a row of components to the builder, up to 5 components per row, and up to 5 rows per message.
⋮----
public DiscordWebhookBuilder AddComponents(IEnumerable&lt;DiscordComponent&gt; components)
⋮----
var cmpArr = components.ToArray();
⋮----
throw new ArgumentOutOfRangeException(nameof(components), &quot;You must provide at least one component&quot;);
⋮----
throw new ArgumentException(&quot;Cannot add more than 40 components!&quot;);
⋮----
this.ComponentsInternal.AddRange(cmpArr);
⋮----
throw new ArgumentException(&quot;Cannot add more than 5 components per action row!&quot;);
⋮----
var comp = new DiscordActionRowComponent(cmpArr);
this.ComponentsInternal.Add(comp);
⋮----
///     Sets that this builder should be using UI Kit.
⋮----
/// &lt;returns&gt;The current builder to chain calls with.&lt;/returns&gt;
public DiscordWebhookBuilder WithV2Components()
⋮----
///     Adds a poll to this webhook builder.
⋮----
/// &lt;param name=&quot;pollBuilder&quot;&gt;The poll builder to add.&lt;/param&gt;
⋮----
public DiscordWebhookBuilder WithPoll(DiscordPollBuilder pollBuilder)
⋮----
///     Sets the username for this webhook builder.
⋮----
/// &lt;param name=&quot;username&quot;&gt;Username of the webhook&lt;/param&gt;
public DiscordWebhookBuilder WithUsername(string username)
⋮----
///     Sets the avatar of this webhook builder from its url.
⋮----
/// &lt;param name=&quot;avatarUrl&quot;&gt;Avatar url of the webhook&lt;/param&gt;
public DiscordWebhookBuilder WithAvatarUrl(string avatarUrl)
⋮----
///     Indicates if the webhook must use text-to-speech.
⋮----
/// &lt;param name=&quot;tts&quot;&gt;Text-to-speech&lt;/param&gt;
public DiscordWebhookBuilder WithTts(bool tts)
⋮----
///     Sets the message to send at the execution of the webhook.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Message to send.&lt;/param&gt;
public DiscordWebhookBuilder WithContent(string content)
⋮----
///     Sets the thread name to create at the execution of the webhook.
///     Only works for &lt;see cref=&quot;ChannelType.Forum&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The thread name.&lt;/param&gt;
public DiscordWebhookBuilder WithThreadName(string name)
⋮----
///     Adds an embed to send at the execution of the webhook.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to add.&lt;/param&gt;
public DiscordWebhookBuilder AddEmbed(DiscordEmbed embed)
⋮----
ArgumentNullException.ThrowIfNull(embed, nameof(embed));
⋮----
this.EmbedsInternal.Add(embed);
⋮----
///     Adds the given embeds to send at the execution of the webhook.
⋮----
/// &lt;param name=&quot;embeds&quot;&gt;Embeds to add.&lt;/param&gt;
public DiscordWebhookBuilder AddEmbeds(IEnumerable&lt;DiscordEmbed&gt; embeds)
⋮----
this.EmbedsInternal.AddRange(embeds);
⋮----
///     Adds a file to send at the execution of the webhook.
⋮----
/// &lt;param name=&quot;filename&quot;&gt;Name of the file.&lt;/param&gt;
/// &lt;param name=&quot;data&quot;&gt;File data.&lt;/param&gt;
/// &lt;param name=&quot;resetStreamPosition&quot;&gt;
///     Tells the API Client to reset the stream position to what it was after the file is
///     sent.
/// &lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;Description of the file.&lt;/param&gt;
public DiscordWebhookBuilder AddFile(string filename, Stream data, bool resetStreamPosition = false, string description = null)
⋮----
throw new ArgumentException(&quot;Cannot send more than 10 files with a single message.&quot;);
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == filename))
throw new ArgumentException(&quot;A File with that filename already exists&quot;);
⋮----
this.FilesInternal.Add(new(filename, data, data.Position, description: description));
⋮----
this.FilesInternal.Add(new(filename, data, null, description: description));
⋮----
///     Sets if the message has files to be sent.
⋮----
/// &lt;param name=&quot;stream&quot;&gt;The Stream to the file.&lt;/param&gt;
⋮----
public DiscordWebhookBuilder AddFile(FileStream stream, bool resetStreamPosition = false, string description = null)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == stream.Name))
⋮----
this.FilesInternal.Add(new(stream.Name, stream, stream.Position, description: description));
⋮----
this.FilesInternal.Add(new(stream.Name, stream, null, description: description));
⋮----
///     Adds the given files to send at the execution of the webhook.
⋮----
/// &lt;param name=&quot;files&quot;&gt;Dictionary of file name and file data.&lt;/param&gt;
⋮----
public DiscordWebhookBuilder AddFiles(Dictionary&lt;string, Stream&gt; files, bool resetStreamPosition = false)
⋮----
if (this.FilesInternal.Any(x =&gt; x.Filename == file.Key))
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, file.Value.Position));
⋮----
this.FilesInternal.Add(new(file.Key, file.Value, null));
⋮----
///     Modifies the given attachments on edit.
⋮----
/// &lt;param name=&quot;attachments&quot;&gt;Attachments to edit.&lt;/param&gt;
⋮----
public DiscordWebhookBuilder ModifyAttachments(IEnumerable&lt;DiscordAttachment&gt; attachments)
⋮----
this.AttachmentsInternal.AddRange(attachments);
⋮----
///     Whether to keep the message attachments, if new ones are added.
⋮----
public DiscordWebhookBuilder KeepAttachments(bool keep)
⋮----
///     Adds the mention to the mentions to parse, etc. at the execution of the webhook.
⋮----
/// &lt;param name=&quot;mention&quot;&gt;Mention to add.&lt;/param&gt;
public DiscordWebhookBuilder WithAllowedMention(IMention mention)
⋮----
this.MentionsInternal.Add(mention);
⋮----
///     Adds the mentions to the mentions to parse, etc. at the execution of the webhook.
⋮----
/// &lt;param name=&quot;mentions&quot;&gt;Mentions to add.&lt;/param&gt;
public DiscordWebhookBuilder WithAllowedMentions(IEnumerable&lt;IMention&gt; mentions)
⋮----
this.MentionsInternal.AddRange(mentions);
⋮----
///     Tags to apply to forum posts.
⋮----
/// &lt;param name=&quot;tags&quot;&gt;Tags to add.&lt;/param&gt;
public DiscordWebhookBuilder WithAppliedTags(IEnumerable&lt;ulong&gt; tags)
⋮----
this._appliedTags.AddRange(tags);
⋮----
///     Executes a webhook.
⋮----
/// &lt;param name=&quot;webhook&quot;&gt;The webhook that should be executed.&lt;/param&gt;
/// &lt;param name=&quot;threadId&quot;&gt;The target thread id.&lt;/param&gt;
/// &lt;returns&gt;The message sent&lt;/returns&gt;
public async Task&lt;DiscordMessage&gt; SendAsync(DiscordWebhook webhook, ulong? threadId = null)
=&gt; await webhook.ExecuteAsync(this, threadId).ConfigureAwait(false);
⋮----
///     Sends the modified webhook message.
⋮----
/// &lt;param name=&quot;message&quot;&gt;The message to modify.&lt;/param&gt;
/// &lt;param name=&quot;thread&quot;&gt;The target thread.&lt;/param&gt;
/// &lt;returns&gt;The modified message&lt;/returns&gt;
public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, DiscordMessage message, DiscordThreadChannel? thread = null)
=&gt; await this.ModifyAsync(webhook, message.Id, thread?.Id).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The id of the message to modify.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordWebhook webhook, ulong messageId, ulong? threadId = null)
=&gt; await webhook.EditMessageAsync(messageId, this, threadId).ConfigureAwait(false);
⋮----
/// &lt;inheritdoc cref=&quot;DisCatSharpBuilder.ClearComponents&quot;/&gt;
public new DiscordWebhookBuilder ClearComponents()
⋮----
base.ClearComponents();
⋮----
/// &lt;inheritdoc /&gt;
public override void Clear()
⋮----
base.Clear();
⋮----
internal override void DoReplace()
⋮----
base.DoReplace();
⋮----
internal override void DoConditionalReplace()
⋮----
base.DoConditionalReplace();
⋮----
///     Does the validation before we send the Create/Modify request.
⋮----
/// &lt;param name=&quot;isModify&quot;&gt;Tells the method to perform the Modify Validation or Create Validation.&lt;/param&gt;
/// &lt;param name=&quot;isFollowup&quot;&gt;Tells the method to perform the follow-up message validation.&lt;/param&gt;
/// &lt;param name=&quot;isInteractionResponse&quot;&gt;Tells the method to perform the interaction response validation.&lt;/param&gt;
internal void Validate(bool isModify = false, bool isFollowup = false, bool isInteractionResponse = false)
⋮----
throw new ArgumentException(&quot;You cannot change the username of a message.&quot;);
⋮----
throw new ArgumentException(&quot;You cannot change the avatar of a message.&quot;);
⋮----
throw new InvalidOperationException(&quot;You cannnot edit a poll.&quot;);
⋮----
throw new ArgumentException(&quot;You cannot change the username of a follow up message.&quot;);
⋮----
throw new ArgumentException(&quot;You cannot change the avatar of a follow up message.&quot;);
⋮----
throw new ArgumentException(&quot;You cannot change the username of an interaction response.&quot;);
⋮----
throw new ArgumentException(&quot;You cannot change the avatar of an interaction response.&quot;);
⋮----
if (this.Files?.Count is 0 or null &amp;&amp; string.IsNullOrEmpty(this.Content) &amp;&amp; this.Embeds?.Count is 0 or null &amp;&amp; this.Components?.Count is 0 or null &amp;&amp; this.Poll is null &amp;&amp; this.Attachments?.Count is 0 or null)
throw new ArgumentException(&quot;You must specify content, an embed, a component, a poll, or at least one file.&quot;);
⋮----
base.Validate();</file><file path="DisCatSharp/Entities/Message/DiscordMessage.cs">/// &lt;summary&gt;
///     Represents a Discord text message.
/// &lt;/summary&gt;
public class DiscordMessage : SnowflakeObject, IEquatable&lt;DiscordMessage&gt;
⋮----
private readonly DiscordThreadChannel _startedThread;
⋮----
private DiscordChannel _channel;
⋮----
private DiscordThreadChannel _thread;
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordMessage&quot; /&gt; class.
⋮----
? this.GuildId.Value.ToString(CultureInfo.InvariantCulture)
⋮----
var cid = this.ChannelId.ToString(CultureInfo.InvariantCulture);
var mid = this.Id.ToString(CultureInfo.InvariantCulture);
⋮----
_ =&gt; throw new ArgumentException(&quot;Invalid api channel&quot;)
⋮----
/// &lt;param name=&quot;other&quot;&gt;The other message.&lt;/param&gt;
⋮----
this.AttachmentsInternal = other.AttachmentsInternal; // the attachments cannot change, thus no need to copy and reallocate.
⋮----
///     Gets the channel in which the message was sent.
⋮----
///     Gets the type of the &lt;see cref=&quot;Channel&quot; /&gt; this message was send in.
⋮----
///     Gets the thread in which the message was sent.
⋮----
///     Gets the ID of the channel in which the message was sent.
⋮----
///     Currently unknown.
⋮----
///     Gets the components this message was sent with.
⋮----
///     Gets the user or member that sent the message.
⋮----
///     Gets the message&apos;s content.
⋮----
///     Gets the message&apos;s creation timestamp.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.TimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.TimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : this.CreationTimestamp;
⋮----
///     Gets the message&apos;s creation timestamp as raw string.
⋮----
///     Gets the message&apos;s edit timestamp. Will be null if the message was not edited.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw) &amp;&amp; DateTimeOffset.TryParse(this.EditedTimestampRaw, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dto) ? dto : null;
⋮----
///     Gets the message&apos;s edit timestamp as raw string. Will be null if the message was not edited.
⋮----
///     Gets whether this message was edited.
⋮----
=&gt; !string.IsNullOrWhiteSpace(this.EditedTimestampRaw);
⋮----
///     Gets whether the message is a text-to-speech message.
⋮----
///     Gets whether the message mentions everyone.
⋮----
///     Gets users or members mentioned by this message.
⋮----
// TODO: this will probably throw an exception in DMs since it tries to wrap around a null List...
// this is probably low priority but need to find out a clean way to solve it...
⋮----
///     Gets roles mentioned by this message.
⋮----
///     Gets channels mentioned by this message.
⋮----
///     Gets files attached to this message.
⋮----
///     Gets embeds attached to this message.
⋮----
///     Gets reactions used on this message.
⋮----
///     Gets the nonce sent with the message, if the message was sent by the client.
⋮----
///     Gets whether the &lt;see cref=&quot;Nonce&quot; /&gt; is enforced to be validated.
⋮----
///     Gets whether the message is pinned.
⋮----
///     Gets the id of the webhook that generated this message.
⋮----
///     Gets the type of the message.
⋮----
///     Gets the message activity in the Rich Presence embed.
⋮----
///     Gets the message application in the Rich Presence embed.
⋮----
///     Gets the message application id in the Rich Presence embed.
⋮----
///     Gets the internal reference.
⋮----
///     Gets the message reference.
⋮----
///     Gets the message snapshots.
⋮----
///     Gets whether this message has a message reference (reply, announcement, etc.).
⋮----
///     Gets whether this message has forwarded messages.
⋮----
///     Gets the bitwise flags for this message.
⋮----
///     Gets whether the message originated from a webhook.
⋮----
///     Gets the jump link to this message.
⋮----
///     Gets stickers for this message.
⋮----
///     Gets the guild id.
⋮----
///     Gets the guild to which this channel belongs.
⋮----
=&gt; this.GuildId.HasValue &amp;&amp; this.Discord.Guilds.TryGetValue(this.GuildId.Value, out var guild) ? guild : null;
⋮----
///     Gets the message object for the referenced message
⋮----
///     Gets whether the message is a response to an interaction.
⋮----
///     &lt;para&gt;Gets the thread that was started from this message.&lt;/para&gt;
///     &lt;para&gt;
///         &lt;note type=&quot;warning&quot;&gt;
///             If you&apos;re looking to get the actual thread channel this message was send in, call
///             &lt;see cref=&quot;Channel&quot; /&gt; and convert it to a &lt;see cref=&quot;DiscordThreadChannel&quot; /&gt;.
///         &lt;/note&gt;
///     &lt;/para&gt;
⋮----
: this.GuildId.HasValue &amp;&amp; this.Guild.ThreadsInternal.TryGetValue(this.Id, out var thread)
⋮----
///     Gets the Discord snowflake objects resolved from this message&apos;s auto-populated select menus.
⋮----
///     Gets the interaction metadata if the message is a response to an interaction.
⋮----
///     Gets the poll of the message if one was attached.
⋮----
///     Gets whether this message has a poll.
⋮----
///     Gets the soundboard sounds send with this message, if applicable.
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordMessage&quot; /&gt; is equal to another &lt;see cref=&quot;DiscordMessage&quot; /&gt;.
⋮----
/// &lt;param name=&quot;e&quot;&gt;&lt;see cref=&quot;DiscordMessage&quot; /&gt; to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the &lt;see cref=&quot;DiscordMessage&quot; /&gt; is equal to this &lt;see cref=&quot;DiscordMessage&quot; /&gt;.&lt;/returns&gt;
public bool Equals(DiscordMessage e)
⋮----
///     &lt;para&gt;Ends the poll on this message.&lt;/para&gt;
///     &lt;para&gt;Works only for own polls and if they are not expired yet. &lt;/para&gt;
⋮----
/// &lt;returns&gt;The fresh discord message.&lt;/returns&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
///     Thrown when the message has no poll, the author is not us, or the poll has
///     been already ended.
/// &lt;/exception&gt;
public async Task&lt;DiscordMessage&gt; EndPollAsync()
⋮----
? throw new InvalidOperationException(&quot;This message has no poll.&quot;)
⋮----
? throw new InvalidOperationException(&quot;Can only end own polls.&quot;)
⋮----
? throw new InvalidOperationException(&quot;The poll was already ended.&quot;)
: await this.Discord.ApiClient.EndPollAsync(this.ChannelId, this.Id);
⋮----
///     Forwards this message to another channel.
⋮----
/// &lt;param name=&quot;targetChannel&quot;&gt;The channel to forward this message to.&lt;/param&gt;
/// &lt;param name=&quot;content&quot;&gt;Content is not available at the moment, but already added for the future.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;
///     Thrown when the bot tries forwarding a message it doesn&apos;t has access to or the
///     client tried to modify a message not sent by them.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the target channel does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
public async Task&lt;DiscordMessage&gt; ForwardMessageAsync(DiscordChannel targetChannel, string? content = null)
=&gt; await this.Discord.ApiClient.ForwardMessageAsync(this, targetChannel.Id, content);
⋮----
///     Build the message reference.
⋮----
internal DiscordMessageReference InternalBuildMessageReference()
⋮----
ArgumentNullException.ThrowIfNull(this.InternalReference);
⋮----
var reference = new DiscordMessageReference
⋮----
reference.Guild = client.GuildsInternal.TryGetValue(guildId.Value, out var g)
⋮----
var channel = client.InternalGetCachedChannel(channelId.Value);
⋮----
if (client.MessageCache != null &amp;&amp; client.MessageCache.TryGet(m =&gt; m.Id == messageId.Value &amp;&amp; m.ChannelId == channelId, out var msg))
⋮----
///     Gets the mentions.
⋮----
/// &lt;returns&gt;An array of IMentions.&lt;/returns&gt;
internal List&lt;IMention&gt; GetMentions()
⋮----
if (this.ReferencedMessage is not null &amp;&amp; this.MentionedUsersInternal.Count is not 0 &amp;&amp; this.MentionedUsersInternal.Contains(this.ReferencedMessage.Author))
mentions.Add(new RepliedUserMention());
⋮----
mentions.AddRange(this.MentionedUsersInternal.Select(m =&gt; (IMention)new UserMention(m)));
⋮----
mentions.AddRange(this.MentionedRoleIds.Select(r =&gt; (IMention)new RoleMention(r)));
⋮----
///     Populates the mentions.
⋮----
internal void PopulateMentions()
⋮----
var mentionedUsers = new HashSet&lt;DiscordUser&gt;(new DiscordUserComparer());
⋮----
this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
⋮----
mentionedUsers.Add(guild is not null &amp;&amp; guild.MembersInternal.TryGetValue(usr.Id, out var member) ? member : usr);
⋮----
if (!string.IsNullOrWhiteSpace(this.Content))
⋮----
this.MentionedRolesInternal = [.. this.MentionedRolesInternal.Union(this.MentionedRoleIds.Select(guild.GetRole))!];
this.MentionedChannelsInternal = [.. this.MentionedChannelsInternal.Union(Utilities.GetChannelMentions(this.Content).Select(guild.GetChannel))!];
⋮----
///     Edits the message.
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The builder of the message to edit.&lt;/param&gt;
/// &lt;param name=&quot;modifyMode&quot;&gt;The mode of modification.&lt;/param&gt;
/// &lt;exception cref=&quot;UnauthorizedException&quot;&gt;Thrown when the client tried to modify a message not sent by them.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the member does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordMessage&gt; ModifyAsync(DiscordMessageBuilder builder, ModifyMode modifyMode = ModifyMode.Update)
⋮----
builder.DoConditionalReplace();
builder.MentionsInternal ??= this.GetMentions();
if (builder.KeepAttachmentsInternal.GetValueOrDefault())
builder.ModifyAttachments(this.Attachments);
return await this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, builder).ConfigureAwait(false);
⋮----
/// &lt;param name=&quot;action&quot;&gt;The builder of the message to edit.&lt;/param&gt;
⋮----
public async Task&lt;DiscordMessage&gt; ModifyAsync(Action&lt;DiscordMessageBuilder&gt; action, ModifyMode modifyMode = ModifyMode.Update)
⋮----
var builder = new DiscordMessageBuilder();
⋮----
builder.DoReplace();
⋮----
return await this.Discord.ApiClient.EditMessageAsync(this.ChannelId, this.Id, builder, builder.KeepAttachmentsInternal.GetValueOrDefault() ? this.Attachments : null).ConfigureAwait(false);
⋮----
///		Modifies the message by removing components.
⋮----
public Task&lt;DiscordMessage&gt; RemoveComponentsAsync()
=&gt; this.ModifyAsync(x =&gt; x.ClearComponents());
⋮----
///		Modifies the message by editing the content.
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content to edit.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(string content)
=&gt; this.ModifyAsync(x =&gt; x.WithContent(content));
⋮----
///		Modifies the message by adding an embed.
⋮----
/// &lt;param name=&quot;embed&quot;&gt;The embed to add.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(DiscordEmbed embed)
=&gt; this.ModifyAsync(x =&gt; x.AddEmbed(embed));
⋮----
///		Modifies the message by adding embeds.
⋮----
/// &lt;param name=&quot;embeds&quot;&gt;The embeds to add.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(IEnumerable&lt;DiscordEmbed&gt; embeds)
=&gt; this.ModifyAsync(x =&gt; x.AddEmbeds(embeds));
⋮----
///		Modifies the message by modifying the content an embed.
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(string content, DiscordEmbed embed)
=&gt; this.ModifyAsync(x =&gt; x.WithContent(content).AddEmbed(embed));
⋮----
///		Modifies the message by modifying the content and adding embeds.
⋮----
public Task&lt;DiscordMessage&gt; ModifyAsync(string content, IEnumerable&lt;DiscordEmbed&gt; embeds)
=&gt; this.ModifyAsync(x =&gt; x.WithContent(content).AddEmbeds(embeds));
⋮----
///     Edits the message embed suppression.
⋮----
public Task&lt;DiscordMessage&gt; SuppressEmbedsAsync()
=&gt; this.ModifyAsync(x =&gt; x.SuppressEmbeds());
⋮----
///     Deletes the message.
⋮----
///     Thrown when the client does not have the
///     &lt;see cref=&quot;Permissions.ManageMessages&quot; /&gt; permission.
⋮----
public Task DeleteAsync(string reason = null)
=&gt; this.Discord.ApiClient.DeleteMessageAsync(this.ChannelId, this.Id, reason);
⋮----
///     Creates a thread.
///     Depending on the &lt;see cref=&quot;ChannelType&quot; /&gt; of the parent channel it&apos;s either a
///     &lt;see cref=&quot;ChannelType.PublicThread&quot; /&gt; or a &lt;see cref=&quot;ChannelType.NewsThread&quot; /&gt;.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The name of the thread.&lt;/param&gt;
/// &lt;param name=&quot;autoArchiveDuration&quot;&gt;
///     &lt;see cref=&quot;ThreadAutoArchiveDuration&quot; /&gt; till it gets archived. Defaults to
///     &lt;see cref=&quot;ThreadAutoArchiveDuration.OneHour&quot; /&gt;
/// &lt;/param&gt;
/// &lt;param name=&quot;rateLimitPerUser&quot;&gt;The per user ratelimit, aka slowdown.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason.&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.CreatePrivateThreads&quot; /&gt; or &lt;see cref=&quot;Permissions.SendMessagesInThreads&quot; /&gt; permission.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the channel does not exist.&lt;/exception&gt;
⋮----
public async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(string name, ThreadAutoArchiveDuration autoArchiveDuration = ThreadAutoArchiveDuration.OneHour, int? rateLimitPerUser = null, string? reason = null)
=&gt; await this.Discord.ApiClient.CreateThreadAsync(this.ChannelId, this.Id, name, autoArchiveDuration, this.Channel.Type == ChannelType.News ? ChannelType.NewsThread : ChannelType.PublicThread, rateLimitPerUser, isForum: false, reason: reason).ConfigureAwait(false);
⋮----
///     Pins the message in its channel.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The audit log reason.&lt;/param&gt;
⋮----
public Task PinAsync(string? reason = null)
=&gt; this.Discord.ApiClient.PinMessageAsync(this.ChannelId, this.Id, reason);
⋮----
///     Unpins the message in its channel.
⋮----
public Task UnpinAsync(string? reason = null)
=&gt; this.Discord.ApiClient.UnpinMessageAsync(this.ChannelId, this.Id, reason);
⋮----
///     Responds to the message. This produces a reply.
⋮----
/// &lt;param name=&quot;content&quot;&gt;Message content to respond with.&lt;/param&gt;
/// &lt;param name=&quot;mention&quot;&gt;Whether to mention on reply.&lt;/param&gt;
/// &lt;returns&gt;The sent message.&lt;/returns&gt;
⋮----
///     &lt;see cref=&quot;Permissions.SendMessages&quot; /&gt; permission.
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(string content, bool mention = true)
=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, content, null, null, this.Id, mention, false);
⋮----
/// &lt;param name=&quot;embed&quot;&gt;Embed to attach to the message.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(DiscordEmbed embed, bool mention = true)
=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, null, embed != null
⋮----
Task&lt;DiscordMessage&gt; RespondAsync(string content, DiscordEmbed embed, bool mention = true)
=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, content, embed != null
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The Discord message builder.&lt;/param&gt;
⋮----
Task&lt;DiscordMessage&gt; RespondAsync(DiscordMessageBuilder builder, bool mention = true)
=&gt; this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, builder.WithReply(this.Id, mention));
⋮----
/// &lt;param name=&quot;action&quot;&gt;The Discord message builder.&lt;/param&gt;
⋮----
public Task&lt;DiscordMessage&gt; RespondAsync(Action&lt;DiscordMessageBuilder&gt; action, bool mention = true)
⋮----
return this.Discord.ApiClient.CreateMessageAsync(this.ChannelId, builder.WithReply(this.Id, mention));
⋮----
///     Creates a reaction to this message.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji you want to react with, either an emoji or name:id&lt;/param&gt;
⋮----
///     &lt;see cref=&quot;Permissions.AddReactions&quot; /&gt; permission.
⋮----
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the emoji does not exist.&lt;/exception&gt;
⋮----
public Task CreateReactionAsync(DiscordEmoji emoji)
=&gt; this.Discord.ApiClient.CreateReactionAsync(this.ChannelId, this.Id, emoji.ToReactionString());
⋮----
///     Deletes your own reaction
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji for the reaction you want to remove, either an emoji or name:id&lt;/param&gt;
⋮----
public Task DeleteOwnReactionAsync(DiscordEmoji emoji)
=&gt; this.Discord.ApiClient.DeleteOwnReactionAsync(this.ChannelId, this.Id, emoji.ToReactionString());
⋮----
///     Deletes another user&apos;s reaction.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji for the reaction you want to remove, either an emoji or name:id.&lt;/param&gt;
/// &lt;param name=&quot;user&quot;&gt;Member you want to remove the reaction for&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;Reason for audit logs.&lt;/param&gt;
⋮----
public Task DeleteReactionAsync(DiscordEmoji emoji, DiscordUser user, string reason = null)
=&gt; this.Discord.ApiClient.DeleteUserReactionAsync(this.ChannelId, this.Id, user.Id, emoji.ToReactionString(), reason);
⋮----
///     Gets users that reacted with this emoji.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;Emoji to react with.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Limit of users to fetch.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Fetch users after this user&apos;s id.&lt;/param&gt;
⋮----
public Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsAsync(DiscordEmoji emoji, int limit = 25, ulong? after = null)
=&gt; this.GetReactionsInternalAsync(emoji, limit, after);
⋮----
///     Deletes all reactions for this message.
⋮----
public Task DeleteAllReactionsAsync(string reason = null)
=&gt; this.Discord.ApiClient.DeleteAllReactionsAsync(this.ChannelId, this.Id, reason);
⋮----
///     Deletes all reactions of a specific reaction for this message.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to clear, either an emoji or name:id.&lt;/param&gt;
⋮----
public Task DeleteReactionsEmojiAsync(DiscordEmoji emoji)
=&gt; this.Discord.ApiClient.DeleteReactionsEmojiAsync(this.ChannelId, this.Id, emoji.ToReactionString());
⋮----
///     Gets the reactions.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji to search for.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The limit of results.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get the reasctions after snowflake.&lt;/param&gt;
private async Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsInternalAsync(DiscordEmoji emoji, int limit = 25, ulong? after = null)
⋮----
throw new ArgumentException(&quot;Cannot get a negative number of reactions&apos; users.&quot;);
⋮----
var fetch = await this.Discord.ApiClient.GetReactionsAsync(this.Channel.Id, this.Id, emoji.ToReactionString(), last, fetchSize).ConfigureAwait(false);
⋮----
users.AddRange(fetch);
last = fetch.LastOrDefault()?.Id;
⋮----
///     Returns a string representation of this message.
⋮----
/// &lt;returns&gt;String representation of this message.&lt;/returns&gt;
public override string ToString()
⋮----
///     Checks whether this &lt;see cref=&quot;DiscordMessage&quot; /&gt; is equal to another object.
⋮----
/// &lt;param name=&quot;obj&quot;&gt;Object to compare to.&lt;/param&gt;
/// &lt;returns&gt;Whether the object is equal to this &lt;see cref=&quot;DiscordMessage&quot; /&gt;.&lt;/returns&gt;
public override bool Equals(object obj)
=&gt; this.Equals(obj as DiscordMessage);
⋮----
///     Gets the hash code for this &lt;see cref=&quot;DiscordMessage&quot; /&gt;.
⋮----
/// &lt;returns&gt;The hash code for this &lt;see cref=&quot;DiscordMessage&quot; /&gt;.&lt;/returns&gt;
public override int GetHashCode()
⋮----
hash = (hash * 7) + this.Id.GetHashCode();
hash = (hash * 7) + this.ChannelId.GetHashCode();
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordMessage&quot; /&gt; objects are equal.
⋮----
/// &lt;param name=&quot;e1&quot;&gt;First message to compare.&lt;/param&gt;
/// &lt;param name=&quot;e2&quot;&gt;Second message to compare.&lt;/param&gt;
/// &lt;returns&gt;Whether the two messages are equal.&lt;/returns&gt;
⋮----
///     Gets whether the two &lt;see cref=&quot;DiscordMessage&quot; /&gt; objects are not equal.
⋮----
/// &lt;returns&gt;Whether the two messages are not equal.&lt;/returns&gt;</file><file path="DisCatSharp/Net/Rest/DiscordApiClient.cs">/// &lt;summary&gt;
///     Represents a discord api client.
/// &lt;/summary&gt;
public sealed class DiscordApiClient
⋮----
///     The audit log reason header name.
⋮----
///     Initializes a new instance of the &lt;see cref=&quot;DiscordApiClient&quot; /&gt; class.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The base discord client.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;client&quot;&gt;The oauth2 client.&lt;/param&gt;
/// &lt;param name=&quot;proxy&quot;&gt;The proxy.&lt;/param&gt;
/// &lt;param name=&quot;timeout&quot;&gt;The timeout.&lt;/param&gt;
/// &lt;param name=&quot;useRelativeRateLimit&quot;&gt;If true, use relative rate limit.&lt;/param&gt;
/// &lt;param name=&quot;logger&quot;&gt;The logger.&lt;/param&gt;
⋮----
///     Gets the discord client.
⋮----
///     Gets the oauth2 client.
⋮----
///     Gets the rest client.
⋮----
///     Builds the query string.
⋮----
/// &lt;param name=&quot;values&quot;&gt;The values.&lt;/param&gt;
/// &lt;param name=&quot;post&quot;&gt;Whether this query will be transmitted via POST.&lt;/param&gt;
private static string BuildQueryString(Dictionary&lt;string, string&gt; values, bool post = false)
⋮----
var valsCollection = values.Select(xkvp =&gt;
$&quot;{WebUtility.UrlEncode(xkvp.Key)}={WebUtility.UrlEncode(xkvp.Value)}&quot;);
var vals = string.Join(&quot;&amp;&quot;, valsCollection);
⋮----
///     Prepares the message.
⋮----
/// &lt;param name=&quot;msgRaw&quot;&gt;The raw message.&lt;/param&gt;
private DiscordMessage PrepareMessage(JToken msgRaw)
⋮----
this.PopulateMessage(author, ret);
⋮----
if (ret is { InternalReference.Type: ReferenceType.Default, MessageType: MessageType.Reply } &amp;&amp; !string.IsNullOrWhiteSpace(referencedMsg?.ToString()))
⋮----
this.PopulateMessage(author, ret.ReferencedMessage);
⋮----
? new DiscordDmChannel
⋮----
: new DiscordChannel
⋮----
///     Populates the message.
⋮----
/// &lt;param name=&quot;author&quot;&gt;The author.&lt;/param&gt;
/// &lt;param name=&quot;ret&quot;&gt;The message.&lt;/param&gt;
private void PopulateMessage(TransportUser author, DiscordMessage ret)
⋮----
//If this is a webhook, it shouldn&apos;t be in the user cache.
if (author.IsBot &amp;&amp; int.Parse(author.Discriminator) == 0)
⋮----
if (!this.Discord.UserCache.TryGetValue(author.Id, out var usr))
⋮----
if (!guild.Members.TryGetValue(author.Id, out var mbr))
⋮----
ret.PopulateMentions();
⋮----
x.Message.MentionedUsersInternal.ForEach(u =&gt; u.Discord = this.Discord);
⋮----
x.Message.AttachmentsInternal.ForEach(a =&gt; a.Discord = this.Discord);
⋮----
x.Message.EmbedsInternal.ForEach(a =&gt; a.Discord = this.Discord);
⋮----
x.Message.MentionedChannelsInternal.ForEach(u =&gt; u.Discord = this.Discord);
⋮----
x.Message.MentionedRolesInternal.ForEach(u =&gt; u.Discord = this.Discord);
x.Message.PopulateMentions();
⋮----
///     Executes a rest request.
⋮----
/// &lt;param name=&quot;client&quot;&gt;The client.&lt;/param&gt;
/// &lt;param name=&quot;bucket&quot;&gt;The bucket.&lt;/param&gt;
/// &lt;param name=&quot;url&quot;&gt;The url.&lt;/param&gt;
/// &lt;param name=&quot;method&quot;&gt;The method.&lt;/param&gt;
/// &lt;param name=&quot;route&quot;&gt;The route.&lt;/param&gt;
/// &lt;param name=&quot;headers&quot;&gt;The headers.&lt;/param&gt;
/// &lt;param name=&quot;payload&quot;&gt;The payload.&lt;/param&gt;
/// &lt;param name=&quot;ratelimitWaitOverride&quot;&gt;The ratelimit wait override.&lt;/param&gt;
/// &lt;param name=&quot;targetDebug&quot;&gt;Enables a possible breakpoint in the rest client for debugging purposes.&lt;/param&gt;
internal Task&lt;RestResponse&gt; DoRequestAsync(BaseDiscordClient client, RateLimitBucket bucket, Uri url, RestRequestMethod method, string route, IReadOnlyDictionary&lt;string, string&gt;? headers = null, string? payload = null, double? ratelimitWaitOverride = null, bool targetDebug = false)
⋮----
var req = new RestRequest(client, bucket, url, method, route, headers, payload, ratelimitWaitOverride);
⋮----
this.Rest.ExecuteRequestAsync(req, targetDebug).LogTaskFault(this.Discord.Logger, LogLevel.Error, LoggerEvents.RestError, $&quot;Error while executing request. Url: {url.AbsoluteUri}&quot;);
⋮----
_ = this.Rest.ExecuteRequestAsync(req, targetDebug);
⋮----
return req.WaitForCompletionAsync();
⋮----
///     Executes a rest form data request.
⋮----
/// &lt;param name=&quot;formData&quot;&gt;The form data.&lt;/param&gt;
⋮----
internal Task&lt;RestResponse&gt; DoFormRequestAsync(DiscordOAuth2Client client, RateLimitBucket bucket, Uri url, RestRequestMethod method, string route, Dictionary&lt;string, string&gt; formData, Dictionary&lt;string, string&gt;? headers = null, double? ratelimitWaitOverride = null, bool targetDebug = false)
⋮----
var req = new RestFormRequest(client, bucket, url, method, route, formData, headers, ratelimitWaitOverride);
⋮----
this.Rest.ExecuteFormRequestAsync(req, targetDebug).LogTaskFault(this.OAuth2Client.Logger, LogLevel.Error, LoggerEvents.RestError, $&quot;Error while executing request. Url: {url.AbsoluteUri}&quot;);
⋮----
///     Executes a multipart rest request for stickers.
⋮----
/// &lt;param name=&quot;name&quot;&gt;The sticker name.&lt;/param&gt;
/// &lt;param name=&quot;tags&quot;&gt;The sticker tag.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The sticker description.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;file&quot;&gt;The file.&lt;/param&gt;
⋮----
private Task&lt;RestResponse&gt; DoStickerMultipartAsync(
⋮----
var req = new MultipartStickerWebRequest(client, bucket, url, method, route, name, tags, description, headers, file, ratelimitWaitOverride);
⋮----
this.Rest.ExecuteRequestAsync(req, targetDebug).LogTaskFault(this.Discord.Logger, LogLevel.Error, LoggerEvents.RestError, &quot;Error while executing request&quot;);
⋮----
///     Executes a multipart request.
⋮----
/// &lt;param name=&quot;files&quot;&gt;The files.&lt;/param&gt;
⋮----
private Task&lt;RestResponse&gt; DoMultipartAsync(
⋮----
var req = new MultipartWebRequest(client, bucket, url, method, route, headers, values, files, ratelimitWaitOverride);
⋮----
///     Lists the voice regions async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; ListVoiceRegionsAsync()
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.GET, route, new
⋮----
var url = Utilities.GetApiUriFor(path, this.Discord.Configuration);
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route).ConfigureAwait(false);
⋮----
// begin todo
⋮----
///     Gets the guild async.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id.&lt;/param&gt;
/// &lt;param name=&quot;withCounts&quot;&gt;If true, with_counts.&lt;/param&gt;
internal async Task&lt;DiscordGuild&gt; GetGuildAsync(ulong guildId, bool? withCounts)
⋮----
urlParams[&quot;with_counts&quot;] = withCounts.Value.ToString();
⋮----
var url = Utilities.GetApiUriFor(path, urlParams.Count != 0 ? BuildQueryString(urlParams) : &quot;&quot;, this.Discord.Configuration);
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route, urlParams).ConfigureAwait(false);
⋮----
var json = JObject.Parse(res.Response);
⋮----
await dc.OnGuildUpdateEventAsync(guildRest, rawMembers).ConfigureAwait(false);
⋮----
///     Searches the members async.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild_id.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The limit.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordMember&gt;&gt; SearchGuildMembersAsync(ulong guildId, string name, int? limit)
⋮----
[&quot;limit&quot;] = limit.ToString()
⋮----
var url = Utilities.GetApiUriFor(path, BuildQueryString(querydict), this.Discord.Configuration);
⋮----
var json = JArray.Parse(res.Response);
⋮----
var usr = new DiscordUser(xtm.User)
⋮----
this.Discord.UserCache.AddOrUpdate(xtm.User.Id, usr, (id, old) =&gt;
⋮----
mbrs.Add(new(xtm)
⋮----
///     Gets the guild ban async.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user_id.&lt;/param&gt;
internal async Task&lt;DiscordBan&gt; GetGuildBanAsync(ulong guildId, ulong userId)
⋮----
var uri = Utilities.GetApiUriFor(path, this.Discord.Configuration);
var res = await this.DoRequestAsync(this.Discord, bucket, uri, RestRequestMethod.GET, route).ConfigureAwait(false);
⋮----
///     Modifies the guild.
⋮----
/// &lt;param name=&quot;verificationLevel&quot;&gt;The verification level.&lt;/param&gt;
/// &lt;param name=&quot;defaultMessageNotifications&quot;&gt;The default message notifications.&lt;/param&gt;
/// &lt;param name=&quot;mfaLevel&quot;&gt;The mfa level.&lt;/param&gt;
/// &lt;param name=&quot;explicitContentFilter&quot;&gt;The explicit content filter.&lt;/param&gt;
/// &lt;param name=&quot;afkChannelId&quot;&gt;The afk channel id.&lt;/param&gt;
/// &lt;param name=&quot;afkTimeout&quot;&gt;The afk timeout.&lt;/param&gt;
/// &lt;param name=&quot;iconb64&quot;&gt;The iconb64.&lt;/param&gt;
/// &lt;param name=&quot;splashb64&quot;&gt;The splashb64.&lt;/param&gt;
/// &lt;param name=&quot;systemChannelId&quot;&gt;The system channel id.&lt;/param&gt;
/// &lt;param name=&quot;systemChannelFlags&quot;&gt;The system channel flags.&lt;/param&gt;
/// &lt;param name=&quot;publicUpdatesChannelId&quot;&gt;The public updates channel id.&lt;/param&gt;
/// &lt;param name=&quot;rulesChannelId&quot;&gt;The rules channel id.&lt;/param&gt;
/// &lt;param name=&quot;description&quot;&gt;The description.&lt;/param&gt;
/// &lt;param name=&quot;bannerb64&quot;&gt;The banner base64.&lt;/param&gt;
/// &lt;param name=&quot;discoverySplashb64&quot;&gt;The discovery base64.&lt;/param&gt;
/// &lt;param name=&quot;homeHeaderb64&quot;&gt;The home header base64.&lt;/param&gt;
/// &lt;param name=&quot;preferredLocale&quot;&gt;The preferred locale.&lt;/param&gt;
/// &lt;param name=&quot;premiumProgressBarEnabled&quot;&gt;Whether the premium progress bar should be enabled.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason.&lt;/param&gt;
internal async Task&lt;DiscordGuild&gt; ModifyGuildAsync(
⋮----
var pld = new RestGuildModifyPayload
⋮----
var headers = Utilities.GetBaseHeaders();
if (!string.IsNullOrWhiteSpace(reason))
headers.Add(REASON_HEADER_NAME, reason);
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.PATCH, route, new
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
await dc.OnGuildUpdateEventAsync(guild, rawMembers).ConfigureAwait(false);
⋮----
///     Modifies the guild community settings.
⋮----
/// &lt;param name=&quot;features&quot;&gt;The guild features.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuild&gt; ModifyGuildCommunitySettingsAsync(ulong guildId, List&lt;string&gt; features, Optional&lt;ulong?&gt; rulesChannelId, Optional&lt;ulong?&gt; publicUpdatesChannelId, string preferredLocale, string description, DefaultMessageNotifications defaultMessageNotifications, ExplicitContentFilter explicitContentFilter, Optional&lt;VerificationLevel&gt; verificationLevel, string? reason)
⋮----
var pld = new RestGuildCommunityModifyPayload
⋮----
Description = Optional.FromNullable(description),
⋮----
///     Modifies the guilds inventory settings.
⋮----
/// &lt;param name=&quot;isEmojiPackCollectible&quot;&gt;Whether emoji packs are collectible.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuild&gt; ModifyGuildInventorySettingsAsync(ulong guildId, bool isEmojiPackCollectible, string? reason)
⋮----
var pld = new RestGuildInventoryModifyPayload
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Modifies the guilds incident actions.
⋮----
/// &lt;param name=&quot;invitesDisabledUntil&quot;&gt;Until when invites are disabled. Set &lt;see langword=&quot;null&quot; /&gt; to disable.&lt;/param&gt;
/// &lt;param name=&quot;dmsDisabledUntil&quot;&gt;Until when direct messages are disabled. Set &lt;see langword=&quot;null&quot; /&gt; to disable.&lt;/param&gt;
internal async Task&lt;IncidentsData&gt; ModifyGuildIncidentActionsAsync(ulong guildId, DateTimeOffset? invitesDisabledUntil, DateTimeOffset? dmsDisabledUntil)
⋮----
var pld = new RestGuildIncidentActionsModifyPayload
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.PUT, route, new
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Gets the guilds onboarding.
⋮----
internal async Task&lt;DiscordOnboarding&gt; GetGuildOnboardingAsync(ulong guildId)
⋮----
///     Modifies the guilds onboarding.
⋮----
/// &lt;param name=&quot;prompts&quot;&gt;The onboarding prompts&lt;/param&gt;
/// &lt;param name=&quot;defaultChannelIds&quot;&gt;The default channel ids.&lt;/param&gt;
/// &lt;param name=&quot;enabled&quot;&gt;Whether onboarding is enabled.&lt;/param&gt;
/// &lt;param name=&quot;mode&quot;&gt;The onboarding mode.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordOnboarding&gt; ModifyGuildOnboardingAsync(ulong guildId, Optional&lt;List&lt;DiscordOnboardingPrompt&gt;&gt; prompts, Optional&lt;List&lt;ulong&gt;&gt; defaultChannelIds, Optional&lt;bool&gt; enabled, Optional&lt;OnboardingMode&gt; mode, string? reason = null)
⋮----
var pld = new RestGuildOnboardingModifyPayload
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Gets the guilds server guide.
⋮----
internal async Task&lt;DiscordServerGuide&gt; GetGuildServerGuideAsync(ulong guildId)
⋮----
///     Modifies the guilds server guide.
⋮----
/// &lt;param name=&quot;enabled&quot;&gt;Whether the server guide is enabled.&lt;/param&gt;
/// &lt;param name=&quot;welcomeMessage&quot;&gt;The server guide welcome message.&lt;/param&gt;
/// &lt;param name=&quot;newMemberActions&quot;&gt;The new member actions.&lt;/param&gt;
/// &lt;param name=&quot;resourceChannels&quot;&gt;The resource channels.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordServerGuide&gt; ModifyGuildServerGuideAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;WelcomeMessage&gt; welcomeMessage, Optional&lt;List&lt;NewMemberAction&gt;&gt; newMemberActions, Optional&lt;List&lt;ResourceChannel&gt;&gt; resourceChannels, string? reason = null)
⋮----
var pld = new RestGuildServerGuideModifyPayload
⋮----
///     Modifies the guild safety settings.
⋮----
/// &lt;param name=&quot;safetyAlertsChannelId&quot;&gt;The safety alerts channel id.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuild&gt; ModifyGuildSafetyAlertsSettingsAsync(ulong guildId, List&lt;string&gt; features, Optional&lt;ulong?&gt; safetyAlertsChannelId, string? reason)
⋮----
var pld = new RestGuildSafetyModifyPayload
⋮----
///     Modifies the guild features.
⋮----
/// &lt;returns&gt;&lt;/returns&gt;
internal async Task&lt;DiscordGuild&gt; ModifyGuildFeaturesAsync(ulong guildId, List&lt;string&gt; features, string? reason)
⋮----
var pld = new RestGuildFeatureModifyPayload
⋮----
///     Enables the guilds mfa requirement.
⋮----
internal async Task EnableGuildMfaAsync(ulong guildId, string? reason)
⋮----
var pld = new RestGuildMfaLevelModifyPayload
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.POST, route, new
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Disables the guilds mfa requirement.
⋮----
internal async Task DisableGuildMfaAsync(ulong guildId, string? reason)
⋮----
///     Implements https://discord.com/developers/docs/resources/guild#get-guild-bans.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordBan&gt;&gt; GetGuildBansAsync(ulong guildId, int? limit, ulong? before, ulong? after)
⋮----
urlParams[&quot;limit&quot;] = limit.Value.ToString(CultureInfo.InvariantCulture);
⋮----
urlParams[&quot;before&quot;] = before.Value.ToString(CultureInfo.InvariantCulture);
⋮----
urlParams[&quot;after&quot;] = after.Value.ToString(CultureInfo.InvariantCulture);
⋮----
var url = Utilities.GetApiUriFor(path, BuildQueryString(urlParams), this.Discord.Configuration);
⋮----
var bansRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordBan&gt;&gt;(res.Response).Select(xb =&gt;
⋮----
if (!this.Discord.TryGetCachedUserInternal(xb.RawUser.Id, out var usr))
⋮----
usr = this.Discord.UserCache.AddOrUpdate(usr.Id, usr, (id, old) =&gt;
⋮----
///     Creates a guild ban.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to ban from.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user id to ban.&lt;/param&gt;
/// &lt;param name=&quot;deleteMessageSeconds&quot;&gt;The delete message seconds.&lt;/param&gt;
⋮----
internal Task CreateGuildBanAsync(ulong guildId, ulong userId, int deleteMessageSeconds, string? reason)
⋮----
throw new ArgumentException(&quot;Delete message seconds must be a number between 0 and 604800.&quot;, nameof(deleteMessageSeconds));
⋮----
var pld = new RestGuildBanPayload
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld));
⋮----
///     Creates a guild bulk ban.
⋮----
/// &lt;param name=&quot;userIds&quot;&gt;The user ids to ban.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordBulkBanResponse&gt; CreateGuildBulkBanAsync(ulong guildId, List&lt;ulong&gt; userIds, int deleteMessageSeconds, string? reason)
⋮----
throw new ArgumentException(&quot;Can only bulk-ban up to 200 users.&quot;, nameof(userIds));
⋮----
var pld = new RestGuildBulkBanPayload
⋮----
var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Removes the guild ban async.
⋮----
internal Task RemoveGuildBanAsync(ulong guildId, ulong userId, string? reason)
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.DELETE, route, new
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers);
⋮----
///     Leaves the guild async.
⋮----
internal Task LeaveGuildAsync(ulong guildId)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route);
⋮----
///     Adds the guild member async.
⋮----
/// &lt;param name=&quot;userId&quot;&gt;The user id.&lt;/param&gt;
/// &lt;param name=&quot;accessToken&quot;&gt;The user&apos;s access token.&lt;/param&gt;
/// &lt;param name=&quot;nickname&quot;&gt;The nickname.&lt;/param&gt;
/// &lt;param name=&quot;roles&quot;&gt;The roles.&lt;/param&gt;
/// &lt;param name=&quot;muted&quot;&gt;If true, muted.&lt;/param&gt;
/// &lt;param name=&quot;deafened&quot;&gt;If true, deafened.&lt;/param&gt;
/// &lt;returns&gt;The added &lt;see cref=&quot;DiscordMember&quot; /&gt;, or &lt;see langword=&quot;null&quot; /&gt; if they were already a member.&lt;/returns&gt;
internal async Task&lt;DiscordMember?&gt; AddGuildMemberAsync(ulong guildId, ulong userId, string accessToken, string? nickname = null, IEnumerable&lt;DiscordRole&gt;? roles = null, bool? muted = null, bool? deafened = null)
⋮----
var pld = new RestGuildMemberAddPayload
⋮----
this.Rest.HttpClient.DefaultRequestHeaders.TryAddWithoutValidation(CommonHeaders.AUTHORIZATION, $&quot;{CommonHeaders.AUTHORIZATION_BOT} {this.OAuth2Client.DiscordConfiguration.Token}&quot;);
⋮----
var url = Utilities.GetApiUriFor(path, this.Discord is not null ? this.Discord.Configuration : this.OAuth2Client.DiscordConfiguration);
⋮----
this.Rest.HttpClient.DefaultRequestHeaders.Remove(CommonHeaders.AUTHORIZATION);
⋮----
DiscordMember dm = new(tm);
⋮----
///     Lists the guild members async.
⋮----
/// &lt;param name=&quot;after&quot;&gt;The after.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;TransportMember&gt;&gt; ListGuildMembersAsync(ulong guildId, int? limit, ulong? after)
⋮----
///     Adds the guild member role async.
⋮----
/// &lt;param name=&quot;roleId&quot;&gt;The role_id.&lt;/param&gt;
⋮----
internal Task AddGuildMemberRoleAsync(ulong guildId, ulong userId, ulong roleId, string? reason)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, headers);
⋮----
///     Removes the guild member role async.
⋮----
internal Task RemoveGuildMemberRoleAsync(ulong guildId, ulong userId, ulong roleId, string? reason)
⋮----
///     Modifies the guild channel position async.
⋮----
/// &lt;param name=&quot;pld&quot;&gt;The pld.&lt;/param&gt;
⋮----
internal Task ModifyGuildChannelPositionAsync(ulong guildId, IEnumerable&lt;RestGuildChannelReorderPayload&gt; pld, string? reason)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, headers, DiscordJson.SerializeObject(pld));
⋮----
///     Modifies the guild channel parent async.
⋮----
internal Task ModifyGuildChannelParentAsync(ulong guildId, IEnumerable&lt;RestGuildChannelNewParentPayload&gt; pld, string? reason)
⋮----
///     Detaches the guild channel parent async.
⋮----
internal Task DetachGuildChannelParentAsync(ulong guildId, IEnumerable&lt;RestGuildChannelNoParentPayload&gt; pld, string? reason)
⋮----
///     Modifies the guild role position async.
⋮----
internal Task ModifyGuildRolePositionAsync(ulong guildId, IEnumerable&lt;RestGuildRoleReorderPayload&gt; pld, string? reason)
⋮----
///     Gets the audit logs async.
⋮----
/// &lt;param name=&quot;before&quot;&gt;The before.&lt;/param&gt;
/// &lt;param name=&quot;responsible&quot;&gt;The responsible.&lt;/param&gt;
/// &lt;param name=&quot;actionType&quot;&gt;The action_type.&lt;/param&gt;
internal async Task&lt;AuditLog&gt; GetAuditLogsAsync(ulong guildId, int limit, ulong? after, ulong? before, ulong? responsible, int? actionType)
⋮----
[&quot;limit&quot;] = limit.ToString(CultureInfo.InvariantCulture)
⋮----
///     Gets the guild vanity url async.
⋮----
internal async Task&lt;DiscordInvite&gt; GetGuildVanityUrlAsync(ulong guildId)
⋮----
///     Gets the guild widget async.
⋮----
internal async Task&lt;DiscordWidget&gt; GetGuildWidgetAsync(ulong guildId)
⋮----
ret.Guild = this.Discord.Guilds.ContainsKey(guildId) ? this.Discord.Guilds[guildId] : null;
⋮----
.. rawChannels.Select(r =&gt; new DiscordChannel
⋮----
Name = r[&quot;name&quot;].ToString(),
⋮----
.. rawChannels.Select(r =&gt;
⋮----
var c = ret.Guild.GetChannel((ulong)r[&quot;id&quot;]);
⋮----
///     Gets the guild widget settings async.
⋮----
internal async Task&lt;DiscordWidgetSettings&gt; GetGuildWidgetSettingsAsync(ulong guildId)
⋮----
///     Modifies the guild widget settings async.
⋮----
/// &lt;param name=&quot;isEnabled&quot;&gt;If true, is enabled.&lt;/param&gt;
/// &lt;param name=&quot;channelId&quot;&gt;The channel id.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordWidgetSettings&gt; ModifyGuildWidgetSettingsAsync(ulong guildId, bool? isEnabled, ulong? channelId, string? reason)
⋮----
var pld = new RestGuildWidgetSettingsPayload
⋮----
///     Gets the guild templates async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordGuildTemplate&gt;&gt; GetGuildTemplatesAsync(ulong guildId)
⋮----
///     Creates the guild template async.
⋮----
internal async Task&lt;DiscordGuildTemplate&gt; CreateGuildTemplateAsync(ulong guildId, string name, string? description)
⋮----
var pld = new RestGuildTemplateCreateOrModifyPayload
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Syncs the guild template async.
⋮----
/// &lt;param name=&quot;templateCode&quot;&gt;The template_code.&lt;/param&gt;
internal async Task&lt;DiscordGuildTemplate&gt; SyncGuildTemplateAsync(ulong guildId, string templateCode)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route).ConfigureAwait(false);
⋮----
///     Modifies the guild template async.
⋮----
internal async Task&lt;DiscordGuildTemplate&gt; ModifyGuildTemplateAsync(ulong guildId, string templateCode, string? name, string? description)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Deletes the guild template async.
⋮----
internal async Task&lt;DiscordGuildTemplate&gt; DeleteGuildTemplateAsync(ulong guildId, string templateCode)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route).ConfigureAwait(false);
⋮----
///     Gets the guild membership screening form async.
⋮----
internal async Task&lt;DiscordGuildMembershipScreening&gt; GetGuildMembershipScreeningFormAsync(ulong guildId)
⋮----
///     Modifies the guild membership screening form async.
⋮----
/// &lt;param name=&quot;enabled&quot;&gt;The enabled.&lt;/param&gt;
/// &lt;param name=&quot;fields&quot;&gt;The fields.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuildMembershipScreening&gt; ModifyGuildMembershipScreeningFormAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;DiscordGuildMembershipScreeningField[]&gt; fields, Optional&lt;string&gt; description)
⋮----
var pld = new RestGuildMembershipScreeningFormModifyPayload
⋮----
///     Gets the guild welcome screen async.
⋮----
internal async Task&lt;DiscordGuildWelcomeScreen&gt; GetGuildWelcomeScreenAsync(ulong guildId)
⋮----
///     Modifies the guild welcome screen async.
⋮----
/// &lt;param name=&quot;welcomeChannels&quot;&gt;The welcome channels.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuildWelcomeScreen&gt; ModifyGuildWelcomeScreenAsync(ulong guildId, Optional&lt;bool&gt; enabled, Optional&lt;IEnumerable&lt;DiscordGuildWelcomeScreenChannel&gt;&gt; welcomeChannels, Optional&lt;string&gt; description)
⋮----
var pld = new RestGuildWelcomeScreenModifyPayload
⋮----
///     Gets the current user&apos;s voice state.
⋮----
internal async Task&lt;DiscordVoiceState?&gt; GetCurrentUserVoiceStateAsync(ulong guildId)
⋮----
///     Gets the voice state for a member.
⋮----
/// &lt;param name=&quot;memberId&quot;&gt;The member id.&lt;/param&gt;
internal async Task&lt;DiscordVoiceState?&gt; GetMemberVoiceStateAsync(ulong guildId, ulong memberId)
⋮----
///     Updates the current user voice state async.
⋮----
/// &lt;param name=&quot;suppress&quot;&gt;If true, suppress.&lt;/param&gt;
/// &lt;param name=&quot;requestToSpeakTimestamp&quot;&gt;The request to speak timestamp.&lt;/param&gt;
internal async Task UpdateCurrentUserVoiceStateAsync(ulong guildId, ulong channelId, bool? suppress, DateTimeOffset? requestToSpeakTimestamp)
⋮----
var pld = new RestGuildUpdateCurrentUserVoiceStatePayload
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Updates the user voice state async.
⋮----
internal async Task UpdateUserVoiceStateAsync(ulong guildId, ulong userId, ulong channelId, bool? suppress)
⋮----
var pld = new RestGuildUpdateUserVoiceStatePayload
⋮----
///     Gets all auto mod rules for a guild.
⋮----
/// &lt;returns&gt;A collection of all auto mod rules in the guild.&lt;/returns&gt;
internal async Task&lt;ReadOnlyCollection&lt;AutomodRule&gt;&gt; GetAutomodRulesAsync(ulong guildId)
⋮----
return ret.AsReadOnly();
⋮----
///     Gets a specific auto mod rule in the guild.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id for the rule.&lt;/param&gt;
/// &lt;param name=&quot;ruleId&quot;&gt;The rule id.&lt;/param&gt;
/// &lt;returns&gt;The rule if one is found.&lt;/returns&gt;
internal async Task&lt;AutomodRule&gt; GetAutomodRuleAsync(ulong guildId, ulong ruleId)
⋮----
///     Creates an auto mod rule.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id of the rule.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the rule.&lt;/param&gt;
/// &lt;param name=&quot;eventType&quot;&gt;The event type of the rule.&lt;/param&gt;
/// &lt;param name=&quot;triggerType&quot;&gt;The trigger type.&lt;/param&gt;
/// &lt;param name=&quot;actions&quot;&gt;The actions of the rule.&lt;/param&gt;
/// &lt;param name=&quot;triggerMetadata&quot;&gt;The metadata of the rule.&lt;/param&gt;
/// &lt;param name=&quot;enabled&quot;&gt;Whether this rule is enabled.&lt;/param&gt;
/// &lt;param name=&quot;exemptRoles&quot;&gt;The exempt roles of the rule.&lt;/param&gt;
/// &lt;param name=&quot;exemptChannels&quot;&gt;The exempt channels of the rule.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for this addition.&lt;/param&gt;
/// &lt;returns&gt;The new auto mod rule.&lt;/returns&gt;
internal async Task&lt;AutomodRule&gt; CreateAutomodRuleAsync(
⋮----
RestAutomodRuleModifyPayload pld = new()
⋮----
Actions = actions.ToArray(),
⋮----
pld.ExemptChannels = exemptChannels.ToArray();
⋮----
pld.ExemptRoles = exemptRoles.ToArray();
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
await dc.OnAutomodRuleCreated(ret).ConfigureAwait(false);
⋮----
///     Modifies an auto mod role
⋮----
/// &lt;param name=&quot;name&quot;&gt;The new name of the rule.&lt;/param&gt;
/// &lt;param name=&quot;eventType&quot;&gt;The new event type of the rule.&lt;/param&gt;
/// &lt;param name=&quot;metadata&quot;&gt;The new metadata of the rule.&lt;/param&gt;
/// &lt;param name=&quot;actions&quot;&gt;The new actions of the rule.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;exemptRoles&quot;&gt;The new exempt roles of the rule.&lt;/param&gt;
/// &lt;param name=&quot;exemptChannels&quot;&gt;The new exempt channels of the rule.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for this modification.&lt;/param&gt;
/// &lt;returns&gt;The updated automod rule&lt;/returns&gt;
internal async Task&lt;AutomodRule&gt; ModifyAutomodRuleAsync(
⋮----
var pld = new RestAutomodRuleModifyPayload
⋮----
await dc.OnAutomodRuleUpdated(ret).ConfigureAwait(false);
⋮----
///     Deletes an auto mod rule.
⋮----
/// &lt;param name=&quot;reason&quot;&gt;The reason for this deletion.&lt;/param&gt;
/// &lt;returns&gt;The deleted auto mod rule.&lt;/returns&gt;
internal async Task&lt;AutomodRule&gt; DeleteAutomodRuleAsync(ulong guildId, ulong ruleId, string? reason = null)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers).ConfigureAwait(false);
⋮----
await dc.OnAutomodRuleDeleted(ret).ConfigureAwait(false);
⋮----
///     Creates a new soundboard sound in the guild.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild ID.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the soundboard sound.&lt;/param&gt;
/// &lt;param name=&quot;sound&quot;&gt;The base64-encoded sound data (MP3 or OGG format).&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume of the soundboard sound (optional, defaults to 1).&lt;/param&gt;
/// &lt;param name=&quot;emojiId&quot;&gt;The ID of the custom emoji (optional).&lt;/param&gt;
/// &lt;param name=&quot;emojiName&quot;&gt;The unicode character of the standard emoji (optional).&lt;/param&gt;
⋮----
public async Task&lt;DiscordSoundboardSound&gt; CreateGuildSoundboardSoundAsync(ulong guildId, string name, string sound, double? volume = null, ulong? emojiId = null, string? emojiName = null, string? reason = null)
⋮----
var pld = new RestSoundboardSoundCreatePayload
⋮----
///     Modifies an existing soundboard sound.
⋮----
/// &lt;param name=&quot;soundId&quot;&gt;The soundboard sound ID.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The new name of the soundboard sound (optional).&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The new volume of the soundboard sound (optional).&lt;/param&gt;
/// &lt;param name=&quot;emojiId&quot;&gt;The new custom emoji ID (optional).&lt;/param&gt;
/// &lt;param name=&quot;emojiName&quot;&gt;The new standard emoji name (optional).&lt;/param&gt;
⋮----
public async Task&lt;DiscordSoundboardSound&gt; ModifyGuildSoundboardSoundAsync(ulong guildId, ulong soundId, Optional&lt;string&gt; name, Optional&lt;double?&gt; volume, Optional&lt;ulong?&gt; emojiId, Optional&lt;string?&gt; emojiName, string? reason = null)
⋮----
var pld = new RestSoundboardSoundModifyPayload
⋮----
///     Deletes an existing soundboard sound.
⋮----
public async Task DeleteGuildSoundboardSoundAsync(ulong guildId, ulong soundId, string? reason = null)
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers).ConfigureAwait(false);
⋮----
///     Gets all soundboard sounds for a guild.
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListGuildSoundboardSoundsAsync(ulong guildId)
⋮----
///     Gets all default soundboard sounds available for all users.
⋮----
public async Task&lt;IReadOnlyList&lt;DiscordSoundboardSound&gt;&gt; ListDefaultSoundboardSoundsAsync()
⋮----
///     Gets a specific soundboard sound for a guild.
⋮----
public async Task&lt;DiscordSoundboardSound&gt; GetGuildSoundboardSoundAsync(ulong guildId, ulong soundId)
⋮----
///     Sends a soundboard sound to a voice channel the user is connected to.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The ID of the channel to send the sound to.&lt;/param&gt;
/// &lt;param name=&quot;soundId&quot;&gt;The ID of the soundboard sound to play.&lt;/param&gt;
/// &lt;param name=&quot;sourceGuildId&quot;&gt;
///     The ID of the guild the soundboard sound is from, required to play sounds from different
///     servers. Optional.
/// &lt;/param&gt;
/// &lt;returns&gt;A task representing the asynchronous operation.&lt;/returns&gt;
public async Task SendSoundboardSoundAsync(ulong channelId, ulong soundId, ulong? sourceGuildId = null)
⋮----
var pld = new RestSendSoundboardSoundPayload
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
// End todo
⋮----
///     Creates a scheduled event.
⋮----
/// &lt;param name=&quot;metadata&quot;&gt;The metadata.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;scheduledStartTime&quot;&gt;The scheduled start time.&lt;/param&gt;
/// &lt;param name=&quot;scheduledEndTime&quot;&gt;The scheduled end time.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
/// &lt;param name=&quot;coverb64&quot;&gt;The cover image.&lt;/param&gt;
/// &lt;param name=&quot;recurrenceRule&quot;&gt;The recurrence rule.&lt;/param&gt;
⋮----
/// &lt;returns&gt;A scheduled event.&lt;/returns&gt;
/// &lt;exception cref=&quot;ValidationException&quot;&gt;Thrown if the user gave an invalid input.&lt;/exception&gt;
/// &lt;exception cref=&quot;NotFoundException&quot;&gt;Thrown when the guild does not exist.&lt;/exception&gt;
/// &lt;exception cref=&quot;BadRequestException&quot;&gt;Thrown when an invalid parameter was provided.&lt;/exception&gt;
/// &lt;exception cref=&quot;ServerErrorException&quot;&gt;Thrown when Discord is unable to process the request.&lt;/exception&gt;
internal async Task&lt;DiscordScheduledEvent&gt; CreateGuildScheduledEventAsync(ulong guildId, ulong? channelId, DiscordScheduledEventEntityMetadata metadata, string name, DateTimeOffset scheduledStartTime, DateTimeOffset? scheduledEndTime, string description, ScheduledEventEntityType type, Optional&lt;string&gt; coverb64, DiscordScheduledEventRecurrenceRule? recurrenceRule, string? reason = null)
⋮----
var (isValid, errorMessage) = recurrenceRule.Validate();
⋮----
throw new ValidationException(
⋮----
var pld = new RestGuildScheduledEventCreatePayload
⋮----
await dc.OnGuildScheduledEventCreateEventAsync(scheduledEvent, guild).ConfigureAwait(false);
⋮----
///     Modifies a scheduled event.
⋮----
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The scheduled event id.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;status&quot;&gt;The status.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordScheduledEvent&gt; ModifyGuildScheduledEventAsync(
⋮----
var (isValid, errorMessage) = recurrenceRule.Value.Validate();
⋮----
var pld = new RestGuildScheduledEventModifyPayload
⋮----
this.Discord.UserCache.AddOrUpdate(scheduledEvent.Creator.Id, scheduledEvent.Creator, (id, old) =&gt;
⋮----
await dc.OnGuildScheduledEventUpdateEventAsync(scheduledEvent, guild).ConfigureAwait(false);
⋮----
internal async Task&lt;DiscordScheduledEvent&gt; ModifyGuildScheduledEventStatusAsync(ulong guildId, ulong scheduledEventId, ScheduledEventStatus status, string? reason = null)
⋮----
///     Gets a scheduled event.
⋮----
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The event id.&lt;/param&gt;
/// &lt;param name=&quot;withUserCount&quot;&gt;Whether to include user count.&lt;/param&gt;
internal async Task&lt;DiscordScheduledEvent&gt; GetGuildScheduledEventAsync(ulong guildId, ulong scheduledEventId, bool? withUserCount)
⋮----
///     Gets the guilds scheduled events.
⋮----
/// &lt;param name=&quot;withUserCount&quot;&gt;Whether to include the count of users subscribed to the scheduled event.&lt;/param&gt;
internal async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEvent&gt;&gt; ListGuildScheduledEventsAsync(ulong guildId, bool? withUserCount)
⋮----
this.Discord.UserCache.AddOrUpdate(ev.Creator.Id, ev.Creator, (id, old) =&gt;
⋮----
events.Add(ev.Id, ev);
⋮----
///     Deletes a guild scheduled event.
⋮----
internal Task DeleteGuildScheduledEventAsync(ulong guildId, ulong scheduledEventId, string? reason)
⋮----
///     Gets the users who RSVP&apos;d to a scheduled event.
///     Optional with member objects.
///     This endpoint is paginated.
⋮----
/// &lt;param name=&quot;limit&quot;&gt;The limit how many users to receive from the event.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Get results before the given id.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get results after the given id.&lt;/param&gt;
/// &lt;param name=&quot;withMember&quot;&gt;Whether to include guild member data. attaches guild_member property to the user object.&lt;/param&gt;
internal async Task&lt;IReadOnlyDictionary&lt;ulong, DiscordScheduledEventUser&gt;&gt; GetGuildScheduledEventRspvUsersAsync(ulong guildId, ulong scheduledEventId, int? limit, ulong? before, ulong? after, bool? withMember)
⋮----
urlParams[&quot;with_member&quot;] = withMember.Value.ToString(CultureInfo.InvariantCulture);
⋮----
rspvUser.User = this.Discord.UserCache.AddOrUpdate(rspvUser.User.Id, rspvUser.User, (id, old) =&gt;
⋮----
/*if (with_member.HasValue &amp;&amp; with_member.Value &amp;&amp; rspv_user.Member != null)
                {
                    rspv_user.Member.Discord = this.Discord;
                }*/
⋮----
rspv.Add(rspvUser.User.Id, rspvUser);
⋮----
///     Creates a guild channel.
⋮----
/// &lt;param name=&quot;parent&quot;&gt;The parent.&lt;/param&gt;
/// &lt;param name=&quot;topic&quot;&gt;The topic.&lt;/param&gt;
/// &lt;param name=&quot;bitrate&quot;&gt;The bitrate.&lt;/param&gt;
/// &lt;param name=&quot;userLimit&quot;&gt;The user_limit.&lt;/param&gt;
/// &lt;param name=&quot;overwrites&quot;&gt;The overwrites.&lt;/param&gt;
/// &lt;param name=&quot;nsfw&quot;&gt;If true, nsfw.&lt;/param&gt;
/// &lt;param name=&quot;perUserRateLimit&quot;&gt;The per user rate limit.&lt;/param&gt;
/// &lt;param name=&quot;qualityMode&quot;&gt;The quality mode.&lt;/param&gt;
/// &lt;param name=&quot;defaultAutoArchiveDuration&quot;&gt;The default auto archive duration.&lt;/param&gt;
/// &lt;param name=&quot;flags&quot;&gt;The channel flags.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordChannel&gt; CreateGuildChannelAsync(ulong guildId, string name, ChannelType type, ulong? parent, Optional&lt;string&gt; topic, int? bitrate, int? userLimit, IEnumerable&lt;DiscordOverwriteBuilder&gt;? overwrites, bool? nsfw, Optional&lt;int?&gt; perUserRateLimit, VideoQualityMode? qualityMode, ThreadAutoArchiveDuration? defaultAutoArchiveDuration, Optional&lt;ChannelFlags?&gt; flags, string? reason)
⋮----
restOverwrites.AddRange(overwrites.Select(ow =&gt; ow.Build()));
⋮----
var pld = new RestChannelCreatePayload
⋮----
ret.Initialize(this.Discord);
⋮----
///     Creates a guild forum channel.
⋮----
/// &lt;param name=&quot;template&quot;&gt;The template.&lt;/param&gt;
/// &lt;param name=&quot;defaultReactionEmoji&quot;&gt;The default reaction emoji.&lt;/param&gt;
/// &lt;param name=&quot;permissionOverwrites&quot;&gt;The overwrites.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;postCreateUserRateLimit&quot;&gt;The per user post create rate limit.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;defaultSortOrder&quot;&gt;The default sort order.&lt;/param&gt;
/// &lt;param name=&quot;defaultLayout&quot;&gt;The default layout.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordChannel&gt; CreateGuildForumChannelAsync(
⋮----
restoverwrites.AddRange(permissionOverwrites.Select(ow =&gt; ow.Build()));
⋮----
//Template = template,
⋮----
///     Modifies the channel async.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel_id.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;position&quot;&gt;The position.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;rtcRegion&quot;&gt;The rtc region.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;autoArchiveDuration&quot;&gt;The default auto archive duration.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;permissionOverwrites&quot;&gt;The permission overwrites.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;forumLayout&quot;&gt;The default forum layout.&lt;/param&gt;
⋮----
internal Task ModifyChannelAsync(
⋮----
var pld = new RestChannelModifyPayload
⋮----
///     Modifies the forum channel.
⋮----
/// &lt;param name=&quot;availableTags&quot;&gt;The available tags.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;forumLayout&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;defaultTagSetting&quot;&gt;The default tag setting for the forum channel (&quot;match_some&quot; or &quot;match_all&quot;).&lt;/param&gt;
internal async Task&lt;DiscordChannel&gt; ModifyForumChannelAsync(
⋮----
///     Gets the channel async.
⋮----
internal async Task&lt;DiscordChannel&gt; GetChannelAsync(ulong channelId)
⋮----
///     Deletes the channel async.
⋮----
internal Task DeleteChannelAsync(ulong channelId, string? reason)
⋮----
///     Gets the message async.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The message_id.&lt;/param&gt;
internal async Task&lt;DiscordMessage&gt; GetMessageAsync(ulong channelId, ulong messageId)
⋮----
var ret = this.PrepareMessage(JObject.Parse(res.Response));
⋮----
///     Creates the message async.
⋮----
/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
/// &lt;param name=&quot;embeds&quot;&gt;The embeds.&lt;/param&gt;
/// &lt;param name=&quot;sticker&quot;&gt;The sticker.&lt;/param&gt;
/// &lt;param name=&quot;replyMessageId&quot;&gt;The reply message id.&lt;/param&gt;
/// &lt;param name=&quot;mentionReply&quot;&gt;If true, mention reply.&lt;/param&gt;
/// &lt;param name=&quot;failOnInvalidReply&quot;&gt;If true, fail on invalid reply.&lt;/param&gt;
/// &lt;param name=&quot;components&quot;&gt;The components.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
///     Thrown when the &lt;paramref name=&quot;content&quot; /&gt; exceeds 2000 characters or is empty and
///     if neither content, sticker, components and embeds are definied..
/// &lt;/exception&gt;
internal async Task&lt;DiscordMessage&gt; CreateMessageAsync(ulong channelId, string content, IEnumerable&lt;DiscordEmbed&gt;? embeds = null, DiscordSticker? sticker = null, ulong? replyMessageId = null, bool mentionReply = false, bool failOnInvalidReply = false, IEnumerable&lt;DiscordComponent&gt;? components = null)
⋮----
throw new ArgumentException(&quot;Message content length cannot exceed 2000 characters.&quot;);
⋮----
throw new ArgumentException(&quot;You must specify message content, a sticker, components or embeds.&quot;);
⋮----
throw new ArgumentException(&quot;Message content must not be empty.&quot;);
⋮----
embed.Timestamp = embed.Timestamp.Value.ToUniversalTime();
⋮----
var pld = new RestChannelMessageCreatePayload
⋮----
HasContent = !string.IsNullOrEmpty(content),
⋮----
pld.MessageReference = new InternalDiscordMessageReference
⋮----
/// &lt;param name=&quot;builder&quot;&gt;The builder.&lt;/param&gt;
internal async Task&lt;DiscordMessage&gt; CreateMessageAsync(ulong channelId, DiscordMessageBuilder builder)
⋮----
builder.Validate();
⋮----
attachments.Add(att);
⋮----
if (!flags.HasMessageFlag(MessageFlags.IsVoiceMessage))
⋮----
DiscordAttachment att = new()
⋮----
attachments.AddRange(builder.Attachments);
⋮----
[&quot;payload_json&quot;] = DiscordJson.SerializeObject(pld)
⋮----
var res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
⋮----
///     Forwards a message.
⋮----
/// &lt;param name=&quot;forwardMessage&quot;&gt;The message to forward.&lt;/param&gt;
/// &lt;param name=&quot;targetChannelId&quot;&gt;The target channel id to forward the message to.&lt;/param&gt;
/// &lt;param name=&quot;content&quot;&gt;The content to attach.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the &lt;paramref name=&quot;content&quot; /&gt; exceeds 2000 characters.&lt;/exception&gt;
public async Task&lt;DiscordMessage&gt; ForwardMessageAsync(DiscordMessage forwardMessage, ulong targetChannelId, string? content)
⋮----
//HasContent = content != null,
//Content = content,
MessageReference = new InternalDiscordMessageReference
⋮----
///     Gets the guild channels async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordChannel&gt;&gt; GetGuildChannelsAsync(ulong guildId)
⋮----
var channelsRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordChannel&gt;&gt;(res.Response).Select(xc =&gt;
⋮----
///     Modifies a voice channels status.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The voice channel id.&lt;/param&gt;
⋮----
internal Task ModifyVoiceChannelStatusAsync(ulong channelId, string? status)
⋮----
var pld = new RestVoiceChannelStatusModifyPayload
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, payload: DiscordJson.SerializeObject(pld));
⋮----
///     Creates the stage instance async.
⋮----
/// &lt;param name=&quot;sendStartNotification&quot;&gt;Whether everyone should be notified about the stage.&lt;/param&gt;
/// &lt;param name=&quot;scheduledEventId&quot;&gt;The associated scheduled event id.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordStageInstance&gt; CreateStageInstanceAsync(ulong channelId, string topic, bool sendStartNotification, ulong? scheduledEventId = null, string? reason = null)
⋮----
var pld = new RestStageInstanceCreatePayload
⋮----
///     Gets the stage instance async.
⋮----
internal async Task&lt;DiscordStageInstance&gt; GetStageInstanceAsync(ulong channelId)
⋮----
///     Modifies the stage instance async.
⋮----
internal Task ModifyStageInstanceAsync(ulong channelId, Optional&lt;string&gt; topic, string? reason)
⋮----
var pld = new RestStageInstanceModifyPayload
⋮----
///     Deletes the stage instance async.
⋮----
internal Task DeleteStageInstanceAsync(ulong channelId, string? reason)
⋮----
///     Gets the channel messages async.
⋮----
/// &lt;param name=&quot;around&quot;&gt;The around.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetChannelMessagesAsync(ulong channelId, int limit, ulong? before, ulong? after, ulong? around)
⋮----
urlParams[&quot;limit&quot;] = limit.ToString(CultureInfo.InvariantCulture);
⋮----
var msgsRaw = JArray.Parse(res.Response);
⋮----
msgs.Add(this.PrepareMessage(xj));
⋮----
///     Gets the channel message async.
⋮----
internal async Task&lt;DiscordMessage&gt; GetChannelMessageAsync(ulong channelId, ulong messageId)
⋮----
///     Edits the message async.
⋮----
/// &lt;param name=&quot;previousAttachments&quot;&gt;The previous attachments if they should be kept.&lt;/param&gt;
internal async Task&lt;DiscordMessage&gt; EditMessageAsync(ulong channelId, ulong messageId, DiscordMessageBuilder builder, IEnumerable&lt;DiscordAttachment&gt;? previousAttachments = null)
⋮----
builder.Validate(true);
⋮----
var pld = new RestChannelMessageEditPayload
⋮----
if (!flags.HasValue || !flags.Value.HasMessageFlag(MessageFlags.IsVoiceMessage))
⋮----
var res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route, values: values, files: builder.Files).ConfigureAwait(false);
⋮----
foreach (var file in builder.Files.Where(x =&gt; x.ResetPositionTo.HasValue))
⋮----
///     Deletes the message async.
⋮----
internal Task DeleteMessageAsync(ulong channelId, ulong messageId, string? reason)
⋮----
///     Deletes the messages async.
⋮----
/// &lt;param name=&quot;messageIds&quot;&gt;The message_ids.&lt;/param&gt;
⋮----
internal Task DeleteMessagesAsync(ulong channelId, IEnumerable&lt;ulong&gt; messageIds, string? reason)
⋮----
var pld = new RestChannelMessageBulkDeletePayload
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers, DiscordJson.SerializeObject(pld));
⋮----
///     Get a list of users that voted for a specific answer on a &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The message id containing the poll.&lt;/param&gt;
/// &lt;param name=&quot;answerId&quot;&gt;The answer id.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The max number of users to return (&lt;c&gt;1&lt;/c&gt;-&lt;c&gt;100&lt;/c&gt;). Defaults to &lt;c&gt;25&lt;/c&gt;.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Get users after this user ID.&lt;/param&gt;
/// &lt;returns&gt;
///     A &lt;see cref=&quot;ReadOnlyCollection{T}&quot; /&gt; of &lt;see cref=&quot;DiscordUser&quot; /&gt;s who voted for the given
///     &lt;paramref name=&quot;answerId&quot; /&gt; on the &lt;see cref=&quot;DiscordPoll&quot; /&gt;.
/// &lt;/returns&gt;
internal async Task&lt;ReadOnlyCollection&lt;DiscordUser&gt;&gt; GetAnswerVotersAsync(ulong channelId, ulong messageId, int answerId, int? limit, ulong? after)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route);
⋮----
var votersRaw = JObject.Parse(res.Response);
⋮----
var usr = new DiscordUser(xr)
⋮----
usr = this.Discord.UserCache.AddOrUpdate(xr.Id, usr, (id, old) =&gt;
⋮----
voters.Add(usr);
⋮----
///     Immediately ends a poll. Only for own polls.
⋮----
/// &lt;returns&gt;The &lt;see cref=&quot;DiscordMessage&quot; /&gt; containing the &lt;see cref=&quot;DiscordPoll&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;DiscordMessage&gt; EndPollAsync(ulong channelId, ulong messageId)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route);
⋮----
///     Gets the channel invites async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetChannelInvitesAsync(ulong channelId)
⋮----
var invitesRaw = JsonConvert.DeserializeObject&lt;IEnumerable&lt;DiscordInvite&gt;&gt;(res.Response).Select(xi =&gt;
⋮----
///     Creates the channel invite async.
⋮----
/// &lt;param name=&quot;maxAge&quot;&gt;The max_age.&lt;/param&gt;
/// &lt;param name=&quot;maxUses&quot;&gt;The max_uses.&lt;/param&gt;
/// &lt;param name=&quot;targetType&quot;&gt;The target_type.&lt;/param&gt;
/// &lt;param name=&quot;targetApplicationId&quot;&gt;The target_application.&lt;/param&gt;
/// &lt;param name=&quot;targetUser&quot;&gt;The target_user.&lt;/param&gt;
/// &lt;param name=&quot;temporary&quot;&gt;If true, temporary.&lt;/param&gt;
/// &lt;param name=&quot;unique&quot;&gt;If true, unique.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordInvite&gt; CreateChannelInviteAsync(ulong channelId, int maxAge, int maxUses, TargetType? targetType, ulong? targetApplicationId, ulong? targetUser, bool temporary, bool unique, string? reason)
⋮----
var pld = new RestChannelInviteCreatePayload
⋮----
///     Deletes the channel permission async.
⋮----
/// &lt;param name=&quot;overwriteId&quot;&gt;The overwrite_id.&lt;/param&gt;
⋮----
internal Task DeleteChannelPermissionAsync(ulong channelId, ulong overwriteId, string? reason)
⋮----
///     Edits the channel permissions async.
⋮----
/// &lt;param name=&quot;allow&quot;&gt;The allow.&lt;/param&gt;
/// &lt;param name=&quot;deny&quot;&gt;The deny.&lt;/param&gt;
⋮----
internal Task EditChannelPermissionsAsync(ulong channelId, ulong overwriteId, Permissions allow, Permissions deny, string type, string? reason)
⋮----
var pld = new RestChannelPermissionEditPayload
⋮----
///     Triggers the typing async.
⋮----
internal Task TriggerTypingAsync(ulong channelId)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route);
⋮----
///     Gets the pinned messages async.
⋮----
/// &lt;param name=&quot;before&quot;&gt;Get messages pinned before this timestamp.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Max number of pins to return (1-50).&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordMessage&gt;&gt; GetPinnedMessagesAsync(ulong channelId, ulong? before = null, int limit = 50)
⋮----
var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration)
.AddParameter(&quot;limit&quot;, limit.ToString(CultureInfo.InvariantCulture));
⋮----
url.AddParameter(&quot;before&quot;, before.Value.ToString(CultureInfo.InvariantCulture));
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url.Build(), RestRequestMethod.GET, route).ConfigureAwait(false);
⋮----
// TODO: https://discord.com/developers/docs/resources/message#get-channel-pins
var pinResponseRaw = JObject.Parse(res.Response);
var msgsRaw = pinResponseRaw[&quot;items&quot;].ToArray();
⋮----
msgs.Add(this.PrepareMessage(xj[&quot;message&quot;]));
⋮----
///     Pins the message async.
⋮----
internal Task PinMessageAsync(ulong channelId, ulong messageId, string? reason)
⋮----
///     Unpins the message async.
⋮----
internal Task UnpinMessageAsync(ulong channelId, ulong messageId, string? reason)
⋮----
///     Adds the group dm recipient async.
⋮----
/// &lt;param name=&quot;accessToken&quot;&gt;The access_token.&lt;/param&gt;
⋮----
internal Task AddGroupDmRecipientAsync(ulong channelId, ulong userId, string accessToken, string nickname)
⋮----
var pld = new RestChannelGroupDmRecipientAddPayload
⋮----
///     Removes the group dm recipient async.
⋮----
internal Task RemoveGroupDmRecipientAsync(ulong channelId, ulong userId)
⋮----
///     Creates the group dm async.
⋮----
/// &lt;param name=&quot;accessTokens&quot;&gt;The access_tokens.&lt;/param&gt;
/// &lt;param name=&quot;nicks&quot;&gt;The nicks.&lt;/param&gt;
internal async Task&lt;DiscordDmChannel&gt; CreateGroupDmAsync(IEnumerable&lt;string&gt; accessTokens, IDictionary&lt;ulong, string&gt; nicks)
⋮----
var pld = new RestUserGroupDmCreatePayload
⋮----
///     Creates the dm async.
⋮----
/// &lt;param name=&quot;recipientId&quot;&gt;The recipient_id.&lt;/param&gt;
internal async Task&lt;DiscordDmChannel&gt; CreateDmAsync(ulong recipientId)
⋮----
var pld = new RestUserDmCreatePayload
⋮----
///     Follows the channel async.
⋮----
/// &lt;param name=&quot;webhookChannelId&quot;&gt;The webhook_channel_id.&lt;/param&gt;
internal async Task&lt;DiscordFollowedChannel&gt; FollowChannelAsync(ulong channelId, ulong webhookChannelId)
⋮----
var pld = new FollowedChannelAddPayload
⋮----
var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Crossposts the message async.
⋮----
internal async Task&lt;DiscordMessage&gt; CrosspostMessageAsync(ulong channelId, ulong messageId)
⋮----
var response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route).ConfigureAwait(false);
⋮----
///     Gets the current user async.
⋮----
internal Task&lt;DiscordUser&gt; GetCurrentUserAsync()
=&gt; this.GetUserAsync(Endpoints.ME);
⋮----
///     Gets the user async.
⋮----
internal Task&lt;DiscordUser&gt; GetUserAsync(ulong userId)
=&gt; this.GetUserAsync(userId.ToString(CultureInfo.InvariantCulture));
⋮----
internal async Task&lt;DiscordUser&gt; GetUserAsync(string userId)
⋮----
var url = Utilities.GetApiUriFor(path.Replace(&quot;//&quot;, &quot;/&quot;), this.Discord.Configuration);
⋮----
if (this.Discord.Configuration.Intents.HasIntent(DiscordIntents.GuildPresences) &amp;&amp; duser.Presence == null &amp;&amp; this.Discord is DiscordClient dc)
⋮----
///     Gets the guild member async.
⋮----
internal async Task&lt;DiscordMember&gt; GetGuildMemberAsync(ulong guildId, ulong userId)
⋮----
var usr = new DiscordUser(tm.User)
⋮----
usr = this.Discord.UserCache.AddOrUpdate(tm.User.Id, usr, (id, old) =&gt;
⋮----
if (this.Discord.Configuration.Intents.HasIntent(DiscordIntents.GuildPresences) &amp;&amp; usr.Presence == null &amp;&amp; this.Discord is DiscordClient dc)
⋮----
///     Removes the guild member async.
⋮----
internal Task RemoveGuildMemberAsync(ulong guildId, ulong userId, string? reason)
⋮----
///     Modifies the current user async.
⋮----
/// &lt;param name=&quot;username&quot;&gt;The new username.&lt;/param&gt;
/// &lt;param name=&quot;base64Avatar&quot;&gt;The new avatar.&lt;/param&gt;
/// &lt;param name=&quot;base64Banner&quot;&gt;The new banner.&lt;/param&gt;
internal async Task&lt;DiscordUser&gt; ModifyCurrentUserAsync(string username, Optional&lt;string?&gt; base64Avatar, Optional&lt;string?&gt; base64Banner)
⋮----
var pld = new RestUserUpdateCurrentPayload
⋮----
///     Gets the current user guilds async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(int limit = 100, ulong? before = null, ulong? after = null)
⋮----
url.AddParameter(&quot;after&quot;, after.Value.ToString(CultureInfo.InvariantCulture));
⋮----
var glds = guildsRaw.Select(xug =&gt; (this.Discord as DiscordClient)?.GuildsInternal[xug.Id]);
⋮----
///     Modifies the guild member async.
⋮----
/// &lt;param name=&quot;nick&quot;&gt;The nick.&lt;/param&gt;
/// &lt;param name=&quot;roleIds&quot;&gt;The role_ids.&lt;/param&gt;
/// &lt;param name=&quot;mute&quot;&gt;The mute.&lt;/param&gt;
/// &lt;param name=&quot;deaf&quot;&gt;The deaf.&lt;/param&gt;
/// &lt;param name=&quot;voiceChannelId&quot;&gt;The voice_channel_id.&lt;/param&gt;
/// &lt;param name=&quot;verify&quot;&gt;Whether to verify the member.&lt;/param&gt;
/// &lt;param name=&quot;flags&quot;&gt;The member flags&lt;/param&gt;
⋮----
internal Task ModifyGuildMemberAsync(
⋮----
var pld = new RestGuildMemberModifyPayload
⋮----
///     Modifies the time out of a guild member.
⋮----
/// &lt;param name=&quot;until&quot;&gt;Datetime offset.&lt;/param&gt;
⋮----
internal Task ModifyTimeoutAsync(ulong guildId, ulong userId, DateTimeOffset? until, string? reason)
⋮----
var pld = new RestGuildMemberTimeoutModifyPayload
⋮----
///     Modifies the current member nickname async.
⋮----
internal Task ModifyCurrentMemberNicknameAsync(ulong guildId, string nick, string? reason)
⋮----
///     Gets the guild roles async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordRole&gt;&gt; GetGuildRolesAsync(ulong guildId)
⋮----
var roles = DiscordJson.DeserializeIEnumerableObject&lt;IEnumerable&lt;DiscordRole&gt;&gt;(res.Response, this.Discord).Select(xr =&gt;
⋮----
}).ToList();
⋮----
///     Gets a guild role async.
⋮----
internal async Task&lt;DiscordRole&gt; GetGuildRoleAsync(ulong guildId, ulong roleId)
⋮----
///     Modifies the guild role async.
⋮----
/// &lt;param name=&quot;permissions&quot;&gt;The permissions.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color.&lt;/param&gt;
/// &lt;param name=&quot;colors&quot;&gt;The colors.&lt;/param&gt;
/// &lt;param name=&quot;hoist&quot;&gt;If true, hoist.&lt;/param&gt;
/// &lt;param name=&quot;mentionable&quot;&gt;If true, mentionable.&lt;/param&gt;
/// &lt;param name=&quot;iconb64&quot;&gt;The icon.&lt;/param&gt;
/// &lt;param name=&quot;emoji&quot;&gt;The unicode emoji icon.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordRole&gt; ModifyGuildRoleAsync(ulong guildId, ulong roleId, string name, Permissions? permissions, int? color, DiscordRoleColors? colors, bool? hoist, bool? mentionable, Optional&lt;string&gt; iconb64, Optional&lt;string&gt; emoji, string? reason)
⋮----
var pld = new RestGuildRolePayload
⋮----
///     Deletes the role async.
⋮----
internal Task DeleteRoleAsync(ulong guildId, ulong roleId, string? reason)
⋮----
///     Creates the guild role async.
⋮----
internal async Task&lt;DiscordRole&gt; CreateGuildRoleAsync(ulong guildId, string name, Permissions? permissions, int? color, bool? hoist, bool? mentionable, string? reason)
⋮----
///     Gets the guild join requests.
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The ID of the guild.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;The maximum number of join requests to return. Defaults to 100.&lt;/param&gt;
/// &lt;param name=&quot;statusType&quot;&gt;The status type to filter join requests by. Can be Submitted, Approved, or Rejected.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Retrieve join requests before this ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Retrieve join requests after this ID.&lt;/param&gt;
/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;Thrown when the status type is not supported.&lt;/exception&gt;
internal async Task&lt;DiscordGuildJoinRequestSearchResult&gt; GetGuildJoinRequestsAsync(ulong guildId, int limit = 100, JoinRequestStatusType? statusType = null, ulong? before = null, ulong? after = null)
⋮----
JoinRequestStatusType.Submitted or JoinRequestStatusType.Approved or JoinRequestStatusType.Rejected =&gt; statusType.Value.ToString().ToUpperInvariant(),
_ =&gt; throw new ArgumentOutOfRangeException(nameof(statusType), $&quot;Status type {statusType.Value} is not supported&quot;)
⋮----
///     Gets a specific guild join request.
⋮----
/// &lt;param name=&quot;joinRequestId&quot;&gt;The ID of the join request.&lt;/param&gt;
internal async Task&lt;DiscordGuildJoinRequest&gt; GetGuildJoinRequestAsync(ulong guildId, ulong joinRequestId)
⋮----
///     Modifies a guild join request.
⋮----
/// &lt;param name=&quot;statusType&quot;&gt;The status type to set for the join request. Can be Approved or Rejected.&lt;/param&gt;
/// &lt;param name=&quot;rejectionReason&quot;&gt;The optional rejection reason.&lt;/param&gt;
/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when the status type is not Approved or Rejected.&lt;/exception&gt;
internal async Task&lt;DiscordGuildJoinRequest&gt; ModifyGuildJoinRequestsAsync(ulong guildId, ulong joinRequestId, JoinRequestStatusType statusType, string? rejectionReason)
⋮----
var pld = new RestGuildJoinRequestUpdatePayload
⋮----
Action = statusType is JoinRequestStatusType.Approved or JoinRequestStatusType.Rejected ? statusType.ToString().ToUpperInvariant() : throw new InvalidOperationException($&quot;Can not {statusType} as action for join request {joinRequestId}&quot;),
⋮----
///     Gets the guild prune count async.
⋮----
/// &lt;param name=&quot;days&quot;&gt;The days.&lt;/param&gt;
/// &lt;param name=&quot;includeRoles&quot;&gt;The include_roles.&lt;/param&gt;
internal async Task&lt;int&gt; GetGuildPruneCountAsync(ulong guildId, int days, IEnumerable&lt;ulong&gt; includeRoles)
⋮----
throw new ArgumentException(&quot;Prune inactivity days must be a number between 0 and 30.&quot;, nameof(days));
⋮----
[&quot;days&quot;] = days.ToString(CultureInfo.InvariantCulture)
⋮----
var sb = includeRoles?.Aggregate(new StringBuilder(),
(sb, id) =&gt; sb.Append($&quot;&amp;include_roles={id}&quot;))
?? new StringBuilder();
⋮----
var url = Utilities.GetApiUriFor(path, $&quot;{BuildQueryString(urlParams)}{sb}&quot;, this.Discord.Configuration);
⋮----
///     Begins the guild prune async.
⋮----
/// &lt;param name=&quot;computePruneCount&quot;&gt;If true, compute_prune_count.&lt;/param&gt;
⋮----
internal async Task&lt;int?&gt; BeginGuildPruneAsync(ulong guildId, int days, bool computePruneCount, IEnumerable&lt;ulong&gt; includeRoles, string? reason)
⋮----
[&quot;days&quot;] = days.ToString(CultureInfo.InvariantCulture),
[&quot;compute_prune_count&quot;] = computePruneCount.ToString()
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, headers).ConfigureAwait(false);
⋮----
///     Gets the template async.
⋮----
/// &lt;param name=&quot;code&quot;&gt;The code.&lt;/param&gt;
internal async Task&lt;DiscordGuildTemplate&gt; GetTemplateAsync(string code)
⋮----
///     Gets the guild integrations async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordIntegration&gt;&gt; GetGuildIntegrationsAsync(ulong guildId)
⋮----
///     Gets the guild preview async.
⋮----
internal async Task&lt;DiscordGuildPreview&gt; GetGuildPreviewAsync(ulong guildId)
⋮----
///     Creates the guild integration async.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The id.&lt;/param&gt;
internal async Task&lt;DiscordIntegration&gt; CreateGuildIntegrationAsync(ulong guildId, string type, ulong id)
⋮----
var pld = new RestGuildIntegrationAttachPayload
⋮----
///     Modifies the guild integration async.
⋮----
/// &lt;param name=&quot;integrationId&quot;&gt;The integration_id.&lt;/param&gt;
/// &lt;param name=&quot;expireBehaviour&quot;&gt;The expire_behaviour.&lt;/param&gt;
/// &lt;param name=&quot;expireGracePeriod&quot;&gt;The expire_grace_period.&lt;/param&gt;
/// &lt;param name=&quot;enableEmoticons&quot;&gt;If true, enable_emoticons.&lt;/param&gt;
internal async Task&lt;DiscordIntegration&gt; ModifyGuildIntegrationAsync(ulong guildId, ulong integrationId, int expireBehaviour, int expireGracePeriod, bool enableEmoticons)
⋮----
var pld = new RestGuildIntegrationModifyPayload
⋮----
///     Deletes the guild integration async.
⋮----
/// &lt;param name=&quot;integration&quot;&gt;The integration.&lt;/param&gt;
internal Task DeleteGuildIntegrationAsync(ulong guildId, DiscordIntegration integration)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, payload: DiscordJson.SerializeObject(integration));
⋮----
///     Syncs the guild integration async.
⋮----
internal Task SyncGuildIntegrationAsync(ulong guildId, ulong integrationId)
⋮----
///     Gets the guild voice regions async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordVoiceRegion&gt;&gt; GetGuildVoiceRegionsAsync(ulong guildId)
⋮----
///     Gets the guild invites async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordInvite&gt;&gt; GetGuildInvitesAsync(ulong guildId)
⋮----
///     Gets the invite async.
⋮----
/// &lt;param name=&quot;inviteCode&quot;&gt;The invite_code.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;guildScheduledEventId&quot;&gt;The scheduled event id to get.&lt;/param&gt;
/// &lt;param name=&quot;withPermissions&quot;&gt;If true, with_permissions.&lt;/param&gt;
internal async Task&lt;DiscordInvite&gt; GetInviteAsync(string inviteCode, bool? withCounts, ulong? guildScheduledEventId, bool? withPermissions)
⋮----
///     Deletes the invite async.
⋮----
internal async Task&lt;DiscordInvite&gt; DeleteInviteAsync(string inviteCode, string? reason)
⋮----
/*
	 * Disabled due to API restrictions
	 *
	 * internal async Task&lt;DiscordInvite&gt; InternalAcceptInvite(string invite_code)
	 * {
	 *     this.Discord.DebugLogger.LogMessage(LogLevel.Warning, &quot;REST API&quot;, &quot;Invite accept endpoint was used; this account is now likely unverified&quot;, DateTime.Now);
	 *
	 *     var url = new Uri($&quot;{Utils.GetApiBaseUri(this.Configuration), Endpoints.INVITES}/{invite_code));
	 *     var bucket = this.Rest.GetBucket(0, MajorParameterType.Unbucketed, url, HttpRequestMethod.POST);
	 *     var res = await this.DoRequestAsync(this.Discord, bucket, url, HttpRequestMethod.POST).ConfigureAwait(false);
	 *
	 *     var ret = DiscordJson.DeserializeObject&lt;DiscordInvite&gt;(res.Response, this.Discord);
	 *     ret.Discord = this.Discord;
	 *
	 *     return ret;
	 * }
	 */
⋮----
///     Gets the users connections async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetUserConnectionsAsync()
⋮----
///     Gets the applications role connection metadata records.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The application id.&lt;/param&gt;
/// &lt;returns&gt;A list of metadata records or &lt;see langword=&quot;null&quot; /&gt;.&lt;/returns&gt;
/// s
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; GetRoleConnectionMetadataRecords(ulong id)
⋮----
///     Updates the applications role connection metadata records.
⋮----
/// &lt;param name=&quot;metadataObjects&quot;&gt;A list of metadata objects. Max 5.&lt;/param&gt;
/// &lt;returns&gt;A list of the created metadata records.&lt;/returns&gt;
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationRoleConnectionMetadata&gt;&gt; UpdateRoleConnectionMetadataRecords(ulong id, IEnumerable&lt;DiscordApplicationRoleConnectionMetadata&gt; metadataObjects)
⋮----
pld.Add(new()
⋮----
///     Creates the webhook async.
⋮----
/// &lt;param name=&quot;base64Avatar&quot;&gt;The base64_avatar.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordWebhook&gt; CreateWebhookAsync(ulong channelId, string name, Optional&lt;string&gt; base64Avatar, string? reason)
⋮----
var pld = new RestWebhookPayload
⋮----
AvatarBase64 = base64Avatar.ValueOrDefault(),
⋮----
///     Gets the channel webhooks async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetChannelWebhooksAsync(ulong channelId)
⋮----
var webhooksRaw = DiscordJson.DeserializeIEnumerableObject&lt;List&lt;DiscordWebhook&gt;&gt;(res.Response, this.Discord).Select(xw =&gt;
⋮----
///     Gets the guild webhooks async.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordWebhook&gt;&gt; GetGuildWebhooksAsync(ulong guildId)
⋮----
///     Gets the webhook async.
⋮----
/// &lt;param name=&quot;webhookId&quot;&gt;The webhook_id.&lt;/param&gt;
internal async Task&lt;DiscordWebhook&gt; GetWebhookAsync(ulong webhookId)
⋮----
var url = Utilities.GetApiUriFor(path, this.Discord?.Configuration);
⋮----
///     Gets the webhook with token async.
⋮----
/// &lt;param name=&quot;webhookToken&quot;&gt;The webhook_token.&lt;/param&gt;
internal async Task&lt;DiscordWebhook&gt; GetWebhookWithTokenAsync(ulong webhookId, string webhookToken)
⋮----
///     Modifies the webhook async.
⋮----
internal async Task&lt;DiscordWebhook&gt; ModifyWebhookAsync(ulong webhookId, ulong channelId, string name, Optional&lt;string&gt; base64Avatar, string? reason)
⋮----
internal async Task&lt;DiscordWebhook&gt; ModifyWebhookAsync(ulong webhookId, string name, string base64Avatar, string webhookToken, string? reason)
⋮----
///     Deletes the webhook async.
⋮----
internal Task DeleteWebhookAsync(ulong webhookId, string? reason)
⋮----
internal Task DeleteWebhookAsync(ulong webhookId, string webhookToken, string? reason)
⋮----
///     Executes the webhook async.
⋮----
/// &lt;param name=&quot;threadId&quot;&gt;The thread_id.&lt;/param&gt;
internal async Task&lt;DiscordMessage&gt; ExecuteWebhookAsync(ulong webhookId, string webhookToken, DiscordWebhookBuilder builder, string threadId)
⋮----
var pld = new RestWebhookExecutePayload
⋮----
Username = builder.Username.ValueOrDefault(),
AvatarUrl = builder.AvatarUrl.ValueOrDefault(),
⋮----
if (!string.IsNullOrEmpty(builder.Content) || builder.Embeds?.Count &gt; 0 || builder.Files?.Count &gt; 0 || builder.IsTts || builder.Mentions?.Count &gt; 0)
values[&quot;payload_json&quot;] = DiscordJson.SerializeObject(pld);
⋮----
var qub = Utilities.GetApiUriBuilderFor(path, this.Discord?.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;);
⋮----
qub.AddParameter(&quot;thread_id&quot;, threadId);
⋮----
qub.AddParameter(&quot;with_components&quot;, builder.WithComponents.Value.ToString().ToLower());
⋮----
var url = qub.Build();
⋮----
///     Executes the webhook slack async.
⋮----
/// &lt;param name=&quot;jsonPayload&quot;&gt;The json_payload.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordMessage&gt; ExecuteWebhookSlackAsync(ulong webhookId, string webhookToken, string jsonPayload, string threadId)
⋮----
var qub = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;);
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: jsonPayload).ConfigureAwait(false);
⋮----
///     Executes the webhook github async.
⋮----
internal async Task&lt;DiscordMessage&gt; ExecuteWebhookGithubAsync(ulong webhookId, string webhookToken, string jsonPayload, string threadId)
⋮----
///     Edits the webhook message async.
⋮----
internal async Task&lt;DiscordMessage&gt; EditWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, DiscordWebhookBuilder builder, string threadId)
⋮----
var pld = new RestWebhookMessageEditPayload
⋮----
var qub = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration);
⋮----
internal Task&lt;DiscordMessage&gt; EditWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, DiscordWebhookBuilder builder, ulong threadId) =&gt;
this.EditWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), builder, threadId.ToString());
⋮----
///     Gets the webhook message async.
⋮----
internal async Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, string threadId)
⋮----
internal Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId) =&gt;
this.GetWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), null);
⋮----
internal Task&lt;DiscordMessage&gt; GetWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, ulong threadId) =&gt;
this.GetWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), threadId.ToString());
⋮----
///     Deletes the webhook message async.
⋮----
internal async Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, string messageId, string threadId)
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route).ConfigureAwait(false);
⋮----
internal Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId) =&gt;
this.DeleteWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), null);
⋮----
internal Task DeleteWebhookMessageAsync(ulong webhookId, string webhookToken, ulong messageId, ulong threadId) =&gt;
this.DeleteWebhookMessageAsync(webhookId, webhookToken, messageId.ToString(), threadId.ToString());
⋮----
///     Creates the reaction async.
⋮----
/// &lt;param name=&quot;emoji&quot;&gt;The emoji.&lt;/param&gt;
internal Task CreateReactionAsync(ulong channelId, ulong messageId, string emoji)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
⋮----
///     Deletes the own reaction async.
⋮----
internal Task DeleteOwnReactionAsync(ulong channelId, ulong messageId, string emoji)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
⋮----
///     Deletes the user reaction async.
⋮----
internal Task DeleteUserReactionAsync(ulong channelId, ulong messageId, ulong userId, string emoji, string? reason)
⋮----
return this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.DELETE, route, headers, ratelimitWaitOverride: this.Discord.Configuration.UseRelativeRatelimit ? null : 0.26);
⋮----
///     Gets the reactions async.
⋮----
/// &lt;param name=&quot;afterId&quot;&gt;The after_id.&lt;/param&gt;
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordUser&gt;&gt; GetReactionsAsync(ulong channelId, ulong messageId, string emoji, ulong? afterId = null, int limit = 25)
⋮----
urlParams[&quot;after&quot;] = afterId.Value.ToString(CultureInfo.InvariantCulture);
⋮----
reacters.Add(usr);
⋮----
///     Deletes the all reactions async.
⋮----
internal Task DeleteAllReactionsAsync(ulong channelId, ulong messageId, string? reason)
⋮----
///     Deletes the reactions emoji async.
⋮----
internal Task DeleteReactionsEmojiAsync(ulong channelId, ulong messageId, string emoji)
⋮----
///     Creates the thread.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel id to create the thread in.&lt;/param&gt;
/// &lt;param name=&quot;messageId&quot;&gt;The optional message id to create the thread from.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the thread.&lt;/param&gt;
/// &lt;param name=&quot;autoArchiveDuration&quot;&gt;The auto_archive_duration for the thread.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;Can be either &lt;see cref=&quot;ChannelType.PublicThread&quot; /&gt; or &lt;see cref=&quot;ChannelType.PrivateThread&quot; /&gt;.&lt;/param&gt;
/// &lt;param name=&quot;rateLimitPerUser&quot;&gt;The rate limit per user.&lt;/param&gt;
/// &lt;param name=&quot;appliedTags&quot;&gt;The tags to add on creation.&lt;/param&gt;
/// &lt;param name=&quot;builder&quot;&gt;The message builder.&lt;/param&gt;
/// &lt;param name=&quot;isForum&quot;&gt;Whether this thread is in a forum.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordThreadChannel&gt; CreateThreadAsync(
⋮----
var pld = new RestThreadChannelCreatePayload
⋮----
if (appliedTags != null &amp;&amp; appliedTags.Any())
⋮----
tags.Add(b.Id.Value);
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.POST, route, param, out var path);
⋮----
///     Gets the thread.
⋮----
/// &lt;param name=&quot;threadId&quot;&gt;The thread id.&lt;/param&gt;
internal async Task&lt;DiscordThreadChannel&gt; GetThreadAsync(ulong threadId)
⋮----
///     Joins the thread.
⋮----
internal async Task JoinThreadAsync(ulong channelId)
⋮----
await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PUT, route).ConfigureAwait(false);
⋮----
///     Leaves the thread.
⋮----
internal async Task LeaveThreadAsync(ulong channelId)
⋮----
///     Adds a thread member.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel id to add the member to.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user id to add.&lt;/param&gt;
internal async Task AddThreadMemberAsync(ulong channelId, ulong userId)
⋮----
///     Gets a thread member.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel id to get the member from.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user id to get.&lt;/param&gt;
/// &lt;param name=&quot;withMember&quot;&gt;Whether to include a &lt;see cref=&quot;DiscordMember&quot; /&gt; object.&lt;/param&gt;
internal async Task&lt;DiscordThreadChannelMember&gt; GetThreadMemberAsync(ulong channelId, ulong userId, bool withMember = false)
⋮----
[&quot;with_member&quot;] = withMember.ToString(CultureInfo.InvariantCulture)
⋮----
///     Removes a thread member.
⋮----
/// &lt;param name=&quot;channelId&quot;&gt;The channel id to remove the member from.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user id to remove.&lt;/param&gt;
internal async Task RemoveThreadMemberAsync(ulong channelId, ulong userId)
⋮----
///     Gets the thread members.
⋮----
/// &lt;param name=&quot;after&quot;&gt;Get members after specified snowflake.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Limits the results.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordThreadChannelMember&gt;&gt; GetThreadMembersAsync(ulong threadId, bool withMember = false, ulong? after = null, int? limit = null)
⋮----
// TODO: Starting in API v11, List Thread Members will always return paginated results, regardless of whether with_member is passed or not.
⋮----
///     Gets the active threads in a guild.
⋮----
internal async Task&lt;DiscordThreadResult&gt; GetActiveThreadsAsync(ulong guildId)
⋮----
threadReturn.Threads.ForEach(x =&gt; x.Discord = this.Discord);
⋮----
///     Gets the joined private archived threads in a channel.
⋮----
/// &lt;param name=&quot;before&quot;&gt;Get threads before snowflake.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Limit the results.&lt;/param&gt;
internal async Task&lt;DiscordThreadResult&gt; GetJoinedPrivateArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
⋮----
///     Gets the public archived threads in a channel.
⋮----
internal async Task&lt;DiscordThreadResult&gt; GetPublicArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
⋮----
///     Gets the private archived threads in a channel.
⋮----
internal async Task&lt;DiscordThreadResult&gt; GetPrivateArchivedThreadsAsync(ulong channelId, ulong? before, int? limit)
⋮----
///     Modifies a thread.
⋮----
/// &lt;param name=&quot;threadId&quot;&gt;The thread to modify.&lt;/param&gt;
/// &lt;param name=&quot;parentType&quot;&gt;The parent channels type as failback to ignore forum fields.&lt;/param&gt;
/// &lt;param name=&quot;name&quot;&gt;The new name.&lt;/param&gt;
/// &lt;param name=&quot;locked&quot;&gt;The new locked state.&lt;/param&gt;
/// &lt;param name=&quot;archived&quot;&gt;The new archived state.&lt;/param&gt;
/// &lt;param name=&quot;perUserRateLimit&quot;&gt;The new per user rate limit.&lt;/param&gt;
/// &lt;param name=&quot;autoArchiveDuration&quot;&gt;The new auto archive duration.&lt;/param&gt;
/// &lt;param name=&quot;invitable&quot;&gt;The new user invitable state.&lt;/param&gt;
⋮----
/// &lt;param name=&quot;pinned&quot;&gt;Whether the post is pinned.&lt;/param&gt;
/// &lt;param name=&quot;reason&quot;&gt;The reason for the modification.&lt;/param&gt;
internal Task ModifyThreadAsync(ulong threadId, ChannelType parentType, string name, Optional&lt;bool?&gt; locked, Optional&lt;bool?&gt; archived, Optional&lt;int?&gt; perUserRateLimit, Optional&lt;ThreadAutoArchiveDuration?&gt; autoArchiveDuration, Optional&lt;bool?&gt; invitable, Optional&lt;IEnumerable&lt;ForumPostTag&gt;&gt; appliedTags, Optional&lt;bool?&gt; pinned, string? reason)
⋮----
var pld = new RestThreadChannelModifyPayload
⋮----
List&lt;ulong&gt; tags = new(appliedTags.Value.Count());
⋮----
///     Gets the guild emojis.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordGuildEmoji&gt;&gt; GetGuildEmojisAsync(ulong guildId)
⋮----
this.Discord.Guilds.TryGetValue(guildId, out var gld);
⋮----
if (!users.ContainsKey(xtu.Id))
⋮----
var user = gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu);
⋮----
emojis.Add(xge);
⋮----
///     Gets the guild emoji.
⋮----
/// &lt;param name=&quot;emojiId&quot;&gt;The emoji id.&lt;/param&gt;
internal async Task&lt;DiscordGuildEmoji&gt; GetGuildEmojiAsync(ulong guildId, ulong emojiId)
⋮----
var emojiRaw = JObject.Parse(res.Response);
⋮----
emoji.User = gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu);
⋮----
///     Creates the guild emoji.
⋮----
/// &lt;param name=&quot;imageb64&quot;&gt;The imageb64.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordGuildEmoji&gt; CreateGuildEmojiAsync(ulong guildId, string name, string imageb64, IEnumerable&lt;ulong&gt; roles, string? reason)
⋮----
var pld = new RestGuildEmojiCreatePayload
⋮----
? gld != null &amp;&amp; gld.Members.TryGetValue(xtu.Id, out var member) ? member : new DiscordUser(xtu)
⋮----
///     Modifies the guild emoji.
⋮----
internal async Task&lt;DiscordGuildEmoji&gt; ModifyGuildEmojiAsync(ulong guildId, ulong emojiId, string name, IEnumerable&lt;ulong&gt; roles, string? reason)
⋮----
var pld = new RestGuildEmojiModifyPayload
⋮----
///     Deletes the guild emoji.
⋮----
internal Task DeleteGuildEmojiAsync(ulong guildId, ulong emojiId, string? reason)
⋮----
///     Gets the application emojis.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationEmoji&gt;&gt; GetApplicationEmojisAsync(ulong applicationId)
⋮----
return [.. this.Discord.UpdateCachedApplicationEmojis(emojisRaw?.Value&lt;JArray&gt;(&quot;items&quot;)).Select(x =&gt; x.Value)];
⋮----
///     Gets an application emoji.
⋮----
internal async Task&lt;DiscordApplicationEmoji&gt; GetApplicationEmojiAsync(ulong applicationId, ulong emojiId)
⋮----
return this.Discord.UpdateCachedApplicationEmoji(emoji);
⋮----
///     Creates an application emoji.
⋮----
internal async Task&lt;DiscordApplicationEmoji&gt; CreateApplicationEmojiAsync(ulong applicationId, string name, string imageb64)
⋮----
var pld = new RestApplicationEmojiCreatePayload
⋮----
///     Modifies an application emoji.
⋮----
internal async Task&lt;DiscordApplicationEmoji&gt; ModifyApplicationEmojiAsync(ulong applicationId, ulong emojiId, string name)
⋮----
var pld = new RestApplicationEmojiModifyPayload
⋮----
///     Deletes an application emoji.
⋮----
internal Task DeleteApplicationEmojiAsync(ulong applicationId, ulong emojiId)
⋮----
///     Gets a sticker.
⋮----
/// &lt;param name=&quot;stickerId&quot;&gt;The sticker id.&lt;/param&gt;
internal async Task&lt;DiscordSticker&gt; GetStickerAsync(ulong stickerId)
⋮----
///     Gets the sticker pack.
⋮----
/// &lt;param name=&quot;id&quot;&gt;The sticker pack&apos;s id.&lt;/param&gt;
internal async Task&lt;DiscordStickerPack&gt; GetStickerPackAsync(ulong id)
⋮----
///     Gets the sticker packs.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordStickerPack&gt;&gt; GetStickerPacksAsync()
⋮----
var json = JObject.Parse(res.Response)[&quot;sticker_packs&quot;] as JArray;
⋮----
///     Gets the guild stickers.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordSticker&gt;&gt; GetGuildStickersAsync(ulong guildId)
⋮----
///     Gets a guild sticker.
⋮----
internal async Task&lt;DiscordSticker&gt; GetGuildStickerAsync(ulong guildId, ulong stickerId)
⋮----
///     Creates the guild sticker.
⋮----
/// &lt;param name=&quot;tags&quot;&gt;The tags.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordSticker&gt; CreateGuildStickerAsync(ulong guildId, string name, string description, string tags, DiscordMessageFile file, string? reason)
⋮----
var res = await this.DoStickerMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, name, tags, description, headers, file).ConfigureAwait(false);
⋮----
///     Modifies the guild sticker.
⋮----
internal async Task&lt;DiscordSticker&gt; ModifyGuildStickerAsync(ulong guildId, ulong stickerId, Optional&lt;string&gt; name, Optional&lt;string&gt; description, Optional&lt;string&gt; tags, string? reason)
⋮----
var pld = new RestStickerModifyPayload
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.PATCH, route).ConfigureAwait(false);
⋮----
///     Deletes the guild sticker async.
⋮----
internal async Task DeleteGuildStickerAsync(ulong guildId, ulong stickerId, string? reason)
⋮----
///     Gets the global application commands.
⋮----
/// &lt;param name=&quot;withLocalizations&quot;&gt;Whether to get the full localization dict.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGlobalApplicationCommandsAsync(ulong applicationId, bool withLocalizations = false)
⋮----
[&quot;with_localizations&quot;] = withLocalizations.ToString().ToLower()
⋮----
///     Bulk overwrites the global application commands.
⋮----
/// &lt;param name=&quot;commands&quot;&gt;The commands.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGlobalApplicationCommandsAsync(ulong applicationId, IEnumerable&lt;DiscordApplicationCommand&gt; commands)
⋮----
if (commands.Any())
pld.AddRange(commands.Select(command =&gt; new RestApplicationCommandCreatePayload
⋮----
///     Creates a global application command.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The applicationid.&lt;/param&gt;
/// &lt;param name=&quot;command&quot;&gt;The command.&lt;/param&gt;
internal async Task&lt;DiscordApplicationCommand&gt; CreateGlobalApplicationCommandAsync(ulong applicationId, DiscordApplicationCommand command)
⋮----
var pld = new RestApplicationCommandCreatePayload
⋮----
///     Gets a global application command.
⋮----
/// &lt;param name=&quot;commandId&quot;&gt;The command id.&lt;/param&gt;
internal async Task&lt;DiscordApplicationCommand&gt; GetGlobalApplicationCommandAsync(ulong applicationId, ulong commandId)
⋮----
///     Edits a global application command.
⋮----
/// &lt;param name=&quot;options&quot;&gt;The options.&lt;/param&gt;
/// &lt;param name=&quot;nameLocalization&quot;&gt;The localizations of the name.&lt;/param&gt;
/// &lt;param name=&quot;descriptionLocalization&quot;&gt;The localizations of the description.&lt;/param&gt;
/// &lt;param name=&quot;defaultMemberPermission&quot;&gt;The default member permissions.&lt;/param&gt;
/// &lt;param name=&quot;isNsfw&quot;&gt;Whether this command is marked as NSFW.&lt;/param&gt;
/// &lt;param name=&quot;allowedContexts&quot;&gt;The allowed contexts.&lt;/param&gt;
/// &lt;param name=&quot;integrationTypes&quot;&gt;The allowed integration types.&lt;/param&gt;
internal async Task&lt;DiscordApplicationCommand&gt; EditGlobalApplicationCommandAsync(
⋮----
var pld = new RestApplicationCommandEditPayload
⋮----
NameLocalizations = nameLocalization.ValueOrDefault()?.GetKeyValuePairs(),
DescriptionLocalizations = descriptionLocalization.ValueOrDefault()?.GetKeyValuePairs(),
⋮----
///     Deletes a global application command.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application_id.&lt;/param&gt;
/// &lt;param name=&quot;commandId&quot;&gt;The command_id.&lt;/param&gt;
internal async Task DeleteGlobalApplicationCommandAsync(ulong applicationId, ulong commandId)
⋮----
///     Gets the guild application commands.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; GetGuildApplicationCommandsAsync(ulong applicationId, ulong guildId, bool withLocalizations = false)
⋮----
///     Bulk overwrites the guild application commands.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationCommand&gt;&gt; BulkOverwriteGuildApplicationCommandsAsync(ulong applicationId, ulong guildId, IEnumerable&lt;DiscordApplicationCommand&gt; commands)
⋮----
///     Creates a guild application command.
⋮----
internal async Task&lt;DiscordApplicationCommand&gt; CreateGuildApplicationCommandAsync(ulong applicationId, ulong guildId, DiscordApplicationCommand command)
⋮----
///     Gets a guild application command.
⋮----
internal async Task&lt;DiscordApplicationCommand&gt; GetGuildApplicationCommandAsync(ulong applicationId, ulong guildId, ulong commandId)
⋮----
///     Edits a guild application command.
⋮----
internal async Task&lt;DiscordApplicationCommand&gt; EditGuildApplicationCommandAsync(
⋮----
///     Deletes a guild application command.
⋮----
internal async Task DeleteGuildApplicationCommandAsync(ulong applicationId, ulong guildId, ulong commandId)
⋮----
///     Creates an interaction response.
⋮----
/// &lt;param name=&quot;interactionId&quot;&gt;The interaction id.&lt;/param&gt;
/// &lt;param name=&quot;interactionToken&quot;&gt;The interaction token.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordInteractionCallbackResponse&gt; CreateInteractionResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, DiscordInteractionResponseBuilder? builder)
⋮----
RestInteractionResponsePayload pld;
⋮----
? new DiscordInteractionApplicationCommandCallbackData
⋮----
if (!string.IsNullOrEmpty(builder.Content) || builder.Embeds?.Count &gt; 0 || builder.IsTts || builder.Mentions?.Count &gt; 0 || builder.Files?.Count &gt; 0 || builder.Components?.Count &gt; 0)
⋮----
RestResponse response;
⋮----
var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;false&quot;).AddParameter(&quot;with_response&quot;, &quot;true&quot;).Build();
⋮----
response = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
⋮----
response = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
return response.ResponseCode is not HttpStatusCode.NoContent &amp;&amp; !string.IsNullOrEmpty(response.Response)
⋮----
///     Creates an interaction response with a modal.
⋮----
internal async Task CreateInteractionModalResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, DiscordInteractionModalBuilder builder)
⋮----
var oldHook = builder.Components.All(x =&gt; x.Type is ComponentType.ActionRow);
if (oldHook &amp;&amp; builder.ModalComponents.Any(mc =&gt; mc.Components.Any(c =&gt; c.Type is not ComponentType.TextInput)))
throw new NotSupportedException(&quot;Can&apos;t send any other type then Input Text as Modal Component.&quot;);
else if (!oldHook &amp;&amp; builder.Components.Any(x =&gt; x.Type is not (ComponentType.Label or ComponentType.TextDisplay)))
throw new NotSupportedException(&quot;Can&apos;t send any other type then Label as Modal Component.&quot;);
⋮----
var pld = new RestInteractionModalResponsePayload
⋮----
var url = Utilities.GetApiUriBuilderFor(path, this.Discord.Configuration).AddParameter(&quot;wait&quot;, &quot;true&quot;).Build();
⋮----
///     Creates an interaction response with an iFrame.
⋮----
/// &lt;param name=&quot;customId&quot;&gt;The custom id of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;title&quot;&gt;The title of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;modalSize&quot;&gt;The size of the iframe.&lt;/param&gt;
/// &lt;param name=&quot;iFramePath&quot;&gt;The path of the iframe.&lt;/param&gt;
internal async Task CreateInteractionIframeResponseAsync(ulong interactionId, string interactionToken, InteractionResponseType type, string customId, string title, IframeModalSize modalSize, string? iFramePath = null)
⋮----
var pld = new RestInteractionIframeResponsePayload
⋮----
///     Gets the original interaction response.
⋮----
internal Task&lt;DiscordMessage&gt; GetOriginalInteractionResponseAsync(ulong applicationId, string interactionToken) =&gt;
this.GetWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, null);
⋮----
///     Edits the original interaction response.
⋮----
internal Task&lt;DiscordMessage&gt; EditOriginalInteractionResponseAsync(ulong applicationId, string interactionToken, DiscordWebhookBuilder builder) =&gt;
this.EditWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, builder, null);
⋮----
///     Deletes the original interaction response.
⋮----
internal Task DeleteOriginalInteractionResponseAsync(ulong applicationId, string interactionToken) =&gt;
this.DeleteWebhookMessageAsync(applicationId, interactionToken, Endpoints.ORIGINAL, null);
⋮----
///     Creates the followup message.
⋮----
internal async Task&lt;DiscordMessage&gt; CreateFollowupMessageAsync(ulong applicationId, string interactionToken, DiscordFollowupMessageBuilder builder)
⋮----
ArgumentNullException.ThrowIfNull(builder, nameof(builder));
⋮----
var pld = new RestFollowupMessageCreatePayload
⋮----
RestResponse res;
⋮----
res = await this.DoMultipartAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, values: values, files: builder.Files).ConfigureAwait(false);
⋮----
res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route, payload: DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Gets the followup message.
⋮----
/// &lt;param name=&quot;messageId&quot;&gt;The message id.&lt;/param&gt;
internal Task&lt;DiscordMessage&gt; GetFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId) =&gt;
this.GetWebhookMessageAsync(applicationId, interactionToken, messageId);
⋮----
///     Edits the followup message.
⋮----
internal Task&lt;DiscordMessage&gt; EditFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId, DiscordWebhookBuilder builder) =&gt;
this.EditWebhookMessageAsync(applicationId, interactionToken, messageId.ToString(), builder, null);
⋮----
///     Deletes the followup message.
⋮----
internal Task DeleteFollowupMessageAsync(ulong applicationId, string interactionToken, ulong messageId) =&gt;
this.DeleteWebhookMessageAsync(applicationId, interactionToken, messageId);
⋮----
///     Gets the published store sku listings (premium application subscription).
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to fetch the listenings for.&lt;/param&gt;
/// &lt;returns&gt;A list of published listings with &lt;see cref=&quot;DiscordStoreSku&quot; /&gt;s.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordStoreSku&gt;&gt; GetPublishedListingsAsync(ulong applicationId)
⋮----
[&quot;application_id&quot;] = applicationId.ToString()
⋮----
///     Gets the applications skus.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordSku&gt;&gt; GetSkusAsync(ulong applicationId)
⋮----
///     Gets the applications entitlements.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to fetch the entitlements for.&lt;/param&gt;
/// &lt;param name=&quot;guildId&quot;&gt;Filter returned entitlements to a specific guild id.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;Filter returned entitlements to a specific user id.&lt;/param&gt;
/// &lt;param name=&quot;skuIds&quot;&gt;Optional list of SKU IDs to check entitlements for.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;Retrieve entitlements before this entitlement ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;Retrieve entitlements after this entitlement ID.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Number of entitlements to return, 1-100, default 100.&lt;/param&gt;
/// &lt;param name=&quot;excludeEnded&quot;&gt;
///     Whether or not ended entitlements should be omitted. Defaults to false, ended entitlements
///     are included by default.
⋮----
/// &lt;param name=&quot;excludeDeleted&quot;&gt;
///     Whether or not deleted entitlements should be omitted. Defaults to true, deleted
///     entitlements are not included by default.
⋮----
/// &lt;returns&gt;A list of &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordEntitlement&gt;&gt; GetEntitlementsAsync(ulong applicationId, ulong? guildId, ulong? userId, List&lt;ulong&gt;? skuIds = null, ulong? before = null, ulong? after = null, int limit = 100, bool? excludeEnded = null, bool? excludeDeleted = null)
⋮----
urlParams[&quot;limit&quot;] = limit.ToString();
⋮----
urlParams[&quot;guild_id&quot;] = guildId.Value.ToString();
⋮----
urlParams[&quot;user_id&quot;] = userId.Value.ToString();
⋮----
urlParams[&quot;sku_ids&quot;] = string.Join(&quot;,&quot;, skuIds);
⋮----
urlParams[&quot;before&quot;] = before.Value.ToString();
⋮----
urlParams[&quot;after&quot;] = after.Value.ToString();
⋮----
urlParams[&quot;exclude_ended&quot;] = excludeEnded.Value.ToString().ToLower();
⋮----
urlParams[&quot;exclude_deleted&quot;] = excludeDeleted.Value.ToString().ToLower();
⋮----
///     Gets an entitlement.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to fetch the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to fetch.&lt;/param&gt;
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;DiscordEntitlement?&gt; GetEntitlementAsync(ulong applicationId, ulong entitlementId)
⋮----
///     Consumes an entitlement.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to consume the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to consume.&lt;/param&gt;
⋮----
internal async Task&lt;bool&gt; ConsumeEntitlementAsync(ulong applicationId, ulong entitlementId)
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.POST, route).ConfigureAwait(false);
⋮----
// TODO: userId can be skipped if using oauth
⋮----
///     Gets the subscriptions of an sku.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to fetch the subscriptions for.&lt;/param&gt;
/// &lt;param name=&quot;userId&quot;&gt;The user ID for which to return subscriptions. Required except for OAuth queries.&lt;/param&gt;
/// &lt;param name=&quot;before&quot;&gt;List subscriptions before this ID.&lt;/param&gt;
/// &lt;param name=&quot;after&quot;&gt;List subscriptions after this ID.&lt;/param&gt;
/// &lt;param name=&quot;limit&quot;&gt;Number of results to return (1-100).&lt;/param&gt;
/// &lt;returns&gt;A list of &lt;see cref=&quot;DiscordSubscription&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordSubscription&gt;&gt; GetSkuSubscriptionsAsync(ulong skuId, ulong userId, ulong? before = null, ulong? after = null, int limit = 100)
⋮----
urlParams[&quot;userId&quot;] = userId.ToString();
⋮----
///     Gets a subscription of an sku.
⋮----
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to fetch the subscription for.&lt;/param&gt;
/// &lt;param name=&quot;subscriptionId&quot;&gt;The subscription id to fetch.&lt;/param&gt;
/// &lt;returns&gt;The requested &lt;see cref=&quot;DiscordSubscription&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;DiscordSubscription?&gt; GetSkuSubscriptionAsync(ulong skuId, ulong subscriptionId)
⋮----
///     Creates a test entitlement.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;skuId&quot;&gt;The sku id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;ownerId&quot;&gt;The owner id to create the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;ownerType&quot;&gt;The owner type to create the entitlement for.&lt;/param&gt;
/// &lt;returns&gt;A partial &lt;see cref=&quot;DiscordEntitlement&quot; /&gt;.&lt;/returns&gt;
internal async Task&lt;DiscordEntitlement&gt; CreateTestEntitlementAsync(ulong applicationId, ulong skuId, ulong ownerId, EntitlementOwnerType ownerType)
⋮----
TestEntitlementCreatePayload pld = new()
⋮----
///     Deletes a test entitlement.
⋮----
/// &lt;param name=&quot;applicationId&quot;&gt;The application id to delete the entitlement for.&lt;/param&gt;
/// &lt;param name=&quot;entitlementId&quot;&gt;The entitlement id to delete.&lt;/param&gt;
internal async Task DeleteTestEntitlementAsync(ulong applicationId, ulong entitlementId)
⋮----
///     Gets the current application info via oauth2.
⋮----
internal Task&lt;TransportApplication&gt; GetCurrentApplicationOauth2InfoAsync()
=&gt; this.GetApplicationOauth2InfoAsync(Endpoints.ME);
⋮----
///     Gets the application rpc info.
⋮----
internal Task&lt;DiscordRpcApplication&gt; GetApplicationRpcInfoAsync(ulong applicationId)
=&gt; this.GetApplicationRpcInfoAsync(applicationId.ToString(CultureInfo.InvariantCulture));
⋮----
///     Gets the application info via oauth2.
⋮----
private async Task&lt;TransportApplication&gt; GetApplicationOauth2InfoAsync(string applicationId)
⋮----
///     Gets the application info.
⋮----
internal async Task&lt;TransportApplication&gt; GetCurrentApplicationInfoAsync()
⋮----
internal async Task&lt;TransportApplication&gt; ModifyCurrentApplicationInfoAsync(
⋮----
var pld = new RestApplicationModifyPayload
⋮----
private async Task&lt;DiscordRpcApplication&gt; GetApplicationRpcInfoAsync(string applicationId)
⋮----
///     Gets the application assets async.
⋮----
/// &lt;param name=&quot;application&quot;&gt;The application.&lt;/param&gt;
internal async Task&lt;IReadOnlyList&lt;DiscordApplicationAsset&gt;&gt; GetApplicationAssetsAsync(DiscordApplication application)
⋮----
///     Gets the gateway info async.
⋮----
internal async Task&lt;GatewayInfo&gt; GetGatewayInfoAsync()
⋮----
var res = await this.DoRequestAsync(this.Discord, bucket, url, RestRequestMethod.GET, route, headers).ConfigureAwait(false);
⋮----
var info = JObject.Parse(res.Response).ToObject&lt;GatewayInfo&gt;();
info.SessionBucket.ResetAfter = DateTimeOffset.UtcNow + TimeSpan.FromMilliseconds(info.SessionBucket.ResetAfterInternal);
⋮----
///     Gets the current oauth2 authorization information.
⋮----
/// &lt;param name=&quot;accessToken&quot;&gt;The access token.&lt;/param&gt;
internal async Task&lt;DiscordAuthorizationInformation&gt; GetCurrentOAuth2AuthorizationInformationAsync(string accessToken)
⋮----
throw new InvalidOperationException(&quot;Cannot use oauth2 endpoints with discord client&quot;);
⋮----
// ReSharper disable once HeuristicUnreachableCode
⋮----
headers.Add(&quot;Bearer&quot;, accessToken);
⋮----
var url = Utilities.GetApiUriFor(path, this.OAuth2Client.DiscordConfiguration);
var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.GET, route, headers).ConfigureAwait(false);
⋮----
///     Gets the current user.
⋮----
internal async Task&lt;DiscordUser&gt; GetCurrentUserAsync(string accessToken)
⋮----
var bucket = this.Rest.GetBucket(RestRequestMethod.GET, route,
⋮----
application_id = this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture)
⋮----
var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.GET, route, headers)
.ConfigureAwait(false);
⋮----
///     Gets the current user&apos;s connections.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordConnection&gt;&gt; GetCurrentUserConnectionsAsync(string accessToken)
⋮----
///     Gets the current user&apos;s guilds.
⋮----
internal async Task&lt;IReadOnlyList&lt;DiscordGuild&gt;&gt; GetCurrentUserGuildsAsync(string accessToken)
⋮----
/// &lt;param name=&quot;guildId&quot;&gt;The guild id to get the member for.&lt;/param&gt;
internal async Task&lt;DiscordMember&gt; GetCurrentUserGuildMemberAsync(string accessToken, ulong guildId)
⋮----
guild_id = guildId.ToString(CultureInfo.InvariantCulture)
⋮----
///     Gets the current user&apos;s role connection.
⋮----
internal async Task&lt;DiscordApplicationRoleConnection&gt; GetCurrentUserApplicationRoleConnectionAsync(string accessToken)
⋮----
///     Updates the current user&apos;s role connection.
⋮----
/// &lt;param name=&quot;platformName&quot;&gt;The platform name.&lt;/param&gt;
/// &lt;param name=&quot;platformUsername&quot;&gt;The platform username.&lt;/param&gt;
⋮----
internal async Task&lt;DiscordApplicationRoleConnection&gt; ModifyCurrentUserApplicationRoleConnectionAsync(string accessToken, Optional&lt;string&gt; platformName, Optional&lt;string&gt; platformUsername, Optional&lt;ApplicationRoleConnectionMetadata&gt; metadata)
⋮----
RestOAuth2ApplicationRoleConnectionPayload pld = new()
⋮----
Metadata = metadata.HasValue ? metadata.Value.GetKeyValuePairs() : Optional&lt;Dictionary&lt;string, string&gt;&gt;.None
⋮----
var res = await this.DoRequestAsync(null, bucket, url, RestRequestMethod.PUT, route, headers, DiscordJson.SerializeObject(pld)).ConfigureAwait(false);
⋮----
///     Exchanges a code for an access token.
⋮----
internal async Task&lt;DiscordAccessToken&gt; ExchangeOAuth2AccessTokenAsync(string code)
⋮----
{ &quot;client_id&quot;, this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture) },
⋮----
var res = await this.DoFormRequestAsync(this.OAuth2Client, bucket, url, RestRequestMethod.POST, route, formData).ConfigureAwait(false);
⋮----
///     Exchanges a refresh token for a new access token
⋮----
/// &lt;param name=&quot;refreshToken&quot;&gt;The refresh token.&lt;/param&gt;
internal async Task&lt;DiscordAccessToken&gt; RefreshOAuth2AccessTokenAsync(string refreshToken)
⋮----
///     Revokes an oauth2 token.
⋮----
/// &lt;param name=&quot;token&quot;&gt;The token to revoke.&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;The type of token to revoke.&lt;/param&gt;
internal async Task RevokeOAuth2TokenAsync(string token, string type)
⋮----
var authorizationString = Encoding.UTF8.GetBytes($&quot;{this.OAuth2Client.ClientId.ToString(CultureInfo.InvariantCulture)}:{this.OAuth2Client.ClientSecret}&quot;);
var base64EncodedAuthorizationString = Convert.ToBase64String(authorizationString);
⋮----
headers.Add(&quot;Basic&quot;, base64EncodedAuthorizationString);
⋮----
await this.DoFormRequestAsync(this.OAuth2Client, bucket, url, RestRequestMethod.POST, route, formData, headers).ConfigureAwait(false);</file></files></repomix>